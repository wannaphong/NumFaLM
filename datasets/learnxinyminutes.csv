text
"Pascal (ปาสกาล) เป็นภาษาโปรแกรมมิ่งทั้งแบบ imperative และ procedural ที่ออกแบบโดย Niklaus Wirth (นิเคล้า เวิร์ท) เมื่อปี 1968-69 และเผยแพร่ตอน 1970 โดยเน้นให้เป็นภาษาที่เล็ก มีประสิทธิภาพ เพื่อเสริมการเขียนโปรแกรมที่มีแนวปฏิบัติที่ดีด้วยการใช้โครงสร้างของตัวภาษา และโครงสร้างข้อมูลมากำกับ ชื่อของภาษานี้ตั้งเป็นเกียรติให้กับนักคณิตศาสตร์ชาวฝรั่งเศส, นักปรัชญา และนักฟิสิกส์ ชื่อ Blaise Pascal (เบลส ปาสกาล) ข้อมูลจาก : [วิกิพีเดีย][1]

การคอมไพล์และรันโค้ดภาษาปาสกาลนี้ สามารถใช้ปาสกาลคอมไพลเลอร์ฟรีชื่อ Free Pascal ได้ โดย [ดาวน์โหลดที่นี่][2]

ด้านล่างจะเป็นโครงสร้างภาษาหลัก ๆ ที่ต้องเข้าใจก่อน ปาสกาลจะเป็นภาษาที่เข้มงวดกับโครงสร้างโค้ดมาก

```pascal
//โปรแกรมปาสกาล
//คอมเม้นต์เขียนแบบนี้ ใช้สแลชสองครั้ง
{
    แต่ถ้าต้องการคอมเม้นหลาย ๆ บรรทัด
    ให้ใช้ วงเล็บปีกกา (curly brackets)
    เนื้อหาอยู่บรรทัดเดียวกันกับปีกกาได้
}

//อย่างแรก ต้องประกาศ ชื่อโปรแกรม
program learn_pascal; //<-- ห้ามลืม semicolon

const
    {
        ประกาศค่าคงที่ (constant) ในบล็อคนี้
    }
type
    {
        ประกาศชนิดข้อมูลของเราเองที่นี่ ไม่ว่าจะเป็น ชนิดข้อมูลทั่วไป
        หรือจะเป็นคลาส 
    }
var
    {
        ตัวแปร ในภาษาปาสกาล ไม่เหมือนกับภาษาอื่น ๆ 
        เพราะต้องประกาศในบล็อค var ก่อนใช้งานเสมอ
    }

//มาถึงส่วนโปรแกรมหลัก หรือ main fucntion นั่นเอง
begin
    {
        โค้ดเราทำงานอะไร อย่างไร ก็เริ่มรันจากตรงนี้
    }
end. // จบการทำงานของ _โปรแกรม_ เราจะจบด้วย จุลภาค "".""
```

โค้ดต่อจากนี้ จะเป็นการอธิบายประกาศตัวแปรของปาสกาล

```pascal
//การประกาศตัวแปร ทำได้แบบนี้
//var ชื่อตัวแปร : ชนิด ;
var a:integer;
var b:integer;

//หรือแบบที่นิยมมากกว่า คือเอามาเก็บในบล็อค var ทั้งหมด
var 
    a : integer;
    b : integer;

//ถ้าจะเอาแบบสั้น ๆ บรรทัดเดียว ก็ทำได้ ทำได้พร้อมกันหลาย ๆ ตัวแปรด้วย
var a,b : integer;
```

โค้ดตัวอย่างนี้เป็นโปรแกรม Learn\_More ที่เป็นโครงสร้างโปรแกรมง่าย ๆ ที่จบสมบูรณ์หนึ่งโปรแกรม มีบล็อค program, const, type, main (Begin..End.)

```pascal
program Learn_More;
// มาต่อเรื่อง ชนิดของข้อมูล (data types) และ ตัวดำเนินการ (operators)

const
    PI = 3.141592654;
    GNU = 'GNU''s Not Unix';
        // ค่าคงที่ ให้ตั้งชื่อเป็น ตัวพิมพ์ใหญ่ ทั้งหมด ใช้กับชนิดข้อมูลใดๆ ก็ได้
        // ค่าคงที่ ก็ตามชื่อเลย กำหนดค่าแล้ว ไม่สามารถเปลี่ยนแปลงได้ขณะรัน

// การประกาศชนิดข้อมูลของเราเอง
// ""ชนิด"" ของตัวแปรสองแบบนี้ จะนำไปใช้ด้านล่าง
type
    ch_array : array [0..255] of char;
        // อะเรย์ เป็นชนิดข้อมูลที่มี ความยาว/ช่องเก็บข้อมูล และ ชนิดข้อมูล
        // โค้ดด้านบน เป็นการประกาศอะเรย์ของตัวอักษา 255 ตัวอักษา
        // ซึ่งได้ ความยาว/ช่องเก็บข้อมูลในตัวแปรตัวนี้ 256 ช่องที่เป็นข้อความ 
    md_array : array of array of integer;
        // ด้านบนนี้ เป็นตัวอย่าง อะเรย์สองมิติของเลขจำนวนเต็ม
        // อะเรย์ ยังซ้อนกับอะเรย์ได้อีกด้วย ทำให้สร้าง อะเรย์หลายมิติได้
        // เรายังสามารถสร้าง อะเรย์ที่มีความยาวช่องเท่ากับศูนย์ (0) ได้อีกด้วย
        // ซึ่งทำให้เกิด อะเรย์ที่จำนวนช่องยืดหยุ่นได้ (dymaically sized array)

// การประกาศตัวแปร : ชื่อตัวแปรเหล่านี้จะนำไปใช้ด้านล่างต่อไป
var
    int, c, d  : integer;
           // ประกาศในบล็อค var มีตัวแปรสามตัวเป็นอินทีเจอร์ 
           // ชนิดจำนวนเต็ม แบบ 16 bit มีช่วงข้อมูล [-32,768.. 32,767]
           // »int« ในที่นี้เป็น ""ชื่อตัวแปร"" ที่ต้นฉบับตั้งให้สอดคล้องกับชนิดข้อมูล
           // อย่าสับสนกับบางภาษาที่มีชนิด int ประกาศหน้าชื่อตัวแปร
    r    : real;
           // ตัวแปร r เป็นชนิดเรียล (real) หรือเลขทศนิยม 
           // real มีช่วงข้อมูล [3.4E-38..3.4E38]
    bool : boolean;
           // ข้อมูลชนิดบูเลียน (boolean) มีค่าได้สองแบบ คือ True/False
    ch   : char;
           // ตัวแปร ch เป็นชนิดตัวอักษร (ชาร์? คาร์?) หรือคาแรกเตอร์
           // ตัวอักษรเป็นแบบ ASCII 8 bit ดังนั้นจะไม่ใช่ UTF, Unicode 
    str  : string;
           // ตัวแปรสตริงจะเก็บข้อความ หรือ char หลาย ๆ ตัว
           // ชนิดข้อมูลนี้ไม่เป็นมาตรฐานภาษาแต่คอมไพเลอร์ปาสกาลก็มักจะมีให้
           // ทั่ว ๆ ไปแล้ว จะเป็นอะเรย์ของ char ความยาวตั้งต้น 255 
    s    : string[50];
           // แบบนี้คือ กำหนดความยาว string เอง ให้เก็บ char 50 ตัว
           // แบบนี้ก็ทำให้ประหยัดหน่วยความจำมากขึ้นนั่นเอง
    my_str: ch_array;
           // ชนิดตัวแปร ใช้เป็นชนิดที่เรากำหนดเองก็ได้ อย่างตอนนี้
           // ch_array เป็น ""ชนิดข้อมูล"" ที่เราสร้างขึ้นมาในบล็อค type
    my_2d : md_array;
           // ตัวแปรแบบอะเรย์ที่ไม่ประกาศขนาด (dynamically sized array)
           // ก่อนเอาไปใช้จริงต้องระบุขนาดก่อนใช้เสมอ

    // ชนิดข้อมูลแบบ integer เพิ่มเติม
    b    : byte;     // มีช่วงข้อมูล [0..255]
    shi  : shortint; // มีช่วงข้อมูล [-128..127]
    smi  : smallint; // มีช่วงข้อมูล [-32,768..32,767] (standard Integer)
    w    : word;     // มีช่วงข้อมูล [0..65,535]
    li   : longint;  // มีช่วงข้อมูล [-2,147,483,648..2,147,483,647]
    lw   : longword; // มีช่วงข้อมูล [0..4,294,967,295]
    c    : cardinal; // ก็คือ longword
    i64  : int64;    // มีช่วงข้อมูล 
                     // [-9223372036854775808..9223372036854775807]
    qw   : qword;    // มีช่วงข้อมูล [0..18,446,744,073,709,551,615]

    // ชนิดข้อมูลแบบ real เพิ่มเติม
    rr   : real;     // มีช่วงข้อมูลที่ขึ้นกับระบบปฏิบัติการ 
                     // (เช่นเป็นแบบ 8-bit, 16-bit, ฯลฯ)
    rs   : single;   // มีช่วงข้อมูล [1.5E-45..3.4E38]
    rd   : double;   // มีช่วงข้อมูล [5.0E-324 .. 1.7E308]
    re   : extended; // มีช่วงข้อมูล [1.9E-4932..1.1E4932]
    rc   : comp;     // มีช่วงข้อมูล [-2E64+1 .. 2E63-1]

Begin
    // การกำหนดค่าตัวแปรให้ขณะประกาศ
    int  := 1;
    r    := 3.14;
    ch   := 'a';  // ใช้ single quote เหมือนกันทั้ง char และ string
    str  := 'apple';  
    bool := true;
    // ภาษาปาสกาล มอง ""ชื่อเฉพาะ"" แบบไม่สนพิมพ์ใหญ่พิมพ์เล็ก
    // (case-insensitive language)
    // ตัวดำเนินการแบบคณิตศาสตร์ (arithmethic operation)
    int := 1 + 1;   // int = 2 ซึ่งจะกำหนดทับค่าเดิมด้านบนที่เคยประกาศ
    int := int + 1; // int = 2 + 1 = 3 นำค่าตอนนี้ (2) มา +1 ได้ 3
    int := 4 div 2; // int = 2 หารด้วย div จะได้ผลเป็น integer เสมอ
    int := 3 div 2; // int = 1
    int := 1 div 2; // int = 0

    bool := true or false;  // bool = true
    bool := false and true; // bool = false
    bool := true xor true;  // bool = false

    r := 3 / 2;  // หารด้วย / จะได้ผลเป็น real เสมอ
    r := int;    // เรากำหนดค่า integer ให้ตัวแปร real ได้
                 // แต่ทำกลับกัน โดยกำหนด real ให้ integer ไม่ได้

    c := str[1]; // กำหนดค่าแรกใน array str ให้ตัวแปร c ที่เป็น char
    str := 'hello' + 'world'; // เรารวม string เข้าด้วยกันด้วย + 

    my_str[0] := 'a'; // กำหนดค่าให้ string เฉพาะตำแหน่งแบบอะเรย์ทั่วไป

    setlength(my_2d,10,10); // ปรับขนาดอะเรย์ 2 มิติให้เป็นขนาด 10x10
                            // โดยตัวแปร my_2d นี้สร้างแล้วด้านบน
    for c := 0 to 9 do      // อะเรย์เริ่มจาก 0 และจบที่ ความยาว-1
        for d := 0 to 9 do  // ตัวนับ (counter) จำเป็นต้องประกาศก่อนใช้
        my_2d[c,d] := c * d;
          // กำหนดอะเรย์หลายมิติ ด้วยการใช้วงเล็บก้ามปู (square brackets)

End.
// จบโปรแกรมบริบูรณ์ ด้วย "".""
```

ด้านล่าง เป็นตัวอย่างการเขียนโปรแกรมปาสกาลชื่อ Functional\_Programming

```pascal
program Functional_Programming;

Var
    i, dummy : integer;

function factorial_recursion(const a: integer) : integer;
{  ทำการคำนวณแฟคทอเรียลซ้ำ ๆ ของเลขจำนวนเต็ม โดยผ่านพารามิเตอร์ a
   ถ้าจะประกาศตัวแปรโลคอลในฟังก์ชั่น ก็ทำได้ โดยการใช้บล็อค var ภายในฟังก์ชั่น
   เช่น :
   var
      local_a : integer;
}
Begin
    If a >= 1 Then
    { ฟังก์ชั่นนี้คืนค่ากลับ โดยการกำหนดค่าที่ผ่านทางพารามิเตอร์ a
     นำมาคูณกับฟังก์ชั่นที่ผ่าน a-1 สุดท้ายก็กำหนดค่าลงไปให้กับฟังก์ชั่นตรงๆ }
        factorial_recursion := a * factorial_recursion(a-1)
    Else
        factorial_recursion := 1;
End; // จบ ฟังก์ชั่น ด้วย "";"" หลัง End ไม่เหมือนกับจบ โปรแกรม ที่จะใช้ "".""

procedure get_integer(var i : integer; dummy : integer);
{ เรารับ input จากผู้ใช้มาเก็บใน parameter i ที่เป็น integer ที่ตั้งขึ้นใน
  พารามิเตอร์ โดยใช้ var ประกาศ ทำให้ค่าที่รับเข้ามาจะเปลี่ยนปรับได้จาก
  ภายนอกการประกาศพารามิเตอร์นี้ ส่วน dummy เป็นตัวแปรที่ปรับเปลี่ยนได้
  ""เฉพาะจากภายในฟังก์ชั่น,โพรซีเยอร์นั้น ๆ }
Begin
    write('Enter an integer: ');
    readln(i);
    dummy := 4; // dummy จะไม่ทำให้ค่าที่ได้รับมาครั้งแรกใน main block เปลี่ยน
End;

//--------------------//
// main program block
//--------------------//
Begin 
    dummy := 3;
    get_integer(i, dummy);
    writeln(i, '! = ', factorial_recursion(i));
    // พิมพ์ค่า i!
    writeln('dummy = ', dummy); // จะให้ค่าเป็น '3' เสมอ 
                                // เพราะจะไม่เปลี่ยนเนื่องด้วย
                                // การประกาศพารามิเตอร์ใน
                                // โพรซีเยอร์ get_integer ด้านบน
End.

```

[1]:	https://en.wikipedia.org/wiki/Pascal_(programming_language)
[2]:	https://www.freepascal.org/"
"TypeScript เป็นภาษาที่มีเป้าหมายเพื่อทำให้การพัฒนาซอฟต์แวร์ขนาดใหญ่ด้วย JavaScript ทำได้ง่ายขึ้น โดยที่ TypeScript ได้เพิ่มแนวคิดที่พบทั่วไป อาทิ classes, modules, interfaces, generics และ static typing (ไม่บังคับ) เข้าไปในภาษา JavaScript ดังนั้น TypeScript ก็เลยเป็น Super Set ของ JavaScript อีกที โค้ด JavaScript ทุกส่วน ก็คือโค้ดที่ทำงานได้ถูกต้องใน TypeScript ทำให้เราเพิ่ม TypeScript เข้าไปใช้ในโปรเจคการพัฒนาของเราได้ไม่ยากเลย เพราะ TypeScript คอมไพล์ผลลัพธ์ออกมาเป็น JavaScript ในท้ายสุดอยู่ดี

บทความนี้จะเน้นเฉพาะ syntax ส่วนขยายของ TypeScript ซึ่งจะไม่รวมกับที่มีใน  [JavaScript](/docs/javascript)

การทดสอบเขียน TypeScript เริ่มได้ง่าย ๆ โดยเข้าไปที่
[Playground](http://www.typescriptlang.org/Playground) ซึ่งคุณจะเขียนโค้ดพร้อม autocomplete และเห็นเลยว่ามันจะแปลงมาเป็นผลลัพธ์แบบ JavaScript อย่างไร

```ts
// TypeScript มี data type พื้นฐาน 3 แบบ
let isDone: boolean = false;
let lines: number = 42;
let name: string = ""Anders"";

// แต่เราก็สามารถละการบอกชนิดได้ โดยชนิดตัวแปรก็จะปรับชนิดของเขาจากข้อมูลที่กำหนดให้โดยตรง
let isDone = false;
let lines = 42;
let name = ""Anders"";

// ถ้าไม่รู้ ก็กำหนดเป็นชนิด ""Any"" ได้
let notSure: any = 4;
notSure = ""maybe a string instead"";
notSure = false; // โอเค ตอนนี้เป็น Boolean แน่ ๆ

// ใช้ const สำหรับสร้าง ค่าคงที่
const numLivesForCat = 9;
numLivesForCat = 1; // Error

// สำหรับ collections มี typed arrays และ generic arrays
// ก็คือ อะเรย์บอกชนิด และ อะเรย์เจเนอริก ตามลำดับ
let list: number[] = [1, 2, 3];
// ในอีกทางหนึ่ง สร้างเป็นอะเรย์ชนิด generic array
let list: Array<number> = [1, 2, 3];

// และสำหรับ enumerations:
enum Color { Red, Green, Blue };
let c: Color = Color.Green;

// สุดท้าย, ""void"" ใช้เมื่อเป็นกรณีพิเศษที่ฟังก์ชันไม่ส่งค่ากลับ
function bigHorribleAlert(): void {
  alert(""I'm a little annoying box!"");
}

// ฟังก์ชั่น (Functions) เป็นสิ่งที่มีความสำคัญมาเป็นอันดับหนึ่ง รองรับการใช้ ""fat arrow"" ในการสร้าง lambda function และ type inference

// สไตล์ต่อไปนี้มีค่าเท่ากันกับบรรทัดที่ยกตัวอย่างด้านล่าง เพราะคอมไพเลอร์จะมองเหมือนกัน และได้ JavaScript แบบเดียวกัน
let f1 = function (i: number): number { return i * i; }
// อนุมานชนิดที่ส่งกลับ หรือ type inferred
let f2 = function (i: number) { return i * i; }
// เขียนแบบ ""Fat arrow"" แต่บอกชนิดส่งกลับ
let f3 = (i: number): number => { return i * i; }
// เขียนแบบ ""Fat arrow"" แต่อนุมานชนิดส่งกลับ
let f4 = (i: number) => { return i * i; }
// เขียนแบบ ""Fat arrow"" อนุมานชนิดส่งกลับ พร้อมกับไม่มีวงเล็บ แปลว่าไม่ต้องมี return keyword ด้วย
let f5 = (i: number) => i * i;

// Interfaces นั้นเป็นเหมือนเราออกแบบโครงสร้าง คุณสมบัติต่าง ๆ ตอนเอาไปใช้ จะต้องเป็นไปตาม interface นั้น ๆ เหมือนกับเป็นการกำหนดสเป็คของ ""ชนิดข้อมูล""
interface Person {
  name: string;
  // Optional properties กำหนดด้วย ""?""
  age?: number;
  // และมี function พร้อมชนิดได้ใน interface
  move(): void;
}

// Object นี้ implements ""Person"" interface ทำให้มันเป็นชนิด Person และมันก็มี property name และ function move() 
let p: Person = { name: ""Bobby"", move: () => { } };
// Objects นี้เป็นชนิด Person ด้วย และมี optional property หรือ age?: นั่นเอง
let validPerson: Person = { name: ""Bobby"", age: 42, move: () => { } };
// ไม่ใช่ Person เพราะ age: ต้องเป็น number เท่านั้น ตามข้อกำหนดใน interface Person
let invalidPerson: Person = { name: ""Bobby"", age: true };

// Interfaces ยังนำมาใช้ในลักษณะของ function ได้อีกด้วย
interface SearchFunc {
  (source: string, subString: string): boolean;
}
// เฉพาะชนิด parameters เท่านั้นที่สำคัญ ชื่อของมันไม่จำเป็นต้องเหมือน
let mySearch: SearchFunc;
mySearch = function (src: string, sub: string) {
  return src.search(sub) != -1;
}

// สมาชิกใน class จะเข้าถึงได้แบบ public เป็นค่าปริยาย
class Point {
  // Properties
  // ตั้งค่า Properties ของ class นี้
  x: number;

  // Constructor
  // เราใส่ public/private keywords ตรงนี้ได้ มีผลเหมือนกันกับกำหนด x ด้านบน
  // ในตัวอย่าง y มีการกำหนดเช่นเดียวกับ x แต่พิมพ์สั้นกว่า
  // สังเกตว่า มีการกำหนดค่าปริยายให้ parameters ได้ด้วย

  constructor(x: number, public y: number = 0) {
    this.x = x;
  }

  // Functions
  dist() { return Math.sqrt(this.x*this.x + this.y*this.y); }

  // Static members
  static origin = new Point(0, 0);
}

// Classes สามารถระบุชนิด interface ที่ต้องการได้ตรง ๆ ด้วยเช่นโค้ดด้านล่าง
// แต่อะไรที่จะ implement มานั้น ถ้าไม่ได้กำหนดไว้ใน constructor ก็จะเกิดข้อผิดพลาดตอนคอมไพล์
class PointPerson implements Person {
    name: string  // ตรงนี้จะผิด แก้ไขโดยการไปสร้างตัวรับค่าเข้ามาผ่านทาง constructor
    move() {}
}

let p1 = new Point(10, 20);
let p2 = new Point(25); //y เป็น 0 เพราะกำหนดค่าปริยายไว้ให้แล้ว

// Inheritance การสืบทอดคุณสมบัติ
class Point3D extends Point {
  constructor(x: number, y: number, public z: number = 0) {
    super(x, y); // เราจะต้องเรียกใช้ super class constructor โดยตรง
  }

  // Overwrite ฟังก์ชั่นที่มีอยู่เดิมใน Point
  dist() {
    let d = super.dist();
    return Math.sqrt(d * d + this.z * this.z);
  }
}

// Modules ใช้เป็นกลุ่มของ class เราใช้ ""."" เป็นตัวแบ่ง sub modules
// อย่างกรณีนี้จะเป็น Module.Class เช่น Geometry.Square
module Geometry {
  export class Square {
    constructor(public sideLength: number = 0) {
    }
    area() {
      return Math.pow(this.sideLength, 2);
    }
  }
}

let s1 = new Geometry.Square(5);

// เราทำให้เรียกใช้ง่ายขึ้นโดยการใช้ alias มาอ้างชื่อ module แบบเดียวกับบางภาษา เช่น Python
import G = Geometry;

let s2 = new G.Square(10);

// Generics
// Classes
class Tuple<T1, T2> {
  constructor(public item1: T1, public item2: T2) {
  }
}

// Interfaces
interface Pair<T> {
  item1: T;
  item2: T;
}

// และ functions
let pairToTuple = function <T>(p: Pair<T>) {
  return new Tuple(p.item1, p.item2);
};

let tuple = pairToTuple({ item1: ""hello"", item2: ""world"" });

// เราเรียกใช้ไฟล์ definition แบบนี้:
/// <reference path=""jquery.d.ts"" />

// Template Strings ( คือ strings ที่ใช้ backticks ครอบ — ""`"" ปุ่มบนซ้ายคีย์บอร์ด )
// แทรกข้อความใน String ด้วย Template Strings
let name = 'Tyrone';
let greeting = `Hi ${name}, how are you?`
// Strings หลายบรรทัดก็ทำได้ใน Template Strings
let multiline = `This is an example
of a multiline string`;

// READONLY: ความสามารถใหม่ใน TypeScript 3.1
interface Person {
  readonly name: string;
  readonly age: number;
}

var p1: Person = { name: ""Tyrone"", age: 42 };
p1.age = 25; // Error แน่นอน เพราะ p1.age ถูกกำหนดเป็น read-only

var p2 = { name: ""John"", age: 60 }; // สังเกตว่า p2 ไม่ได้กำหนดเป็น Person
var p3: Person = p2; // ทำได้ เป็น read-only alias ของ p2 และกำหนดเป็น Person
p3.x = 35; // Error p3.x ก็เป็น read-only
p2.x = 45; // Ok ทำได้แต่ก็จะเปลี่ยนค่า p3.x ด้วย เพราะ p3 เป็น alias ของ p2

class Car {
  readonly make: string;
  readonly model: string;
  readonly year = 2018;

  constructor() {
    this.make  = ""Unknown Make"";   // อนุญาตให้กำหนดค่าได้ใน constructor แม้ว่าจะ read-only
    this.model = ""Unknown Model""; // อนุญาตให้กำหนดค่าได้ใน constructor แม้ว่าจะ read-only
  }
}

let numbers: Array<number> = [0, 1, 2, 3, 4];
let moreNumbers: ReadonlyArray<number> = numbers;
moreNumbers[5] = 5;     // Error, สมาชิกอะเรย์เป็น read-only แปลว่า ห้ามแก้ไข
moreNumbers.push(5);    // Error, push method ใช้ไม่ได้ เพราะมันจะไปแก้ไข read-only array
moreNumbers.length = 3; // Error, เพราะ length ก็ต้อง read-only
numbers = moreNumbers;  // Error, method ที่ทำให้อะเรย์เปลี่ยนได้จะไม่อนุญาต

// Tagged Union Types สำหรับโมเดลสเตท ที่อาจจะมีได้หลายๆ สเตท
type State = 
  | { type: ""loading"" }
  | { type: ""success"", value: number }
  | { type: ""error"", message: string };

ประกาศ const state: State;
if (state.type === ""success"") {
  console.log(state.value);
} else if (state.type === ""error"") {
  console.error(state.message);
}

// Iterators และ Generators

// ประโยคแบบ for..of
// การทำซ้ำกับ ลิสต์ของค่าในออปเจ็คต์
let arrayOfAnyType = [1, ""string"", false];
for (const val of arrayOfAnyType) {
    console.log(val); // 1, ""string"", false
}

let list = [4, 5, 6];
for (const i of list) {
   console.log(i); // 4, 5, 6
}

// ประโยคแบบ for..in
// การทำซ้ำกับ ลิสต์ของคีย์ในออปเจ็คต์
for (const i in list) {
   console.log(i); // 0, 1, 2
}


```

## อ่านเพิ่มเติมที่
 * [TypeScript Official website] (http://www.typescriptlang.org/)
 * [TypeScript language specifications] (https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md)
 * [Anders Hejlsberg - Introducing TypeScript on Channel 9] (http://channel9.msdn.com/posts/Anders-Hejlsberg-Introducing-TypeScript)
 * [Source Code on GitHub] (https://github.com/Microsoft/TypeScript)
 * [Definitely Typed - repository for type definitions] (http://definitelytyped.org/)"
"Structured Query Language (SQL) is an [ISO/IEC 9075](https://www.iso.org/standard/63555.html) standard language for creating and working with databases stored in a set of tables. Implementations usually add their own extensions to the language; [Comparison of different SQL implementations](http://troels.arvin.dk/db/rdbms/) is a good reference on product differences.

Implementations typically provide a command line prompt where you can enter the commands shown here interactively, and they also offer a way to execute a series of these commands stored in a script file.  (Showing that you’re done with the interactive prompt is a good example of something that isn’t standardized--most SQL implementations support the keywords QUIT, EXIT, or both.)

Several of these sample commands assume that the [MySQL employee sample database](https://dev.mysql.com/doc/employee/en/) available on [github](https://github.com/datacharmer/test_db) has already been loaded. The github files are scripts of commands, similar to the relevant commands below, that create and populate tables of data about a fictional company’s employees. The syntax for running these scripts will depend on the SQL implementation you are using. A utility that you run from the operating system prompt is typical.


```sql
-- Comments start with two hyphens. End each command with a semicolon.

-- SQL is not case-sensitive about keywords. The sample commands here
-- follow the convention of spelling them in upper-case because it makes
-- it easier to distinguish them from database, table, and column names.

-- Create and delete a database. Database and table names are case-sensitive.
CREATE DATABASE someDatabase;
DROP DATABASE someDatabase;

-- List available databases.
SHOW DATABASES;

-- Use a particular existing database.
USE employees;

-- Select all rows and columns from the current database's departments table.
-- Default activity is for the interpreter to scroll the results on your screen.
SELECT * FROM departments;

-- Retrieve all rows from the departments table,
-- but only the dept_no and dept_name columns.
-- Splitting up commands across lines is OK.
SELECT dept_no,
       dept_name FROM departments;

-- Retrieve all departments columns, but just 5 rows.
SELECT * FROM departments LIMIT 5;

-- Retrieve dept_name column values from the departments
-- table where the dept_name value has the substring 'en'.
SELECT dept_name FROM departments WHERE dept_name LIKE '%en%';

-- Retrieve all columns from the departments table where the dept_name
-- column starts with an 'S' and has exactly 4 characters after it.
SELECT * FROM departments WHERE dept_name LIKE 'S____';

-- Select title values from the titles table but don't show duplicates.
SELECT DISTINCT title FROM titles;

-- Same as above, but sorted (case-sensitive) by the title values.
SELECT DISTINCT title FROM titles ORDER BY title;

-- Show the number of rows in the departments table.
SELECT COUNT(*) FROM departments;

-- Show the number of rows in the departments table that
-- have 'en' as a substring of the dept_name value.
SELECT COUNT(*) FROM departments WHERE dept_name LIKE '%en%';

-- A JOIN of information from multiple tables: the titles table shows
-- who had what job titles, by their employee numbers, from what
-- date to what date. Retrieve this information, but instead of the
-- employee number, use the employee number as a cross-reference to
-- the employees table to get each employee's first and last name
-- instead. (And only get 10 rows.)

SELECT employees.first_name, employees.last_name,
       titles.title, titles.from_date, titles.to_date
FROM titles INNER JOIN employees ON
       employees.emp_no = titles.emp_no LIMIT 10;

-- List all the tables in all the databases. Implementations typically provide
-- their own shortcut command to do this with the database currently in use.
SELECT * FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_TYPE='BASE TABLE';

-- Create a table called tablename1, with the two columns shown, for
-- the database currently in use. Lots of other options are available
-- for how you specify the columns, such as their datatypes.
CREATE TABLE tablename1 (fname VARCHAR(20), lname VARCHAR(20));

-- Insert a row of data into the table tablename1. This assumes that the
-- table has been defined to accept these values as appropriate for it.
INSERT INTO tablename1 VALUES('Richard','Mutt');

-- In tablename1, change the fname value to 'John'
-- for all rows that have an lname value of 'Mutt'.
UPDATE tablename1 SET fname='John' WHERE lname='Mutt';

-- Delete rows from the tablename1 table
-- where the lname value begins with 'M'.
DELETE FROM tablename1 WHERE lname LIKE 'M%';

-- Delete all rows from the tablename1 table, leaving the empty table.
DELETE FROM tablename1;

-- Remove the entire tablename1 table.
DROP TABLE tablename1;
```

## Further Reading

* [Codecademy - SQL](https://www.codecademy.com/learn/learn-sql) A good introduction to SQL in a ""learn by doing it"" format.
* [Database System Concepts](https://www.db-book.com) book's Chapter 3 - Introduction to SQL has an in depth explanation of SQL concepts."
"Java is a general-purpose, concurrent, class-based, object-oriented computer
programming language.
[Read more here.](https://docs.oracle.com/javase/tutorial/java/)

```java
// Single-line comments start with //

/*
Multi-line comments look like this.
*/

/**
 * JavaDoc comments look like this. Used to describe the Class or various
 * attributes of a Class.
 * Main attributes:
 *
 * @author         Name (and contact information such as email) of author(s).
 * @version     Current version of the program.
 * @since        When this part of the program was first added.
 * @param         For describing the different parameters for a method.
 * @return        For describing what the method returns.
 * @deprecated  For showing the code is outdated or shouldn't be used.
 * @see         Links to another part of documentation.
*/

// Import ArrayList class inside of the java.util package
import java.util.ArrayList;
// Import all classes inside of java.security package
import java.security.*;

public class LearnJava {

    // In order to run a java program, it must have a main method as an entry
    // point.
    public static void main(String[] args) {

    ///////////////////////////////////////
    // Input/Output
    ///////////////////////////////////////

        /*
        * Output
        */

        // Use System.out.println() to print lines.
        System.out.println(""Hello World!"");
        System.out.println(
            ""Integer: "" + 10 +
            "" Double: "" + 3.14 +
            "" Boolean: "" + true);

        // To print without a newline, use System.out.print().
        System.out.print(""Hello "");
        System.out.print(""World"");

        // Use System.out.printf() for easy formatted printing.
        System.out.printf(""pi = %.5f"", Math.PI); // => pi = 3.14159

        /*
         * Input
         */

        // use Scanner to read input
        // must import java.util.Scanner;
        Scanner scanner = new Scanner(System.in);

        // read string input
        String name = scanner.next();

        // read byte input
        byte numByte = scanner.nextByte();

        // read int input
        int numInt = scanner.nextInt();

        // read long input
        long numLong = scanner.nextLong();

        // read float input
        float numFloat = scanner.nextFloat();

        // read double input
        double numDouble = scanner.nextDouble();

        // read boolean input
        boolean bool = scanner.nextBoolean();

        ///////////////////////////////////////
        // Variables
        ///////////////////////////////////////

        /*
        *  Variable Declaration
        */
        // Declare a variable using <type> <name>
        int fooInt;
        // Declare multiple variables of the same
        // type <type> <name1>, <name2>, <name3>
        int fooInt1, fooInt2, fooInt3;

        /*
        *  Variable Initialization
        */

        // Initialize a variable using <type> <name> = <val>
        int barInt = 1;
        // Initialize multiple variables of same type with same
        // value <type> <name1>, <name2>, <name3>
        // <name1> = <name2> = <name3> = <val>
        int barInt1, barInt2, barInt3;
        barInt1 = barInt2 = barInt3 = 1;

        /*
        *  Variable types
        */
        // Byte - 8-bit signed two's complement integer
        // (-128 <= byte <= 127)
        byte fooByte = 100;

        // If you would like to interpret a byte as an unsigned integer
        // then this simple operation can help
        int unsignedIntLessThan256 = 0xff & fooByte;
        // this contrasts a cast which can be negative.
        int signedInt = (int) fooByte;

        // Short - 16-bit signed two's complement integer
        // (-32,768 <= short <= 32,767)
        short fooShort = 10000;

        // Integer - 32-bit signed two's complement integer
        // (-2,147,483,648 <= int <= 2,147,483,647)
        int bazInt = 1;

        // Long - 64-bit signed two's complement integer
        // (-9,223,372,036,854,775,808 <= long <= 9,223,372,036,854,775,807)
        long fooLong = 100000L;
        // L is used to denote that this variable value is of type Long;
        // anything without is treated as integer by default.

        // Note: byte, short, int and long are signed. They can have positive and negative values.
        // There are no unsigned variants.
        // char, however, is 16-bit unsigned.

        // Float - Single-precision 32-bit IEEE 754 Floating Point
        // 2^-149 <= float <= (2-2^-23) * 2^127
        float fooFloat = 234.5f;
        // f or F is used to denote that this variable value is of type float;
        // otherwise it is treated as double.

        // Double - Double-precision 64-bit IEEE 754 Floating Point
        // 2^-1074 <= x <= (2-2^-52) * 2^1023
        double fooDouble = 123.4;

        // Boolean - true & false
        boolean fooBoolean = true;
        boolean barBoolean = false;

        // Char - A single 16-bit Unicode character
        char fooChar = 'A';

        // final variables can't be reassigned,
        final int HOURS_I_WORK_PER_WEEK = 9001;
        // but they can be initialized later.
        final double E;
        E = 2.71828;

        // BigInteger - Immutable arbitrary-precision integers
        //
        // BigInteger is a data type that allows programmers to manipulate
        // integers longer than 64-bits. Integers are stored as an array of
        // bytes and are manipulated using functions built into BigInteger
        //
        // BigInteger can be initialized using an array of bytes or a string.
        BigInteger fooBigInteger = new BigInteger(fooByteArray);

        // BigDecimal - Immutable, arbitrary-precision signed decimal number
        //
        // A BigDecimal takes two parts: an arbitrary precision integer
        // unscaled value and a 32-bit integer scale
        //
        // BigDecimal allows the programmer complete control over decimal
        // rounding. It is recommended to use BigDecimal with currency values
        // and where exact decimal precision is required.
        //
        // BigDecimal can be initialized with an int, long, double or String
        // or by initializing the unscaled value (BigInteger) and scale (int).
        BigDecimal fooBigDecimal = new BigDecimal(fooBigInteger, fooInt);

        // Be wary of the constructor that takes a float or double as
        // the inaccuracy of the float/double will be copied in BigDecimal.
        // Prefer the String constructor when you need an exact value.
        BigDecimal tenCents = new BigDecimal(""0.1"");

        // Strings
        String fooString = ""My String Is Here!"";

        // \n is an escaped character that starts a new line
        String barString = ""Printing on a new line?\nNo Problem!"";
        // \t is an escaped character that adds a tab character
        String bazString = ""Do you want to add a tab?\tNo Problem!"";
        System.out.println(fooString);
        System.out.println(barString);
        System.out.println(bazString);

        // String Building
        // #1 - with plus operator
        // That's the basic way to do it (optimized under the hood)
        String plusConcatenated = ""Strings can "" + ""be concatenated "" + ""via + operator."";
        System.out.println(plusConcatenated);
        // Output: Strings can be concatenated via + operator.

        // #2 - with StringBuilder
        // This way doesn't create any intermediate strings. It just stores the string pieces, and ties them together
        // when toString() is called.
        // Hint: This class is not thread safe. A thread-safe alternative (with some impact on performance) is StringBuffer.
        StringBuilder builderConcatenated = new StringBuilder();
        builderConcatenated.append(""You "");
        builderConcatenated.append(""can use "");
        builderConcatenated.append(""the StringBuilder class."");
        System.out.println(builderConcatenated.toString()); // only now is the string built
        // Output: You can use the StringBuilder class.

        // StringBuilder is efficient when the fully constructed String is not required until the end of some processing.
        StringBuilder stringBuilder = new StringBuilder();
        String inefficientString = """";
        for (int i = 0 ; i < 10; i++) {
            stringBuilder.append(i).append("" "");
            inefficientString += i + "" "";
        }
        System.out.println(inefficientString);
        System.out.println(stringBuilder.toString());
        // inefficientString requires a lot more work to produce, as it generates a String on every loop iteration.
        // Simple concatenation with + is compiled to a StringBuilder and toString()
        // Avoid string concatenation in loops.

        // #3 - with String formatter
        // Another alternative way to create strings. Fast and readable.
        String.format(""%s may prefer %s."", ""Or you"", ""String.format()"");
        // Output: Or you may prefer String.format().

        // Arrays
        // The array size must be decided upon instantiation
        // The following formats work for declaring an array
        // <datatype>[] <var name> = new <datatype>[<array size>];
        // <datatype> <var name>[] = new <datatype>[<array size>];
        int[] intArray = new int[10];
        String[] stringArray = new String[1];
        boolean boolArray[] = new boolean[100];

        // Another way to declare & initialize an array
        int[] y = {9000, 1000, 1337};
        String names[] = {""Bob"", ""John"", ""Fred"", ""Juan Pedro""};
        boolean bools[] = {true, false, false};

        // Indexing an array - Accessing an element
        System.out.println(""intArray @ 0: "" + intArray[0]);

        // Arrays are zero-indexed and mutable.
        intArray[1] = 1;
        System.out.println(""intArray @ 1: "" + intArray[1]); // => 1

        // Other data types worth checking out
        // ArrayLists - Like arrays except more functionality is offered, and
        //              the size is mutable.
        // LinkedLists - Implementation of doubly-linked list. All of the
        //               operations perform as could be expected for a
        //               doubly-linked list.
        // Maps - A mapping of key Objects to value Objects. Map is
        //        an interface and therefore cannot be instantiated.
        //        The type of keys and values contained in a Map must
        //        be specified upon instantiation of the implementing
        //        class. Each key may map to only one corresponding value,
        //        and each key may appear only once (no duplicates).
        // HashMaps - This class uses a hashtable to implement the Map
        //            interface. This allows the execution time of basic
        //            operations, such as get and insert element, to remain
        //            constant-amortized even for large sets.
        // TreeMap - A Map that is sorted by its keys. Each modification
        //           maintains the sorting defined by either a Comparator
        //           supplied at instantiation, or comparisons of each Object
        //           if they implement the Comparable interface.
        //           Failure of keys to implement Comparable combined with failure to
        //           supply a Comparator will throw ClassCastExceptions.
        //           Insertion and removal operations take O(log(n)) time
        //           so avoid using this data structure unless you are taking
        //           advantage of the sorting.

        ///////////////////////////////////////
        // Operators
        ///////////////////////////////////////
        System.out.println(""\n->Operators"");

        int i1 = 1, i2 = 2; // Shorthand for multiple declarations

        // Arithmetic is straightforward
        System.out.println(""1+2 = "" + (i1 + i2)); // => 3
        System.out.println(""2-1 = "" + (i2 - i1)); // => 1
        System.out.println(""2*1 = "" + (i2 * i1)); // => 2
        System.out.println(""1/2 = "" + (i1 / i2)); // => 0 (int/int returns int)
        System.out.println(""1/2.0 = "" + (i1 / (double)i2)); // => 0.5

        // Modulo
        System.out.println(""11%3 = "" + (11 % 3)); // => 2

        // Comparison operators
        System.out.println(""3 == 2? "" + (3 == 2)); // => false
        System.out.println(""3 != 2? "" + (3 != 2)); // => true
        System.out.println(""3 > 2? "" + (3 > 2)); // => true
        System.out.println(""3 < 2? "" + (3 < 2)); // => false
        System.out.println(""2 <= 2? "" + (2 <= 2)); // => true
        System.out.println(""2 >= 2? "" + (2 >= 2)); // => true

        // Boolean operators
        System.out.println(""3 > 2 && 2 > 3? "" + ((3 > 2) && (2 > 3))); // => false
        System.out.println(""3 > 2 || 2 > 3? "" + ((3 > 2) || (2 > 3))); // => true
        System.out.println(""!(3 == 2)? "" + (!(3 == 2))); // => true

        // Bitwise operators!
        /*
        ~      Unary bitwise complement
        <<     Signed left shift
        >>     Signed/Arithmetic right shift
        >>>    Unsigned/Logical right shift
        &      Bitwise AND
        ^      Bitwise exclusive OR
        |      Bitwise inclusive OR
        */

        // Increment operators
        int i = 0;
        System.out.println(""\n->Inc/Dec-rementation"");
        // The ++ and -- operators increment and decrement by 1 respectively.
        // If they are placed before the variable, they increment then return;
        // after the variable they return then increment.
        System.out.println(i++); // i = 1, prints 0 (post-increment)
        System.out.println(++i); // i = 2, prints 2 (pre-increment)
        System.out.println(i--); // i = 1, prints 2 (post-decrement)
        System.out.println(--i); // i = 0, prints 0 (pre-decrement)

        ///////////////////////////////////////
        // Control Structures
        ///////////////////////////////////////
        System.out.println(""\n->Control Structures"");

        // If statements are c-like
        int j = 10;
        if (j == 10) {
            System.out.println(""I get printed"");
        } else if (j > 10) {
            System.out.println(""I don't"");
        } else {
            System.out.println(""I also don't"");
        }

        // While loop
        int fooWhile = 0;
        while (fooWhile < 100) {
            System.out.println(fooWhile);
            // Increment the counter
            // Iterated 100 times, fooWhile 0,1,2...99
            fooWhile++;
        }
        System.out.println(""fooWhile Value: "" + fooWhile);

        // Do While Loop
        int fooDoWhile = 0;
        do {
            System.out.println(fooDoWhile);
            // Increment the counter
            // Iterated 100 times, fooDoWhile 0->99
            fooDoWhile++;
        } while (fooDoWhile < 100);
        System.out.println(""fooDoWhile Value: "" + fooDoWhile);

        // For Loop
        // for loop structure => for(<start_statement>; <conditional>; <step>)
        for (int fooFor = 0; fooFor < 10; fooFor++) {
            System.out.println(fooFor);
            // Iterated 10 times, fooFor 0->9
        }
        System.out.println(""fooFor Value: "" + fooFor);

        // Nested For Loop Exit with Label
        outer:
        for (int i = 0; i < 10; i++) {
          for (int j = 0; j < 10; j++) {
            if (i == 5 && j ==5) {
              break outer;
              // breaks out of outer loop instead of only the inner one
            }
          }
        }

        // For Each Loop
        // The for loop is also able to iterate over arrays as well as objects
        // that implement the Iterable interface.
        int[] fooList = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        // for each loop structure => for (<object> : <iterable>)
        // reads as: for each element in the iterable
        // note: the object type must match the element type of the iterable.
        for (int bar : fooList) {
            System.out.println(bar);
            //Iterates 9 times and prints 1-9 on new lines
        }

        // Switch Case
        // A switch works with the byte, short, char, and int data types.
        // It also works with enumerated types (discussed in Enum Types), the
        // String class, and a few special classes that wrap primitive types:
        // Character, Byte, Short, and Integer.
        // Starting in Java 7 and above, we can also use the String type.
        // Note: Do remember that, not adding ""break"" at end any particular case ends up in
        // executing the very next case(given it satisfies the condition provided) as well.
        int month = 3;
        String monthString;
        switch (month) {
            case 1: monthString = ""January"";
                    break;
            case 2: monthString = ""February"";
                    break;
            case 3: monthString = ""March"";
                    break;
            default: monthString = ""Some other month"";
                     break;
        }
        System.out.println(""Switch Case Result: "" + monthString);


        // Try-with-resources (Java 7+)
        // Try-catch-finally statements work as expected in Java but in Java 7+
        // the try-with-resources statement is also available. Try-with-resources
        // simplifies try-catch-finally statements by closing resources
        // automatically.

        // In order to use a try-with-resources, include an instance of a class
        // in the try statement. The class must implement java.lang.AutoCloseable.
        try (BufferedReader br = new BufferedReader(new FileReader(""foo.txt""))) {
            // You can attempt to do something that could throw an exception.
            System.out.println(br.readLine());
            // In Java 7, the resource will always be closed, even if it throws
            // an Exception.
        } catch (Exception ex) {
            //The resource will be closed before the catch statement executes.
            System.out.println(""readLine() failed."");
        }
        // No need for a finally statement in this case, the BufferedReader is
        // already closed. This can be used to avoid certain edge cases where
        // a finally statement might not be called.
        // To learn more:
        // https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html


        // Conditional Shorthand
        // You can use the '?' operator for quick assignments or logic forks.
        // Reads as ""If (statement) is true, use <first value>, otherwise, use
        // <second value>""
        int foo = 5;
        String bar = (foo < 10) ? ""A"" : ""B"";
        System.out.println(""bar : "" + bar); // Prints ""bar : A"", because the
        // statement is true.
        // Or simply
        System.out.println(""bar : "" + (foo < 10 ? ""A"" : ""B""));


        ////////////////////////////////////////
        // Converting Data Types
        ////////////////////////////////////////

        // Converting data

        // Convert String To Integer
        Integer.parseInt(""123"");//returns an integer version of ""123""

        // Convert Integer To String
        Integer.toString(123);//returns a string version of 123

        // For other conversions check out the following classes:
        // Double
        // Long
        // String

        ///////////////////////////////////////
        // Classes And Functions
        ///////////////////////////////////////

        System.out.println(""\n->Classes & Functions"");

        // (definition of the Bicycle class follows)

        // Use new to instantiate a class
        Bicycle trek = new Bicycle();

        // Call object methods
        trek.speedUp(3); // You should always use setter and getter methods
        trek.setCadence(100);

        // toString returns this Object's string representation.
        System.out.println(""trek info: "" + trek.toString());
    } // End main method

    private static class TestInitialization {
        // Double Brace Initialization
        // Before Java 11, the Java Language had no syntax for how to create
        // static Collections in an easy way. Usually you end up like this:
        private static final Set<String> COUNTRIES = new HashSet<String>();
        static {
           COUNTRIES.add(""DENMARK"");
           COUNTRIES.add(""SWEDEN"");
           COUNTRIES.add(""FINLAND"");
        }

        // There's a nifty way to achieve the same thing, 
        // by using something that is called Double Brace Initialization.
        private static final Set<String> COUNTRIES_DOUBLE_BRACE = 
        new HashSet<String>() {{
            add(""DENMARK"");
            add(""SWEDEN"");
            add(""FINLAND"");
        }}

        // The first brace is creating a new AnonymousInnerClass and the
        // second one declares an instance initializer block. This block
        // is called when the anonymous inner class is created.
        // This does not only work for Collections, it works for all
        // non-final classes.
        

        // Another option was to initialize the Collection from an array,
        // using Arrays.asList() method:
        private static final List<String> COUNTRIES_AS_LIST = 
                        Arrays.asList(""SWEDEN"", ""DENMARK"", ""NORWAY"");
        // This has one catch: the list we get is internally backed by the array,
        // and since arrays can't change their size, the list backed by the array
        // is not resizeable, which means we can't add new elements to it: 
        public static void main(String[] args) {
            COUNTRIES.add(""FINLAND""); // throws UnsupportedOperationException!
            // However, we can replace elements by index, just like in array: 
            COUNTRIES.set(1, ""FINLAND"");
            System.out.println(COUNTRIES); // prints [SWEDEN, FINLAND, NORWAY]
        }
        // The resizing problem can be circumvented 
        // by creating another Collection from the List:
         private static final Set<String> COUNTRIES_SET = 
                new HashSet<>(Arrays.asList(""SWEDEN"", ""DENMARK"", ""NORWAY""));
        // It's perfectly fine to add anything to the Set of COUNTRIES now. 
    } // End TestInitialization class

    private static class TestJava11Initialization {
        // Since Java 11, there is a convenient option to initialize Collections:
        // Set.of() and List.of() methods. 
        private static final Set<String> COUNTRIES = 
                Set.of(""SWEDEN"", ""DENMARK"", ""NORWAY"");
        // There is a massive catch, though: Lists and Sets initialized like this 
        // 1) are immutable 
        // 2) can't contain null elements (even check for null elements fails)!
        public static void main(String[] args) {
            COUNTRIES.add(""FINLAND""); // throws UnsupportedOperationException
            COUNTRIES.remove(""NORWAY""); // throws UnsupportedOperationException 
            COUNTRIES.contains(null); // throws NullPointerException
        }
        private static final Set<String> COUNTRIES_WITH_NULL = 
                    Set.of(""SWEDEN"", null, ""NORWAY""); // throws NullPointerException

    } // End TestJava11Initialization class
} // End LearnJava class

// You can include other, non-public outer-level classes in a .java file,
// but it is not good practice. Instead split classes into separate files.

// Class Declaration Syntax:
// <public/private/protected> class <class name> {
//    // data fields, constructors, functions all inside.
//    // functions are called as methods in Java.
// }

class Bicycle {

    // Bicycle's Fields/Variables
    public int cadence; // Public: Can be accessed from anywhere
    private int speed;  // Private: Only accessible from within the class
    protected int gear; // Protected: Accessible from the class and subclasses
    String name; // default: Only accessible from within this package
    static String className; // Static class variable

    // Static block
    // Java has no implementation of static constructors, but
    // has a static block that can be used to initialize class variables
    // (static variables).
    // This block will be called when the class is loaded.
    static {
        className = ""Bicycle"";
    }

    // Constructors are a way of creating classes
    // This is a constructor
    public Bicycle() {
        // You can also call another constructor:
        // this(1, 50, 5, ""Bontrager"");
        gear = 1;
        cadence = 50;
        speed = 5;
        name = ""Bontrager"";
    }
    // This is a constructor that takes arguments
    public Bicycle(int startCadence, int startSpeed, int startGear,
        String name) {
        this.gear = startGear;
        this.cadence = startCadence;
        this.speed = startSpeed;
        this.name = name;
    }

    // Method Syntax:
    // <public/private/protected> <return type> <function name>(<args>)

    // Java classes often implement getters and setters for their fields

    // Method declaration syntax:
    // <access modifier> <return type> <method name>(<args>)
    public int getCadence() {
        return cadence;
    }

    // void methods require no return statement
    public void setCadence(int newValue) {
        cadence = newValue;
    }
    public void setGear(int newValue) {
        gear = newValue;
    }
    public void speedUp(int increment) {
        speed += increment;
    }
    public void slowDown(int decrement) {
        speed -= decrement;
    }
    public void setName(String newName) {
        name = newName;
    }
    public String getName() {
        return name;
    }

    //Method to display the attribute values of this Object.
    @Override // Inherited from the Object class.
    public String toString() {
        return ""gear: "" + gear + "" cadence: "" + cadence + "" speed: "" + speed +
            "" name: "" + name;
    }
} // end class Bicycle

// PennyFarthing is a subclass of Bicycle
class PennyFarthing extends Bicycle {
    // (Penny Farthings are those bicycles with the big front wheel.
    // They have no gears.)

    public PennyFarthing(int startCadence, int startSpeed) {
        // Call the parent constructor with super
        super(startCadence, startSpeed, 0, ""PennyFarthing"");
    }

    // You should mark a method you're overriding with an @annotation.
    // To learn more about what annotations are and their purpose check this
    // out: http://docs.oracle.com/javase/tutorial/java/annotations/
    @Override
    public void setGear(int gear) {
        this.gear = 0;
    }
}

// Object casting
// Since the PennyFarthing class is extending the Bicycle class, we can say
// a PennyFarthing is a Bicycle and write :
// Bicycle bicycle = new PennyFarthing();
// This is called object casting where an object is taken for another one. There
// are lots of details and deals with some more intermediate concepts here:
// https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html

// Interfaces
// Interface declaration syntax
// <access-level> interface <interface-name> extends <super-interfaces> {
//     // Constants
//     // Method declarations
// }

// Example - Food:
public interface Edible {
    public void eat(); // Any class that implements this interface, must
                       // implement this method.
}

public interface Digestible {
    public void digest();
    // Since Java 8, interfaces can have default method.
    public default void defaultMethod() {
        System.out.println(""Hi from default method ..."");
    }
}

// We can now create a class that implements both of these interfaces.
public class Fruit implements Edible, Digestible {
    @Override
    public void eat() {
        // ...
    }

    @Override
    public void digest() {
        // ...
    }
}

// In Java, you can extend only one class, but you can implement many
// interfaces. For example:
public class ExampleClass extends ExampleClassParent implements InterfaceOne,
    InterfaceTwo {
    @Override
    public void InterfaceOneMethod() {
    }

    @Override
    public void InterfaceTwoMethod() {
    }

}

// Abstract Classes

// Abstract Class declaration syntax
// <access-level> abstract class <abstract-class-name> extends
// <super-abstract-classes> {
//     // Constants and variables
//     // Method declarations
// }

// Abstract Classes cannot be instantiated.
// Abstract classes may define abstract methods.
// Abstract methods have no body and are marked abstract
// Non-abstract child classes must @Override all abstract methods
// from their super-classes.
// Abstract classes can be useful when combining repetitive logic
// with customised behavior, but as Abstract classes require
// inheritance, they violate ""Composition over inheritance""
// so consider other approaches using composition.
// https://en.wikipedia.org/wiki/Composition_over_inheritance

public abstract class Animal
{
    private int age;

    public abstract void makeSound();

    // Method can have a body
    public void eat()
    {
        System.out.println(""I am an animal and I am Eating."");
        // Note: We can access private variable here.
        age = 30;
    }

    public void printAge()
    {
        System.out.println(age);
    }

    // Abstract classes can have main method.
    public static void main(String[] args)
    {
        System.out.println(""I am abstract"");
    }
}

class Dog extends Animal
{
    // Note still have to override the abstract methods in the
    // abstract class.
    @Override
    public void makeSound()
    {
        System.out.println(""Bark"");
        // age = 30;    ==> ERROR!    age is private to Animal
    }

    // NOTE: You will get an error if you used the
    // @Override annotation here, since java doesn't allow
    // overriding of static methods.
    // What is happening here is called METHOD HIDING.
    // Check out this SO post: http://stackoverflow.com/questions/16313649/
    public static void main(String[] args)
    {
        Dog pluto = new Dog();
        pluto.makeSound();
        pluto.eat();
        pluto.printAge();
    }
}

// Final Classes

// Final Class declaration syntax
// <access-level> final <final-class-name> {
//     // Constants and variables
//     // Method declarations
// }

// Final classes are classes that cannot be inherited from and are therefore a
// final child. In a way, final classes are the opposite of abstract classes
// because abstract classes must be extended, but final classes cannot be
// extended.
public final class SaberToothedCat extends Animal
{
    // Note still have to override the abstract methods in the
    // abstract class.
    @Override
    public void makeSound()
    {
        System.out.println(""Roar"");
    }
}

// Final Methods
public abstract class Mammal()
{
    // Final Method Syntax:
    // <access modifier> final <return type> <function name>(<args>)

    // Final methods, like, final classes cannot be overridden by a child
    // class, and are therefore the final implementation of the method.
    public final boolean isWarmBlooded()
    {
        return true;
    }
}

// Enum Type
//
// An enum type is a special data type that enables for a variable to be a set
// of predefined constants. The variable must be equal to one of the values
// that have been predefined for it. Because they are constants, the names of
// an enum type's fields are in uppercase letters. In the Java programming
// language, you define an enum type by using the enum keyword. For example,
// you would specify a days-of-the-week enum type as:
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY
}

// We can use our enum Day like that:
public class EnumTest {
    // Variable Enum
    Day day;

    public EnumTest(Day day) {
        this.day = day;
    }

    public void tellItLikeItIs() {
        switch (day) {
            case MONDAY:
                System.out.println(""Mondays are bad."");
                break;
            case FRIDAY:
                System.out.println(""Fridays are better."");
                break;
            case SATURDAY:
            case SUNDAY:
                System.out.println(""Weekends are best."");
                break;
            default:
                System.out.println(""Midweek days are so-so."");
                break;
        }
    }

    public static void main(String[] args) {
        EnumTest firstDay = new EnumTest(Day.MONDAY);
        firstDay.tellItLikeItIs(); // => Mondays are bad.
        EnumTest thirdDay = new EnumTest(Day.WEDNESDAY);
        thirdDay.tellItLikeItIs(); // => Midweek days are so-so.
    }
}

// Enum types are much more powerful than we show above.
// The enum body can include methods and other fields.
// You can see more at https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html

// Getting Started with Lambda Expressions
//
// New to Java version 8 are lambda expressions. Lambdas are more commonly found
// in functional programming languages, which means they are methods which can
// be created without belonging to a class, passed around as if it were itself
// an object, and executed on demand.
//
// Final note, lambdas must implement a functional interface. A functional
// interface is one which has only a single abstract method declared. It can
// have any number of default methods. Lambda expressions can be used as an
// instance of that functional interface. Any interface meeting the requirements
// is treated as a functional interface. You can read more about interfaces
// above.
//
import java.util.Map;
import java.util.HashMap;
import java.util.function.*;
import java.security.SecureRandom;

public class Lambdas {
    public static void main(String[] args) {
        // Lambda declaration syntax:
	// <zero or more parameters> -> <expression body or statement block>

        // We will use this hashmap in our examples below.
        Map<String, String> planets = new HashMap<>();
            planets.put(""Mercury"", ""87.969"");
            planets.put(""Venus"", ""224.7"");
            planets.put(""Earth"", ""365.2564"");
            planets.put(""Mars"", ""687"");
            planets.put(""Jupiter"", ""4,332.59"");
            planets.put(""Saturn"", ""10,759"");
            planets.put(""Uranus"", ""30,688.5"");
            planets.put(""Neptune"", ""60,182"");

        // Lambda with zero parameters using the Supplier functional interface
        // from java.util.function.Supplier. The actual lambda expression is
        // what comes after numPlanets =.
        Supplier<String> numPlanets = () -> Integer.toString(planets.size());
        System.out.format(""Number of Planets: %s\n\n"", numPlanets.get());

        // Lambda with one parameter and using the Consumer functional interface
        // from java.util.function.Consumer. This is because planets is a Map,
        // which implements both Collection and Iterable. The forEach used here,
        // found in Iterable, applies the lambda expression to each member of
        // the Collection. The default implementation of forEach behaves as if:
        /*
            for (T t : this)
                action.accept(t);
        */

        // The actual lambda expression is the parameter passed to forEach.
        planets.keySet().forEach((p) -> System.out.format(""%s\n"", p));

        // If you are only passing a single argument, then the above can also be
        // written as (note absent parentheses around p):
        planets.keySet().forEach(p -> System.out.format(""%s\n"", p));

        // Tracing the above, we see that planets is a HashMap, keySet() returns
        // a Set of its keys, forEach applies each element as the lambda
        // expression of: (parameter p) -> System.out.format(""%s\n"", p). Each
        // time, the element is said to be ""consumed"" and the statement(s)
        // referred to in the lambda body is applied. Remember the lambda body
        // is what comes after the ->.

        // The above without use of lambdas would look more traditionally like:
        for (String planet : planets.keySet()) {
            System.out.format(""%s\n"", planet);
        }

        // This example differs from the above in that a different forEach
        // implementation is used: the forEach found in the HashMap class
        // implementing the Map interface. This forEach accepts a BiConsumer,
        // which generically speaking is a fancy way of saying it handles
        // the Set of each Key -> Value pairs. This default implementation
        // behaves as if:
        /*
            for (Map.Entry<K, V> entry : map.entrySet())
                action.accept(entry.getKey(), entry.getValue());
        */

        // The actual lambda expression is the parameter passed to forEach.
        String orbits = ""%s orbits the Sun in %s Earth days.\n"";
        planets.forEach((K, V) -> System.out.format(orbits, K, V));

        // The above without use of lambdas would look more traditionally like:
        for (String planet : planets.keySet()) {
            System.out.format(orbits, planet, planets.get(planet));
        }

        // Or, if following more closely the specification provided by the
        // default implementation:
        for (Map.Entry<String, String> planet : planets.entrySet()) {
            System.out.format(orbits, planet.getKey(), planet.getValue());
        }

        // These examples cover only the very basic use of lambdas. It might not
        // seem like much or even very useful, but remember that a lambda can be
        // created as an object that can later be passed as parameters to other
        // methods.
    }
}
```

## Further Reading

The links provided here below are just to get an understanding of the topic, feel free to Google and find specific examples.

**Official Oracle Guides**:

* [Java Tutorial Trail from Sun / Oracle](https://docs.oracle.com/javase/tutorial/index.html)

* [Java Access level modifiers](https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)

* [Object-Oriented Programming Concepts](https://docs.oracle.com/javase/tutorial/java/concepts/index.html):
    * [Inheritance](https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html)
    * [Polymorphism](https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html)
    * [Abstraction](https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html)

* [Exceptions](https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html)

* [Interfaces](https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html)

* [Generics](https://docs.oracle.com/javase/tutorial/java/generics/index.html)

* [Java Code Conventions](https://www.oracle.com/technetwork/java/codeconvtoc-136057.html)

* New features in Java 8:
    * [Lambda expressions (functional programming)](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)
    * [Date and time API (java.time package)](http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html)

**Online Practice and Tutorials**

* [Learneroo.com - Learn Java](http://www.learneroo.com)

* [Codingbat.com](http://codingbat.com/java)

* [Codewars - Java Katas](https://www.codewars.com/?language=java)

* [University of Helsinki - Object-Oriented programming with Java](http://moocfi.github.io/courses/2013/programming-part-1/)

**Books**:

* [Head First Java](http://www.headfirstlabs.com/books/hfjava/)

* [Thinking in Java](http://www.mindview.net/Books/TIJ/)

* [Objects First with Java](https://www.amazon.com/Objects-First-Java-Practical-Introduction/dp/0132492660)

* [Java The Complete Reference](https://www.amazon.com/gp/product/0071606300)"
"## About

SmallBASIC is a fast and easy to learn BASIC language interpreter ideal for everyday calculations, scripts and prototypes. SmallBASIC includes trigonometric, matrices and algebra functions, a built in IDE, a powerful string library, system, sound, and graphic commands along with structured programming syntax.

## Development

SmallBASIC was originally developed by Nicholas Christopoulos in late 1999 for the Palm Pilot. Project development has been continued by Chris Warren-Smith since around 2005.

Versions of SmallBASIC have been made for a number of early hand held devices including Franklin eBookman and the Nokia 770. Also various desktop versions have been released based on a variety of GUI tool-kits, some of which have become defunct. The current supported platforms are Linux and Windows based on SDL2 and Android based on NDK. A desktop command line version is also available, although not typically released in binary form.

In around 2008 a large corporation released a BASIC like programming environment with a similar sounding name. SmallBASIC is not related to this other project.

```
REM This is a comment
' and this is also a comment

REM print text
print ""hello""
? ""? is short for PRINT""

REM Control structures
FOR index = 0 TO 10 STEP 2
  ? ""This is line number ""; index
NEXT
J=0
REPEAT
 J++
UNTIL J=10
WHILE J>0
 J--
WEND

REM Select case statement
Select Case ""Cool""
 Case ""null"", 1,2,3,4,5,6,7,8,""Cool"",""blah""
 Case ""Not cool""
   PRINT ""Epic fail""
 Case Else
   PRINT ""Fail""
End Select

REM catching errors with TRY/CATCH
Try
  fn = Freefile
  Open filename For Input As #fn
Catch err
  Print ""failed to open""
End Try

REM User defined subs and functions
func add2(x,y)
  ' variables may be declared as local within the scope of a SUB or FUNC
  local K
  k = ""k will cease to exist when this FUNC returns""
  add2=x+y
end
Print add2(5,5)
sub print_it(it)
  print it
end
print_it ""IT....""

REM Display lines and pixels
At 0,ymax/2+txth(""Q"")
Color 1: ? ""sin(x)"":
Color 8: ? ""cos(x)"":
Color 12: ? ""tan(x)""
Line 0,ymax/2,xmax,ymax/2
For i=0 to xmax
  Pset i,ymax/2-sin(i*2*pi/ymax)*ymax/4 color 1
  Pset i,ymax/2-cos(i*2*pi/ymax)*ymax/4 color 8
  Pset i,ymax/2-tan(i*2*pi/ymax)*ymax/4 color 12
Next
showpage

REM SmallBASIC is great for experimenting with fractals and other interesting effects
Delay 3000
Randomize
ff = 440.03
For j = 0 to 20
  r = rnd * 1000 % 255
  b = rnd * 1000 % 255
  g = rnd * 1000 % 255
  c = rgb(r,b,g)
  ff += 9.444
  for i=0 to 25000
    f += ff
    x = min(xmax, -x + cos(f*i))
    y = min(ymax, -y + sin(f*i))
    pset x, y color c
    if (i%1000==0) then
      showpage
    fi
  next
Next j

REM For computer historians, SmallBASIC can run programs
REM found in early computer books and magazines, for example:
10 LET A=9
20 LET B=7
30 PRINT A*B
40 PRINT A/B

REM SmallBASIC also has support for a few modern concepts such as JSON
aa = array(""{\""cat\"":{\""name\"":\""harry\""},\""pet\"":\""true\""}"")
If (ismap(aa) == false) Then
  throw ""not an map""
End If
Print aa

PAUSE

```

## Articles

* [Getting started](http://smallbasic.sourceforge.net/?q=node/1573)
* [Welcome to SmallBASIC](http://smallbasic.sourceforge.net/?q=node/838)

## GitHub

* [Source code](https://github.com/smallbasic/SmallBASIC)
* [Reference snapshot](http://smallbasic.github.io/)"
">Pascal is an imperative and procedural programming language, which Niklaus Wirth designed in 1968–69 and published in 1970, as a small, efficient language intended to encourage good programming practices using structured programming and data structuring. It is named in honor of the French mathematician, philosopher and physicist Blaise Pascal. 
source : [wikipedia](https://en.wikipedia.org/wiki/Pascal_(programming_language))



To compile and run a pascal program you could use a free pascal compiler. [Download Here](https://www.freepascal.org/)

```pascal
//Anatomy of a Pascal Program
//this is a comment
{
    this is a 
    multiline comment
}

//name of the program
program learn_pascal; //<-- don't forget a semicolon

const
    {
        this is where you should declare constant values
    }
type
    {
        this is where you should declare custom
        data-types
    }
var
    {
        this is where you should declare a variable
    }

//main program area
begin
    {
        area to declare your instruction
    }
end. // End of a main program area should require a ""."" symbol
```

```pascal
//When declaring variables
//you can do this
var a:integer;
var b:integer;
//or this
var 
    a : integer;
    b : integer;
//or this
var a,b : integer;
```

```pascal
program Learn_More;
//Let's learn about data types and their operations

const
    PI = 3.141592654;
    GNU = 'GNU''s Not Unix';
        // constants are conventionally named using CAPS
        // their values are fixed and cannot be changed during runtime
        // holds any standard data type (integer, real, boolean, char, string)

type
    ch_array : array [0..255] of char;
        // arrays are new 'types' specifying the length and data type
        // this defines a new data type that contains 255 characters
        // (this is functionally equivalent to a string[256] variable)
    md_array : array of array of integer;
        // nested arrays are equivalent to multidimensional arrays
        // can define zero (0) length arrays that are dynamically sized
        // this is a 2-dimensional array of integers

//Declaring variables
var
    int, c, d  : integer;
           // three variables that contain integer numbers
           // integers are 16-bits and limited to the range [-32,768..32,767]
    r    : real;
           // a variable that contains a real number data types
           // reals can range between [3.4E-38..3.4E38]
    bool : boolean;
           // a variable that contains a Boolean(True/False) value
    ch   : char;
           // a variable that contains a character value
           // char variables are stored as 8-bit data types so no UTF
    str  : string;
           // a non-standard variable that contains a string value
           // strings are an extension included in most Pascal compilers
           // they are stored as an array of char with default length of 255.
    s    : string[50];
           // a string with maximum length of 50 chars.
           // you can specify the length of the string to minimize memory usage
    my_str: ch_array;
           // you can declare variables of custom types
    my_2d : md_array;
           // dynamically sized arrays need to be sized before they can be used.

    // additional integer data types
    b    : byte;     // range [0..255]
    shi  : shortint; // range [-128..127]
    smi  : smallint; // range [-32,768..32,767] (standard Integer)
    w    : word;     // range [0..65,535]
    li   : longint;  // range [-2,147,483,648..2,147,483,647]
    lw   : longword; // range [0..4,294,967,295]
    c    : cardinal; // longword
    i64  : int64;    // range [-9223372036854775808..9223372036854775807]
    qw   : qword;    // range [0..18,446,744,073,709,551,615]

    // additional real types
    rr   : real;     // range depends on platform (i.e., 8-bit, 16-bit, etc.)
    rs   : single;   // range [1.5E-45..3.4E38]
    rd   : double;   // range [5.0E-324 .. 1.7E308]
    re   : extended; // range [1.9E-4932..1.1E4932]
    rc   : comp;     // range [-2E64+1 .. 2E63-1]

Begin
    int := 1;// how to assign a value to a variable
    r   := 3.14;
    ch  := 'a';
    str := 'apple';
    bool := true;
    //pascal is not a case-sensitive language
    //arithmetic operation
    int := 1 + 1; // int = 2 overwriting the previous assignment
    int := int + 1; // int = 2 + 1 = 3;
    int := 4 div 2; //int = 2 division operation where result will be floored
    int := 3 div 2; //int = 1
    int := 1 div 2; //int = 0

    bool := true or false; // bool = true
    bool := false and true; // bool = false
    bool := true xor true; // bool = false

    r := 3 / 2; // a division operator for real
    r := int; // can assign an integer to a real variable but not the reverse

    c := str[1]; // assign the first letter of str to c
    str := 'hello' + 'world'; //combining strings

    my_str[0] := 'a'; // array assignment needs an index

    setlength(my_2d,10,10); // initialize dynamically sized arrays: 10×10 array
    for c := 0 to 9 do // arrays begin at 0 and end at length-1
        for d := 0 to 9 do // for loop counters need to be declared variables
        my_2d[c,d] := c * d;
          // address multidimensional arrays with a single set of brackets

End.
```

```pascal
program Functional_Programming;

Var
    i, dummy : integer;

function factorial_recursion(const a: integer) : integer;
{ recursively calculates the factorial of integer parameter a }

// Declare local variables within the function
// e.g.:
// Var
//    local_a : integer;

Begin
    If a >= 1 Then
    // return values from functions by assigning a value to the function name
        factorial_recursion := a * factorial_recursion(a-1)
    Else
        factorial_recursion := 1;
End; // terminate a function using a semicolon after the End statement.

procedure get_integer(var i : integer; dummy : integer);
{ get user input and store it in the integer parameter i.
  parameters prefaced with 'var' are variable, meaning their value can change
  outside of the parameter. Value parameters (without 'var') like 'dummy' are
  static and changes made within the scope of the function/procedure do not
  affect the variable passed as a parameter }

Begin
    write('Enter an integer: ');
    readln(i);
    dummy := 4; // dummy will not change value outside of the procedure
End;

Begin // main program block
    dummy := 3;
    get_integer(i, dummy);
    writeln(i, '! = ', factorial_recursion(i));
    // outputs i!
    writeln('dummy = ', dummy); // always outputs '3' since dummy is unchanged.
End.

```"
"language: ""Common Lisp""
filename: commonlisp.lisp
contributors:
  - [""Paul Nathan"", ""https://github.com/pnathan""]
  - [""Rommel Martinez"", ""https://ebzzry.io""]
---

Common Lisp is a general-purpose, multi-paradigm programming language suited for a wide variety of
industry applications. It is frequently referred to as a programmable programming language.

The classic starting point is [Practical Common Lisp](http://www.gigamonkeys.com/book/). Another
popular and recent book is [Land of Lisp](http://landoflisp.com/). A new book about best practices,
[Common Lisp Recipes](http://weitz.de/cl-recipes/), was recently published.



```lisp

;;;-----------------------------------------------------------------------------
;;; 0. Syntax
;;;-----------------------------------------------------------------------------

;;; General form

;;; CL has two fundamental pieces of syntax: ATOM and S-EXPRESSION.
;;; Typically, grouped S-expressions are called `forms`.

10            ; an atom; it evaluates to itself
:thing        ; another atom; evaluating to the symbol :thing
t             ; another atom, denoting true
(+ 1 2 3 4)   ; an s-expression
'(4 :foo t)   ; another s-expression


;;; Comments

;;; Single-line comments start with a semicolon; use four for file-level
;;; comments, three for section descriptions, two inside definitions, and one
;;; for single lines. For example,

;;;; life.lisp

;;; Foo bar baz, because quu quux. Optimized for maximum krakaboom and umph.
;;; Needed by the function LINULUKO.

(defun meaning (life)
  ""Return the computed meaning of LIFE""
  (let ((meh ""abc""))
    ;; Invoke krakaboom
    (loop :for x :across meh
       :collect x)))                    ; store values into x, then return it

;;; Block comments, on the other hand, allow for free-form comments. They are
;;; delimited with #| and |#

#| This is a block comment which
   can span multiple lines and
    #|
       they can be nested!
    |#
|#


;;; Environment

;;; A variety of implementations exist; most are standards-conformant. SBCL
;;; is a good starting point. Third party libraries can be easily installed with
;;; Quicklisp

;;; CL is usually developed with a text editor and a Read Eval Print
;;; Loop (REPL) running at the same time. The REPL allows for interactive
;;; exploration of the program while it is running ""live"".


;;;-----------------------------------------------------------------------------
;;; 1. Primitive datatypes and operators
;;;-----------------------------------------------------------------------------

;;; Symbols

'foo ; => FOO  Notice that the symbol is upper-cased automatically.

;;; INTERN manually creates a symbol from a string.

(intern ""AAAA"")        ; => AAAA
(intern ""aaa"")         ; => |aaa|

;;; Numbers

9999999999999999999999 ; integers
#b111                  ; binary => 7
#o111                  ; octal => 73
#x111                  ; hexadecimal => 273
3.14159s0              ; single
3.14159d0              ; double
1/2                    ; ratios
#C(1 2)                ; complex numbers

;;; Function application are written as (f x y z ...) where f is a function and
;;; x, y, z, ... are the arguments.

(+ 1 2)                ; => 3

;;; If you want to create literal data, use QUOTE to prevent it from being
;;; evaluated

(quote (+ 1 2))        ; => (+ 1 2)
(quote a)              ; => A

;;; The shorthand for QUOTE is '

'(+ 1 2)               ; => (+ 1 2)
'a                     ; => A

;;; Basic arithmetic operations

(+ 1 1)                ; => 2
(- 8 1)                ; => 7
(* 10 2)               ; => 20
(expt 2 3)             ; => 8
(mod 5 2)              ; => 1
(/ 35 5)               ; => 7
(/ 1 3)                ; => 1/3
(+ #C(1 2) #C(6 -4))   ; => #C(7 -2)

;;; Booleans

t                      ; true; any non-NIL value is true
nil                    ; false; also, the empty list: ()
(not nil)              ; => T
(and 0 t)              ; => T
(or 0 nil)             ; => 0

;;; Characters

#\A                    ; => #\A
#\λ                    ; => #\GREEK_SMALL_LETTER_LAMDA
#\u03BB                ; => #\GREEK_SMALL_LETTER_LAMDA

;;; Strings are fixed-length arrays of characters

""Hello, world!""
""Benjamin \""Bugsy\"" Siegel""   ; backslash is an escaping character

;;; Strings can be concatenated

(concatenate 'string ""Hello, "" ""world!"") ; => ""Hello, world!""

;;; A string can be treated like a sequence of characters

(elt ""Apple"" 0) ; => #\A

;;; FORMAT is used to create formatted output, which ranges from simple string
;;; interpolation to loops and conditionals. The first argument to FORMAT
;;; determines where will the formatted string go. If it is NIL, FORMAT
;;; simply returns the formatted string as a value; if it is T, FORMAT outputs
;;; to the standard output, usually the screen, then it returns NIL.

(format nil ""~A, ~A!"" ""Hello"" ""world"")   ; => ""Hello, world!""
(format t ""~A, ~A!"" ""Hello"" ""world"")     ; => NIL


;;;-----------------------------------------------------------------------------
;;; 2. Variables
;;;-----------------------------------------------------------------------------

;;; You can create a global (dynamically scoped) variable using DEFVAR and
;;; DEFPARAMETER. The variable name can use any character except: ()"",'`;#|\

;;; The difference between DEFVAR and DEFPARAMETER is that re-evaluating a
;;; DEFVAR expression doesn't change the value of the variable. DEFPARAMETER,
;;; on the other hand, does.

;;; By convention, dynamically scoped variables have earmuffs in their name.

(defparameter *some-var* 5)
*some-var* ; => 5

;;; You can also use unicode characters.
(defparameter *AΛB* nil)

;;; Accessing a previously unbound variable results in an UNBOUND-VARIABLE
;;; error, however it is defined behavior. Don't do it.

;;; You can create local bindings with LET. In the following snippet, `me` is
;;; bound to ""dance with you"" only within the (let ...). LET always returns
;;; the value of the last `form` in the LET form.

(let ((me ""dance with you"")) me) ; => ""dance with you""


;;;-----------------------------------------------------------------------------;
;;; 3. Structs and collections
;;;-----------------------------------------------------------------------------;


;;; Structs

(defstruct dog name breed age)
(defparameter *rover*
    (make-dog :name ""rover""
              :breed ""collie""
              :age 5))
*rover*            ; => #S(DOG :NAME ""rover"" :BREED ""collie"" :AGE 5)
(dog-p *rover*)    ; => T
(dog-name *rover*) ; => ""rover""

;;; DOG-P, MAKE-DOG, and DOG-NAME are all automatically created by DEFSTRUCT


;;; Pairs

;;; CONS constructs pairs. CAR and CDR return the head and tail of a CONS-pair.

(cons 'SUBJECT 'VERB)         ; => '(SUBJECT . VERB)
(car (cons 'SUBJECT 'VERB))   ; => SUBJECT
(cdr (cons 'SUBJECT 'VERB))   ; => VERB


;;; Lists

;;; Lists are linked-list data structures, made of CONS pairs and end with a
;;; NIL (or '()) to mark the end of the list

(cons 1 (cons 2 (cons 3 nil)))     ; => '(1 2 3)

;;; LIST is a convenience variadic constructor for lists

(list 1 2 3)                       ; => '(1 2 3)

;;; When the first argument to CONS is an atom and the second argument is a
;;; list, CONS returns a new CONS-pair with the first argument as the first
;;; item and the second argument as the rest of the CONS-pair

(cons 4 '(1 2 3))                  ; => '(4 1 2 3)

;;; Use APPEND to join lists

(append '(1 2) '(3 4))             ; => '(1 2 3 4)

;;; Or CONCATENATE

(concatenate 'list '(1 2) '(3 4))  ; => '(1 2 3 4)

;;; Lists are a very central type, so there is a wide variety of functionality for
;;; them, a few examples:

(mapcar #'1+ '(1 2 3))             ; => '(2 3 4)
(mapcar #'+ '(1 2 3) '(10 20 30))  ; => '(11 22 33)
(remove-if-not #'evenp '(1 2 3 4)) ; => '(2 4)
(every #'evenp '(1 2 3 4))         ; => NIL
(some #'oddp '(1 2 3 4))           ; => T
(butlast '(subject verb object))   ; => (SUBJECT VERB)


;;; Vectors

;;; Vector's literals are fixed-length arrays

#(1 2 3) ; => #(1 2 3)

;;; Use CONCATENATE to add vectors together

(concatenate 'vector #(1 2 3) #(4 5 6)) ; => #(1 2 3 4 5 6)


;;; Arrays

;;; Both vectors and strings are special-cases of arrays.

;;; 2D arrays

(make-array (list 2 2))         ; => #2A((0 0) (0 0))
(make-array '(2 2))             ; => #2A((0 0) (0 0))
(make-array (list 2 2 2))       ; => #3A(((0 0) (0 0)) ((0 0) (0 0)))

;;; Caution: the default initial values of MAKE-ARRAY are implementation-defined.
;;; To explicitly specify them:

(make-array '(2) :initial-element 'unset)  ; => #(UNSET UNSET)

;;; To access the element at 1, 1, 1:

(aref (make-array (list 2 2 2)) 1 1 1)     ;  => 0
;;; This value is implementation-defined:
;;; NIL on ECL, 0 on SBCL and CCL.

;;; Adjustable vectors

;;; Adjustable vectors have the same printed representation as
;;; fixed-length vector's literals.

(defparameter *adjvec* (make-array '(3) :initial-contents '(1 2 3)
                                   :adjustable t :fill-pointer t))
*adjvec* ; => #(1 2 3)

;;; Adding new elements

(vector-push-extend 4 *adjvec*)   ; => 3
*adjvec*                          ; => #(1 2 3 4)


;;; Sets, naively, are just lists:

(set-difference '(1 2 3 4) '(4 5 6 7))   ; => (3 2 1)
(intersection '(1 2 3 4) '(4 5 6 7))     ; => 4
(union '(1 2 3 4) '(4 5 6 7))            ; => (3 2 1 4 5 6 7)
(adjoin 4 '(1 2 3 4))                    ; => (1 2 3 4)

;;; However, you'll need a better data structure than linked lists when working
;;; with larger data sets

;;; Dictionaries are implemented as hash tables.

;;; Create a hash table

(defparameter *m* (make-hash-table))

;;; Set value

(setf (gethash 'a *m*) 1)

;;; Retrieve value

(gethash 'a *m*) ; => 1, T

;;; CL expressions have the ability to return multiple values.

(values 1 2) ; => 1, 2

;;; which can be bound with MULTIPLE-VALUE-BIND

(multiple-value-bind (x y)
    (values 1 2)
  (list y x))

; => '(2 1)

;;; GETHASH is an example of a function that returns multiple values. The first
;;; value it return is the value of the key in the hash table; if the key is
;;; not found it returns NIL.

;;; The second value determines if that key is indeed present in the hash
;;; table. If a key is not found in the table it returns NIL. This behavior
;;; allows us to check if the value of a key is actually NIL.

;;; Retrieving a non-present value returns nil

(gethash 'd *m*) ;=> NIL, NIL

;;; You can provide a default value for missing keys

(gethash 'd *m* :not-found) ; => :NOT-FOUND

;;; Let's handle the multiple return values here in code.

(multiple-value-bind (a b)
    (gethash 'd *m*)
  (list a b))
; => (NIL NIL)

(multiple-value-bind (a b)
    (gethash 'a *m*)
  (list a b))
; => (1 T)


;;;-----------------------------------------------------------------------------
;;; 3. Functions
;;;-----------------------------------------------------------------------------

;;; Use LAMBDA to create anonymous functions. Functions always returns the
;;; value of the last expression. The exact printable representation of a
;;; function varies between implementations.

(lambda () ""Hello World"") ; => #<FUNCTION (LAMBDA ()) {1004E7818B}>

;;; Use FUNCALL to call anonymous functions

(funcall (lambda () ""Hello World""))   ; => ""Hello World""
(funcall #'+ 1 2 3)                   ; => 6

;;; A call to FUNCALL is also implied when the lambda expression is the CAR of
;;; an unquoted list

((lambda () ""Hello World""))           ; => ""Hello World""
((lambda (val) val) ""Hello World"")    ; => ""Hello World""

;;; FUNCALL is used when the arguments are known beforehand. Otherwise, use APPLY

(apply #'+ '(1 2 3))   ; => 6
(apply (lambda () ""Hello World"") nil) ; => ""Hello World""

;;; To name a function, use DEFUN

(defun hello-world () ""Hello World"")
(hello-world) ; => ""Hello World""

;;; The () in the definition above is the list of arguments

(defun hello (name) (format nil ""Hello, ~A"" name))
(hello ""Steve"") ; => ""Hello, Steve""

;;; Functions can have optional arguments; they default to NIL

(defun hello (name &optional from)
  (if from
      (format t ""Hello, ~A, from ~A"" name from)
      (format t ""Hello, ~A"" name)))

(hello ""Jim"" ""Alpacas"")       ; => Hello, Jim, from Alpacas

;;; The default values can also be specified

(defun hello (name &optional (from ""The world""))
   (format nil ""Hello, ~A, from ~A"" name from))

(hello ""Steve"")               ; => Hello, Steve, from The world
(hello ""Steve"" ""the alpacas"") ; => Hello, Steve, from the alpacas

;;; Functions also have keyword arguments to allow non-positional arguments

(defun generalized-greeter (name &key (from ""the world"") (honorific ""Mx""))
  (format t ""Hello, ~A ~A, from ~A"" honorific name from))

(generalized-greeter ""Jim"")
; => Hello, Mx Jim, from the world

(generalized-greeter ""Jim"" :from ""the alpacas you met last summer"" :honorific ""Mr"")
; => Hello, Mr Jim, from the alpacas you met last summer


;;;-----------------------------------------------------------------------------
;;; 4. Equality
;;;-----------------------------------------------------------------------------

;;; CL has a sophisticated equality system. Some are covered here.

;;; For numbers, use `='
(= 3 3.0)               ; => T
(= 2 1)                 ; => NIL

;;; For object identity (approximately) use EQL
(eql 3 3)               ; => T
(eql 3 3.0)             ; => NIL
(eql (list 3) (list 3)) ; => NIL

;;; for lists, strings, and bit-vectors use EQUAL
(equal (list 'a 'b) (list 'a 'b)) ; => T
(equal (list 'a 'b) (list 'b 'a)) ; => NIL


;;;-----------------------------------------------------------------------------
;;; 5. Control Flow
;;;-----------------------------------------------------------------------------

;;; Conditionals

(if t                ; test expression
    ""this is true""   ; then expression
    ""this is false"") ; else expression
; => ""this is true""

;;; In conditionals, all non-NIL values are treated as true

(member 'Groucho '(Harpo Groucho Zeppo)) ; => '(GROUCHO ZEPPO)
(if (member 'Groucho '(Harpo Groucho Zeppo))
    'yep
    'nope)
; => 'YEP

;;; COND chains a series of tests to select a result
(cond ((> 2 2) (error ""wrong!""))
      ((< 2 2) (error ""wrong again!""))
      (t 'ok)) ; => 'OK

;;; TYPECASE switches on the type of the value
(typecase 1
  (string :string)
  (integer :int))
; => :int


;;; Looping

;;; Recursion

(defun fact (n)
  (if (< n 2)
      1
    (* n (fact(- n 1)))))

(fact 5) ; => 120

;;; Iteration

(defun fact (n)
  (loop :for result = 1 :then (* result i)
     :for i :from 2 :to n
     :finally (return result)))

(fact 5) ; => 120

(loop :for x :across ""abcd"" :collect x)
; => (#\a #\b #\c #\d)

(dolist (i '(1 2 3 4))
  (format t ""~A"" i))
; => 1234


;;;-----------------------------------------------------------------------------
;;; 6. Mutation
;;;-----------------------------------------------------------------------------

;;; Use SETF to assign a new value to an existing variable. This was
;;; demonstrated earlier in the hash table example.

(let ((variable 10))
    (setf variable 2))
; => 2

;;; Good Lisp style is to minimize the use of destructive functions and to avoid
;;; mutation when reasonable.


;;;-----------------------------------------------------------------------------
;;; 7. Classes and objects
;;;-----------------------------------------------------------------------------

;;; No more animal classes. Let's have Human-Powered Mechanical
;;; Conveyances.

(defclass human-powered-conveyance ()
  ((velocity
    :accessor velocity
    :initarg :velocity)
   (average-efficiency
    :accessor average-efficiency
   :initarg :average-efficiency))
  (:documentation ""A human powered conveyance""))

;;; The arguments to DEFCLASS, in order are:
;;; 1. class name
;;; 2. superclass list
;;; 3. slot list
;;; 4. optional specifiers

;;; When no superclass list is set, the empty list defaults to the
;;; standard-object class. This *can* be changed, but not until you
;;; know what you're doing. Look up the Art of the Metaobject Protocol
;;; for more information.

(defclass bicycle (human-powered-conveyance)
  ((wheel-size
    :accessor wheel-size
    :initarg :wheel-size
    :documentation ""Diameter of the wheel."")
   (height
    :accessor height
    :initarg :height)))

(defclass recumbent (bicycle)
  ((chain-type
    :accessor chain-type
    :initarg :chain-type)))

(defclass unicycle (human-powered-conveyance) nil)

(defclass canoe (human-powered-conveyance)
  ((number-of-rowers
    :accessor number-of-rowers
    :initarg :number-of-rowers)))

;;; Calling DESCRIBE on the HUMAN-POWERED-CONVEYANCE class in the REPL gives:

(describe 'human-powered-conveyance)

; COMMON-LISP-USER::HUMAN-POWERED-CONVEYANCE
;  [symbol]
;
; HUMAN-POWERED-CONVEYANCE names the standard-class #<STANDARD-CLASS
;                                                    HUMAN-POWERED-CONVEYANCE>:
;  Documentation:
;    A human powered conveyance
;  Direct superclasses: STANDARD-OBJECT
;  Direct subclasses: UNICYCLE, BICYCLE, CANOE
;  Not yet finalized.
;  Direct slots:
;    VELOCITY
;      Readers: VELOCITY
;      Writers: (SETF VELOCITY)
;    AVERAGE-EFFICIENCY
;      Readers: AVERAGE-EFFICIENCY
;      Writers: (SETF AVERAGE-EFFICIENCY)

;;; Note the reflective behavior available. CL was designed to be an
;;; interactive system

;;; To define a method, let's find out what our circumference of the
;;; bike wheel turns out to be using the equation: C = d * pi

(defmethod circumference ((object bicycle))
  (* pi (wheel-size object)))

;;; PI is defined as a built-in in CL

;;; Let's suppose we find out that the efficiency value of the number
;;; of rowers in a canoe is roughly logarithmic. This should probably be set
;;; in the constructor/initializer.

;;; To initialize your instance after CL gets done constructing it:

(defmethod initialize-instance :after ((object canoe) &rest args)
  (setf (average-efficiency object)  (log (1+ (number-of-rowers object)))))

;;; Then to construct an instance and check the average efficiency...

(average-efficiency (make-instance 'canoe :number-of-rowers 15))
; => 2.7725887


;;;-----------------------------------------------------------------------------
;;; 8. Macros
;;;-----------------------------------------------------------------------------

;;; Macros let you extend the syntax of the language. CL doesn't come
;;; with a WHILE loop, however, it's trivial to write one. If we obey our
;;; assembler instincts, we wind up with:

(defmacro while (condition &body body)
    ""While `condition` is true, `body` is executed.
`condition` is tested prior to each execution of `body`""
    (let ((block-name (gensym)) (done (gensym)))
        `(tagbody
           ,block-name
           (unless ,condition
               (go ,done))
           (progn
           ,@body)
           (go ,block-name)
           ,done)))

;;; Let's look at the high-level version of this:

(defmacro while (condition &body body)
    ""While `condition` is true, `body` is executed.
`condition` is tested prior to each execution of `body`""
  `(loop while ,condition
         do
         (progn
            ,@body)))

;;; However, with a modern compiler, this is not required; the LOOP form
;;; compiles equally well and is easier to read.

;;; Note that ``` is used, as well as `,` and `@`. ``` is a quote-type operator
;;; known as quasiquote; it allows the use of `,` . `,` allows ""unquoting""
;;; variables. @ interpolates lists.

;;; GENSYM creates a unique symbol guaranteed to not exist elsewhere in
;;; the system. This is because macros are expanded at compile time and
;;; variables declared in the macro can collide with variables used in
;;; regular code.

;;; See Practical Common Lisp and On Lisp for more information on macros.
```


## Further reading

- [Practical Common Lisp](http://www.gigamonkeys.com/book/)
- [Common Lisp: A Gentle Introduction to Symbolic Computation](https://www.cs.cmu.edu/~dst/LispBook/book.pdf)


## Extra information

- [CLiki](http://www.cliki.net/)
- [common-lisp.net](https://common-lisp.net/)
- [Awesome Common Lisp](https://github.com/CodyReichert/awesome-cl)
- [Lisp Lang](http://lisp-lang.org/)


## Credits

Lots of thanks to the Scheme people for rolling up a great starting
point which could be easily moved to Common Lisp.

- [Paul Khuong](https://github.com/pkhuong) for some great reviewing."
"JavaScript was created by Netscape's Brendan Eich in 1995. It was originally
intended as a simpler scripting language for websites, complementing the use of
Java for more complex web applications, but its tight integration with Web pages
and built-in support in browsers has caused it to become far more common than
Java in web frontends.

JavaScript isn't just limited to web browsers, though: Node.js, a project that
provides a standalone runtime for Google Chrome's V8 JavaScript engine, is
becoming more and more popular.

JavaScript has a C-like syntax, so if you've used languages like C or Java,
a lot of the basic syntax will already be familiar. Despite this, and despite
the similarity in name, JavaScript's object model is significantly different to
Java's.

```js
// Single-line comments start with two slashes.
/* Multiline comments start with slash-star,
   and end with star-slash */

// Statements can be terminated by ;
doStuff();

// ... but they don't have to be, as semicolons are automatically inserted
// wherever there's a newline, except in certain cases.
doStuff()

// Because those cases can cause unexpected results, we'll keep on using
// semicolons in this guide.

///////////////////////////////////
// 1. Numbers, Strings and Operators

// JavaScript has one number type (which is a 64-bit IEEE 754 double).
// Doubles have a 52-bit mantissa, which is enough to store integers
// up to about 9✕10¹⁵ precisely.
3; // = 3
1.5; // = 1.5

// Some basic arithmetic works as you'd expect.
1 + 1; // = 2
0.1 + 0.2; // = 0.30000000000000004
8 - 1; // = 7
10 * 2; // = 20
35 / 5; // = 7

// Including uneven division.
5 / 2; // = 2.5

// And modulo division.
10 % 2; // = 0
30 % 4; // = 2
18.5 % 7; // = 4.5

// Bitwise operations also work; when you perform a bitwise operation your float
// is converted to a signed int *up to* 32 bits.
1 << 2; // = 4

// Precedence is enforced with parentheses.
(1 + 3) * 2; // = 8

// There are three special not-a-real-number values:
Infinity; // result of e.g. 1/0
-Infinity; // result of e.g. -1/0
NaN; // result of e.g. 0/0, stands for 'Not a Number'

// There's also a boolean type.
true;
false;

// Strings are created with ' or "".
'abc';
""Hello, world"";

// Negation uses the ! symbol
!true; // = false
!false; // = true

// Equality is ===
1 === 1; // = true
2 === 1; // = false

// Inequality is !==
1 !== 1; // = false
2 !== 1; // = true

// More comparisons
1 < 10; // = true
1 > 10; // = false
2 <= 2; // = true
2 >= 2; // = true

// Strings are concatenated with +
""Hello "" + ""world!""; // = ""Hello world!""

// ... which works with more than just strings
""1, 2, "" + 3; // = ""1, 2, 3""
""Hello "" + [""world"", ""!""]; // = ""Hello world,!""

// ...which can result in some weird behaviour...
13 + !0; // 14
""13"" + !0; // '13true'

// and are compared with < and >
""a"" < ""b""; // = true

// Type coercion is performed for comparisons with double equals...
""5"" == 5; // = true
null == undefined; // = true

// ...unless you use ===
""5"" === 5; // = false
null === undefined; // = false

// You can access characters in a string with `charAt`
""This is a string"".charAt(0);  // = 'T'

// ...or use `substring` to get larger pieces.
""Hello world"".substring(0, 5); // = ""Hello""

// `length` is a property, so don't use ().
""Hello"".length; // = 5

// There's also `null` and `undefined`.
null;      // used to indicate a deliberate non-value
undefined; // used to indicate a value is not currently present (although
           // `undefined` is actually a value itself)

// false, null, undefined, NaN, 0 and """" are falsy; everything else is truthy.
// Note that 0 is falsy and ""0"" is truthy, even though 0 == ""0"".

///////////////////////////////////
// 2. Variables, Arrays and Objects

// Variables are declared with the `var` keyword. JavaScript is dynamically
// typed, so you don't need to specify type. Assignment uses a single `=`
// character.
var someVar = 5;

// If you leave the var keyword off, you won't get an error...
someOtherVar = 10;

// ...but your variable will be created in the global scope, not in the scope
// you defined it in.

// Variables declared without being assigned to are set to undefined.
var someThirdVar; // = undefined

// If you want to declare a couple of variables, then you could use a comma
// separator
var someFourthVar = 2, someFifthVar = 4;

// There's shorthand for performing math operations on variables:
someVar += 5; // equivalent to someVar = someVar + 5; someVar is 10 now
someVar *= 10; // now someVar is 100

// and an even-shorter-hand for adding or subtracting 1
someVar++; // now someVar is 101
someVar--; // back to 100

// Arrays are ordered lists of values, of any type.
var myArray = [""Hello"", 45, true];

// Their members can be accessed using the square-brackets subscript syntax.
// Array indices start at zero.
myArray[1]; // = 45

// Arrays are mutable and of variable length.
myArray.push(""World"");
myArray.length; // = 4

// Add/Modify at specific index
myArray[3] = ""Hello"";

// Add and remove element from front or back end of an array
myArray.unshift(3); // Add as the first element
someVar = myArray.shift(); // Remove first element and return it
myArray.push(3); // Add as the last element
someVar = myArray.pop(); // Remove last element and return it

// Join all elements of an array with semicolon
var myArray0 = [32,false,""js"",12,56,90];
myArray0.join("";""); // = ""32;false;js;12;56;90""

// Get subarray of elements from index 1 (include) to 4 (exclude)
myArray0.slice(1,4); // = [false,""js"",12]

// Remove 4 elements starting from index 2, and insert there strings
// ""hi"",""wr"" and ""ld""; return removed subarray
myArray0.splice(2,4,""hi"",""wr"",""ld""); // = [""js"",12,56,90]
// myArray0 === [32,false,""hi"",""wr"",""ld""]

// JavaScript's objects are equivalent to ""dictionaries"" or ""maps"" in other
// languages: an unordered collection of key-value pairs.
var myObj = {key1: ""Hello"", key2: ""World""};

// Keys are strings, but quotes aren't required if they're a valid
// JavaScript identifier. Values can be any type.
var myObj = {myKey: ""myValue"", ""my other key"": 4};

// Object attributes can also be accessed using the subscript syntax,
myObj[""my other key""]; // = 4

// ... or using the dot syntax, provided the key is a valid identifier.
myObj.myKey; // = ""myValue""

// Objects are mutable; values can be changed and new keys added.
myObj.myThirdKey = true;

// If you try to access a value that's not yet set, you'll get undefined.
myObj.myFourthKey; // = undefined

///////////////////////////////////
// 3. Logic and Control Structures

// The `if` structure works as you'd expect.
var count = 1;
if (count == 3){
    // evaluated if count is 3
} else if (count == 4){
    // evaluated if count is 4
} else {
    // evaluated if it's not either 3 or 4
}

// As does `while`.
while (true){
    // An infinite loop!
}

// Do-while loops are like while loops, except they always run at least once.
var input;
do {
    input = getInput();
} while (!isValid(input));

// The `for` loop is the same as C and Java:
// initialization; continue condition; iteration.
for (var i = 0; i < 5; i++){
    // will run 5 times
}

// Breaking out of labeled loops is similar to Java
outer:
for (var i = 0; i < 10; i++) {
    for (var j = 0; j < 10; j++) {
        if (i == 5 && j ==5) {
            break outer;
            // breaks out of outer loop instead of only the inner one
        }
    }
}

// The for/in statement allows iteration over properties of an object.
var description = """";
var person = {fname:""Paul"", lname:""Ken"", age:18};
for (var x in person){
    description += person[x] + "" "";
} // description = 'Paul Ken 18 '

// The for/of statement allows iteration over iterable objects (including the built-in String, 
// Array, e.g. the Array-like arguments or NodeList objects, TypedArray, Map and Set, 
// and user-defined iterables).
var myPets = """";
var pets = [""cat"", ""dog"", ""hamster"", ""hedgehog""];
for (var pet of pets){
    myPets += pet + "" "";
} // myPets = 'cat dog hamster hedgehog '

// && is logical and, || is logical or
if (house.size == ""big"" && house.colour == ""blue""){
    house.contains = ""bear"";
}
if (colour == ""red"" || colour == ""blue""){
    // colour is either red or blue
}

// && and || ""short circuit"", which is useful for setting default values.
var name = otherName || ""default"";

// The `switch` statement checks for equality with `===`.
// Use 'break' after each case
// or the cases after the correct one will be executed too.
grade = 'B';
switch (grade) {
  case 'A':
    console.log(""Great job"");
    break;
  case 'B':
    console.log(""OK job"");
    break;
  case 'C':
    console.log(""You can do better"");
    break;
  default:
    console.log(""Oy vey"");
    break;
}


///////////////////////////////////
// 4. Functions, Scope and Closures

// JavaScript functions are declared with the `function` keyword.
function myFunction(thing){
    return thing.toUpperCase();
}
myFunction(""foo""); // = ""FOO""

// Note that the value to be returned must start on the same line as the
// `return` keyword, otherwise you'll always return `undefined` due to
// automatic semicolon insertion. Watch out for this when using Allman style.
function myFunction(){
    return // <- semicolon automatically inserted here
    {thisIsAn: 'object literal'};
}
myFunction(); // = undefined

// JavaScript functions are first class objects, so they can be reassigned to
// different variable names and passed to other functions as arguments - for
// example, when supplying an event handler:
function myFunction(){
    // this code will be called in 5 seconds' time
}
setTimeout(myFunction, 5000);
// Note: setTimeout isn't part of the JS language, but is provided by browsers
// and Node.js.

// Another function provided by browsers is setInterval
function myFunction(){
    // this code will be called every 5 seconds
}
setInterval(myFunction, 5000);

// Function objects don't even have to be declared with a name - you can write
// an anonymous function definition directly into the arguments of another.
setTimeout(function(){
    // this code will be called in 5 seconds' time
}, 5000);

// JavaScript has function scope; functions get their own scope but other blocks
// do not.
if (true){
    var i = 5;
}
i; // = 5 - not undefined as you'd expect in a block-scoped language

// This has led to a common pattern of ""immediately-executing anonymous
// functions"", which prevent temporary variables from leaking into the global
// scope.
(function(){
    var temporary = 5;
    // We can access the global scope by assigning to the ""global object"", which
    // in a web browser is always `window`. The global object may have a
    // different name in non-browser environments such as Node.js.
    window.permanent = 10;
})();
temporary; // raises ReferenceError
permanent; // = 10

// One of JavaScript's most powerful features is closures. If a function is
// defined inside another function, the inner function has access to all the
// outer function's variables, even after the outer function exits.
function sayHelloInFiveSeconds(name){
    var prompt = ""Hello, "" + name + ""!"";
    // Inner functions are put in the local scope by default, as if they were
    // declared with `var`.
    function inner(){
        alert(prompt);
    }
    setTimeout(inner, 5000);
    // setTimeout is asynchronous, so the sayHelloInFiveSeconds function will
    // exit immediately, and setTimeout will call inner afterwards. However,
    // because inner is ""closed over"" sayHelloInFiveSeconds, inner still has
    // access to the `prompt` variable when it is finally called.
}
sayHelloInFiveSeconds(""Adam""); // will open a popup with ""Hello, Adam!"" in 5s

///////////////////////////////////
// 5. More about Objects; Constructors and Prototypes

// Objects can contain functions.
var myObj = {
    myFunc: function(){
        return ""Hello world!"";
    }
};
myObj.myFunc(); // = ""Hello world!""

// When functions attached to an object are called, they can access the object
// they're attached to using the `this` keyword.
myObj = {
    myString: ""Hello world!"",
    myFunc: function(){
        return this.myString;
    }
};
myObj.myFunc(); // = ""Hello world!""

// What this is set to has to do with how the function is called, not where
// it's defined. So, our function doesn't work if it isn't called in the
// context of the object.
var myFunc = myObj.myFunc;
myFunc(); // = undefined

// Inversely, a function can be assigned to the object and gain access to it
// through `this`, even if it wasn't attached when it was defined.
var myOtherFunc = function(){
    return this.myString.toUpperCase();
};
myObj.myOtherFunc = myOtherFunc;
myObj.myOtherFunc(); // = ""HELLO WORLD!""

// We can also specify a context for a function to execute in when we invoke it
// using `call` or `apply`.

var anotherFunc = function(s){
    return this.myString + s;
};
anotherFunc.call(myObj, "" And Hello Moon!""); // = ""Hello World! And Hello Moon!""

// The `apply` function is nearly identical, but takes an array for an argument
// list.

anotherFunc.apply(myObj, ["" And Hello Sun!""]); // = ""Hello World! And Hello Sun!""

// This is useful when working with a function that accepts a sequence of
// arguments and you want to pass an array.

Math.min(42, 6, 27); // = 6
Math.min([42, 6, 27]); // = NaN (uh-oh!)
Math.min.apply(Math, [42, 6, 27]); // = 6

// But, `call` and `apply` are only temporary. When we want it to stick, we can
// use `bind`.

var boundFunc = anotherFunc.bind(myObj);
boundFunc("" And Hello Saturn!""); // = ""Hello World! And Hello Saturn!""

// `bind` can also be used to partially apply (curry) a function.

var product = function(a, b){ return a * b; };
var doubler = product.bind(this, 2);
doubler(8); // = 16

// When you call a function with the `new` keyword, a new object is created, and
// made available to the function via the `this` keyword. Functions designed to be
// called like that are called constructors.

var MyConstructor = function(){
    this.myNumber = 5;
};
myNewObj = new MyConstructor(); // = {myNumber: 5}
myNewObj.myNumber; // = 5

// Unlike most other popular object-oriented languages, JavaScript has no
// concept of 'instances' created from 'class' blueprints; instead, JavaScript
// combines instantiation and inheritance into a single concept: a 'prototype'.

// Every JavaScript object has a 'prototype'. When you go to access a property
// on an object that doesn't exist on the actual object, the interpreter will
// look at its prototype.

// Some JS implementations let you access an object's prototype on the magic
// property `__proto__`. While this is useful for explaining prototypes it's not
// part of the standard; we'll get to standard ways of using prototypes later.
var myObj = {
    myString: ""Hello world!""
};
var myPrototype = {
    meaningOfLife: 42,
    myFunc: function(){
        return this.myString.toLowerCase();
    }
};

myObj.__proto__ = myPrototype;
myObj.meaningOfLife; // = 42

// This works for functions, too.
myObj.myFunc(); // = ""hello world!""

// Of course, if your property isn't on your prototype, the prototype's
// prototype is searched, and so on.
myPrototype.__proto__ = {
    myBoolean: true
};
myObj.myBoolean; // = true

// There's no copying involved here; each object stores a reference to its
// prototype. This means we can alter the prototype and our changes will be
// reflected everywhere.
myPrototype.meaningOfLife = 43;
myObj.meaningOfLife; // = 43

// The for/in statement allows iteration over properties of an object,
// walking up the prototype chain until it sees a null prototype.
for (var x in myObj){
    console.log(myObj[x]);
}
///prints:
// Hello world!
// 43
// [Function: myFunc]
// true

// To only consider properties attached to the object itself
// and not its prototypes, use the `hasOwnProperty()` check.
for (var x in myObj){
    if (myObj.hasOwnProperty(x)){
        console.log(myObj[x]);
    }
}
///prints:
// Hello world!

// We mentioned that `__proto__` was non-standard, and there's no standard way to
// change the prototype of an existing object. However, there are two ways to
// create a new object with a given prototype.

// The first is Object.create, which is a recent addition to JS, and therefore
// not available in all implementations yet.
var myObj = Object.create(myPrototype);
myObj.meaningOfLife; // = 43

// The second way, which works anywhere, has to do with constructors.
// Constructors have a property called prototype. This is *not* the prototype of
// the constructor function itself; instead, it's the prototype that new objects
// are given when they're created with that constructor and the new keyword.
MyConstructor.prototype = {
    myNumber: 5,
    getMyNumber: function(){
        return this.myNumber;
    }
};
var myNewObj2 = new MyConstructor();
myNewObj2.getMyNumber(); // = 5
myNewObj2.myNumber = 6;
myNewObj2.getMyNumber(); // = 6

// Built-in types like strings and numbers also have constructors that create
// equivalent wrapper objects.
var myNumber = 12;
var myNumberObj = new Number(12);
myNumber == myNumberObj; // = true

// Except, they aren't exactly equivalent.
typeof myNumber; // = 'number'
typeof myNumberObj; // = 'object'
myNumber === myNumberObj; // = false
if (0){
    // This code won't execute, because 0 is falsy.
}
if (new Number(0)){
   // This code will execute, because wrapped numbers are objects, and objects
   // are always truthy.
}

// However, the wrapper objects and the regular builtins share a prototype, so
// you can actually add functionality to a string, for instance.
String.prototype.firstCharacter = function(){
    return this.charAt(0);
};
""abc"".firstCharacter(); // = ""a""

// This fact is often used in ""polyfilling"", which is implementing newer
// features of JavaScript in an older subset of JavaScript, so that they can be
// used in older environments such as outdated browsers.

// For instance, we mentioned that Object.create isn't yet available in all
// implementations, but we can still use it with this polyfill:
if (Object.create === undefined){ // don't overwrite it if it exists
    Object.create = function(proto){
        // make a temporary constructor with the right prototype
        var Constructor = function(){};
        Constructor.prototype = proto;
        // then use it to create a new, appropriately-prototyped object
        return new Constructor();
    };
}

// ES6 Additions

// The ""let"" keyword allows you to define variables in a lexical scope, 
// as opposed to a function scope like the var keyword does.
let name = ""Billy"";

// Variables defined with let can be reassigned new values.
name = ""William"";

// The ""const"" keyword allows you to define a variable in a lexical scope
// like with let, but you cannot reassign the value once one has been assigned.

const pi = 3.14;

pi = 4.13; // You cannot do this.

// There is a new syntax for functions in ES6 known as ""lambda syntax"".
// This allows functions to be defined in a lexical scope like with variables
// defined by const and let. 

const isEven = (number) => {
    return number % 2 === 0;
};

isEven(7); // false

// The ""equivalent"" of this function in the traditional syntax would look like this:

function isEven(number) {
    return number % 2 === 0;
};

// I put the word ""equivalent"" in double quotes because a function defined
// using the lambda syntax cannot be called before the definition.
// The following is an example of invalid usage:

add(1, 8);

const add = (firstNumber, secondNumber) => {
    return firstNumber + secondNumber;
};
```

## Further Reading

The [Mozilla Developer Network][1] provides excellent documentation for
JavaScript as it's used in browsers. Plus, it's a wiki, so as you learn more you
can help others out by sharing your own knowledge.

MDN's [A re-introduction to JavaScript][2] covers much of the concepts covered
here in more detail. This guide has quite deliberately only covered the
JavaScript language itself; if you want to learn more about how to use
JavaScript in web pages, start by learning about the [Document Object Model][3].

[Learn Javascript by Example and with Challenges][4] is a variant of this
reference with built-in challenges.

[JavaScript Garden][5] is an in-depth guide of all the counter-intuitive parts
of the language.

[JavaScript: The Definitive Guide][6] is a classic guide and reference book.

[Eloquent Javascript][8] by Marijn Haverbeke is an excellent JS book/ebook with
attached terminal

[Javascript: The Right Way][10] is a guide intended to introduce new developers
to JavaScript and help experienced developers learn more about its best practices.

[Javascript:Info][11] is a modern javascript tutorial covering the basics (core language and working with a browser)
as well as advanced topics with concise explanations.


In addition to direct contributors to this article, some content is adapted from
Louie Dinh's Python tutorial on this site, and the [JS Tutorial][7] on the
Mozilla Developer Network.


[1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript
[2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript
[3]: https://developer.mozilla.org/en-US/docs/Using_the_W3C_DOM_Level_1_Core
[4]: http://www.learneroo.com/modules/64/nodes/350
[5]: http://bonsaiden.github.io/JavaScript-Garden/
[6]: http://www.amazon.com/gp/product/0596805527/
[7]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript
[8]: https://www.javascripttutorial.net/
[8]: http://eloquentjavascript.net/
[10]: http://jstherightway.org/
[11]: https://javascript.info/"
"Less is a CSS pre-processor, that adds features such as variables, nesting, mixins and more.
Less (and other preprocessors, such as [Sass](http://sass-lang.com/)) help developers to write maintainable and DRY (Don't Repeat Yourself) code.

```css


//Single line comments are removed when Less is compiled to CSS.

/*Multi line comments are preserved. */



/* Variables
==============================*/


/* You can store a CSS value (such as a color) in a variable.
   Use the '@' symbol to create a variable. */

@primary-color: #a3a4ff;
@secondary-color: #51527f;
@body-font: 'Roboto', sans-serif;

/* You can use the variables throughout your stylesheet.
   Now if you want to change a color, you only have to make the change once.*/

body {
	background-color: @primary-color;
	color: @secondary-color;
	font-family: @body-font;
}

/* This would compile to: */

body {
	background-color: #a3a4ff;
	color: #51527F;
	font-family: 'Roboto', sans-serif;
}


/* This is much more maintainable than having to change the color
   each time it appears throughout your stylesheet. */



/* Mixins
==============================*/


/* If you find you are writing the same code for more than one
   element, you might want to reuse that easily.*/

.center {
	display: block;
	margin-left: auto;
	margin-right: auto;
	left: 0;
	right: 0;
}

/* You can use the mixin by simply adding the selector as a style */

div {
	.center;
	background-color: @primary-color;
}

/* Which would compile to: */

.center {
  display: block;
  margin-left: auto;
  margin-right: auto;
  left: 0;
  right: 0;
}
div {
	display: block;
	margin-left: auto;
	margin-right: auto;
	left: 0;
	right: 0;
	background-color: #a3a4ff;
}

/* You can omit the mixin code from being compiled by adding parenthesis
   after the selector */

.center() {
  display: block;
  margin-left: auto;
  margin-right: auto;
  left: 0;
  right: 0;
}

div {
  .center;
  background-color: @primary-color;
}

/* Which would compile to: */
div {
  display: block;
  margin-left: auto;
  margin-right: auto;
  left: 0;
  right: 0;
  background-color: #a3a4ff;
}



/* Nesting
==============================*/


/* Less allows you to nest selectors within selectors */

ul {
	list-style-type: none;
	margin-top: 2em;

	li {
		background-color: #f00;
	}
}

/* '&' will be replaced by the parent selector. */
/* You can also nest pseudo-classes. */
/* Keep in mind that over-nesting will make your code less maintainable.
   Best practices recommend going no more than 3 levels deep when nesting.
   For example: */

ul {
	list-style-type: none;
	margin-top: 2em;

	li {
		background-color: red;

		&:hover {
		  background-color: blue;
		}

		a {
		  color: white;
		}
	}
}

/* Compiles to: */

ul {
  list-style-type: none;
  margin-top: 2em;
}

ul li {
  background-color: red;
}

ul li:hover {
  background-color: blue;
}

ul li a {
  color: white;
}



/* Functions
==============================*/


/* Less provides functions that can be used to accomplish a variety of
   tasks. Consider the following: */

/* Functions can be invoked by using their name and passing in the
   required arguments. */

body {
  width: round(10.25px);
}

.header {
	background-color: lighten(#000, 0.5);
}

.footer {
  background-color: fadeout(#000, 0.25)
}

/* Compiles to: */

body {
  width: 10px;
}

.header {
  background-color: #010101;
}

.footer {
  background-color: rgba(0, 0, 0, 0.75);
}

/* You may also define your own functions. Functions are very similar to
   mixins. When trying to choose between a function or a mixin, remember
   that mixins are best for generating CSS while functions are better for
   logic that might be used throughout your Less code. The examples in
   the 'Math Operators' section are ideal candidates for becoming a reusable
   function. */

/* This function calculates the average of two numbers: */

.average(@x, @y) {
  @average-result: ((@x + @y) / 2);
}

div {
  .average(16px, 50px); // ""call"" the mixin
  padding: @average-result;    // use its ""return"" value
}

/* Compiles to: */

div {
  padding: 33px;
}



/*Extend (Inheritance)
==============================*/


/*Extend is a way to share the properties of one selector with another. */

.display {
  height: 50px;
}

.display-success {
  &:extend(.display);
	border-color: #22df56;
}

/* Compiles to: */
.display,
.display-success {
  height: 50px;
}
.display-success {
  border-color: #22df56;
}

/* Extending a CSS statement is preferable to creating a mixin
   because of the way it groups together the classes that all share
   the same base styling. If this was done with a mixin, the properties
   would be duplicated for each statement that
   called the mixin. While it won't affect your workflow, it will
   add unnecessary bloat to the files created by the Less compiler. */



/*Partials and Imports
==============================*/


/* Less allows you to create partial files. This can help keep your Less
   code modularized. Partial files conventionally begin with an '_',
   e.g. _reset.less. and are imported into a main less file that gets
   compiled into CSS */

/* Consider the following CSS which we'll put in a file called _reset.less */

html,
body,
ul,
ol {
  margin: 0;
  padding: 0;
}

/* Less offers @import which can be used to import partials into a file.
   This differs from the traditional CSS @import statement which makes
   another HTTP request to fetch the imported file. Less takes the
   imported file and combines it with the compiled code. */

@import 'reset';

body {
  font-size: 16px;
  font-family: Helvetica, Arial, Sans-serif;
}

/* Compiles to: */

html, body, ul, ol {
  margin: 0;
  padding: 0;
}

body {
  font-size: 16px;
  font-family: Helvetica, Arial, Sans-serif;
}



/* Math Operations
==============================*/


/* Less provides the following operators: +, -, *, /, and %. These can
   be useful for calculating values directly in your Less files instead
   of using values that you've already calculated by hand. Below is an example
   of a setting up a simple two column design. */

@content-area: 960px;
@main-content: 600px;
@sidebar-content: 300px;

@main-size: @main-content / @content-area * 100%;
@sidebar-size: @sidebar-content / @content-area * 100%;
@gutter: 100% - (@main-size + @sidebar-size);

body {
  width: 100%;
}

.main-content {
  width: @main-size;
}

.sidebar {
  width: @sidebar-size;
}

.gutter {
  width: @gutter;
}

/* Compiles to: */

body {
  width: 100%;
}

.main-content {
  width: 62.5%;
}

.sidebar {
  width: 31.25%;
}

.gutter {
  width: 6.25%;
}


```

## Practice Less

If you want to play with Less in your browser, check out:
* [Codepen](http://codepen.io/)
* [LESS2CSS](http://lesscss.org/less-preview/)

## Compatibility

Less can be used in any project as long as you have a program to compile it into CSS. You'll want to verify that the CSS you're using is compatible with your target browsers.

[QuirksMode CSS](http://www.quirksmode.org/css/) and [CanIUse](http://caniuse.com) are great resources for checking compatibility.

## Further reading
* [Official Documentation](http://lesscss.org/features/)
* [Less CSS - Beginner's Guide](http://www.hongkiat.com/blog/less-basic/)"
"**raylib** is a cross-platform easy-to-use graphics library, built around
OpenGL 1.1, 2.1, 3.3 and OpenGL ES 2.0. Even though it is written in C
it has bindings to over 50 different languages. This tutorial will use C,
more specifically C99.

```c
#include <raylib.h>

int main(void)
{
    const int screenWidth = 800;
    const int screenHeight = 450;

    // Before initialising raylib we can set configuration flags
    SetConfigFlags(FLAG_MSAA_4X_HINT | FLAG_VSYNC_HINT);

    // raylib doesn't require us to store any instance structures
    // At the moment raylib can handle only one window at a time
    InitWindow(screenWidth, screenHeight, ""MyWindow"");

    // Set our game to run at 60 frames-per-second
    SetTargetFPS(60);

    // Set a key that closes the window
    // Could be 0 for no key
    SetExitKey(KEY_DELETE);

    // raylib defines two types of cameras: Camera3D and Camera2D
    // Camera is a typedef for Camera3D
    Camera camera = {
            .position = {0.0f, 0.0f, 0.0f},
            .target   = {0.0f, 0.0f, 1.0f},
            .up       = {0.0f, 1.0f, 0.0f},
            .fovy     = 70.0f,
            .type     = CAMERA_PERSPECTIVE
    };

    // raylib supports loading of models, animations, images and sounds
    // from various different file formats
    Model myModel = LoadModel(""my_model.obj"");
    Font someFont = LoadFont(""some_font.ttf"");

    // Creates a 100x100 render texture
    RenderTexture renderTexture = LoadRenderTexture(100, 100);

    // WindowShouldClose checks if the user is closing the window
    // This might happen using a shortcut, window controls
    // or the key we set earlier
    while (!WindowShouldClose())
    {

        // BeginDrawing needs to be called before any draw call
        BeginDrawing();
        {

            // Sets the background to a certain color
            ClearBackground(BLACK);

            if (IsKeyDown(KEY_SPACE))
                DrawCircle(400, 400, 30, GREEN);

            // Simple draw text
            DrawText(""Congrats! You created your first window!"",
                     190, // x
                     200, // y
                     20,  // font size
                     LIGHTGRAY
            );

            // For most functions there are several versions
            // These are usually postfixed with Ex, Pro, V
            // or sometimes Rec, Wires (only for 3D), Lines (only for 2D)
            DrawTextEx(someFont,
                       ""Text in another font"",
                       (Vector2) {10, 10},
                       20, // font size
                       2,  // spacing
                       LIGHTGRAY);

            // Required for drawing 3D, has 2D equivalent
            BeginMode3D(camera);
            {

                DrawCube((Vector3) {0.0f, 0.0f, 3.0f},
                         1.0f, 1.0f, 1.0f, RED);

                // White tint when drawing will keep the original color
                DrawModel(myModel, (Vector3) {0.0f, 0.0f, 3.0f},
                          1.0f, //Scale
                          WHITE);

            }
            // End 3D mode so we can draw normally again
            EndMode3D();

            // Start drawing onto render texture
            BeginTextureMode(renderTexture);
            {

                // It behaves the same as if we just called `BeginDrawing()`

                ClearBackground(RAYWHITE);

                BeginMode3D(camera);
                {

                    DrawGrid(10, // Slices
                             1.0f // Spacing
                    );

                }
                EndMode3D();

            }
            EndTextureMode();

            // render textures have a Texture2D field
            DrawTexture(renderTexture.texture, 40, 378, BLUE);

        }
        EndDrawing();
    }

    // Unloading loaded objects
    UnloadFont(someFont);
    UnloadModel(myModel);

    // Close window and OpenGL context
    CloseWindow();

    return 0;
}

```

## Further reading
raylib has some [great examples](https://www.raylib.com/examples.html)
If you don't like C check out the [raylib bindings](https://github.com/raysan5/raylib/blob/master/BINDINGS.md)"
"A regular expression (regex or regexp for short) is a special text string for describing a search pattern. e.g. to extract domain name from a string we can say `/^[a-z]+:/` and it will match `http:` from `http://github.com/`.

PCRE (Perl Compatible Regular Expressions) is a C library implementing regex. It was written in 1997 when Perl was the de-facto choice for complex text processing tasks. The syntax for patterns used in PCRE closely resembles Perl. PCRE syntax is being used in many big projects including PHP, Apache, R to name a few.


There are two different sets of metacharacters:

* Those that are recognized anywhere in the pattern except within square brackets

```
  \      general escape character with several uses
  ^      assert start of string (or line, in multiline mode)
  $      assert end of string (or line, in multiline mode)
  .      match any character except newline (by default)
  [      start character class definition
  |      start of alternative branch
  (      start subpattern
  )      end subpattern
  ?      extends the meaning of (
         also 0 or 1 quantifier
         also quantifier minimizer
  *      0 or more quantifier
  +      1 or more quantifier
         also ""possessive quantifier""
  {      start min/max quantifier
```

* Those that are recognized within square brackets. Outside square brackets. They are also called as character classes.

```

  \      general escape character
  ^      negate the class, but only if the first character
  -      indicates character range
  [      POSIX character class (only if followed by POSIX syntax)
  ]      terminates the character class

```

PCRE provides some generic character types, also called as character classes.

```
  \d     any decimal digit
  \D     any character that is not a decimal digit
  \h     any horizontal white space character
  \H     any character that is not a horizontal white space character
  \s     any white space character
  \S     any character that is not a white space character
  \v     any vertical white space character
  \V     any character that is not a vertical white space character
  \w     any ""word"" character
  \W     any ""non-word"" character
```

## Examples

We will test our examples on the following string:

```
66.249.64.13 - - [18/Sep/2004:11:07:48 +1000] ""GET /robots.txt HTTP/1.0"" 200 468 ""-"" ""Googlebot/2.1""
```

 It is a standard Apache access log.

| Regex | Result          | Comment |
| :---- | :-------------- | :------ |
| `GET`   | GET | GET matches the characters GET literally (case sensitive) |
| `\d+.\d+.\d+.\d+` | 66.249.64.13 | `\d+` match a digit [0-9] one or more times defined by `+` quantifier, `\.` matches `.` literally |
| `(\d+\.){3}\d+` | 66.249.64.13 | `(\d+\.){3}` is trying to match group (`\d+\.`) exactly three times. |
| `\[.+\]` | [18/Sep/2004:11:07:48 +1000] | `.+` matches any character (except newline), `.` is any character |
| `^\S+` | 66.249.64.13 | `^` means start of the line, `\S+` matches any number of non-space characters |
| `\+[0-9]+` | +1000 | `\+` matches the character `+` literally. `[0-9]` character class means single number. Same can be achieved using `\+\d+` |

## Further Reading
[Regex101](https://regex101.com/) - Regular Expression tester and debugger"
"Elixir is a modern functional language built on top of the Erlang VM.
It's fully compatible with Erlang, but features a more standard syntax
and many more features.

```elixir

# Single line comments start with a number symbol.

# There's no multi-line comment,
# but you can stack multiple comments.

# To use the elixir shell use the `iex` command.
# Compile your modules with the `elixirc` command.

# Both should be in your path if you installed elixir correctly.

## ---------------------------
## -- Basic types
## ---------------------------

# There are numbers
3    # integer
0x1F # integer
3.0  # float

# Atoms are constants whose values are their own name. They start with `:`.
:hello # atom

# Tuples that are stored contiguously in memory.
{1,2,3} # tuple

# We can access a tuple element with the `elem` function:
elem({1, 2, 3}, 0) #=> 1

# Lists that are implemented as linked lists.
[1,2,3] # list

# We can access the head and tail of a list as follows:
[head | tail] = [1,2,3]
head #=> 1
tail #=> [2,3]

# In elixir, just like in Erlang, the `=` denotes pattern matching and
# not an assignment.
#
# This means that the left-hand side (pattern) is matched against a
# right-hand side.
#
# This is how the above example of accessing the head and tail of a list works.

# A pattern match will error when the sides don't match, in this example
# the tuples have different sizes.
# {a, b, c} = {1, 2} #=> ** (MatchError) no match of right hand side value: {1,2}

# There are also binaries
<<1,2,3>> # binary

# Strings and char lists
""hello"" # string
'hello' # char list

# Multi-line strings
""""""
I'm a multi-line
string.
""""""
#=> ""I'm a multi-line\nstring.\n""

# Strings are all encoded in UTF-8:
""héllò"" #=> ""héllò""

# Strings are really just binaries, and char lists are just lists.
<<?a, ?b, ?c>> #=> ""abc""
[?a, ?b, ?c]   #=> 'abc'

# `?a` in elixir returns the ASCII integer for the letter `a`
?a #=> 97

# To concatenate lists use `++`, for binaries use `<>`
[1,2,3] ++ [4,5]     #=> [1,2,3,4,5]
'hello ' ++ 'world'  #=> 'hello world'

<<1,2,3>> <> <<4,5>> #=> <<1,2,3,4,5>>
""hello "" <> ""world""  #=> ""hello world""

# Ranges are represented as `start..end` (both inclusive)
1..10 #=> 1..10
lower..upper = 1..10 # Can use pattern matching on ranges as well
[lower, upper] #=> [1, 10]

# Maps are key-value pairs
genders = %{""david"" => ""male"", ""gillian"" => ""female""}
genders[""david""] #=> ""male""

# Maps with atom keys can be used like this
genders = %{david: ""male"", gillian: ""female""}
genders.gillian #=> ""female""

## ---------------------------
## -- Operators
## ---------------------------

# Some math
1 + 1  #=> 2
10 - 5 #=> 5
5 * 2  #=> 10
10 / 2 #=> 5.0

# In elixir the operator `/` always returns a float.

# To do integer division use `div`
div(10, 2) #=> 5

# To get the division remainder use `rem`
rem(10, 3) #=> 1

# There are also boolean operators: `or`, `and` and `not`.
# These operators expect a boolean as their first argument.
true and true #=> true
false or true #=> true
# 1 and true
#=> ** (BadBooleanError) expected a boolean on left-side of ""and"", got: 1

# Elixir also provides `||`, `&&` and `!` which accept arguments of any type.
# All values except `false` and `nil` will evaluate to true.
1 || true  #=> 1
false && 1 #=> false
nil && 20  #=> nil
!true #=> false

# For comparisons we have: `==`, `!=`, `===`, `!==`, `<=`, `>=`, `<` and `>`
1 == 1 #=> true
1 != 1 #=> false
1 < 2  #=> true

# `===` and `!==` are more strict when comparing integers and floats:
1 == 1.0  #=> true
1 === 1.0 #=> false

# We can also compare two different data types:
1 < :hello #=> true

# The overall sorting order is defined below:
# number < atom < reference < functions < port < pid < tuple < list < bit string

# To quote Joe Armstrong on this: ""The actual order is not important,
# but that a total ordering is well defined is important.""

## ---------------------------
## -- Control Flow
## ---------------------------

# `if` expression
if false do
  ""This will never be seen""
else
  ""This will""
end

# There's also `unless`
unless true do
  ""This will never be seen""
else
  ""This will""
end

# Remember pattern matching? Many control-flow structures in elixir rely on it.

# `case` allows us to compare a value against many patterns:
case {:one, :two} do
  {:four, :five} ->
    ""This won't match""
  {:one, x} ->
    ""This will match and bind `x` to `:two` in this clause""
  _ ->
    ""This will match any value""
end

# It's common to bind the value to `_` if we don't need it.
# For example, if only the head of a list matters to us:
[head | _] = [1,2,3]
head #=> 1

# For better readability we can do the following:
[head | _tail] = [:a, :b, :c]
head #=> :a

# `cond` lets us check for many conditions at the same time.
# Use `cond` instead of nesting many `if` expressions.
cond do
  1 + 1 == 3 ->
    ""I will never be seen""
  2 * 5 == 12 ->
    ""Me neither""
  1 + 2 == 3 ->
    ""But I will""
end

# It is common to set the last condition equal to `true`, which will always match.
cond do
  1 + 1 == 3 ->
    ""I will never be seen""
  2 * 5 == 12 ->
    ""Me neither""
  true ->
    ""But I will (this is essentially an else)""
end

# `try/catch` is used to catch values that are thrown, it also supports an
# `after` clause that is invoked whether or not a value is caught.
try do
  throw(:hello)
catch
  message -> ""Got #{message}.""
after
  IO.puts(""I'm the after clause."")
end
#=> I'm the after clause
# ""Got :hello""

## ---------------------------
## -- Modules and Functions
## ---------------------------

# Anonymous functions (notice the dot)
square = fn(x) -> x * x end
square.(5) #=> 25

# They also accept many clauses and guards.
# Guards let you fine tune pattern matching,
# they are indicated by the `when` keyword:
f = fn
  x, y when x > 0 -> x + y
  x, y -> x * y
end

f.(1, 3)  #=> 4
f.(-1, 3) #=> -3

# Elixir also provides many built-in functions.
# These are available in the current scope.
is_number(10)    #=> true
is_list(""hello"") #=> false
elem({1,2,3}, 0) #=> 1

# You can group several functions into a module. Inside a module use `def`
# to define your functions.
defmodule Math do
  def sum(a, b) do
    a + b
  end

  def square(x) do
    x * x
  end
end

Math.sum(1, 2)  #=> 3
Math.square(3) #=> 9

# To compile our simple Math module save it as `math.ex` and use `elixirc`
# in your terminal: elixirc math.ex

# Inside a module we can define functions with `def` and private functions with `defp`.
# A function defined with `def` is available to be invoked from other modules,
# a private function can only be invoked locally.
defmodule PrivateMath do
  def sum(a, b) do
    do_sum(a, b)
  end

  defp do_sum(a, b) do
    a + b
  end
end

PrivateMath.sum(1, 2)    #=> 3
# PrivateMath.do_sum(1, 2) #=> ** (UndefinedFunctionError)

# Function declarations also support guards and multiple clauses.
# When a function with multiple clauses is called, the first function
# that satisfies the clause will be invoked.
# Example: invoking area({:circle, 3}) will call the second area
# function defined below, not the first:
defmodule Geometry do
  def area({:rectangle, w, h}) do
    w * h
  end

  def area({:circle, r}) when is_number(r) do
    3.14 * r * r
  end
end

Geometry.area({:rectangle, 2, 3}) #=> 6
Geometry.area({:circle, 3})       #=> 28.25999999999999801048
# Geometry.area({:circle, ""not_a_number""})
#=> ** (FunctionClauseError) no function clause matching in Geometry.area/1

# Due to immutability, recursion is a big part of elixir
defmodule Recursion do
  def sum_list([head | tail], acc) do
    sum_list(tail, acc + head)
  end

  def sum_list([], acc) do
    acc
  end
end

Recursion.sum_list([1,2,3], 0) #=> 6

# Elixir modules support attributes, there are built-in attributes and you
# may also add custom ones.
defmodule MyMod do
  @moduledoc """"""
  This is a built-in attribute on a example module.
  """"""

  @my_data 100 # This is a custom attribute.
  IO.inspect(@my_data) #=> 100
end

# The pipe operator |> allows you to pass the output of an expression
# as the first parameter into a function. 

Range.new(1,10)
|> Enum.map(fn x -> x * x end)
|> Enum.filter(fn x -> rem(x, 2) == 0 end)
#=> [4, 16, 36, 64, 100]

## ---------------------------
## -- Structs and Exceptions
## ---------------------------

# Structs are extensions on top of maps that bring default values,
# compile-time guarantees and polymorphism into Elixir.
defmodule Person do
  defstruct name: nil, age: 0, height: 0
end

joe_info = %Person{ name: ""Joe"", age: 30, height: 180 }
#=> %Person{age: 30, height: 180, name: ""Joe""}

# Access the value of name
joe_info.name #=> ""Joe""

# Update the value of age
older_joe_info = %{ joe_info | age: 31 }
#=> %Person{age: 31, height: 180, name: ""Joe""}

# The `try` block with the `rescue` keyword is used to handle exceptions
try do
  raise ""some error""
rescue
  RuntimeError -> ""rescued a runtime error""
  _error -> ""this will rescue any error""
end
#=> ""rescued a runtime error""

# All exceptions have a message
try do
  raise ""some error""
rescue
  x in [RuntimeError] ->
    x.message
end
#=> ""some error""

## ---------------------------
## -- Concurrency
## ---------------------------

# Elixir relies on the actor model for concurrency. All we need to write
# concurrent programs in elixir are three primitives: spawning processes,
# sending messages and receiving messages.

# To start a new process we use the `spawn` function, which takes a function
# as argument.
f = fn -> 2 * 2 end #=> #Function<erl_eval.20.80484245>
spawn(f) #=> #PID<0.40.0>

# `spawn` returns a pid (process identifier), you can use this pid to send
# messages to the process. To do message passing we use the `send` operator.
# For all of this to be useful we need to be able to receive messages. This is
# achieved with the `receive` mechanism:

# The `receive do` block is used to listen for messages and process
# them when they are received. A `receive do` block will only
# process one received message. In order to process multiple
# messages, a function with a `receive do` block must recursively
# call itself to get into the `receive do` block again.

defmodule Geometry do
  def area_loop do
    receive do
      {:rectangle, w, h} ->
        IO.puts(""Area = #{w * h}"")
        area_loop()
      {:circle, r} ->
        IO.puts(""Area = #{3.14 * r * r}"")
        area_loop()
    end
  end
end

# Compile the module and create a process that evaluates `area_loop` in the shell
pid = spawn(fn -> Geometry.area_loop() end) #=> #PID<0.40.0>
# Alternatively
pid = spawn(Geometry, :area_loop, [])

# Send a message to `pid` that will match a pattern in the receive statement
send pid, {:rectangle, 2, 3}
#=> Area = 6
#   {:rectangle,2,3}

send pid, {:circle, 2}
#=> Area = 12.56000000000000049738
#   {:circle,2}

# The shell is also a process, you can use `self` to get the current pid
self() #=> #PID<0.27.0>

## ---------------------------
## -- Agents
## ---------------------------

# An agent is a process that keeps track of some changing value

# Create an agent with `Agent.start_link`, passing in a function
# The initial state of the agent will be whatever that function returns
{:ok, my_agent} = Agent.start_link(fn -> [""red"", ""green""] end)

# `Agent.get` takes an agent name and a `fn` that gets passed the current state
# Whatever that `fn` returns is what you'll get back
Agent.get(my_agent, fn colors -> colors end) #=> [""red"", ""green""]

# Update the agent's state the same way
Agent.update(my_agent, fn colors -> [""blue"" | colors] end)
```

## References

* [Getting started guide](https://elixir-lang.org/getting-started/introduction.html) from the [Elixir website](https://elixir-lang.org)
* [Elixir Documentation](https://elixir-lang.org/docs.html)
* [""Programming Elixir""](https://pragprog.com/book/elixir/programming-elixir) by Dave Thomas
* [Elixir Cheat Sheet](https://media.pragprog.com/titles/elixir/ElixirCheat.pdf)
* [""Learn You Some Erlang for Great Good!""](https://learnyousomeerlang.com/) by Fred Hebert
* [""Programming Erlang: Software for a Concurrent World""](https://pragprog.com/book/jaerlang2/programming-erlang) by Joe Armstrong
* [Introduction to Elixir](https://learn-elixir.com/)"
"language: ""Lisp Flavoured Erlang(LFE)""
filename: lispflavourederlang.lfe
contributors:
  - [""Pratik Karki"", ""https://github.com/prertik""]
---

Lisp Flavoured Erlang(LFE) is a functional, concurrent, general-purpose programming 
language and Lisp dialect(Lisp-2) built on top of Core Erlang and the Erlang Virtual Machine(BEAM). 

LFE can be obtained from [LFE](https://github.com/rvirding/lfe)

The classic starting point is [LFE DOCS.](http://docs.lfe.io)

Another new site is being built to replace it.[LFE DEV.](http://docs.lfe.io/dev)



```lisp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 0. Syntax
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; General form.

;; Lisp comprises of two syntax called: the ATOM and the S-expression.
;; `forms` are known as grouped S-expressions.

8  ; an atom; it evaluates to itself

:ERLANG ;Atom; evaluates to the symbol :ERLANG.

t  ; another atom which denotes true.

(* 2 21) ; an S- expression

'(8 :foo t)  ;another one


;;; Comments

;; Single line comments start with a semicolon; use two for normal
;; comments, three for section comments, and four fo file-level
;; comments.

;; Block Comment

   #| comment text |#

;;; Environment

;; LFE is the de-facto standard.

;; Libraries can be used directly from the Erlang ecosystem. Rebar3 is the build tool.

;; LFE is usually developed with a text editor(preferably Emacs) and a REPL
;; (Read Evaluate Print Loop) running at the same time. The REPL 
;; allows for interactive exploration of the program as it is ""live""
;; in the system.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 1. Literals and Special Syntactic Rules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Integers

1234 -123	        ; Regular decimal notation
#b0 #b10101	        ; Binary notation
#0 #10101	        ; Binary notation (alternative form)
#o377 #o-111	    ; Octal notation
#d123456789 #d+123	; Explicitly decimal notation
#xc0ffe 0x-01	    ; Hexadecimal notation
#2r1010 #8r377 	    ;Notation with explicit base (up to 36)
#\a #$ #\ä #\🐭     ;Character notation (the value is the Unicode code point of the character)
#\x1f42d;	        ;Character notation with the value in hexadecimal

;;; Floating point numbers
1.0 +2.0 -1.5 1.0e10 1.111e-10     

;;; Strings

""any text between double quotes where \"" and other special characters like \n can be escaped"".
; List String
""Cat: \x1f639;"" ; writing unicode in string for regular font ending with semicolon.

#""This is a binary string \n with some \""escaped\"" and quoted (\x1f639;) characters""
; Binary strings are just strings but function different in the VM. 
; Other ways of writing it are:  #B(""a""), #""a"", and #B(97).


;;; Character escaping

\b	; => Backspace
\t	; => Tab
\n	; => Newline
\v	; => Vertical tab
\f	; => Form Feed
\r	; => Carriage Return
\e	; => Escape
\s	; => Space
\d	; => Delete

;;; Binaries
;; It is used to create binaries with any contents.
#B((#""a"" binary) (#""b"" binary))	               ; #""ab"" (Evaluated form)

;;; Lists are: () or (foo bar baz)

;;; Tuples are written in: #(value1 value2 ...). Empty tuple #() is also valid.

;;; Maps are written as: #M(key1 value1 key2 value2 ...). Empty map #M() is also valid.

;;; Symbols: Things that cannot be parsed. Eg: foo, Foo, foo-bar, :foo
| foo | ; explicit construction of symbol by wrapping vertical bars.

;;; Evaluation 

;; #.(... some expression ...). E.g. '#.(+ 1 1) will evaluate the (+ 1 1) while it            ;; reads the expression and then be effectively '2.

;; List comprehension in LFE REPL

lfe> (list-comp
          ((<- x '(0 1 2 3)))
          (trunc (math:pow 3 x)))
       (1 3 9 27)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 2. Core forms
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; These forms are same as those found at Common Lisp and Scheme.

(quote e)
(cons head tail)
(car e)
(cdr e)
(list e ... )
(tuple e ... )
(binary seg ... )
(map key val ...), (map-get m k), (map-set m k v ...), (map-update m k v ...)

(lambda (arg ...) ...)
  (match-lambda
    ((arg ... ) {{(when e ...)}} ...) ; Matches clauses
    ... )
(let ((pat {{(when e ...)}} e)
      ...)
  ... )
(let-function ((name lambda|match-lambda) ; Only define local
               ... )                      ; functions
  ... )
(letrec-function ((name lambda|match-lambda) ; Only define local
                  ... )                      ; functions
  ... )
(let-macro ((name lambda-match-lambda) ; Only define local
            ...)                       ; macros
  ...)
(progn ... )
(if test true-expr {{false-expr}})
(case e
  (pat {{(when e ...)}} ...)
   ... ))
(receive
  (pat {{(when e ...)}} ... )
  ...
  (after timeout ... ))
(catch ... )
(try
  e
  {{(case ((pat {{(when e ...)}} ... )
          ... ))}}
  {{(catch
     ; Next must be tuple of length 3!
     (((tuple type value ignore) {{(when e ...)}}
      ... )
     ... )}}
  {{(after ... )}})

(funcall func arg ... )
(call mod func arg ... ) - Call to Erlang Mod:Func(Arg, ... )
(define-module name declaration ... )
(extend-module declaration ... ) - Define/extend module and declarations.
(define-function name lambda|match-lambda)
(define-macro name lambda|match-lambda) - Define functions/macros at top-level.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 3. Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Macros are part of the language to allow you to create abstractions 
;; on top of the core language and standard library that move you closer 
;; toward being able to directly express the things you want to express.

;; Top-level function

(defun name (arg ...) ...)

;; Adding comments in functions

(defun name
  ""Toplevel function with pattern-matching arguments""
  ((argpat ...) ...)
  ...)

;; Top-level macro

(defmacro name (arg ...) ...)
(defmacro name arg ...)

;; Top-level macro with pattern matching arguments

(defmacro name
  ((argpat ...) ...)
  ...)

;; Top-level macro using Scheme inspired syntax-rules format 

(defsyntax name
  (pat exp)
  ...)

;;; Local macros in macro or syntax-rule format

(macrolet ((name (arg ... ) ... )
            ... )
    ... )
    
(syntaxlet ((name (pat exp) ...)
             ...)
 ...)

;; Like CLISP

(prog1 ...)
(prog2 ...)

;; Erlang LFE module

(defmodule name ...)

;; Erlang LFE record

(defrecord name ...)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 4. Patterns and Guards
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Using patterns in LFE compared to that of Erlang

;; Erlang                     ;; LFE
;; {ok, X}                       (tuple 'ok x)
;; error                         'error
;; {yes, [X|Xs]}                 (tuple 'yes (cons x xs))
;; <<34,F/float>>                (binary 34 (f float))
;; [P|Ps]=All                    (= (cons p ps) all)

  _    ; => is don't care while pattern matching
  
  (= pattern1 pattern2)     ; => easier, better version of pattern matching
  
;; Guards

;; Whenever pattern occurs(let, case, receive, lc, etc) it can be followed by an optional
;; guard which has the form (when test ...).

(progn gtest ...)             ;; => Sequence of guard tests
(if gexpr gexpr gexpr)
(type-test e)
(guard-bif ...)               ;; => Guard BIFs, arithmetic, boolean and comparison operators

;;; REPL

lfe>(set (tuple len status msg) #(8 ok ""Trillian""))
    #(8 ok ""Trillian"")
lfe>msg
    ""Trillian""

;;; Program illustrating use of Guards

(defun right-number?
        ((x) (when (orelse (== x 42) (== x 276709)))
          'true)
        ((_) 'false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 5. Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; A simple function using if.

(defun max (x y)
  ""The max function.""
  (if (>= x y) x y))

;; Same function using more clause

(defun max
  ""The max function.""
  ((x y) (when (>= x y)) x)
  ((x y) y))

;; Same function using similar style but using local functions defined by flet or fletrec

(defun foo (x y)
  ""The max function.""
  (flet ((m (a b) ""Local comment.""
            (if (>= a b) a b)))
    (m x y)))

;; LFE being Lisp-2 has separate namespaces for variables and functions
;; Both variables and function/macros are lexically scoped.
;; Variables are bound by lambda, match-lambda and let.
;; Functions are bound by top-level defun, flet and fletrec.
;; Macros are bound by top-level defmacro/defsyntax and by macrolet/syntaxlet.

;; (funcall func arg ...) like CL to call lambdas/match-lambdas 
;; (funs) bound to variables are used.

;; separate bindings and special for apply.
apply _F (...), 
apply _F/3 ( a1, a2, a3 )
    
;; Cons'ing in function heads
(defun sum (l) (sum l 0))
  (defun sum
    (('() total) total)
    (((cons h t) total) (sum t (+ h total))))
    
;; ``cons`` literal instead of constructor form
      (defun sum (l) (sum l 0))
      (defun sum
        (('() total) total)
        ((`(,h . ,t) total) (sum t (+ h total))))

;; Matching records in function heads

(defun handle_info
  (('ping (= (match-state remote-pid 'undefined) state))
    (gen_server:cast (self) 'ping)
    `#(noreply ,state))
  (('ping state)
   `#(noreply ,state)))

;; Receiving Messages
      (defun universal-server ()
        (receive
          ((tuple 'become func)
           (funcall func))))
           
;; another way for receiving messages

 (defun universal-server ()
        (receive
          (`#(become ,func)
            (funcall func))))

;; Composing a complete function for specific tasks

(defun compose (f g)
  (lambda (x)
   (funcall f
     (funcall g x))))

(defun check ()
  (let* ((sin-asin (compose #'sin/1 #'asin/1))
         (expected (sin (asin 0.5)))
         (compose-result (funcall sin-asin 0.5)))
    (io:format ""Expected answer: ~p~n"" (list expected))
    (io:format ""Answer with compose: ~p~n"" (list compose-result))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 6. Concurrency
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Message passing as done by Erlang's light-weight ""processes"".

(defmodule messenger-back
 (export (print-result 0) (send-message 2)))

(defun print-result ()
  (receive
    ((tuple pid msg)
      (io:format ""Received message: '~s'~n"" (list msg))
      (io:format ""Sending message to process ~p ...~n"" (list pid))
      (! pid (tuple msg))
      (print-result))))

(defun send-message (calling-pid msg)
  (let ((spawned-pid (spawn 'messenger-back 'print-result ())))
    (! spawned-pid (tuple calling-pid msg))))
    
;; Multiple simultaneous HTTP Requests:

(defun parse-args (flag)
  ""Given one or more command-line arguments, extract the passed values.

  For example, if the following was passed via the command line:

    $ erl -my-flag my-value-1 -my-flag my-value-2

  One could then extract it in an LFE program by calling this function:

    (let ((args (parse-args 'my-flag)))
      ...
      )
  In this example, the value assigned to the arg variable would be a list
  containing the values my-value-1 and my-value-2.""
  (let ((`#(ok ,data) (init:get_argument flag)))
    (lists:merge data)))

(defun get-pages ()
  ""With no argument, assume 'url parameter was passed via command line.""
  (let ((urls (parse-args 'url)))
    (get-pages urls)))

(defun get-pages (urls)
  ""Start inets and make (potentially many) HTTP requests.""
  (inets:start)
  (plists:map
    (lambda (x)
      (get-page x)) urls))

(defun get-page (url)
  ""Make a single HTTP request.""
  (let* ((method 'get)
         (headers '())
         (request-data `#(,url ,headers))
         (http-options ())
         (request-options '(#(sync false))))
    (httpc:request method request-data http-options request-options)
    (receive
      (`#(http #(,request-id #(error ,reason)))
       (io:format ""Error: ~p~n"" `(,reason)))
      (`#(http #(,request-id ,result))
       (io:format ""Result: ~p~n"" `(,result))))))


;; Check out Erlang's documentation for more concurrency and OTP docs.
```

## Further Reading

*    [LFE DOCS](http://docs.lfe.io)
*    [LFE GitBook](https://lfe.gitbooks.io/reference-guide/index.html)
*    [LFE Wiki](https://en.wikipedia.org/wiki/LFE_(programming_language))

## Extra Info
*    [LFE PDF](http://www.erlang-factory.com/upload/presentations/61/Robertvirding-LispFlavouredErlang.pdf)
*    [LFE mail](https://groups.google.com/d/msg/lisp-flavoured-erlang/XA5HeLbQQDk/TUHabZCHXB0J)

## Credits

Lots of thanks to Robert Virding for creating LFE, Duncan McGreggor for documenting it and other LFE contributors who made LFE awesome."
"The Wolfram Language is the underlying language originally used in Mathematica, but now available for use in multiple contexts.

Wolfram Language has several interfaces:
* The command line kernel interface on Raspberry Pi (just called _The Wolfram Language_) which runs interactively and can't produce graphical input.
* _Mathematica_ which is a rich text/maths editor with interactive Wolfram built in: pressing shift+Return on a ""code cell"" creates an output cell with the result, which is not dynamic
* _Wolfram Workbench_ which is Eclipse interfaced to the Wolfram Language backend

The code in this example can be typed in to any interface and edited with Wolfram Workbench. Loading directly into Mathematica may be awkward because the file contains no cell formatting information (which would make the file a huge mess to read as text) - it can be viewed/edited but may require some setting up.

```
(* This is a comment *)

(* In Mathematica instead of using these comments you can create a text cell
   and annotate your code with nicely typeset text and images *)

(* Typing an expression returns the result *)
2*2              (* 4 *)
5+8              (* 13 *)

(* Function Call *)
(* Note, function names (and everything else) are case sensitive *)
Sin[Pi/2]        (* 1 *)

(* Alternate Syntaxes for Function Call with one parameter *)
Sin@(Pi/2)       (* 1 *)
(Pi/2) // Sin    (* 1 *)

(* Every syntax in WL has some equivalent as a function call *)
Times[2, 2]      (* 4 *)
Plus[5, 8]       (* 13 *)

(* Using a variable for the first time defines it and makes it global *)
x = 5            (* 5 *)
x == 5           (* True, C-style assignment and equality testing *)
x                (* 5 *)
x = x + 5        (* 10 *)
x                (* 10 *)
Set[x, 20]       (* I wasn't kidding when I said EVERYTHING has a function equivalent *)
x                (* 20 *)

(* Because WL is based on a computer algebra system, *)
(* using undefined variables is fine, they just obstruct evaluation *)
cow + 5          (* 5 + cow, cow is undefined so can't evaluate further *)
cow + 5 + 10     (* 15 + cow, it'll evaluate what it can *)
%                (* 15 + cow, % fetches the last return *)
% - cow          (* 15, undefined variable cow cancelled out *)
moo = cow + 5    (* Beware, moo now holds an expression, not a number! *)

(* Defining a function *)
Double[x_] := x * 2    (* Note := to prevent immediate evaluation of the RHS
                          And _ after x to indicate no pattern matching constraints *)
Double[10]             (* 20 *)
Double[Sin[Pi/2]]      (* 2 *)
Double @ Sin @ (Pi/2)  (* 2, @-syntax avoids queues of close brackets *)
(Pi/2) // Sin // Double(* 2, //-syntax lists functions in execution order *)

(* For imperative-style programming use ; to separate statements *)
(* Discards any output from LHS and runs RHS *)
MyFirst[] := (Print@""Hello""; Print@""World"")  (* Note outer parens are critical
                                                ;'s precedence is lower than := *)
MyFirst[]                                    (* Hello World *)

(* C-Style For Loop *)
PrintTo[x_] := For[y=0, y<x, y++, (Print[y])]  (* Start, test, incr, body *)
PrintTo[5]                                     (* 0 1 2 3 4 *)

(* While Loop *)
x = 0; While[x < 2, (Print@x; x++)]     (* While loop with test and body *)

(* If and conditionals *)
x = 8; If[x==8, Print@""Yes"", Print@""No""]   (* Condition, true case, else case *)
Switch[x, 2, Print@""Two"", 8, Print@""Yes""]  (* Value match style switch *)
Which[x==2, Print@""No"", x==8, Print@""Yes""] (* Elif style switch *)

(* Variables other than parameters are global by default, even inside functions *)
y = 10             (* 10, global variable y *)
PrintTo[5]         (* 0 1 2 3 4 *)
y                  (* 5, global y clobbered by loop counter inside PrintTo *)
x = 20             (* 20, global variable x *)
PrintTo[5]         (* 0 1 2 3 4 *)
x                  (* 20, x in PrintTo is a parameter and automatically local *)

(* Local variables are declared using the Module metafunction *)
(* Version with local variable *)
BetterPrintTo[x_] := Module[{y}, (For[y=0, y<x, y++, (Print@y)])]
y = 20             (* Global variable y *)
BetterPrintTo[5]   (* 0 1 2 3 4 *)
y                  (* 20, that's better *)

(* Module actually lets us declare any scope we like *)
Module[{count}, count=0;        (* Declare scope of this variable count *)
  (IncCount[] := ++count);      (* These functions are inside that scope *)
  (DecCount[] := --count)]
count              (* count - global variable count is not defined *)
IncCount[]         (* 1, using the count variable inside the scope *)
IncCount[]         (* 2, incCount updates it *)
DecCount[]         (* 1, so does decCount *)
count              (* count - still no global variable by that name *)

(* Lists *)
myList = {1, 2, 3, 4}     (* {1, 2, 3, 4} *)
myList[[1]]               (* 1 - note list indexes start at 1, not 0 *)
Map[Double, myList]       (* {2, 4, 6, 8} - functional style list map function *)
Double /@ myList          (* {2, 4, 6, 8} - Abbreviated syntax for above *)
Scan[Print, myList]       (* 1 2 3 4 - imperative style loop over list *)
Fold[Plus, 0, myList]     (* 10 (0+1+2+3+4) *)
FoldList[Plus, 0, myList] (* {0, 1, 3, 6, 10} - fold storing intermediate results *)
Append[myList, 5]         (* {1, 2, 3, 4, 5} - note myList is not updated *)
Prepend[myList, 5]        (* {5, 1, 2, 3, 4} - add ""myList = "" if you want it to be *)
Join[myList, {3, 4}]      (* {1, 2, 3, 4, 3, 4} *)
myList[[2]] = 5          (* {1, 5, 3, 4} - this does update myList *)

(* Associations, aka Dictionaries/Hashes *)
myHash = <|""Green"" -> 2, ""Red"" -> 1|>   (* Create an association *)
myHash[[""Green""]]                       (* 2, use it *)
myHash[[""Green""]] := 5                  (* 5, update it *)
myHash[[""Puce""]] := 3.5                 (* 3.5, extend it *)
KeyDropFrom[myHash, ""Green""]            (* Wipes out key Green *)
Keys[myHash]                            (* {Red, Puce} *)
Values[myHash]                          (* {1, 3.5} *)

(* And you can't do any demo of Wolfram without showing this off *)
Manipulate[y^2, {y, 0, 20}] (* Return a reactive user interface that displays y^2
                               and allows y to be adjusted between 0-20 with a slider.
                               Only works on graphical frontends *)
```

##Ready For More?

* [Wolfram Language Documentation Center](http://reference.wolfram.com/language/)"
"Julia is a new homoiconic functional language focused on technical computing.
While having the full power of homoiconic macros, first-class functions,
and low-level control, Julia is as easy to learn and use as Python.

This is based on Julia version 1.0.0.

```julia
# Single line comments start with a hash (pound) symbol.
#= Multiline comments can be written
   by putting '#=' before the text  and '=#'
   after the text. They can also be nested.
=#

####################################################
## 1. Primitive Datatypes and Operators
####################################################

# Everything in Julia is an expression.

# There are several basic types of numbers.
typeof(3)       # => Int64
typeof(3.2)     # => Float64
typeof(2 + 1im) # => Complex{Int64}
typeof(2 // 3)  # => Rational{Int64}

# All of the normal infix operators are available.
1 + 1      # => 2
8 - 1      # => 7
10 * 2     # => 20
35 / 5     # => 7.0
10 / 2     # => 5.0  # dividing integers always results in a Float64
div(5, 2)  # => 2    # for a truncated result, use div
5 \ 35     # => 7.0
2^2        # => 4    # power, not bitwise xor
12 % 10    # => 2

# Enforce precedence with parentheses
(1 + 3) * 2  # => 8

# Julia (unlike Python for instance) has integer under/overflow
10^19      # => -8446744073709551616
# use bigint or floating point to avoid this
big(10)^19 # => 10000000000000000000
1e19       # => 1.0e19
10.0^19    # => 1.0e19

# Bitwise Operators
~2         # => -3 # bitwise not
3 & 5      # => 1  # bitwise and
2 | 4      # => 6  # bitwise or
xor(2, 4)  # => 6  # bitwise xor
2 >>> 1    # => 1  # logical shift right
2 >> 1     # => 1  # arithmetic shift right
2 << 1     # => 4  # logical/arithmetic shift left

# Use the bitstring function to see the binary representation of a number.
bitstring(12345)
# => ""0000000000000000000000000000000000000000000000000011000000111001""
bitstring(12345.0)
# => ""0100000011001000000111001000000000000000000000000000000000000000""

# Boolean values are primitives
true
false

# Boolean operators
!true   # => false
!false  # => true
1 == 1  # => true
2 == 1  # => false
1 != 1  # => false
2 != 1  # => true
1 < 10  # => true
1 > 10  # => false
2 <= 2  # => true
2 >= 2  # => true
# Comparisons can be chained, like in Python but unlike many other languages
1 < 2 < 3  # => true
2 < 3 < 2  # => false

# Strings are created with ""
""This is a string.""

# Character literals are written with '
'a'

# Strings are UTF8 encoded, so strings like ""π"" or ""☃"" are not directly equivalent
# to an array of single characters.
# Only if they contain only ASCII characters can they be safely indexed.
ascii(""This is a string"")[1]    # => 'T'
# => 'T': ASCII/Unicode U+0054 (category Lu: Letter, uppercase)
# Beware, Julia indexes everything from 1 (like MATLAB), not 0 (like most languages).
# Otherwise, iterating over strings is recommended (map, for loops, etc).

# String can be compared lexicographically, in dictionnary order:
""good"" > ""bye""   # => true
""good"" == ""good"" # => true
""1 + 2 = 3"" == ""1 + 2 = $(1 + 2)"" # => true

# $(..) can be used for string interpolation:
""2 + 2 = $(2 + 2)"" # => ""2 + 2 = 4""
# You can put any Julia expression inside the parentheses.

# Printing is easy
println(""I'm Julia. Nice to meet you!"")  # => I'm Julia. Nice to meet you!

# Another way to format strings is the printf macro from the stdlib Printf.
using Printf   # this is how you load (or import) a module
@printf ""%d is less than %f\n"" 4.5 5.3   # => 5 is less than 5.300000


####################################################
## 2. Variables and Collections
####################################################

# You don't declare variables before assigning to them.
someVar = 5  # => 5
someVar      # => 5

# Accessing a previously unassigned variable is an error
try
    someOtherVar  # => ERROR: UndefVarError: someOtherVar not defined
catch e
    println(e)
end

# Variable names start with a letter or underscore.
# After that, you can use letters, digits, underscores, and exclamation points.
SomeOtherVar123! = 6  # => 6

# You can also use certain unicode characters
# here ☃ is a Unicode 'snowman' characters, see http://emojipedia.org/%E2%98%83%EF%B8%8F if it displays wrongly here
☃ = 8  # => 8
# These are especially handy for mathematical notation, like the constant π
2 * π  # => 6.283185307179586

# A note on naming conventions in Julia:
#
# * Word separation can be indicated by underscores ('_'), but use of
#   underscores is discouraged unless the name would be hard to read
#   otherwise.
#
# * Names of Types begin with a capital letter and word separation is shown
#   with CamelCase instead of underscores.
#
# * Names of functions and macros are in lower case, without underscores.
#
# * Functions that modify their inputs have names that end in !. These
#   functions are sometimes called mutating functions or in-place functions.

# Arrays store a sequence of values indexed by integers 1 through n:
a = Int64[] # => 0-element Array{Int64,1}

# 1-dimensional array literals can be written with comma-separated values.
b = [4, 5, 6] # => 3-element Array{Int64,1}: [4, 5, 6]
b = [4; 5; 6] # => 3-element Array{Int64,1}: [4, 5, 6]
b[1]    # => 4
b[end]  # => 6

# 2-dimensional arrays use space-separated values and semicolon-separated rows.
matrix = [1 2; 3 4] # => 2×2 Array{Int64,2}: [1 2; 3 4]

# Arrays of a particular type
b = Int8[4, 5, 6] # => 3-element Array{Int8,1}: [4, 5, 6]

# Add stuff to the end of a list with push! and append!
# By convention, the exclamation mark '!' is appended to names of functions
# that modify their arguments
push!(a, 1)    # => [1]
push!(a, 2)    # => [1,2]
push!(a, 4)    # => [1,2,4]
push!(a, 3)    # => [1,2,4,3]
append!(a, b)  # => [1,2,4,3,4,5,6]

# Remove from the end with pop
pop!(b)  # => 6
b # => [4,5]

# Let's put it back
push!(b, 6)  # => [4,5,6]
b # => [4,5,6]

a[1]  # => 1  # remember that Julia indexes from 1, not 0!

# end is a shorthand for the last index. It can be used in any
# indexing expression
a[end]  # => 6

# we also have popfirst! and pushfirst!
popfirst!(a)  # => 1 
a # => [2,4,3,4,5,6]
pushfirst!(a, 7)  # => [7,2,4,3,4,5,6]
a # => [7,2,4,3,4,5,6]

# Function names that end in exclamations points indicate that they modify
# their argument.
arr = [5,4,6]  # => 3-element Array{Int64,1}: [5,4,6]
sort(arr)      # => [4,5,6]
arr            # => [5,4,6]
sort!(arr)     # => [4,5,6]
arr            # => [4,5,6]

# Looking out of bounds is a BoundsError
try
    a[0] 
    # => ERROR: BoundsError: attempt to access 7-element Array{Int64,1} at 
    # index [0]
    # => Stacktrace:
    # =>  [1] getindex(::Array{Int64,1}, ::Int64) at .\array.jl:731
    # =>  [2] top-level scope at none:0
    # =>  [3] ...
    # => in expression starting at ...\LearnJulia.jl:180
    a[end + 1] 
    # => ERROR: BoundsError: attempt to access 7-element Array{Int64,1} at 
    # index [8]
    # => Stacktrace:
    # =>  [1] getindex(::Array{Int64,1}, ::Int64) at .\array.jl:731
    # =>  [2] top-level scope at none:0
    # =>  [3] ...
    # => in expression starting at ...\LearnJulia.jl:188
catch e
    println(e)
end

# Errors list the line and file they came from, even if it's in the standard
# library. You can look in the folder share/julia inside the julia folder to
# find these files.

# You can initialize arrays from ranges
a = [1:5;]  # => 5-element Array{Int64,1}: [1,2,3,4,5]
a2 = [1:5]  # => 1-element Array{UnitRange{Int64},1}: [1:5]

# You can look at ranges with slice syntax.
a[1:3]    # => [1, 2, 3]
a[2:end]  # => [2, 3, 4, 5]

# Remove elements from an array by index with splice!
arr = [3,4,5]
splice!(arr, 2) # => 4 
arr # => [3,5]

# Concatenate lists with append!
b = [1,2,3]
append!(a, b) # => [1, 2, 3, 4, 5, 1, 2, 3]
a # => [1, 2, 3, 4, 5, 1, 2, 3]

# Check for existence in a list with in
in(1, a)  # => true

# Examine the length with length
length(a)  # => 8

# Tuples are immutable.
tup = (1, 2, 3)  # => (1,2,3)
typeof(tup) # => Tuple{Int64,Int64,Int64}
tup[1] # => 1
try
    tup[1] = 3  
    # => ERROR: MethodError: no method matching 
    # setindex!(::Tuple{Int64,Int64,Int64}, ::Int64, ::Int64)
catch e
    println(e)
end

# Many array functions also work on tuples
length(tup) # => 3
tup[1:2]    # => (1,2)
in(2, tup)  # => true

# You can unpack tuples into variables
a, b, c = (1, 2, 3)  # => (1,2,3)  
a  # => 1
b  # => 2
c  # => 3

# Tuples are created even if you leave out the parentheses
d, e, f = 4, 5, 6  # => (4,5,6)
d  # => 4
e  # => 5
f  # => 6

# A 1-element tuple is distinct from the value it contains
(1,) == 1 # => false
(1) == 1  # => true

# Look how easy it is to swap two values
e, d = d, e  # => (5,4) 
d  # => 5
e  # => 4

# Dictionaries store mappings
emptyDict = Dict()  # => Dict{Any,Any} with 0 entries

# You can create a dictionary using a literal
filledDict = Dict(""one"" => 1, ""two"" => 2, ""three"" => 3)
# => Dict{String,Int64} with 3 entries:
# =>  ""two"" => 2, ""one"" => 1, ""three"" => 3

# Look up values with []
filledDict[""one""]  # => 1

# Get all keys
keys(filledDict)
# => Base.KeySet for a Dict{String,Int64} with 3 entries. Keys:
# =>  ""two"", ""one"", ""three""
# Note - dictionary keys are not sorted or in the order you inserted them.

# Get all values
values(filledDict)
# => Base.ValueIterator for a Dict{String,Int64} with 3 entries. Values: 
# =>  2, 1, 3
# Note - Same as above regarding key ordering.

# Check for existence of keys in a dictionary with in, haskey
in((""one"" => 1), filledDict)  # => true
in((""two"" => 3), filledDict)  # => false
haskey(filledDict, ""one"")     # => true
haskey(filledDict, 1)         # => false

# Trying to look up a non-existent key will raise an error
try
    filledDict[""four""]  # => ERROR: KeyError: key ""four"" not found
catch e
    println(e)
end

# Use the get method to avoid that error by providing a default value
# get(dictionary, key, defaultValue)
get(filledDict, ""one"", 4)   # => 1
get(filledDict, ""four"", 4)  # => 4

# Use Sets to represent collections of unordered, unique values
emptySet = Set()  # => Set(Any[])
# Initialize a set with values
filledSet = Set([1, 2, 2, 3, 4])  # => Set([4, 2, 3, 1])

# Add more values to a set
push!(filledSet, 5)  # => Set([4, 2, 3, 5, 1])

# Check if the values are in the set
in(2, filledSet)   # => true
in(10, filledSet)  # => false

# There are functions for set intersection, union, and difference.
otherSet = Set([3, 4, 5, 6])         # => Set([4, 3, 5, 6])
intersect(filledSet, otherSet)      # => Set([4, 3, 5])
union(filledSet, otherSet)          # => Set([4, 2, 3, 5, 6, 1])
setdiff(Set([1,2,3,4]), Set([2,3,5])) # => Set([4, 1])

# Assignment with `=` attaches a new label to the same value without copying
a = [1, 2, 3]
b = a
# Now `b` and `a` point to the same value, so changing one affects the other:
a[3] = 5
b[3]  # => 5

# The `copy()` function can create a shallow copy of an array, dictionary,
# or other container
a = [1, 2, 3]
c = copy(a)
a[3] = 5
c[3] # => 3

####################################################
## 3. Control Flow
####################################################

# Let's make a variable
someVar = 5

# Here is an if statement. Indentation is not meaningful in Julia.
if someVar > 10
    println(""someVar is totally bigger than 10."")
elseif someVar < 10    # This elseif clause is optional.
    println(""someVar is smaller than 10."")
else                    # The else clause is optional too.
    println(""someVar is indeed 10."")
end
# => prints ""some var is smaller than 10""

# For loops iterate over iterables.
# Iterable types include Range, Array, Set, Dict, and AbstractString.
for animal = [""dog"", ""cat"", ""mouse""]
    println(""$animal is a mammal"")
    # You can use $ to interpolate variables or expression into strings.
    # In this special case, no need for parenthesis: $animal and $(animal) give the same
end
# => dog is a mammal
# => cat is a mammal
# => mouse is a mammal

# You can use 'in' instead of '='.
for animal in [""dog"", ""cat"", ""mouse""]
    println(""$animal is a mammal"")
end
# => dog is a mammal
# => cat is a mammal
# => mouse is a mammal

for pair in Dict(""dog"" => ""mammal"", ""cat"" => ""mammal"", ""mouse"" => ""mammal"")
    from, to = pair
    println(""$from is a $to"")
end
# => mouse is a mammal
# => cat is a mammal
# => dog is a mammal

for (k, v) in Dict(""dog"" => ""mammal"", ""cat"" => ""mammal"", ""mouse"" => ""mammal"")
    println(""$k is a $v"")
end
# => mouse is a mammal
# => cat is a mammal
# => dog is a mammal

# While loops loop while a condition is true
let x = 0
    while x < 4
        println(x)
        x += 1  # Shorthand for in place increment: x = x + 1
    end
end
# => 0
# => 1
# => 2
# => 3

# Handle exceptions with a try/catch block
try
    error(""help"")
catch e
    println(""caught it $e"")
end
# => caught it ErrorException(""help"")

####################################################
## 4. Functions
####################################################

# The keyword 'function' creates new functions
# function name(arglist)
#   body...
# end
function add(x, y)
    println(""x is $x and y is $y"")

    # Functions return the value of their last statement
    x + y
end

add(5, 6)
# => x is 5 and y is 6
# => 11

# Compact assignment of functions
f_add(x, y) = x + y  # => f_add (generic function with 1 method)
f_add(3, 4)  # => 7

# Function can also return multiple values as tuple
fn(x, y) = x + y, x - y # => fn (generic function with 1 method)
fn(3, 4)  # => (7, -1)

# You can define functions that take a variable number of
# positional arguments
function varargs(args...)
    return args
    # use the keyword return to return anywhere in the function
end
# => varargs (generic function with 1 method)

varargs(1, 2, 3)  # => (1,2,3)

# The ... is called a splat.
# We just used it in a function definition.
# It can also be used in a function call,
# where it will splat an Array or Tuple's contents into the argument list.
add([5,6]...)  # this is equivalent to add(5,6)

x = (5, 6)  # => (5,6)
add(x...)  # this is equivalent to add(5,6)


# You can define functions with optional positional arguments
function defaults(a, b, x=5, y=6)
    return ""$a $b and $x $y""
end
# => defaults (generic function with 3 methods)

defaults('h', 'g')  # => ""h g and 5 6""
defaults('h', 'g', 'j')  # => ""h g and j 6""
defaults('h', 'g', 'j', 'k')  # => ""h g and j k""
try
    defaults('h')  # => ERROR: MethodError: no method matching defaults(::Char)
    defaults()  # => ERROR: MethodError: no method matching defaults()
catch e
    println(e)
end

# You can define functions that take keyword arguments
function keyword_args(;k1=4, name2=""hello"")  # note the ;
    return Dict(""k1"" => k1, ""name2"" => name2)
end
# => keyword_args (generic function with 1 method)

keyword_args(name2=""ness"")  # => [""name2""=>""ness"", ""k1""=>4]
keyword_args(k1=""mine"")     # => [""name2""=>""hello"", ""k1""=>""mine""]
keyword_args()              # => [""name2""=>""hello"", ""k1""=>4]

# You can combine all kinds of arguments in the same function
function all_the_args(normalArg, optionalPositionalArg=2; keywordArg=""foo"")
    println(""normal arg: $normalArg"")
    println(""optional arg: $optionalPositionalArg"")
    println(""keyword arg: $keywordArg"")
end
# => all_the_args (generic function with 2 methods)

all_the_args(1, 3, keywordArg=4)
# => normal arg: 1
# => optional arg: 3
# => keyword arg: 4

# Julia has first class functions
function create_adder(x)
    adder = function (y)
        return x + y
    end
    return adder
end
# => create_adder (generic function with 1 method)

# This is ""stabby lambda syntax"" for creating anonymous functions
(x -> x > 2)(3)  # => true

# This function is identical to create_adder implementation above.
function create_adder(x)
    y -> x + y
end
# => create_adder (generic function with 1 method)

# You can also name the internal function, if you want
function create_adder(x)
    function adder(y)
        x + y
    end
    adder
end
# => create_adder (generic function with 1 method)

add_10 = create_adder(10) # => (::getfield(Main, Symbol(""#adder#11"")){Int64}) 
                          # (generic function with 1 method)
add_10(3) # => 13


# There are built-in higher order functions
map(add_10, [1,2,3])  # => [11, 12, 13]
filter(x -> x > 5, [3, 4, 5, 6, 7])  # => [6, 7]

# We can use list comprehensions
[add_10(i) for i = [1, 2, 3]]   # => [11, 12, 13]
[add_10(i) for i in [1, 2, 3]]  # => [11, 12, 13]
[x for x in [3, 4, 5, 6, 7] if x > 5] # => [6, 7]

####################################################
## 5. Types
####################################################

# Julia has a type system.
# Every value has a type; variables do not have types themselves.
# You can use the `typeof` function to get the type of a value.
typeof(5)  # => Int64

# Types are first-class values
typeof(Int64)     # => DataType
typeof(DataType)  # => DataType
# DataType is the type that represents types, including itself.

# Types are used for documentation, optimizations, and dispatch.
# They are not statically checked.

# Users can define types
# They are like records or structs in other languages.
# New types are defined using the `struct` keyword.

# struct Name
#   field::OptionalType
#   ...
# end
struct Tiger
    taillength::Float64
    coatcolor  # not including a type annotation is the same as `::Any`
end

# The default constructor's arguments are the properties
# of the type, in the order they are listed in the definition
tigger = Tiger(3.5, ""orange"")  # => Tiger(3.5,""orange"")

# The type doubles as the constructor function for values of that type
sherekhan = typeof(tigger)(5.6, ""fire"")  # => Tiger(5.6,""fire"")

# These struct-style types are called concrete types
# They can be instantiated, but cannot have subtypes.
# The other kind of types is abstract types.

# abstract Name
abstract type Cat end  # just a name and point in the type hierarchy

# Abstract types cannot be instantiated, but can have subtypes.
# For example, Number is an abstract type
subtypes(Number)  # => 2-element Array{Any,1}:
                  # =>  Complex
                  # =>  Real
subtypes(Cat)  # => 0-element Array{Any,1}

# AbstractString, as the name implies, is also an abstract type
subtypes(AbstractString)  # => 4-element Array{Any,1}:
                          # =>  String
                          # =>  SubString
                          # =>  SubstitutionString
                          # =>  Test.GenericString

# Every type has a super type; use the `supertype` function to get it.
typeof(5) # => Int64
supertype(Int64)    # => Signed
supertype(Signed)   # => Integer
supertype(Integer)  # => Real
supertype(Real)     # => Number
supertype(Number)   # => Any
supertype(supertype(Signed))  # => Real
supertype(Any)      # => Any
# All of these type, except for Int64, are abstract.
typeof(""fire"")      # => String
supertype(String)   # => AbstractString
# Likewise here with String
supertype(SubString)  # => AbstractString

# <: is the subtyping operator
struct Lion <: Cat  # Lion is a subtype of Cat
    maneColor
    roar::AbstractString
end

# You can define more constructors for your type
# Just define a function of the same name as the type
# and call an existing constructor to get a value of the correct type
Lion(roar::AbstractString) = Lion(""green"", roar)
# This is an outer constructor because it's outside the type definition

struct Panther <: Cat  # Panther is also a subtype of Cat
    eyeColor
    Panther() = new(""green"")
    # Panthers will only have this constructor, and no default constructor.
end
# Using inner constructors, like Panther does, gives you control
# over how values of the type can be created.
# When possible, you should use outer constructors rather than inner ones.

####################################################
## 6. Multiple-Dispatch
####################################################

# In Julia, all named functions are generic functions
# This means that they are built up from many small methods
# Each constructor for Lion is a method of the generic function Lion.

# For a non-constructor example, let's make a function meow:

# Definitions for Lion, Panther, Tiger
function meow(animal::Lion)
    animal.roar  # access type properties using dot notation
end

function meow(animal::Panther)
    ""grrr""
end

function meow(animal::Tiger)
    ""rawwwr""
end

# Testing the meow function
meow(tigger)  # => ""rawwwr""
meow(Lion(""brown"", ""ROAAR""))  # => ""ROAAR""
meow(Panther()) # => ""grrr""

# Review the local type hierarchy
Tiger   <: Cat  # => false
Lion    <: Cat  # => true
Panther <: Cat  # => true

# Defining a function that takes Cats
function pet_cat(cat::Cat)
    println(""The cat says $(meow(cat))"")
end
# => pet_cat (generic function with 1 method)

pet_cat(Lion(""42"")) # => The cat says 42
try
    pet_cat(tigger) # => ERROR: MethodError: no method matching pet_cat(::Tiger)
catch e
    println(e)
end

# In OO languages, single dispatch is common;
# this means that the method is picked based on the type of the first argument.
# In Julia, all of the argument types contribute to selecting the best method.

# Let's define a function with more arguments, so we can see the difference
function fight(t::Tiger, c::Cat)
    println(""The $(t.coatcolor) tiger wins!"")
end
# => fight (generic function with 1 method)

fight(tigger, Panther())  # => The orange tiger wins!
fight(tigger, Lion(""ROAR"")) # => The orange tiger wins!

# Let's change the behavior when the Cat is specifically a Lion
fight(t::Tiger, l::Lion) = println(""The $(l.maneColor)-maned lion wins!"")
# => fight (generic function with 2 methods)

fight(tigger, Panther())  # => The orange tiger wins!
fight(tigger, Lion(""ROAR"")) # => The green-maned lion wins!

# We don't need a Tiger in order to fight
fight(l::Lion, c::Cat) = println(""The victorious cat says $(meow(c))"")
# => fight (generic function with 3 methods)

fight(Lion(""balooga!""), Panther())  # => The victorious cat says grrr
try
    fight(Panther(), Lion(""RAWR""))  
    # => ERROR: MethodError: no method matching fight(::Panther, ::Lion)
    # => Closest candidates are:
    # =>   fight(::Tiger, ::Lion) at ...
    # =>   fight(::Tiger, ::Cat) at ...
    # =>   fight(::Lion, ::Cat) at ...
    # => ...
catch e
    println(e)
end

# Also let the cat go first
fight(c::Cat, l::Lion) = println(""The cat beats the Lion"")
# => fight (generic function with 4 methods)

# This warning is because it's unclear which fight will be called in:
try
    fight(Lion(""RAR""), Lion(""brown"", ""rarrr""))
    # => ERROR: MethodError: fight(::Lion, ::Lion) is ambiguous. Candidates:
    # =>   fight(c::Cat, l::Lion) in Main at ...
    # =>   fight(l::Lion, c::Cat) in Main at ...
    # => Possible fix, define
    # =>   fight(::Lion, ::Lion)
    # => ...
catch e
    println(e)
end
# The result may be different in other versions of Julia

fight(l::Lion, l2::Lion) = println(""The lions come to a tie"") 
# => fight (generic function with 5 methods)
fight(Lion(""RAR""), Lion(""brown"", ""rarrr""))  # => The lions come to a tie


# Under the hood
# You can take a look at the llvm  and the assembly code generated.

square_area(l) = l * l  # square_area (generic function with 1 method)

square_area(5)  # => 25

# What happens when we feed square_area an integer?
code_native(square_area, (Int32,), syntax = :intel)
	#         .text
	# ; Function square_area {
	# ; Location: REPL[116]:1       # Prologue
	#         push    rbp
	#         mov     rbp, rsp
	# ; Function *; {
	# ; Location: int.jl:54
	#         imul    ecx, ecx      # Square l and store the result in ECX
	# ;}
	#         mov     eax, ecx
	#         pop     rbp           # Restore old base pointer
	#         ret                   # Result will still be in EAX
	#         nop     dword ptr [rax + rax]
	# ;}

code_native(square_area, (Float32,), syntax = :intel)
    #         .text
    # ; Function square_area {
    # ; Location: REPL[116]:1
    #         push    rbp
    #         mov     rbp, rsp
    # ; Function *; {
    # ; Location: float.jl:398
    #         vmulss  xmm0, xmm0, xmm0  # Scalar single precision multiply (AVX)
    # ;}
    #         pop     rbp
    #         ret
    #         nop     word ptr [rax + rax]
    # ;}

code_native(square_area, (Float64,), syntax = :intel)
    #         .text
    # ; Function square_area {
    # ; Location: REPL[116]:1
    #         push    rbp
    #         mov     rbp, rsp
    # ; Function *; {
    # ; Location: float.jl:399
    #         vmulsd  xmm0, xmm0, xmm0  # Scalar double precision multiply (AVX)
    # ;}
    #         pop     rbp
    #         ret
    #         nop     word ptr [rax + rax]
    # ;}

# Note that julia will use floating point instructions if any of the
# arguments are floats.
# Let's calculate the area of a circle
circle_area(r) = pi * r * r     # circle_area (generic function with 1 method)
circle_area(5)  # 78.53981633974483

code_native(circle_area, (Int32,), syntax = :intel)
    #         .text
    # ; Function circle_area {
    # ; Location: REPL[121]:1
    #         push    rbp
    #         mov     rbp, rsp
    # ; Function *; {
    # ; Location: operators.jl:502
    # ; Function *; {
    # ; Location: promotion.jl:314
    # ; Function promote; {
    # ; Location: promotion.jl:284
    # ; Function _promote; {
    # ; Location: promotion.jl:261
    # ; Function convert; {
    # ; Location: number.jl:7
    # ; Function Type; {
    # ; Location: float.jl:60
    #         vcvtsi2sd       xmm0, xmm0, ecx     # Load integer (r) from memory
    #         movabs  rax, 497710928              # Load pi
    # ;}}}}}
    # ; Function *; {
    # ; Location: float.jl:399
    #         vmulsd  xmm1, xmm0, qword ptr [rax] # pi * r
    #         vmulsd  xmm0, xmm1, xmm0            # (pi * r) * r
    # ;}}
    #         pop     rbp
    #         ret
    #         nop     dword ptr [rax]
    # ;}

code_native(circle_area, (Float64,), syntax = :intel)
    #         .text
    # ; Function circle_area {
    # ; Location: REPL[121]:1
    #         push    rbp
    #         mov     rbp, rsp
    #         movabs  rax, 497711048
    # ; Function *; {
    # ; Location: operators.jl:502
    # ; Function *; {
    # ; Location: promotion.jl:314
    # ; Function *; {
    # ; Location: float.jl:399
    #         vmulsd  xmm1, xmm0, qword ptr [rax]
    # ;}}}
    # ; Function *; {
    # ; Location: float.jl:399
    #         vmulsd  xmm0, xmm1, xmm0
    # ;}
    #         pop     rbp
    #         ret
    #         nop     dword ptr [rax + rax]
    # ;}
```

## Further Reading

You can get a lot more detail from the [Julia Documentation](https://docs.julialang.org/)

The best place to get help with Julia is the (very friendly) [Discourse forum](https://discourse.julialang.org/)."
"`jq` is a tool for transforming JSON inputs and generating JSON outputs. As a
programming language, jq supports boolean and arithmetic expressions, object
and array indexing; it has conditionals, functions, and even exception
handling... etc.  Knowing jq enables you to easily write small programs that
can perform complex queries on JSON documents to find answers, make reports, or
to produce another JSON document for further processing by other programs.

> **NOTE**: This guide demonstrates the use of jq from the command line,
> specifically, under an environment running the Bash shell.

```bash
# When running jq from the command line, jq program code can be specified as the
# first argument after any options to `jq`. We often quote such jq program with
# single quotes (`'`) to prevent any special interpretation from the command line
# shell.
#
jq -n '# Comments start with # until the end of line.
       # The -n option sets the input to the value, `null`, and prevents `jq`
       # from reading inputs from external sources.
'

# Output:
# null


# By default jq reads from *STDIN* a stream of JSON inputs (values). It
# processes each input with the jq program (filters) specified at the command
# line, and prints the outputs of processing each input with the program to
# *STDOUT*.
#
echo '
  ""hello"" 123 [
    ""one"",
    ""two"",
    ""three""
  ]
  { ""name"": ""jq"" }
' |
 jq '.  # <-- the jq program here is the single dot (.), called the identity
        # operator, which stands for the current input.
'

# Output:
# ""hello""
# 123
# [
#   ""one"",
#   ""two"",
#   ""three""
# ]
# {
#   ""name"": ""jq""
# }


# Notice that jq pretty-prints the outputs by default, therefore, piping
# to `jq` is a simple way to format a response from some REST API endpoint
# that returns JSON. E.g., `curl -s https://freegeoip.app/json/ | jq`


# Instead of processing each JSON input with a jq program, you can also
# ask jq to slurp them up as an array.
#
echo '1 ""two"" 3' | jq -s .

# Output:
# [
#   1,
#   ""two"",
#   3
# ]


# Or, treat each line as a string.
#
(echo line 1; echo line 2) | jq -R .

# Output:
# ""line 1""
# ""line 2""


# Or, combine -s and -R to slurp the input lines into a single string.
#
(echo line 1; echo line 2) | jq -sR .

# Output:
# ""line 1\nline2\n""


# Inputs can also come from a JSON file specified at the command line:
#
echo '""hello""' > hello.json
jq . hello.json

# Output:
# ""hello""


# Passing a value into a jq program can be done with the `--arg` option.
# Below, `val` is the variable name to bind the value, `123`, to.
# The variable is then referenced as `$val`.
#
jq -n --arg val 123 '$val'  # $val is the string ""123"" here

# Output:
# ""123""


# If you need to pass a JSON value, use `--argjson`
#
jq -n --argjson val 123 '$val'  # $val is a number

# Output:
# 123


# Using `--arg` or `--argjson` is an useful way of building JSON output from
# existing input.
#
jq --arg text ""$(date; echo ""Have a nice day!"")"" -n '{ ""today"": $text }'

# Output:
# {
#   ""today"": ""Sun Apr 10 09:53:07 PM EDT 2022\nHave a nice day!""
# }


# Instead of outputting values as JSON, you can use the `-r` option to print
# string values unquoted / unescaped. Non-string values are still printed as
# JSON.
#
echo '""hello"" 2 [1, ""two"", null] {}' | jq -r .

# Output:
# hello
# 2
# [
#   1,
#   ""two"",
#   null
# ]
# {}


# Inside a string in jq, `\(expr)` can be used to substitute the output of
# `expr` into the surrounding string context.
#
jq -rn '""1 + 2 = \(1+2)""'

# Output:
# 1 + 2 = 3


# The `-r` option is most useful for generating text outputs to be processed
# down in a shell pipeline, especially when combined with an intepolated
# string that is prefixed the `@sh` prefix operator.
#
# The `@sh` operator escapes the outputs of `\(...)` inside a string with
# single quotes so that each resulting string of `\(...)` can be evaluated
# by the shell as a single word / token / argument without special
# interpretations.
#
env_vars=$(
    echo '{""var1"": ""value one"", ""var2"": ""value\ntwo""}' \
     |
    jq -r '
      ""export "" + @sh ""var1=\(.var1) var2=\(.var2)""
      #                     ^^^^^^^^      ^^^^^^^^
      #                  ""'value one'""  ""'value\ntwo'""
      #
      # NOTE: The + (plus) operator here concatenates strings.
    '
)
echo ""$env_vars""
eval ""$env_vars""
declare -p var1 var2

# Output:
# export var1='value one' var2='value
# two'
# declare -- var1=""value one""
# declare -- var2=""value
# two""

# There are other string `@prefix` operators (e.g., @base64, @uri, @csv, ...)
# that might be useful to you. See `man jq` for details.


# The comma (`,`) operator in jq evaluates each operand and generates multiple
# outputs:
#
jq -n '""one"", 2, [""three""], {""four"": 4}'

# Output:
# ""one""
# 2
# [
#   ""three""
# ]
# {
#   ""four"": 4
# }


# Any JSON value is a valid jq expression that evaluates to the JSON value
# itself.
#
jq -n '1, ""one"", [1, 2], {""one"": 1}, null, true, false'

# Output:
# 1
# ""one""
# [
#   1,
#   2
# ]
# {
#   ""one"": 1
# }
# null
# true
# false


# Any jq expression can be used where a JSON value is expected, even as object
# keys. (though parenthesis might be required for object keys or values)
#
jq -n '[2*3, 8-1, 16/2], {(""tw"" + ""o""): (1 + 1)}'

# Output:
# [
#   6,
#   7,
#   8
# ]
# {
#   ""two"": 2
# }


# As a shortcut, if a JSON object key looks like a valid identifier (matching
# the regex `^[a-zA-Z_][a-zA-Z_0-9]*$`), quotes can be omitted.
#
jq -n '{ key_1: ""value1"" }'

# If a JSON object's key's value is ommited, it is looked up in the current
# input using the key: (see next example for the meaning of `... | ...`)
#
jq -n '{c: 3} | {a: 1, ""b"", c}'

# Output:
# {
#   ""a"": 1,
#   ""b"": null,
#   ""c"": 3
# }


# jq programs are more commonly written as a series of expressions (filters)
# connected by the pipe (`|`) operator, which makes the output of its left
# filter the input to its right filter.
#
jq -n '1 | . + 2 | . + 3'  # first dot is 1; second dot is 3

# Output:
# 6

# If an expression evaluates to multiple outputs, then jq will iterate through
# them and propagate each output down the pipeline, and generate multiple
# outputs in the end.
#
jq -n '1, 2, 3 | ., 4 | .'

# Output:
# 1
# 4
# 2
# 4
# 3
# 4

# The flows of the data in the last example can be visualized like this:
# (number prefixed with `*` indicates the current output)
#
# *1,  2,  3 | *1,  4 | *1
#  1,  2,  3 |  1, *4 | *4
#  1, *2,  3 | *2,  4 | *2
#  1,  2,  3 |  2, *4 | *4
#  1,  2, *3 | *3,  4 | *3
#  1,  2,  3 |  3, *4 | *4
#
#
# To put it another way, the evaluation of the above example is very similar
# to the following pieces of code in other programming languages:
#
# In Python:
#
#   for first_dot in 1, 2, 3:
#       for second_dot in first_dot, 4:
#           print(second_dot)
#
# In Ruby:
#
#   [1, 2, 3].each do |dot|
#     [dot, 4].each { |dot| puts dot }
#   end
#
# In Javascript:
#
#   [1, 2, 3].forEach(dot => {
#       [dot, 4].forEach(dot => console.log(dot))
#   })
#


# Below are some examples of array index and object attribute lookups using
# the `[expr]` operator after an expression. If `expr` is a number then it's
# an array index lookup; otherwise, it should be a string, in which case it's
# an object attribute lookup:

# Array index lookup
#
jq -n '[2, {""four"": 4}, 6][1 - 1]' # => 2
jq -n '[2, {""four"": 4}, 6][0]'     # => 2
jq -n '[2, {""four"": 4}, 6] | .[0]' # => 2

# You can chain the lookups since they are just expressions.
#
jq -n '[2, {""four"": 4}, 6][1][""fo"" + ""ur""]' # => 4

# For object attributes, you can also use the `.key` shortcut.
#
jq -n '[2, {""four"": 4}, 6][1].four'  # => 4

# Use `.""key""` if the key is not a valid identifier.
#
jq -n '[2, {""f o u r"": 4}, 6][1].""f o u r""' # => 4

# Array index lookup returns null if the index is not found.
#
jq -n '[2, {""four"": 4}, 6][99]' # => null

# Object attribute lookup returns null if the key is not found.
#
jq -n '[2, {""four"": 4}, 6][1].whatever' # => null

# The alternative operator `//` can be used to provide a default
# value when the result of the left operand is either `null` or `false`.
#
jq -n '.unknown_key // 7' # => 7

# If the thing before the lookup operator (`[expr]`) is neither an array
# or an object, then you will get an error:
#
jq -n '123 | .[0]'     # => jq: error (at <unknown>): Cannot index number with number
jq -n '""abc"" | .name'  # => jq: error (at <unknown>): Cannot index string with string ""name""
jq -n '{""a"": 97} | .[0]'    # => jq: error (at <unknown>): Cannot index object with number
jq -n '[89, 64] | .[""key""]' # => jq: error (at <unknown>): Cannot index array with string ""key""

# You can, however, append a `?` to a lookup to make jq return `empty`
# instead when such error happens.
#
jq -n '123 | .[0]?'    # no output since it's empty.
jq -n '""abc"" | .name?' # no output since it's empty.

# The alternative operator (`//`) also works with `empty`:
#
jq -n '123 | .[0]? // 99'           # => 99
jq -n '""abc"" | .name? // ""unknown""' # => ""unknown""

# NOTE: `empty` is actually a built-in function in jq.
# With the nested loop explanation we illustrated earlier before,
# `empty` is like the `continue` or the `next` keyword that skips
# the current iteration of the loop in some programming languages.


# Strings and arrays can be sliced with the same syntax (`[i:j]`, but no
# steppings) and semantic as found in the Python programming language:
#
#                0   1    2    3    4   5 ... infinite
#        array = [""a"", ""b"", ""c"", ""d""]
# -infinite ... -4  -3   -2   -1
#
jq -n '[""Peter"", ""Jerry""][1]'            # => ""Jerry""
jq -n '[""Peter"", ""Jerry""][-1]'           # => ""Jerry""
jq -n '[""Peter"", ""Jerry"", ""Tom""][1:]'    # => [""Jerry"", ""Tom""]
jq -n '[""Peter"", ""Jerry"", ""Tom""][:1+1]'  # => [""Peter"", ""Jerry""]
jq -n '[""Peter"", ""Jerry"", ""Tom""][1:99]'  # => [""Jerry"", ""Tom""]


# If the lookup index or key is ommited then jq iterates through
# the collection, generating one output value from each iteration.
#
# These examples produce the same outputs.
#
echo 1 2 3 | jq .
jq -n '1, 2, 3'
jq -n '[1, 2, 3][]'
jq -n '{a: 1, b: 2, c: 3}[]'

# Output:
# 1
# 2
# 3


# You can build an array out of multiple outputs.
#
jq -n '{values: [{a: 1, b: 2, c: 3}[] | . * 2]}'

# Output:
# {
#   ""values"": [
#     2,
#     4,
#     6
#   ]
# }


# If multiple outputs are not contained, then we'd get multiple outputs
# in the end.
#
jq -n '{values: ({a: 1, b: 2, c: 3}[] | . * 2)}'

# Output:
# {
#   ""values"": 2
# }
# {
#   ""values"": 4
# }
# {
#   ""values"": 6
# }


# Conditional `if ... then ... else ... end` in jq is an expression, so
# both the `then` part and the `else` part are required. In jq, only
# two values, `null` and `false`, are false; all other values are true.
#
jq -n 'if 1 > 2 | not and 1 <= 2 then ""Makes sense"" else ""WAT?!"" end'

# Output
# ""Makes sense""

# Notice that `not` is a built-in function that takes zero arguments,
# that's why it's used as a filter to negate its input value.
# We'll talk about functions soon.

# Another example using a conditional:
#
jq -n '1, 2, 3, 4, 5 | if . % 2 != 0 then . else empty end'

# Output
# 1
# 3
# 5

# The `empty` above is a built-in function that takes 0 arguments and
# generates no outputs. Let's see more examples of built-in functions.

# The above conditional example can be written using the `select/1` built-in
# function (`/1` indicates the number of arguments expected by the function).
#
jq -n '1, 2, 3, 4, 5 | select(. % 2 != 0)'  # NOTE: % gives the remainder.

# Output
# 1
# 3
# 5


# Function arguments in jq are passed with call-by-name semantic, which
# means, an argument is not evaulated at call site, but instead, is
# treated as a lambda expression with the calling context of the call
# site as its scope for variable and function references used in the
# expression.
#
# In the above example, the expression `. % 2 != 0` is what's passed to
# `select/1` as the argument, not `true` or `false`, which is what would
# have been the case had the (boolean) expression was evaluated before it's
# passed to the function.


# The `range/1`, `range/2`, and `range/3` built-in functions generate
# integers within a given range.
#
jq -n '[range(3)]'         # => [0, 1, 2]
jq -n '[range(0; 4)]'      # => [0, 1, 2, 3]
jq -n '[range(2; 10; 2)]'  # => [2, 4, 6, 8]

# Notice that `;` (semicolon) is used to separate function arguments.


# The `map/1` function applies a given expression to each element of
# the current input (array) and outputs a new array.
#
jq -n '[range(1; 6) | select(. % 2 != 0)] | map(. * 2)'

# Output:
# [
#   2,
#   6,
#   10
# ]

# Without using `select/1` and `map/1`, we could have also written the
# above example like this:
#
jq -n '[range(1; 6) | if . % 2 != 0 then . else empty end | . * 2]'


# `keys/0` returns an array of keys of the current input. For an object,
# these are the object's attribute names; for an array, these are the
# array indices.
#
jq -n '[range(2; 10; 2)] | keys'   # => [0, 1, 2, 3]
jq -n '{a: 1, b: 2, c: 3} | keys'  # => [""a"", ""b"", ""c""]

# `values/0` returns an array of values of the current input. For an object,
# these are the object's attribute values; for an array, these are the
# elements of the array.
#
jq -n '[range(2; 10; 2)] | values'   # => [2, 4, 6, 8]
jq -n '{a: 1, b: 2, c: 3} | values'  # => [1, 2, 3]


# `to_entries/0` returns an array of key-value objects of the current input
# object.
#
jq -n '{a: 1, b: 2, c: 3} | to_entries'

# Output:
# [
#   {
#     ""key"": ""a"",
#     ""value"": 1
#   },
#   {
#     ""key"": ""b"",
#     ""value"": 2
#   },
#   {
#     ""key"": ""c"",
#     ""value"": 3
#   }
# ]


# Here's how you can turn an object's attribute into environment variables
# using what we have learned so far.
#
env_vars=$(
    jq -rn '{var1: ""1 2  3   4"", var2: ""line1\nline2\n""}
            | to_entries[]
            | ""export "" + @sh ""\(.key)=\(.value)""
           '
)
eval ""$env_vars""
declare -p var1 var2

# Output:
# declare -x var1=""1 2  3   4""
# declare -x var2=""line1
# line2
# ""


# `from_entries/0` is the opposite of `to_entries/0` in that it takes an
# an array of key-value objects and turn that into an object with keys
# and values from the `key` and `value` attributes of the objects.
#
# It's useful together with `to_entries/0` when you need to iterate and
# do something to each attribute of an object.
#
jq -n '{a: 1, b: 2, c: 3} | to_entries | map(.value *= 2) | from_entries'

# Output:
# {
#   ""a"": 2,
#   ""b"": 4,
#   ""c"": 6
# }


# The example above can be further shortened with the  `with_entries/1` built-in:
#
jq -n '{a: 1, b: 2, c: 3} | with_entries(.value *= 2)'


# The `group_by/1` generates an array of groups (arrays) from the current
# input (array). The classification is done by applying the expression argument
# to each member of the input array.
#
# Let's look at a contrived example (Note that `tostring`, `tonumber`,
# `length` and `max` are all built-in jq functions. Feel free to look
# them up in the jq manual):
#
# Generate some random numbers.
numbers=$(echo $RANDOM{,,,,,,,,,,,,,,,,,,,,})
#
# Feed the numbers to jq, classifying them into groups and calculating their
# averages, and finally generate a report.
#
echo $numbers | jq -rs '  # Slurp the numbers into an array.
[
  [ map(tostring)          # Turn it into an array of strings.
    | group_by(.[0:1])     # Group the numbers by their first digits.
    | .[]                  # Iterate through the array of arrays (groups).
    | map(tonumber)        # Turn each group back to an array of numbers.
  ] # Finally, contain all groups in an array.

  | sort_by([length, max]) # Sort the groups by their sizes.
    # If two groups have the same size then the one with the largest
    # number wins (is bigger).

  | to_entries[]           # Enumerate the array, generating key-value objects.
  |                        # For each object, generate two lines:
  ""Group \(.key): \(.value | sort | join("" ""))""   + ""\n"" +
  ""Average: \(      .value | (add / length)  )""

] # Contain the group+average lines in an array.
  # Join the array elements by separator lines (dashes) to produce the report.
| join(""\n"" + ""-""*78 + ""\n"")
'

# Output:
#
# Group 0: 3267
# Average: 3267
# ------------------------------------------------------------------------------
# Group 1: 7854
# Average: 7854
# ------------------------------------------------------------------------------
# Group 2: 4415 4447
# Average: 4431
# ------------------------------------------------------------------------------
# Group 3: 681 6426
# Average: 3553.5
# ------------------------------------------------------------------------------
# Group 4: 21263 21361 21801 21832 22947 23523 29174
# Average: 23128.714285714286
# ------------------------------------------------------------------------------
# Group 5: 10373 12698 13132 13924 17444 17963 18934 18979
# Average: 15430.875


# The `add/1` built-in ""reduces"" an array of values to a single value.
# You can think of it as sticking the `+` operator in between each value of
# the collection. Here are some examples:
#
jq -n '[1, 2, 3, 4, 5] | add'  # => 15
jq -n '[""a"", ""b"", ""c""] | add'  # => ""abc""

# `+` concatenates arrays
jq -n '[[""a""], [""b""], [""c""]] | add'

# Output:
# [
#   ""a"",
#   ""b"",
#   ""c""
# ]

# `+` merges objects non-recursively.
jq -n '[{a: 1, b: {c: 3}}, {b: 2, c: 4}] | add'

# Output:
# {
#   ""a"": 1,
#   ""b"": 2,
#   ""c"": 4
# }


# jq provides a special syntax for writing an expression that reduces
# the outputs generated by a given expresion to a single value.
# It has this form:
#
#   reduce outputs_expr as $var (initial_value; reduction_expr)
#
# Examples:
#
jq -n 'reduce range(1; 6) as $i (0; . + $i)'             # => 15
jq -n 'reduce (1, 2, 3, 4, 5) as $i (0; . + $i)'         # => 15
jq -n '[1, 2, 3, 4, 5] | reduce .[] as $i (0; . + $i)'   # => 15
jq -n '[""a"", ""b"", ""c""] | reduce .[] as $i (""""; . + $i)'  # => ""abc""

# Notice the `.` in the `reduction_expr` is the `initial_value` at first,
# and then it becomes the result of applying the `reduction_expr` as
# we iterate through the values of `outputs_expr`. The expression:
#
#    reduce (1, 2, 3, 4, 5) as $i (0; . + $i)
#
# can be thought of as doing:
#
#    0 + 1 | . + 2 | . + 3 | . + 4 | . + 5
#


# The `*` operator when used on two objects, merges both recursively.
# Therefore, to merge JSON objects recursively, you can use `reduce`
# with the `*` operator. For example:
#
echo '
  {""a"": 1,  ""b"": {""c"": 3}}
  {         ""b"": {""d"": 4}}
  {""a"": 99, ""e"": 5       }
' | jq -s 'reduce .[] as $m ({}; . * $m)'

# Output:
# {
#   ""a"": 99,
#   ""b"": {
#     ""c"": 3,
#     ""d"": 4
#   },
#   ""e"": 5
# }


# jq has variable assignment in the form of `expr as $var`, which binds
# the value of `expr` to `$var`, and `$var` is immutable. Further more,
# `... as ...` doesn't change the input of the next filter; its introduction
# in a filter pipeline is only for establishing the binding of a value to a
# variable, and its scope extends to the filters following its definition.
# (i.e., to look up a variable's definition, scan to the left of the filter
# chain from the expression using it until you find the definition)
#
jq -rn '[1, 2, 3, 4, 5]
        | (.[0] + .[-1])      as $sum     # Always put ( ) around the binding `expr` to avoid surprises.
        | ($sum * length / 2) as $result  # The current input at this step is still the initial array.
        | ""The result is: \($result)""     # Same.
'

# Output:
# The result is: 15


# With the `expr as $var` form, if multiple values are generated by `expr`
# then jq will iterate through them and bind each value to `$var` in turn
# for the rest of the pipeline.
#
jq -rn 'range(2; 4) as $i
        | range(1; 6) as $j
          | ""\($i) * \($j) = \($i * $j)""
'

# Output:
# 2 * 1 = 2
# 2 * 2 = 4
# 2 * 3 = 6
# 2 * 4 = 8
# 2 * 5 = 10
# 3 * 1 = 3
# 3 * 2 = 6
# 3 * 3 = 9
# 3 * 4 = 12
# 3 * 5 = 15


# It's sometimes useful to bind the initial input to a variable at the
# start of a program, so that you can refer to it later down the pipeline.
#
jq -rn ""$(cat <<'EOF'
    {lookup:  {a: 1, b: 2, c: 3},
     bonuses: {a: 5, b: 2, c: 9}
    }
    | . as $doc
    | .bonuses
    | to_entries[]
    | ""\(.key)'s total is \($doc.lookup[.key] + .value)""
EOF
)""

# Output:
# a's total is 6
# b's total is 4
# c's total is 12


# jq supports destructing during varible binding. This lets you extract values
# from an array or an object and bind them to variables.
#
jq -n '[range(5)] | . as [$first, $second] | $second'

# Output:
# 1

jq -n '{ name: ""Tom"", numbers: [1, 2, 3], age: 32}
       | . as {
            name: $who,                  # bind .name to $who
            $name,                       # shorthand for `name: $name`
            numbers: [$first, $second],
         }
       | $name, $second, $first, $who
'

# Output:
# ""Tom""
# 2
# 1
# ""Tom""


# In jq, values can be assigned to an array index or object key via the
# assignment operator, `=`. The same current input is given to both sides
# of the assignment operator, and the assignment itself evaluates to the
# current input. In other words, the assignment expression is evaluated
# for its side effect, and doesn't generate a new output.
#
jq -n '.a = 1 | .b = .a + 1'  # => {""a"": 1, ""b"": 2}

# Note that input is `null` due to `jq -n`, so `.` is `null` in the first
# filter, and assiging to a key under `null` turns it into an object with
# the key. The same input (now an object) then gets piped to the next filter,
# which then sets the `b` key to the value of the `a` key plus `1`, which is `2`.
#

# Another example:
#
jq -n '.a=1, .a.b=2'   # => {""a"": 1} {""a"": {""b"": 2}}

# In the above example, two objects are generated because both assignments
# received `null` as their inputs, and each operand of the comma operator
# is evaluated independently. Notice also how you can easily generate
# nested objects.


# In addition to the assignment operator, jq also has operators like:
# `+=`, `-=`, `*=`, and '/=', ... etc. Basically, `a op= b` is a shorthand
# for `a = a op b`, and they are handy for updating an object attribute or
# an item in an array based on its current value. Examples:
#
jq -n '.a.b.c = 3 | .a.b.c = .a.b.c + 1' # => {""a"": {""b"": {""c"": 4}}}
jq -n '.a.b.c = 3 | .a.b.c += 1'         # => {""a"": {""b"": {""c"": 4}}}


# To delete a value, use `del/1`, which takes a path expression that specifies
# the locations of the things to be deleted. Example:
#
jq -n '{a: 1, b: {c: 2}, d: [3, 4, 5]} | del(.b.c, .d[1]) | .b.x = 6'

# Output:
# {
#   ""a"": 1,
#   ""b"": {
#     ""x"": 6
#   },
#   ""d"": [
#     3,
#     5
#   ]
# }


# Other than using jq's built-in functions, you can define your own.
# In fact, many built-in functions are defined using jq (see the link
# to jq's built-in functions at the end of the doc).
#
jq -n '
    def my_select(expr): if expr then . else empty end;
    def my_map(expr): [.[] | expr];
    def sum: reduce .[] as $x (0; . + $x);
    def my_range($from; $to):
        if $from >= $to then
            empty
        else
            $from, my_range($from + 1; $to)
        end
    ;
    [my_range(1; 6)] | my_map(my_select(. % 2 != 0)) | sum
'

# Output:
# 9

# Some notes about function definitons:
#
# - Functions are usually defined at the beginning, so that they are available
#   to the rest of the jq program.
#
# - Each function definion should end with a `;` (semicolon).
#
# - It's also possible to define a function within another, though it's not shown here.
#
# - Function parameters are separated by `;` (semicolor). This is consistent with
#   passing multiple arguments when calling a function.
#
# - A function can call itself; in fact, jq has TCO (Tail Call Optimization).
#
# - `def f($a; $b): ...;` is a shorthand for: `def f(a; b): a as $a | b as $b | ...`
```


## Further Reading
- https://stedolan.github.io/jq/manual/
- https://github.com/stedolan/jq/wiki/jq-Language-Description
- https://github.com/stedolan/jq/wiki/Cookbook
- https://github.com/stedolan/jq/blob/master/src/builtin.jq"
"XML is a markup language designed to store and transport data. It is supposed to be both human readable and machine readable.

Unlike HTML, XML does not specify how to display or to format data, it just carries it.

Distinctions are made between the **content** and the **markup**. In short, content could be anything, markup is defined.

## Some definitions and introductions

XML Documents are basically made up of *elements* which can have *attributes* describing them and may contain some textual content or more elements as its children. All XML documents must have a root element, which is the ancestor of all the other elements in the document.

XML Parsers are designed to be very strict, and will stop parsing malformed documents. Therefore it must be ensured that all XML documents follow the [XML Syntax Rules](http://www.w3schools.com/xml/xml_syntax.asp).

```xml
<!-- This is a comment. It must not contain two consecutive hyphens (-). -->
<!-- Comments can span
  multiple lines -->

<!-- Elements -->
<!-- An element is a basic XML component. There are two types, empty: -->
<element1 attribute=""value"" /> <!-- Empty elements do not hold any content -->
<!-- and non-empty: -->
<element2 attribute=""value"">Content</element2>
<!-- Element names may only contain alphabets and numbers. -->

<empty /> <!-- An element either consists an empty element tag… -->
<!-- …which does not hold any content and is pure markup. -->

<notempty> <!-- Or, it consists of a start tag… -->
  <!-- …some content… -->
</notempty> <!-- and an end tag. -->

<!-- Element names are case sensitive. -->
<element />
<!-- is not the same as -->
<eLEMENT />

<!-- Attributes -->
<!-- An attribute is a key-value pair and exists within an element. -->
<element attribute=""value"" another=""anotherValue"" many=""space-separated list"" />
<!-- An attribute may appear only once in an element. It holds just one value.
  Common workarounds to this involve the use of space-separated lists. -->

<!-- Nesting elements -->
<!-- An element's content may include other elements: -->
<parent>
  <child>Text</child>
  <emptysibling />
</parent>
<!-- Standard tree nomenclature is followed. Each element being called a node.
  An ancestor a level up is the parent, descendants a level down are children.
  Elements within the same parent element are siblings. -->

<!-- XML preserves whitespace. -->
<child>
  Text
</child>
<!-- is not the same as -->
<child>Text</child>
```

## An XML document

This is what makes XML versatile. It is human readable too. The following document tells us that it defines a bookstore which sells three books, one of which is Learning XML by Erik T. Ray. All this without having used an XML Parser yet.

```xml
<?xml version=""1.0"" encoding=""UTF-8""?>
<!-- This is called an XML prolog. Optional, but recommended. -->
<bookstore>
  <book category=""COOKING"">
    <title lang=""en"">Everyday Italian</title>
    <author>Giada De Laurentiis</author>
    <year>2005</year>
    <price>30.00</price>
  </book>
  <book category=""CHILDREN"">
    <title lang=""en"">Harry Potter</title>
    <author>J K. Rowling</author>
    <year>2005</year>
    <price>29.99</price>
  </book>
  <book category=""WEB"">
    <title lang=""en"">Learning XML</title>
    <author>Erik T. Ray</author>
    <year>2003</year>
    <price>39.95</price>
  </book>
</bookstore>
```

## Well-formedness and Validation

A XML document is *well-formed* if it is syntactically correct. However, it is possible to add more constraints to the document, using Document Type Definitions (DTDs). A document whose elements are attributes are declared in a DTD and which follows the grammar specified in that DTD is called *valid* with respect to that DTD, in addition to being well-formed.

Declaring a DTD externally:

```xml
<?xml version=""1.0"" encoding=""UTF-8""?>
<!DOCTYPE bookstore SYSTEM ""Bookstore.dtd"">
<!-- Declares that bookstore is our root element and 'Bookstore.dtd' is the path
  to our DTD file. -->
<bookstore>
  <book category=""COOKING"">
    <title lang=""en"">Everyday Italian</title>
    <author>Giada De Laurentiis</author>
    <year>2005</year>
    <price>30.00</price>
  </book>
</bookstore>
```

The DTD file (Bookstore.dtd):

```
<!ELEMENT bookstore (book+)>
<!-- The bookstore element may contain one or more child book elements. -->
<!ELEMENT book (title, price)>
<!-- Each book must have a title and a price as its children. -->
<!ATTLIST book category CDATA ""Literature"">
<!-- A book should have a category attribute. If it doesn't, its default value
  will be 'Literature'. -->
<!ELEMENT title (#PCDATA)>
<!-- The element title must only contain parsed character data. That is, it may
  only contain text which is read by the parser and must not contain children.
  Compare with CDATA, or character data. -->
<!ELEMENT price (#PCDATA)>
```

The DTD could be declared inside the XML file itself:

```xml
<?xml version=""1.0"" encoding=""UTF-8""?>

<!DOCTYPE bookstore [
<!ELEMENT bookstore (book+)>
<!ELEMENT book (title, price)>
<!ATTLIST book category CDATA ""Literature"">
<!ELEMENT title (#PCDATA)>
<!ELEMENT price (#PCDATA)>
]>

<bookstore>
  <book category=""COOKING"">
    <title>Everyday Italian</title>
    <price>30.00</price>
  </book>
</bookstore>
```

## DTD Compatibility and XML Schema Definitions

Support for DTDs is ubiquitous because they are so old. Unfortunately, modern XML features like namespaces are not supported by DTDs. XML Schema Definitions (XSDs) are meant to replace DTDs for defining XML document grammar. 

## Resources

* [Validate your XML](http://www.xmlvalidation.com)

## Further Reading

* [XML Schema Definitions Tutorial](https://www.w3schools.com/xml/schema_intro.asp)
* [DTD Tutorial](http://www.w3schools.com/xml/xml_dtd_intro.asp)
* [XML Tutorial](http://www.w3schools.com/xml/default.asp)
* [Using XPath queries to parse XML](http://www.w3schools.com/xml/xml_xpath.asp)"
"CoffeeScript is a little language that compiles one-to-one into the equivalent
JavaScript, and there is no interpretation at runtime. As one of the successors
to JavaScript, CoffeeScript tries its best to output readable, pretty-printed
and smooth-running JavaScript code, which works well in every JavaScript runtime.
It also attempts to try and make JavaScript more in line with the trends of many
modern languages.

See also [the CoffeeScript website](http://coffeescript.org/), which has a complete tutorial on CoffeeScript.

```coffeescript
# Comments are similar to Ruby and Python, using the hash symbol `#`

###
Block comments are like these, and they translate directly to '/ *'s and '* /'s
for the resulting JavaScript code.

You should understand most of JavaScript semantics
before continuing.
###

# Assignment:
number   = 42 #=> var number = 42;
opposite = true #=> var opposite = true;

# Conditions:
number = -42 if opposite #=> if(opposite) { number = -42; }

# Functions:
square = (x) -> x * x #=> var square = function(x) { return x * x; }

fill = (container, liquid = ""coffee"") ->
  ""Filling the #{container} with #{liquid}...""
#=>var fill;
#
#fill = function(container, liquid) {
#  if (liquid == null) {
#    liquid = ""coffee"";
#  }
#  return ""Filling the "" + container + "" with "" + liquid + ""..."";
#};

# Ranges:
list = [1..5] #=> var list = [1, 2, 3, 4, 5];

# Objects:
math =
  root:   Math.sqrt
  square: square
  cube:   (x) -> x * square x
#=> var math = {
#    ""root"": Math.sqrt,
#    ""square"": square,
#    ""cube"": function(x) { return x * square(x); }
#   };

# Splats:
race = (winner, runners...) ->
  print winner, runners
#=>race = function() {
#    var runners, winner;
#    winner = arguments[0], runners = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
#    return print(winner, runners);
#  };

# Existence:
alert ""I knew it!"" if elvis?
#=> if(typeof elvis !== ""undefined"" && elvis !== null) { alert(""I knew it!""); }

# Array comprehensions:
cubes = (math.cube num for num in list)
#=>cubes = (function() {
#	  var _i, _len, _results;
#	  _results = [];
# 	for (_i = 0, _len = list.length; _i < _len; _i++) {
#		  num = list[_i];
#		  _results.push(math.cube(num));
#	  }
#	  return _results;
# })();

foods = ['broccoli', 'spinach', 'chocolate']
eat food for food in foods when food isnt 'chocolate'
#=>foods = ['broccoli', 'spinach', 'chocolate'];
#
#for (_k = 0, _len2 = foods.length; _k < _len2; _k++) {
#  food = foods[_k];
#  if (food !== 'chocolate') {
#    eat(food);
#  }
#}
```

## Additional resources

- [Smooth CoffeeScript](http://autotelicum.github.io/Smooth-CoffeeScript/)
- [CoffeeScript Ristretto](https://leanpub.com/coffeescript-ristretto/read)"
"Standard ML is a functional programming language with type inference and some
side-effects.  Some of the hard parts of learning Standard ML are: Recursion,
pattern matching, type inference (guessing the right types but never allowing
implicit type conversion). Standard ML is distinguished from Haskell by including
references, allowing variables to be updated.

```ocaml
(* Comments in Standard ML begin with (* and end with *).  Comments can be
   nested which means that all (* tags must end with a *) tag.  This comment,
   for example, contains two nested comments. *)

(* A Standard ML program consists of declarations, e.g. value declarations: *)
val rent = 1200
val phone_no = 5551337
val pi = 3.14159
val negative_number = ~15  (* Yeah, unary minus uses the 'tilde' symbol *)

(* Optionally, you can explicitly declare types. This is not necessary as
   ML will automatically figure out the types of your values. *)
val diameter = 7926 : int
val e = 2.718 : real
val name = ""Bobby"" : string

(* And just as importantly, functions: *)
fun is_large(x : int) = if x > 37 then true else false

(* Floating-point numbers are called ""reals"". *)
val tau = 2.0 * pi         (* You can multiply two reals *)
val twice_rent = 2 * rent  (* You can multiply two ints *)
(* val meh = 1.25 * 10 *)  (* But you can't multiply an int and a real *)
val yeh = 1.25 * (Real.fromInt 10) (* ...unless you explicitly convert
                                      one or the other *)

(* +, - and * are overloaded so they work for both int and real. *)
(* The same cannot be said for division which has separate operators: *)
val real_division = 14.0 / 4.0  (* gives 3.5 *)
val int_division  = 14 div 4    (* gives 3, rounding down *)
val int_remainder = 14 mod 4    (* gives 2, since 3*4 = 12 *)

(* ~ is actually sometimes a function (e.g. when put in front of variables) *)
val negative_rent = ~(rent)  (* Would also have worked if rent were a ""real"" *)

(* There are also booleans and boolean operators *)
val got_milk = true
val got_bread = false
val has_breakfast = got_milk andalso got_bread  (* 'andalso' is the operator *)
val has_something = got_milk orelse got_bread   (* 'orelse' is the operator *)
val is_sad = not(has_something)                 (* not is a function *)

(* Many values can be compared using equality operators: = and <> *)
val pays_same_rent = (rent = 1300)  (* false *)
val is_wrong_phone_no = (phone_no <> 5551337)  (* false *)

(* The operator <> is what most other languages call !=. *)
(* 'andalso' and 'orelse' are called && and || in many other languages. *)

(* Actually, most of the parentheses above are unnecessary.  Here are some
   different ways to say some of the things mentioned above: *)
fun is_large x = x > 37  (* The parens above were necessary because of ': int' *)
val is_sad = not has_something
val pays_same_rent = rent = 1300  (* Looks confusing, but works *)
val is_wrong_phone_no = phone_no <> 5551337
val negative_rent = ~rent  (* ~ rent (notice the space) would also work *)

(* Parentheses are mostly necessary when grouping things: *)
val some_answer = is_large (5 + 5)      (* Without parens, this would break! *)
(* val some_answer = is_large 5 + 5 *)  (* Read as: (is_large 5) + 5. Bad! *)


(* Besides booleans, ints and reals, Standard ML also has chars and strings: *)
val foo = ""Hello, World!\n""  (* The \n is the escape sequence for linebreaks *)
val one_letter = #""a""        (* That funky syntax is just one character, a *)

val combined = ""Hello "" ^ ""there, "" ^ ""fellow!\n""  (* Concatenate strings *)

val _ = print foo       (* You can print things. We are not interested in the *)
val _ = print combined  (* result of this computation, so we throw it away. *)
(* val _ = print one_letter *)  (* Only strings can be printed this way *)


val bar = [ #""H"", #""e"", #""l"", #""l"", #""o"" ]  (* SML also has lists! *)
(* val _ = print bar *)  (* Lists are unfortunately not the same as strings *)

(* Fortunately they can be converted.  String is a library and implode and size
   are functions available in that library that take strings as argument. *)
val bob = String.implode bar          (* gives ""Hello"" *)
val bob_char_count = String.size bob  (* gives 5 *)
val _ = print (bob ^ ""\n"")            (* For good measure, add a linebreak *)

(* You can have lists of any kind *)
val numbers = [1, 3, 3, 7, 229, 230, 248]  (* : int list *)
val names = [ ""Fred"", ""Jane"", ""Alice"" ]    (* : string list *)

(* Even lists of lists of things *)
val groups = [ [ ""Alice"", ""Bob"" ],
               [ ""Huey"", ""Dewey"", ""Louie"" ],
               [ ""Bonnie"", ""Clyde"" ] ]     (* : string list list *)

val number_count = List.length numbers     (* gives 7 *)

(* You can put single values in front of lists of the same kind using
   the :: operator, called ""the cons operator"" (known from Lisp). *)
val more_numbers = 13 :: numbers  (* gives [13, 1, 3, 3, 7, ...] *)
val more_groups  = [""Batman"",""Superman""] :: groups

(* Lists of the same kind can be appended using the @ (""append"") operator *)
val guest_list = [ ""Mom"", ""Dad"" ] @ [ ""Aunt"", ""Uncle"" ]

(* This could have been done with the ""cons"" operator.  It is tricky because the
   left-hand-side must be an element whereas the right-hand-side must be a list
   of those elements. *)
val guest_list = ""Mom"" :: ""Dad"" :: [ ""Aunt"", ""Uncle"" ]
val guest_list = ""Mom"" :: (""Dad"" :: (""Aunt"" :: (""Uncle"" :: [])))

(* If you have many lists of the same kind, you can concatenate them all *)
val everyone = List.concat groups  (* [ ""Alice"", ""Bob"", ""Huey"", ... ] *)

(* A list can contain any (finite) number of values *)
val lots = [ 5, 5, 5, 6, 4, 5, 6, 5, 4, 5, 7, 3 ]  (* still just an int list *)

(* Lists can only contain one kind of thing... *)
(* val bad_list = [ 1, ""Hello"", 3.14159 ] : ??? list *)


(* Tuples, on the other hand, can contain a fixed number of different things *)
val person1 = (""Simon"", 28, 3.14159)  (* : string * int * real *)

(* You can even have tuples inside lists and lists inside tuples *)
val likes = [ (""Alice"", ""ice cream""),
              (""Bob"",   ""hot dogs""),
              (""Bob"",   ""Alice"") ]     (* : (string * string) list *)

val mixup = [ (""Alice"", 39),
              (""Bob"",   37),
              (""Eve"",   41) ]  (* : (string * int) list *)

val good_bad_stuff =
  ([""ice cream"", ""hot dogs"", ""chocolate""],
   [""liver"", ""paying the rent"" ])           (* : string list * string list *)


(* Records are tuples with named slots *)

val rgb = { r=0.23, g=0.56, b=0.91 } (* : {b:real, g:real, r:real} *)

(* You don't need to declare their slots ahead of time. Records with
   different slot names are considered different types, even if their
   slot value types match up. For instance... *)

val Hsl = { H=310.3, s=0.51, l=0.23 } (* : {H:real, l:real, s:real} *)
val Hsv = { H=310.3, s=0.51, v=0.23 } (* : {H:real, s:real, v:real} *)

(* ...trying to evaluate `Hsv = Hsl` or `rgb = Hsl` would give a type
   error. While they're all three-slot records composed only of `real`s,
   they each have different names for at least some slots. *)

(* You can use hash notation to get values out of tuples. *)

val H = #H Hsv (* : real *)
val s = #s Hsl (* : real *)

(* Functions! *)
fun add_them (a, b) = a + b    (* A simple function that adds two numbers *)
val test_it = add_them (3, 4)  (* gives 7 *)

(* Larger functions are usually broken into several lines for readability *)
fun thermometer temp =
    if temp < 37
    then ""Cold""
    else if temp > 37
         then ""Warm""
         else ""Normal""

val test_thermo = thermometer 40  (* gives ""Warm"" *)

(* if-sentences are actually expressions and not statements/declarations.
   A function body can only contain one expression.  There are some tricks
   for making a function do more than just one thing, though. *)

(* A function can call itself as part of its result (recursion!) *)
fun fibonacci n =
    if n = 0 then 0 else                   (* Base case *)
    if n = 1 then 1 else                   (* Base case *)
    fibonacci (n - 1) + fibonacci (n - 2)  (* Recursive case *)

(* Sometimes recursion is best understood by evaluating a function by hand:

 fibonacci 4
   ~> fibonacci (4 - 1) + fibonacci (4 - 2)
   ~> fibonacci 3 + fibonacci 2
   ~> (fibonacci (3 - 1) + fibonacci (3 - 2)) + fibonacci 2
   ~> (fibonacci 2 + fibonacci 1) + fibonacci 2
   ~> ((fibonacci (2 - 1) + fibonacci (2 - 2)) + fibonacci 1) + fibonacci 2
   ~> ((fibonacci 1 + fibonacci 0) + fibonacci 1) + fibonacci 2
   ~> ((1 + fibonacci 0) + fibonacci 1) + fibonacci 2
   ~> ((1 + 0) + fibonacci 1) + fibonacci 2
   ~> (1 + fibonacci 1) + fibonacci 2
   ~> (1 + 1) + fibonacci 2
   ~> 2 + fibonacci 2
   ~> 2 + (fibonacci (2 - 1) + fibonacci (2 - 2))
   ~> 2 + (fibonacci (2 - 1) + fibonacci (2 - 2))
   ~> 2 + (fibonacci 1 + fibonacci 0)
   ~> 2 + (1 + fibonacci 0)
   ~> 2 + (1 + 0)
   ~> 2 + 1
   ~> 3  which is the 4th Fibonacci number, according to this definition

 *)

(* A function cannot change the variables it can refer to.  It can only
   temporarily shadow them with new variables that have the same names.  In this
   sense, variables are really constants and only behave like variables when
   dealing with recursion.  For this reason, variables are also called value
   bindings. An example of this: *)

val x = 42
fun answer(question) =
    if question = ""What is the meaning of life, the universe and everything?""
    then x
    else raise Fail ""I'm an exception. Also, I don't know what the answer is.""
val x = 43
val hmm = answer ""What is the meaning of life, the universe and everything?""
(* Now, hmm has the value 42.  This is because the function answer refers to
   the copy of x that was visible before its own function definition. *)


(* Functions can take several arguments by taking one tuples as argument: *)
fun solve2 (a : real, b : real, c : real) =
    ((~b + Math.sqrt(b * b - 4.0 * a * c)) / (2.0 * a),
     (~b - Math.sqrt(b * b - 4.0 * a * c)) / (2.0 * a))

(* Sometimes, the same computation is carried out several times. It makes sense
   to save and re-use the result the first time. We can use ""let-bindings"": *)
fun solve2 (a : real, b : real, c : real) =
    let val discr  = b * b - 4.0 * a * c
        val sqr = Math.sqrt discr
        val denom = 2.0 * a
    in ((~b + sqr) / denom,
        (~b - sqr) / denom)
    end


(* Pattern matching is a funky part of functional programming.  It is an
   alternative to if-sentences.  The fibonacci function can be rewritten: *)
fun fibonacci 0 = 0  (* Base case *)
  | fibonacci 1 = 1  (* Base case *)
  | fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)  (* Recursive case *)

(* Pattern matching is also possible on composite types like tuples, lists and
   records. Writing ""fun solve2 (a, b, c) = ..."" is in fact a pattern match on
   the one three-tuple solve2 takes as argument. Similarly, but less intuitively,
   you can match on a list consisting of elements in it (from the beginning of
   the list only). *)
fun first_elem (x::xs) = x
fun second_elem (x::y::xs) = y
fun evenly_positioned_elems (odd::even::xs) = even::evenly_positioned_elems xs
  | evenly_positioned_elems [odd] = []  (* Base case: throw away *)
  | evenly_positioned_elems []    = []  (* Base case *)
  
(* The case expression can also be used to pattern match and return a value *)
datatype temp =
      C of real
    | F of real
    
(*  Declaring a new C temp value...
    val t: temp = C 45.0  *)

fun temp_to_f t =
    case t of
      C x => x * (9.0 / 5.0) + 32.0
    | F x => x

(* When matching on records, you must use their slot names, and you must bind
   every slot in a record. The order of the slots doesn't matter though. *)

fun rgbToTup {r, g, b} = (r, g, b)    (* fn : {b:'a, g:'b, r:'c} -> 'c * 'b * 'a *)
fun mixRgbToTup {g, b, r} = (r, g, b) (* fn : {b:'a, g:'b, r:'c} -> 'c * 'b * 'a *)

(* If called with {r=0.1, g=0.2, b=0.3}, either of the above functions
   would return (0.1, 0.2, 0.3). But it would be a type error to call them
   with {r=0.1, g=0.2, b=0.3, a=0.4} *)

(* Higher order functions: Functions can take other functions as arguments.
   Functions are just other kinds of values, and functions don't need names
   to exist.  Functions without names are called ""anonymous functions"" or
   lambda expressions or closures (since they also have a lexical scope). *)
val is_large = (fn x => x > 37)
val add_them = fn (a,b) => a + b
val thermometer =
    fn temp => if temp < 37
               then ""Cold""
               else if temp > 37
                    then ""Warm""
                    else ""Normal""

(* The following uses an anonymous function directly and gives ""ColdWarm"" *)
val some_result = (fn x => thermometer (x - 5) ^ thermometer (x + 5)) 37

(* Here is a higher-order function that works on lists (a list combinator) *)
(* map f l
       applies f to each element of l from left to right, 
       returning the list of results. *)
val readings = [ 34, 39, 37, 38, 35, 36, 37, 37, 37 ]  (* first an int list *)
val opinions = List.map thermometer readings (* gives [ ""Cold"", ""Warm"", ... ] *)

(* And here is another one for filtering lists *)
val warm_readings = List.filter is_large readings  (* gives [39, 38] *)

(* You can create your own higher-order functions, too.  Functions can also take
   several arguments by ""currying"" them. Syntax-wise this means adding spaces
   between function arguments instead of commas and surrounding parentheses. *)
fun map f [] = []
  | map f (x::xs) = f(x) :: map f xs

(* map has type ('a -> 'b) -> 'a list -> 'b list and is called polymorphic. *)
(* 'a is called a type variable. *)


(* We can declare functions as infix *)
val plus = add_them   (* plus is now equal to the same function as add_them *)
infix plus            (* plus is now an infix operator *)
val seven = 2 plus 5  (* seven is now bound to 7 *)

(* Functions can also be made infix before they are declared *)
infix minus
fun x minus y = x - y (* It becomes a little hard to see what's the argument *)
val four = 8 minus 4  (* four is now bound to 4 *)

(* An infix function/operator can be made prefix with 'op' *)
val n = op + (5, 5)   (* n is now 10 *)

(* 'op' is useful when combined with high order functions because they expect
   functions and not operators as arguments. Most operators are really just
   infix functions. *)
(* foldl f init [x1, x2, ..., xn]
       returns
       f(xn, ...f(x2, f(x1, init))...)
       or init if the list is empty. *)
val sum_of_numbers = foldl op+ 0 [1, 2, 3, 4, 5]


(* Datatypes are useful for creating both simple and complex structures *)
datatype color = Red | Green | Blue

(* Here is a function that takes one of these as argument *)
fun say(col) =
    if col = Red then ""You are red!"" else
    if col = Green then ""You are green!"" else
    if col = Blue then ""You are blue!"" else
    raise Fail ""Unknown color""

val _ = print (say(Red) ^ ""\n"")

(* Datatypes are very often used in combination with pattern matching *)
fun say Red   = ""You are red!""
  | say Green = ""You are green!""
  | say Blue  = ""You are blue!""

(* We did not include the match arm `say _ = raise Fail ""Unknown color""`
because after specifying all three colors, the pattern is exhaustive
and redundancy is not permitted in pattern matching *)


(* Here is a binary tree datatype *)
datatype 'a btree = Leaf of 'a
                  | Node of 'a btree * 'a * 'a btree (* three-arg constructor *)

(* Here is a binary tree *)
val myTree = Node (Leaf 9, 8, Node (Leaf 3, 5, Leaf 7))

(* Drawing it, it might look something like...

           8
          / \
 leaf -> 9   5
            / \
   leaf -> 3   7 <- leaf
 *)

(* This function counts the sum of all the elements in a tree *)
fun count (Leaf n) = n
  | count (Node (leftTree, n, rightTree)) = count leftTree + n + count rightTree

val myTreeCount = count myTree  (* myTreeCount is now bound to 32 *)


(* Exceptions! *)
(* Exceptions can be raised/thrown using the reserved word 'raise' *)
fun calculate_interest(n) = if n < 0.0
                            then raise Domain
                            else n * 1.04

(* Exceptions can be caught using ""handle"" *)
val balance = calculate_interest ~180.0
              handle Domain => ~180.0    (* balance now has the value ~180.0 *)

(* Some exceptions carry extra information with them *)
(* Here are some examples of built-in exceptions *)
fun failing_function []    = raise Empty  (* used for empty lists *)
  | failing_function [x]   = raise Fail ""This list is too short!""
  | failing_function [x,y] = raise Overflow  (* used for arithmetic *)
  | failing_function xs    = raise Fail ""This list is too long!""

(* We can pattern match in 'handle' to make sure
   a specific exception was raised, or grab the message *)
val err_msg = failing_function [1,2] handle Fail _ => ""Fail was raised""
                                          | Domain => ""Domain was raised""
                                          | Empty  => ""Empty was raised""
                                          | _      => ""Unknown exception""

(* err_msg now has the value ""Unknown exception"" because Overflow isn't
   listed as one of the patterns -- thus, the catch-all pattern _ is used. *)

(* We can define our own exceptions like this *)
exception MyException
exception MyExceptionWithMessage of string
exception SyntaxError of string * (int * int)

(* File I/O! *)
(* Write a nice poem to a file *)
fun writePoem(filename) =
    let val file = TextIO.openOut(filename)
        val _ = TextIO.output(file, ""Roses are red,\nViolets are blue.\n"")
        val _ = TextIO.output(file, ""I have a gun.\nGet in the van.\n"")
    in TextIO.closeOut(file)
    end

(* Read a nice poem from a file into a list of strings *)
fun readPoem(filename) =
    let val file = TextIO.openIn filename
        val poem = TextIO.inputAll file
        val _ = TextIO.closeIn file
    in String.tokens (fn c => c = #""\n"") poem
    end

val _ = writePoem ""roses.txt""
val test_poem = readPoem ""roses.txt""  (* gives [ ""Roses are red,"",
                                                 ""Violets are blue."",
                                                 ""I have a gun."",
                                                 ""Get in the van."" ] *)

(* We can create references to data which can be updated *)
val counter = ref 0 (* Produce a reference with the ref function *)

(* Assign to a reference with the assignment operator *)
fun set_five reference = reference := 5

(* Read a reference with the dereference operator *)
fun equals_five reference = !reference = 5

(* We can use while loops for when recursion is messy *)
fun decrement_to_zero r = if !r < 0
                          then r := 0
                          else while !r >= 0 do r := !r - 1

(* This returns the unit value (in practical terms, nothing, a 0-tuple) *)

(* To allow returning a value, we can use the semicolon to sequence evaluations *)
fun decrement_ret x y = (x := !x - 1; y)
```

## Further learning

* Install an interactive compiler (REPL), for example
  [Poly/ML](http://www.polyml.org/),
  [Moscow ML](http://mosml.org),
  [SML/NJ](http://smlnj.org/).
* Follow the Coursera course [Programming Languages](https://www.coursera.org/course/proglang).
* Read *[ML for the Working Programmer](https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html)* by Larry C. Paulson.
* Use [StackOverflow's sml tag](http://stackoverflow.com/questions/tagged/sml).
* Solve exercises on [Exercism.io's Standard ML track](https://exercism.io/tracks/sml)."
"CHICKEN is an implementation of Scheme programming language that can
compile Scheme programs to C code as well as interpret them. CHICKEN
supports R5RS and R7RS (work in progress) standards and many extensions.


```scheme
;; #!/usr/bin/env csi -s

;; Run the CHICKEN REPL in the commandline as follows :
;; $ csi

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 0. Syntax
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Single line comments start with a semicolon

#| Block comments
   can span multiple lines and...
   #| can be nested
   |#
|#

;; S-expression comments are used to comment out expressions
#; (display ""nothing"")    ; discard this expression 

;; CHICKEN has two fundamental pieces of syntax: Atoms and S-expressions
;; an atom is something that evaluates to itself
;; all builtin data types viz. numbers, chars, booleans, strings etc. are atoms
;; Furthermore an atom can be a symbol, an identifier, a keyword, a procedure
;; or the empty list (also called null)
'athing              ;; => athing 
'+                   ;; => + 
+                    ;; => <procedure C_plus>

;; S-expressions (short for symbolic expressions) consists of one or more atoms
(quote +)            ;; => + ; another way of writing '+
(+ 1 2 3)            ;; => 6 ; this S-expression evaluates to a function call
'(+ 1 2 3)           ;; => (+ 1 2 3) ; evaluates to a list 


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 1. Primitive Datatypes and Operators 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Numbers
99999999999999999999 ;; integers
#b1010               ;; binary ; => 10
#o10                 ;; octal  ; => 8
#x8ded               ;; hexadecimal ; => 36333
3.14                 ;; real
6.02e+23
3/4                  ;; rational

;;Characters and Strings
#\A                  ;; A char
""Hello, World!""      ;; strings are fixed-length arrays of characters

;; Booleans
#t                  ;; true
#f                  ;; false

;; Function call is written as (f x y z ...)
;; where f is a function and x,y,z, ... are arguments
(print ""Hello, World!"")    ;; => Hello, World!
;; formatted output
(printf ""Hello, ~a.\n"" ""World"")  ;; => Hello, World.

;; print commandline arguments
(map print (command-line-arguments)) 

(list 'foo 'bar 'baz)          ;; => (foo bar baz)
(string-append ""pine"" ""apple"") ;; => ""pineapple""
(string-ref ""tapioca"" 3)       ;; => #\i;; character 'i' is at index 3
(string->list ""CHICKEN"")       ;; => (#\C #\H #\I #\C #\K #\E #\N)
(string-intersperse '(""1"" ""2"") "":"") ;; => ""1:2""
(string-split ""1:2:3"" "":"")     ;; => (""1"" ""2"" ""3"")


;; Predicates are special functions that return boolean values
(atom? #t)                ;; => #t

(symbol? #t)              ;; => #f

(symbol? '+)              ;; => #t

(procedure? +)            ;; => #t

(pair? '(1 2))            ;; => #t

(pair? '(1 2 . 3))        ;; => #t

(pair? '())               ;; => #f

(list? '())               ;; => #t


;; Some arithmetic operations

(+ 1 1)                   ;; => 2
(- 8 1)                   ;; => 7
(* 10 2)                  ;; => 20
(expt 2 3)                ;; => 8
(remainder 5 2)           ;; => 1
(/ 35 5)                  ;; => 7
(/ 1 3)                   ;; => 0.333333333333333

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 2. Variables
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; You can create variables with define
;; A variable name can use any character except: ()[]{}"",'`;#\
(define myvar 5)
myvar        ;; => 5

;; Alias to a procedure
(define ** expt)
(** 2 3)     ;; => 8

;; Accessing an undefined variable raises an exception
s            ;; => Error: unbound variable: s

;; Local binding
(let ((me ""Bob""))
  (print me))     ;; => Bob

(print me)        ;; => Error: unbound variable: me

;; Assign a new value to previously defined variable
(set! myvar 10) 
myvar             ;; => 10


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 3. Collections
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Pairs
;; 'cons' constructs pairs, 
;; 'car' extracts the first element, 'cdr' extracts the rest of the elements
(cons 'subject 'verb)       ;; => '(subject . verb)
(car (cons 'subject 'verb)) ;; => subject
(cdr (cons 'subject 'verb)) ;; => verb

;; Lists
;; cons creates a new list if the second item is a list
(cons 0 '())         ;; => (0)
(cons 1 (cons 2  (cons 3 '())))    ;; => (1 2 3)
;; 'list' is a convenience variadic constructor for lists
(list 1 2 3)    ;; => (1 2 3)


;; Use 'append' to append lists together
(append '(1 2) '(3 4)) ;; => (1 2 3 4)

;; Some basic operations on lists
(map add1 '(1 2 3))    ;; => (2 3 4)
(reverse '(1 3 4 7))   ;; => (7 4 3 1)
(sort '(11 22 33 44) >)   ;; => (44 33 22 11)

(define days '(SUN MON FRI))
(list-ref days 1)      ;; => MON
(set! (list-ref days 1) 'TUE)
days                   ;; => (SUN TUE FRI)

;; Vectors
;; Vectors are heterogeneous structures whose elements are indexed by integers
;; A Vector typically occupies less space than a list of the same length
;; Random access of an element in a vector is faster than in a list
#(1 2 3)                     ;; => #(1 2 3) ;; literal syntax
(vector 'a 'b 'c)            ;; => #(a b c) 
(vector? #(1 2 3))           ;; => #t
(vector-length #(1 (2) ""a"")) ;; => 3
(vector-ref #(1 (2) (3 3)) 2);; => (3 3)

(define vec #(1 2 3))
(vector-set! vec 2 4)
vec                         ;; => #(1 2 4)

;; Vectors can be created from lists and vice-verca
(vector->list #(1 2 4))     ;; => '(1 2 4)
(list->vector '(a b c))     ;; => #(a b c)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 4. Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Use 'lambda' to create functions.
;; A function always returns the value of its last expression
(lambda () ""Hello World"")   ;; => #<procedure (?)> 

;; Use extra parens around function definition to execute 
((lambda () ""Hello World"")) ;; => Hello World ;; argument list is empty

;; A function with an argument
((lambda (x) (* x x)) 3)           ;; => 9
;; A function with two arguments
((lambda (x y) (* x y)) 2 3)       ;; => 6

;; assign a function to a variable
(define sqr (lambda (x) (* x x)))
sqr                        ;; => #<procedure (sqr x)>
(sqr 3)                    ;; => 9

;; We can shorten this using the function definition syntactic sugar
(define (sqr x) (* x x))
(sqr 3)                    ;; => 9

;; We can redefine existing procedures
(foldl cons '() '(1 2 3 4 5)) ;; => (((((() . 1) . 2) . 3) . 4) . 5)
(define (foldl func accu alist)
  (if (null? alist)
    accu
    (foldl func (func (car alist) accu) (cdr alist))))

(foldl cons '() '(1 2 3 4 5))   ;; => (5 4 3 2 1)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 5. Equality
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; For numbers use '='
(= 3 3.0)                  ;; => #t
(= 2 1)                    ;; => #f

;; 'eq?' returns #t if two arguments refer to the same object in memory
;; In other words, it's a simple pointer comparison.
(eq? '() '())              ;; => #t ;; there's only one empty list in memory
(eq? (list 3) (list 3))    ;; => #f ;; not the same object
(eq? 'yes 'yes)            ;; => #t
(eq? 3 3)                  ;; => #t ;; don't do this even if it works in this case
(eq? 3 3.0)                ;; => #f ;; it's better to use '=' for number comparisons
(eq? ""Hello"" ""Hello"")      ;; => #f

;; 'eqv?' is same as 'eq?' all datatypes except numbers and characters
(eqv? 3 3.0)               ;; => #f
(eqv? (expt 2 3) (expt 2 3)) ;; => #t
(eqv? 'yes 'yes)           ;; => #t

;; 'equal?' recursively compares the contents of pairs, vectors, and strings,
;; applying eqv? on other objects such as numbers and symbols. 
;; A rule of thumb is that objects are generally equal? if they print the same.

(equal? '(1 2 3) '(1 2 3)) ;; => #t
(equal? #(a b c) #(a b c)) ;; => #t
(equal? 'a 'a)             ;; => #t
(equal? ""abc"" ""abc"")       ;; => #t

;; In Summary:
;; eq? tests if objects are identical
;; eqv? tests if objects are operationally equivalent
;; equal? tests if objects have same structure and contents

;; Comparing strings for equality
(string=? ""Hello"" ""Hello"") ;; => #t


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 6. Control Flow
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Conditionals
(if #t                     ;; test expression
  ""True""                   ;; then expression
  ""False"")                 ;; else expression
                           ;; => ""True""

(if (> 3 2)
  ""yes""
  ""no"")                    ;; => ""yes""

;; In conditionals, all values that are not '#f' are treated as true.
;; 0, '(), #() """" , are all true values
(if 0
  ""0 is not false""
  ""0 is false"")            ;; => ""0 is not false""

;; 'cond' chains a series of tests and returns as soon as it encounters a true condition
;; 'cond' can be used to simulate 'if/elseif/else' statements
(cond ((> 2 2) ""not true so don't return this"")
      ((< 2 5) ""true, so return this"")
      (else ""returning default""))    ;; => ""true, so return this""


;; A case expression is evaluated as follows:
;; The key is evaluated and compared with each datum in sense of 'eqv?',
;; The corresponding clause in the matching datum is evaluated and returned as result
(case (* 2 3)              ;; the key is 6
  ((2 3 5 7) 'prime)       ;; datum 1
  ((1 4 6 8) 'composite))  ;; datum 2; matched!
                           ;; => composite

;; case with else clause
(case (car '(c d))
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else 'consonant))       ;; =>  consonant

;; Boolean expressions
;; 'and' returns the first expression that evaluates to #f
;; otherwise, it returns the result of the last expression
(and #t #f (= 2 2.0))                ;; => #f
(and (< 2 5) (> 2 0) ""0 < 2 < 5"")    ;; => ""0 < 2 < 5""

;; 'or' returns the first expression that evaluates to #t 
;; otherwise the result of the last expression is returned
(or #f #t #f)                        ;; => #t
(or #f #f #f)                        ;; => #f

;; 'when' is like 'if' without the else expression
(when (positive? 5) ""I'm positive"")  ;; => ""I'm positive""

;; 'unless' is equivalent to (when (not <test>) <expr>)
(unless (null? '(1 2 3)) ""not null"") ;; => ""not null""


;; Loops
;; loops can be created with the help of tail-recursions
(define (loop count)
  (unless (= count 0)
    (print ""hello"") 
    (loop (sub1 count))))
(loop 4)                             ;; => hello, hello ...

;; Or with a named let
(let loop ((i 0) (limit 5))
  (when (< i limit)
    (printf ""i = ~a\n"" i)
    (loop (add1 i) limit)))          ;; => i = 0, i = 1....

;; 'do' is another iteration construct
;; It initializes a set of variables and updates them in each iteration
;; A final expression is evaluated after the exit condition is met
(do ((x 0 (add1 x )))            ;; initialize x = 0 and add 1 in each iteration
  ((= x 10) (print ""done""))      ;; exit condition and final expression
  (print x))                     ;; command to execute in each step
                                 ;; => 0,1,2,3....9,done

;; Iteration over lists 
(for-each (lambda (a) (print (* a a)))
          '(3 5 7))                  ;; => 9, 25, 49

;; 'map' is like for-each but returns a list
(map add1 '(11 22 33))               ;; => (12 23 34)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 7. Extensions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; The CHICKEN core is very minimal, but additional features are provided by library extensions known as Eggs.
;; You can install Eggs with 'chicken-install <eggname>' command.

;; complex numbers
3+4i                               ;; => 3+2i
;; Supports fractions without falling back to inexact flonums
1/3                                ;; => 1/3
;; provides support for large integers through bignums
(expt 9 20)                        ;; => 12157665459056928801 
;; And other 'extended' functions
(log 10 (exp 1))                   ;; => 2.30258509299405
(numerator 2/3)                    ;; => 2

;; 'utf8' provides unicode support
(import utf8)
""\u03BBx:(\u03BC\u0251.\u0251\u2192\u0251).xx"" ;; => ""λx:(μɑ.ɑ→ɑ).xx""

;; 'posix' provides file I/O and lots of other services for unix-like operating systems
;; Some of the functions are not available in Windows system,
;; See http://wiki.call-cc.org/man/5/Module%20(chicken%20file%20posix) for more details

;; Open a file to append, open ""write only"" and create file if it does not exist
(define outfn (file-open ""chicken-hen.txt"" (+ open/append open/wronly open/creat)))
;; write some text to the file
(file-write outfn ""Did chicken came before hen?"") 
;; close the file
(file-close outfn)
;; Open the file ""read only""
(define infn (file-open ""chicken-hen.txt"" open/rdonly))
;; read some text from the file
(file-read infn 30)         ;; => (""Did chicken came before hen?  "", 28)
(file-close infn)

;; CHICKEN also supports SRFI (Scheme Requests For Implementation) extensions
;; See 'http://srfi.schemers.org/srfi-implementers.html"" to see srfi's supported by CHICKEN
(import srfi-1)                    ;; list library
(filter odd? '(1 2 3 4 5 6 7))     ;; => (1 3 5 7)
(count even? '(1 2 3 4 5))         ;; => 2
(take '(12 24 36 48 60) 3)         ;; => (12 24 36)
(drop '(12 24 36 48 60) 2)         ;; => (36 48 60)
(circular-list 'z 'q)              ;; => z q z q ...

(import srfi-13)                   ;; string library
(string-reverse ""pan"")             ;; => ""nap""
(string-index ""Turkey"" #\k)        ;; => 3
(string-every char-upper-case? ""CHICKEN"") ;; => #t
(string-join '(""foo"" ""bar"" ""baz"") "":"")    ;; => ""foo:bar:baz""


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 8. Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; A 'for .. in ..' iteration like python, for lists
(define-syntax for
  (syntax-rules (in)
                ((for elem in alist body ...)
                 (for-each (lambda (elem) body ...) alist))))

(for x in '(2 4 8 16)
     (print x))          ;; => 2, 4, 8, 16

(for chr in (string->list ""PENCHANT"")
     (print chr))        ;; => P, E, N, C, H, A, N, T

;; While loop
(define-syntax while
  (syntax-rules ()
                ((while cond body ...)
                 (let loop ()
                   (when cond
                     body ...
                     (loop))))))

(let ((str ""PENCHANT"") (i 0))
  (while (< i (string-length str))     ;; while (condition)
         (print (string-ref str i))    ;; body 
         (set! i (add1 i))))           
                                       ;; => P, E, N, C, H, A, N, T

;; Advanced Syntax-Rules Primer -> http://petrofsky.org/src/primer.txt
;; Macro system in chicken -> http://lists.gnu.org/archive/html/chicken-users/2008-04/msg00013.html

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 9. Modules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Also See http://wiki.call-cc.org/man/5/Modules

;; The 'test' module exports a value named 'hello' and a macro named 'greet'
(module test (hello greet)
  (import scheme)

  (define-syntax greet
    (syntax-rules ()
      ((_ whom) 
       (begin
         (display ""Hello, "")
         (display whom)
         (display "" !\n"") ) ) ) )

  (define (hello)
    (greet ""world"") )  )

;; we can define our modules in a separate file (say test.scm) and load them to the interpreter with
;;         (load ""test.scm"")

;; import the module
(import test)
(hello)                ;; => Hello, world !
(greet ""schemers"")     ;; => Hello, schemers !

;; We can compile the module files in to shared libraries by using following command,
;;         csc -s test.scm
;;         (load ""test.so"")

;; Functors
;; Functors are high level modules that can be parameterized by other modules
;; Following functor requires another module named 'M' that provides a function called 'multiply'
;; The functor itself exports a generic function 'square'
(functor (squaring-functor (M (multiply))) (square)
         (import scheme M) 
         (define (square x) (multiply x x)))

;; Module 'nums' can be passed as a parameter to 'squaring-functor'
(module nums (multiply) 
        (import scheme)     ;; predefined modules
        (define (multiply x y) (* x y))) 
;; the final module can be imported and used in our program
(module number-squarer = (squaring-functor nums)) 

(import number-squarer)
(square 3)              ;; => 9

;; We can instantiate the functor for other inputs
;; Here's another example module that can be passed to squaring-functor
(module stars (multiply)
        (import chicken scheme)  ;; chicken module for the 'use' keyword
        (use srfi-1)             ;; we can use external libraries in our module
        (define (multiply x y)
          (list-tabulate x (lambda _ (list-tabulate y (lambda _ '*))))))
(module star-squarer = (squaring-functor stars))

(import star-squarer)
(square 3)              ;; => ((* * *)(* * *)(* * *))

```
## Further Reading
* [CHICKEN User's Manual](https://wiki.call-cc.org/manual).
* [R5RS standards](http://www.schemers.org/Documents/Standards/R5RS)


## Extra Info

* [For programmers of other languages](https://wiki.call-cc.org/chicken-for-programmers-of-other-languages)
* [Compare CHICKEN syntax with other languages](http://plr.sourceforge.net/cgi-bin/plr/launch.py)"
"HDL (hardware description language) is a specialized language used to describe the structure/behavior of real world circuits. 

It is used by circuit designers to simulate circuits and logic prior to wiring and fabricating a hardware circuit.

HDL allows circuit designers to simulate circuits at a high level without being connected to specific components.

## Basic building blocks & introduction to the language---
This programming language is built by simulating hardware chips and wiring. Normal programming functions are replaced with specialized chips that are added to the current wiring design. Every base chip must be written as it's own file and imported to be used in the current chip, though they may be reused as often as desired.

```verilog
// Single line comments start with two forward slashes.

/*
 * Multiline comments can be written using '/*' and 'star/'.
 * These are often used as comments.
 *
 * Note that they cannot be nested and will end at the first 'star/'.
 */

////////////////////////////////////////////////////
// 1. Chips & Components
////////////////////////////////////////////////////
/* 
 * Unlike other languages HDL creates an individual chip (function) per file
 * These are defined with a name, input arguments, output arguments
 * and finally the parts/logic of that specific chip.
 */

// Note CHIP is capitalized, the chip name does not need to be.
CHIP Ex {
    IN  a,  // Single bit (0 or 1) variable.
        c[16];  // 16 bit variable bus of single bit values.

    OUT out[16],  // 16 bit variable bus output.
        carry;  // Single bit output variable

    PARTS:
    // The functional components of the chip.
}

// Lines are ended with semicolons but can be continued using commas. The
// whitespace is ignored.



////////////////////////////////////////////////////
// 2. Inputs, Outputs, & Variables
////////////////////////////////////////////////////
/*
 * Variables and IO are treated as pins/wires and can carry a single bit
 * of data (0 or 1).
 */

// Hardware works on low level 0's and 1's, in order to use a constant
// high or low we use the terms true and false.
a=false; // This is a 0 value.
b=true; // This is a 1 value.

// Inputs and outputs can be defined as single bits
IN a, b; // Creates two single bit inputs

// They can also be defined as busses act as arrays where each
// index can contain a single bit value.
OUT c[16]; // Creates a 16 bit output array.

// Bussed values can be accessed using brackets
a[0] // The first indexed value in the bus a.
a[0..3] // The first 4 values in the a bus.
// Values can also be passed in entirety. For example if the function 
// foo() takes an 8 bit input bus and outputs a 2 bit bus:
foo(in=a[0..7], out=c); // C is now a 2 bit internal bus


// Note that internally defined busses cannot be subbussed!
// To access these elements, output or input them separately:
foo(in[0]=false, in[1..7]=a[0..6], out[0]=out1, out[1]=out2);
// out1 and out2 can then be passed into other circuits within the design.



////////////////////////////////////////////////////
// Combining Subsystems
////////////////////////////////////////////////////
/*
 * HDL relies heavily on using smaller ""building block"" chips to then be
 * added into larger and more complex designs. Creating the smaller components
 * and then adding them to the larger circuit allows for fewer lines of code
 * as well as reduction in total rewriting of code.
 */

// We are writing the function AND that checks if inputs I and K are both one.
// To implement this chip we will use the built in NAND gate as well as design
// a custom NOT gate to invert a single input.

// First we construct the Negation (not) chip. We will use the logically
// complete gate NAND that is built in for this task.
CHIP Not {
    IN i; // Not gates only take one single bit input.
    OUT o; // The negated value of a.

    PARTS:
    // Add the input to the built in chip, which then sends output to the NOT
    // output. This effectively negates the given value.
    Nand(a=i, b=i, out=o);
}

// By using the built in NAND gate we were able to construct a NOT gate
// that works like a real world hardware logic chip. Now we must construct
// the AND gate using these two gate primitives.

// We define a two input, single output AND gate:
CHIP And {
    IN i, k; // Two single bit inputs.
    OUT o; // One single bit output.

    PARTS:
    // Insert I and K into the nand gate and store the output in an internal
    // wire called notOut.
    Nand(a=i,b=k,out=notOut);

    // Use the not gate we constructed to invert notOut and send to the AND
    // output.
    Not(in=notOut,out=o);
}

// Easy! Now we can use Nand, And, and Not gates in higher level circuits.
// Many of these low level components are built in to HDL but any chip can
// be written as a submodule and used in larger designs.
```

## Test Files
When working with the nand2tetris hardware simulator chips written using HDL will
then be processed against test and comparison files to test functionality of the
simulated chip versus the expected output. To do this a test file will be loaded
into the hardware simulator and run against the simulated hardware.

```verilog
// First the chip the test file is written for is loaded
load <chip name>.hdl

// We set the output file for the simulated chip output as well as the comparison
// file that it will be tested against. We also specify what the output is
// expected to look like. In this case there will be two output columns, each
// will be buffered by a single space on either side and 4 binary values in
// the center of each column.
output-file <chip name>.out,
compare-to <chip name>.cmp,
output-list in%B1.4.1 out%B1.4.1;

// Then we set initial values for inputs to the chip. For example
set enable1 1, // set input enable1 to 1
set enable2 0, // set input enable2 to 0

// The clock is also controlled in the test file using tick and tock. Tick is a
// positive pulse and tock takes the clock back to 0. Clock cycles can be run
// multiple times in a row with no other changes to inputs or outputs.
tick,
tock,

// Finally we output the first expected value (from the test file) which is then
// compared with the first line of real output from our HDL circuit. This output
// can be viewed in the <chip name>.out file.
output;

// An example of <chip name>, a chip that takes in a 4 bit value as input and
// adds 1 to that value could have the following as test code:

// Set the input value to 0000, clock pulse, compare output from cmp file to actual out.
set in %B0000,
tick,
tock,
output;

// Set the input value to 0110, clock pulse, compare output from cmp file to actual out.
set in %B0110,
tick,
tock,
output;

// The expected output for case 1 should be 0001 and case 2 expects 0111, lets
// learn a little more about comparison files before finalizing our lesson.
```

## Comparison Files
Now lets take a look at comparison files, the files that hold what the test file
compares with the actual output of an HDL chip in the hardware simulator!

```verilog
// Like the <chip name> example above, the structure of the comparison file
// would look something like this
|  in  | out  |
| 0000 | 0001 |
| 0110 | 0111 |

// Notice how the input values specified in the test case are equivalent to the
// `in` column of the comparison file, and that the space buffer is 1 on either side.

// If the output from the HDL code we not this, such as the output below, then the
// test will fail and the user will know that the simulated chip is not correctly designed.
|  in  | out  |
| 0000 | 0001 |
| 0110 | 0110 | // Error! The chip did not add 1 here, something went wrong.


```

This is incredibly useful as it allows designers to simulate chip logic prior to
fabricating real life hardware and identify problems in their designs. Be warned that
errors in the test or comparison files can lead to both false positives and also
the more damaging false negatives so ensure that the logic is sound behind the test
creation.


Good luck and happy coding!

## Resources

* [From Nand To Tetris](https://www.nand2tetris.org)

## Further Reading

* [Hardware Description Language](https://en.wikipedia.org/wiki/Hardware_description_language)

* [HDL Programming Fundamentals](https://www.electronicdesign.com/products/hdl-programming-fundamentals)"
"Self is a fast prototype based OO language which runs in its own JIT vm. Most development is done through interacting with live objects through a visual development environment called *morphic* with integrated browsers and debugger.

Everything in Self is an object. All computation is done by sending messages to objects. Objects in Self can be understood as sets of key-value slots.

# Constructing objects

The inbuild Self parser can construct objects, including method objects.

```
""This is a comment""

""A string:""
'This is a string with \'escaped\' characters.\n'

""A 30 bit integer""
23

""A 30 bit float""
3.2

""-20""
-14r16

""An object which only understands one message, 'x' which returns 20""
(|
  x = 20.
|)

""An object which also understands 'x:' which sets the x slot""
(|
  x <- 20.
|)

""An object which understands the method 'doubleX' which
doubles the value of x and then returns the object""
(|
  x <- 20.
  doubleX = (x: x * 2. self)
|)

""An object which understands all the messages
that 'traits point' understands"". The parser
looks up 'traits point' by sending the messages
'traits' then 'point' to a known object called
the 'lobby'. It looks up the 'true' object by
also sending the message 'true' to the lobby.""
(|     parent* = traits point.
       x = 7.
       y <- 5.
       isNice = true.
|)
```

# Sending messages to objects

Messages can either be unary, binary or keyword. Precedence is in that order. Unlike Smalltalk, the precedence of binary messages must be specified, and all keywords after the first must start with a capital letter. Messages are separated from their destination by whitespace.

```
""unary message, sends 'printLine' to the object '23'
which prints the string '23' to stdout and returns the receiving object (ie 23)""
23 printLine

""sends the message '+' with '7' to '23', then the message '*' with '8' to the result""
(23 + 7) * 8

""sends 'power:' to '2' with '8' returns 256""
2 power: 8

""sends 'keyOf:IfAbsent:' to 'hello' with arguments 'e' and '-1'.
Returns 1, the index of 'e' in 'hello'.""
'hello' keyOf: 'e' IfAbsent: -1
```

# Blocks

Self defines flow control like Smalltalk and Ruby by way of blocks. Blocks are delayed computations of the form:

```
[|:x. localVar| x doSomething with: localVar]
```

Examples of the use of a block:

```
""returns 'HELLO'""
'hello' copyMutable mapBy: [|:c| c capitalize]

""returns 'Nah'""
'hello' size > 5 ifTrue: ['Yay'] False: ['Nah']

""returns 'HaLLO'""
'hello' copyMutable mapBy: [|:c|
   c = 'e' ifTrue: [c capitalize]
            False: ['a']]
```

Multiple expressions are separated by a period. ^ returns immediately.

```
""returns An 'E'! How icky!""
'hello' copyMutable mapBy: [|:c. tmp <- ''|
   tmp: c capitalize.
   tmp = 'E' ifTrue: [^ 'An \'E\'! How icky!'].
   c capitalize
   ]
```

Blocks are performed by sending them the message 'value' and inherit (delegate to) their contexts:
```
""returns 0""
[|x|
    x: 15.
    ""Repeatedly sends 'value' to the first block while the result of sending 'value' to the
     second block is the 'true' object""
    [x > 0] whileTrue: [x: x - 1].
    x
] value
```

# Methods

Methods are like blocks but they are not within a context but instead are stored as values of slots. Unlike Smalltalk, methods by default return their final value not 'self'.

```
""Here is an object with one assignable slot 'x' and a method 'reduceXTo: y'.
Sending the message 'reduceXTo: 10' to this object will put
the object '10' in the 'x' slot and return the original object""
(|
    x <- 50.
    reduceXTo: y = (
        [x > y] whileTrue: [x: x - 1].
        self)
|)
.
```

# Prototypes

Self has no classes. The way to get an object is to find a prototype and copy it.

```
| d |
d: dictionary copy.
d at: 'hello' Put: 23 + 8.
d at: 'goodbye' Put: 'No!.
""Prints No!""
( d at: 'goodbye' IfAbsent: 'Yes! ) printLine.
""Prints 31""
( d at: 'hello' IfAbsent: -1 ) printLine.
```

# Further information

The [Self handbook](http://handbook.selflanguage.org) has much more information, and nothing beats hand-on experience with Self by downloading it from the [homepage](http://www.selflanguage.org)."
"## Getting Started with Compojure

Compojure is a DSL for *quickly* creating *performant* web applications
in Clojure with minimal effort:

```clojure
(ns myapp.core
  (:require [compojure.core :refer :all]
            [org.httpkit.server :refer [run-server]])) ; httpkit is a server

(defroutes myapp
  (GET ""/"" [] ""Hello World""))

(defn -main []
  (run-server myapp {:port 5000}))
```

**Step 1:** Create a project with [Leiningen](http://leiningen.org/):

```
lein new myapp
```

**Step 2:** Put the above code in `src/myapp/core.clj`

**Step 3:** Add some dependencies to `project.clj`:

```
[compojure ""1.1.8""]
[http-kit ""2.1.16""]
```

**Step 4:** Run:

```
lein run -m myapp.core
```

View at: <http://localhost:5000/>

Compojure apps will run on any ring-compatible server, but we recommend
[http-kit](http://http-kit.org/) for its performance and
[massive concurrency](http://http-kit.org/600k-concurrent-connection-http-kit.html).

### Routes

In compojure, each route is an HTTP method paired with a URL-matching pattern,
an argument list, and a body.

```clojure
(defroutes myapp
  (GET ""/"" [] ""Show something"")
  (POST ""/"" [] ""Create something"")
  (PUT ""/"" [] ""Replace something"")
  (PATCH ""/"" [] ""Modify Something"")
  (DELETE ""/"" [] ""Annihilate something"")
  (OPTIONS ""/"" [] ""Appease something"")
  (HEAD ""/"" [] ""Preview something""))
```

Compojure route definitions are just functions which
[accept request maps and return response maps](https://github.com/mmcgrana/ring/blob/master/SPEC):

```clojure
(myapp {:uri ""/"" :request-method :post})
; => {:status 200
;     :headers {""Content-Type"" ""text/html; charset=utf-8}
;     :body ""Create Something""}
```

The body may be a function, which must accept the request as a parameter:

```clojure
(defroutes myapp
  (GET ""/"" [] (fn [req] ""Do something with req"")))
```

Or, you can just use the request directly:

```clojure
(defroutes myapp
  (GET ""/"" req ""Do something with req""))
```

Route patterns may include named parameters:

```clojure
(defroutes myapp
  (GET ""/hello/:name"" [name] (str ""Hello "" name)))
```

You can adjust what each parameter matches by supplying a regex:

```clojure
(defroutes myapp
  (GET [""/file/:name.:ext"" :name #"".*"", :ext #"".*""] [name ext]
    (str ""File: "" name ext)))
```

### Middleware

Clojure uses [Ring](https://github.com/ring-clojure/ring) for routing.
Handlers are just functions that accept a request map and return a
response map (Compojure will turn strings into 200 responses for you).

You can easily write middleware that wraps all or part of your
application to modify requests or responses:

```clojure
(defroutes myapp
  (GET ""/"" req (str ""Hello World v"" (:app-version req))))

(defn wrap-version [handler]
  (fn [request]
    (handler (assoc request :app-version ""1.0.1""))))

(defn -main []
  (run-server (wrap-version myapp) {:port 5000}))
```

[Ring-Defaults](https://github.com/ring-clojure/ring-defaults) provides some handy
middlewares for sites and apis, so add it to your dependencies:

```
[ring/ring-defaults ""0.1.1""]
```

Then, you can import it in your ns:

```
(ns myapp.core
  (:require [compojure.core :refer :all]
            [ring.middleware.defaults :refer :all]
            [org.httpkit.server :refer [run-server]]))
```

And use `wrap-defaults` to add the `site-defaults` middleware to your
app:

```
(defn -main []
  (run-server (wrap-defaults myapp site-defaults) {:port 5000}))
```

Now, your handlers may utilize query parameters:

```clojure
(defroutes myapp
  (GET ""/posts"" req
    (let [title (get (:params req) :title)
          author (get (:params req) :author)]
      (str ""Title: "" title "", Author: "" author))))
```

Or, for POST and PUT requests, form parameters as well

```clojure
(defroutes myapp
  (POST ""/posts"" req
    (let [title (get (:params req) :title)
          author (get (:params req) :author)]
      (str ""Title: "" title "", Author: "" author))))
```


### Return values

The return value of a route block determines the response body
passed on to the HTTP client, or at least the next middleware in the
ring stack. Most commonly, this is a string, as in the above examples.
But, you may also return a [response map](https://github.com/mmcgrana/ring/blob/master/SPEC):

```clojure
(defroutes myapp
  (GET ""/"" []
    {:status 200 :body ""Hello World""})
  (GET ""/is-403"" []
    {:status 403 :body """"})
  (GET ""/is-json"" []
    {:status 200 :headers {""Content-Type"" ""application/json""} :body ""{}""}))
```

### Static Files

To serve up static files, use `compojure.route.resources`.
Resources will be served from your project's `resources/` folder.

```clojure
(require '[compojure.route :as route])

(defroutes myapp
  (GET ""/"")
  (route/resources ""/"")) ; Serve static resources at the root path

(myapp {:uri ""/js/script.js"" :request-method :get})
; => Contents of resources/public/js/script.js
```

### Views / Templates

To use templating with Compojure, you'll need a template library. Here are a few:

#### [Stencil](https://github.com/davidsantiago/stencil)

[Stencil](https://github.com/davidsantiago/stencil) is a [Mustache](http://mustache.github.com/) template library:

```clojure
(require '[stencil.core :refer [render-string]])

(defroutes myapp
  (GET ""/hello/:name"" [name]
    (render-string ""Hello {{name}}"" {:name name})))
```

You can easily read in templates from your resources directory. Here's a helper function

```clojure
(require 'clojure.java.io)

(defn read-template [filename]
  (slurp (clojure.java.io/resource filename)))

(defroutes myapp
  (GET ""/hello/:name"" [name]
    (render-string (read-template ""templates/hello.html"") {:name name})))
```

#### [Selmer](https://github.com/yogthos/Selmer)

[Selmer](https://github.com/yogthos/Selmer) is a Django and Jinja2-inspired templating language:

```clojure
(require '[selmer.parser :refer [render-file]])

(defroutes myapp
  (GET ""/hello/:name"" [name]
    (render-file ""templates/hello.html"" {:name name})))
```

#### [Hiccup](https://github.com/weavejester/hiccup)

[Hiccup](https://github.com/weavejester/hiccup) is a library for representing HTML as Clojure code

```clojure
(require '[hiccup.core :as hiccup])

(defroutes myapp
  (GET ""/hello/:name"" [name]
    (hiccup/html
      [:html
        [:body
          [:h1 {:class ""title""}
            (str ""Hello "" name)]]])))
```

#### [Markdown](https://github.com/yogthos/markdown-clj)

[Markdown-clj](https://github.com/yogthos/markdown-clj) is a Markdown implementation.

```clojure
(require '[markdown.core :refer [md-to-html-string]])

(defroutes myapp
  (GET ""/hello/:name"" [name]
    (md-to-html-string ""## Hello, world"")))
```

Further reading:

* [Official Compojure Documentation](https://github.com/weavejester/compojure/wiki)

* [Clojure for the Brave and True](http://www.braveclojure.com/)"
"Prolog is a logic programming language first specified in 1972, and refined into multiple modern implementations.

```
% This is a comment.

% Prolog treats code entered in interactive mode differently
% to code entered in a file and loaded (""consulted"").
% This code must be loaded from a file to work as intended.
% Lines that begin with ?- can be typed in interactive mode.
% A bunch of errors and warnings will trigger when you load this file
% due to the examples which are supposed to fail - they can be safely
% ignored.

% Output is based on SWI-prolog 7.2.3. Different Prologs may behave
% differently.

% Prolog is based on the ideal of logic programming.
% A subprogram (called a predicate) represents a state of the world.
% A command (called a goal) tells Prolog to make that state of the world
%   come true, if possible.

% As an example, here is a definition of the simplest kind of predicate:
% a fact.

magicNumber(7).
magicNumber(9).
magicNumber(42).

% This introduces magicNumber as a predicate and says that it is true
% with parameter 7, 9, or 42, but no other parameter. Note that
% predicate names must start with lower case letters. We can now use
% interactive mode to ask if it is true for different values:

?- magicNumber(7).                   % True
?- magicNumber(8).                   % False
?- magicNumber(9).                   % True

% Some older Prologs may display ""Yes"" and ""No"" instead of True and
% False.

% What makes Prolog unusual is that we can also tell Prolog to _make_
% magicNumber true, by passing it an undefined variable. Any name
% starting with a capital letter is a variable in Prolog.

?- magicNumber(Presto).              % Presto = 7 ;
                                     % Presto = 9 ;
                                     % Presto = 42.

% Prolog makes magicNumber true by assigning one of the valid numbers to
% the undefined variable Presto. By default it assigns the first one, 7.
% By pressing ; in interactive mode you can reject that solution and
% force it to assign the next one, 9. Pressing ; again forces it to try
% the last one, 42, after which it no longer accepts input because this
% is the last solution. You can accept an earlier solution by pressing .
% instead of ;.

% This is Prolog's central operation: unification. Unification is
% essentially a combination of assignment and equality! It works as
% follows:
%  If both sides are bound (ie, defined), check equality.
%  If one side is free (ie, undefined), assign to match the other side.
%  If both sides are free, the assignment is remembered. With some luck,
%    one of the two sides will eventually be bound, but this isn't
%    necessary.
%
% The = sign in Prolog represents unification, so:

?- 2 = 3.                            % False - equality test
?- X = 3.                            % X = 3 - assignment
?- X = 2, X = Y.                     % X = Y = 2 - two assignments
                                     % Note Y is assigned too, even though it is
                                     % on the right hand side, because it is free
?- X = 3, X = 2.                     % False
                                     % First acts as assignment and binds X=3
                                     % Second acts as equality because X is bound
                                     % Since 3 does not equal 2, gives False
                                     % Thus in Prolog variables are immutable
?- X = 3+2.                          % X = 3+2 - unification can't do arithmetic
?- X is 3+2.                         % X = 5 - ""is"" does arithmetic.
?- 5 = X+2.                          % This is why = can't do arithmetic -
                                     % because Prolog can't solve equations
?- 5 is X+2.                         % Error. Unlike =, the right hand side of IS
                                     % must always be bound, thus guaranteeing
                                     % no attempt to solve an equation.
?- X = Y, X = 2, Z is Y + 3.         % X = Y, Y = 2, Z = 5.
                                     % X = Y are both free, so Prolog remembers
                                     % it. Therefore assigning X will also
                                     % assign Y.

% Any unification, and thus any predicate in Prolog, can either:
% Succeed (return True) without changing anything,
%   because an equality-style unification was true
% Succeed (return True) and bind one or more variables in the process,
%   because an assignment-style unification was made true
% or Fail (return False)
%   because an equality-style unification was false
% (Failure can never bind variables)

% The ideal of being able to give any predicate as a goal and have it
% made true is not always possible, but can be worked toward. For
% example, Prolog has a built in predicate plus which represents
% arithmetic addition but can reverse simple additions.

?- plus(1, 2, 3).                    % True
?- plus(1, 2, X).                    % X = 3 because 1+2 = X.
?- plus(1, X, 3).                    % X = 2 because 1+X = 3.
?- plus(X, 2, 3).                    % X = 1 because X+2 = 3.
?- plus(X, 5, Y).                    % Error - although this could be solved,
                                     % the number of solutions is infinite,
                                     % which most predicates try to avoid.

% When a predicate such as magicNumber can give several solutions, the
% overall compound goal including it may have several solutions too.

?- magicNumber(X), plus(X,Y,100).    % X = 7, Y = 93 ;
                                     % X = 9, Y = 91 ;
                                     % X = 42, Y = 58 .
% Note: on this occasion it works to pass two variables to plus because
% only Y is free (X is bound by magicNumber).

% However, if one of the goals is fully bound and thus acts as a test,
% then solutions which fail the test are rejected.
?- magicNumber(X), X > 40.           % X = 42
?- magicNumber(X), X > 100.          % False

% To see how Prolog actually handles this, let's introduce the print
% predicate. Print always succeeds, never binds any variables, and
% prints out its parameter as a side effect.

?- print(""Hello"").                   % ""Hello"" true.
?- X = 2, print(X).                  % 2 true.
?- X = 2, print(X), X = 3.           % 2 false - print happens immediately when
                                     % it is encountered, even though the overall
                                     % compound goal fails (because 2 != 3,
                                     % see the example above).

% By using Print we can see what actually happens when we give a
% compound goal including a test that sometimes fails.
?- magicNumber(X), print(X), X > 40. % 7 9 42 X = 42 .

% MagicNumber(X) unifies X with its first possibility, 7.
% Print(X) prints out 7.
% X > 40 tests if 7 > 40. It is not, so it fails.
% However, Prolog remembers that magicNumber(X) offered multiple
% solutions. So it _backtracks_ to that point in the code to try
% the next solution, X = 9.
% Having backtracked it must work through the compound goal
% again from that point including the Print(X). So Print(X) prints out
% 9.
% X > 40 tests if 9 > 40 and fails again.
% Prolog remembers that magicNumber(X) still has solutions and
% backtracks. Now X = 42.
% It works through the Print(X) again and prints 42.
% X > 40 tests if 42 > 40 and succeeds so the result bound to X
% The same backtracking process is used when you reject a result at
% the interactive prompt by pressing ;, for example:

?- magicNumber(X), print(X), X > 8.  % 7 9 X = 9 ;
                                     % 42 X = 42.

% As you saw above we can define our own simple predicates as facts.
% More complex predicates are defined as rules, like this:

nearby(X,Y) :- X = Y.
nearby(X,Y) :- Y is X+1.
nearby(X,Y) :- Y is X-1.

% nearby(X,Y) is true if Y is X plus or minus 1.
% However this predicate could be improved. Here's why:

?- nearby(2,3).                      % True ; False.
% Because we have three possible definitions, Prolog sees this as 3
% possibilities. X = Y fails, so Y is X+1 is then tried and succeeds,
% giving the True answer. But Prolog still remembers there are more
% possibilities for nearby() (in Prolog terminology, ""it has a
% choice point"") even though ""Y is X-1"" is doomed to fail, and gives us
% the option of rejecting the True answer, which doesn't make a whole
% lot of sense.

?- nearby(4, X).                     % X = 4 ;
                                     % X = 5 ;
                                     % X = 3. Great, this works
?- nearby(X, 4).                     % X = 4 ;
                                     % error
% After rejecting X = 4 prolog backtracks and tries ""Y is X+1"" which is
% ""4 is X+1"" after substitution of parameters. But as we know from above
% ""is"" requires its argument to be fully instantiated and it is not, so
% an error occurs.

% One way to solve the first problem is to use a construct called the
% cut, !, which does nothing but which cannot be backtracked past.

nearbychk(X,Y) :- X = Y, !.
nearbychk(X,Y) :- Y is X+1, !.
nearbychk(X,Y) :- Y is X-1.

% This solves the first problem:
?- nearbychk(2,3).                   % True.

% But unfortunately it has consequences:
?- nearbychk(2,X).                   % X = 2.
% Because Prolog cannot backtrack past the cut after X = Y, it cannot
% try the possibilities ""Y is X+1"" and ""Y is X-1"", so it only generates
% one solution when there should be 3.
% However if our only interest is in checking if numbers are nearby,
% this may be all we need, thus the name nearbychk.
% This structure is used in Prolog itself from time to time (for example
% in list membership).

% To solve the second problem we can use built-in predicates in Prolog
% to verify if a parameter is bound or free and adjust our calculations
% appropriately.
nearby2(X,Y) :- nonvar(X), X = Y.
nearby2(X,Y) :- nonvar(X), Y is X+1.
nearby2(X,Y) :- nonvar(X), Y is X-1.
nearby2(X,Y) :- var(X), nonvar(Y), nearby2(Y,X).

% We can combine this with a cut in the case where both variables are
% bound, to solve both problems.
nearby3(X,Y) :- nonvar(X), nonvar(Y), nearby2(X,Y), !.
nearby3(X,Y) :- nearby2(X,Y).

% However when writing a predicate it is not normally necessary to go to
% these lengths to perfectly support every possible parameter
% combination. It suffices to support parameter combinations we need to
% use in the program. It is a good idea to document which combinations
% are supported. In regular Prolog this is informally in structured
% comments, but in some Prolog variants like Visual Prolog and Mercury
% this is mandatory and checked by the compiler.

% Here is the structured comment declaration for nearby3:

%!    nearby3(+X:Int, +Y:Int) is semideterministic.
%!    nearby3(+X:Int, -Y:Int) is multi.
%!    nearby3(-X:Int, +Y:Int) is multi.

% For each variable we list a type. The + or - before the variable name
% indicates if the parameter is bound (+) or free (-). The word after
% ""is"" describes the behaviour of the predicate:
%   semideterministic - can succeed once or fail
%     ( Two specific numbers are either nearby or not )
%   multi - can succeed multiple times but cannot fail
%     ( One number surely has at least 3 nearby numbers )
%  Other possibilities are:
%    det - always succeeds exactly once (eg, print)
%    nondet - can succeed multiple times or fail.
% In Prolog these are just structured comments and strictly informal but
% extremely useful.

% An unusual feature of Prolog is its support for atoms. Atoms are
% essentially members of an enumerated type that are created on demand
% whenever an unquoted non variable value is used. For example:
character(batman).            % Creates atom value batman
character(robin).             % Creates atom value robin
character(joker).             % Creates atom value joker
character(darthVader).        % Creates atom value darthVader
?- batman = batman.           % True - Once created value is reused
?- batman = batMan.           % False - atoms are case sensitive
?- batman = darthVader.       % False - atoms are distinct

% Atoms are popular in examples but were created on the assumption that
% Prolog would be used interactively by end users - they are less
% useful for modern applications and some Prolog variants abolish them
% completely. However they can be very useful internally.

% Loops in Prolog are classically written using recursion.
% Note that below, writeln is used instead of print because print is
% intended for debugging.

%!    countTo(+X:Int) is deterministic.
%!    countUpTo(+Value:Int, +Limit:Int) is deterministic.
countTo(X) :- countUpTo(1,X).
countUpTo(Value, Limit) :- Value = Limit, writeln(Value), !.
countUpTo(Value, Limit) :- Value \= Limit, writeln(Value),
    NextValue is Value+1,
    countUpTo(NextValue, Limit).

?- countTo(10).                      % Outputs 1 to 10

% Note the use of multiple declarations in countUpTo to create an
% IF test. If Value = Limit fails the second declaration is run.
% There is also a more elegant syntax.

%!    countUpTo2(+Value:Int, +Limit:Int) is deterministic.
countUpTo2(Value, Limit) :- writeln(Value),
    Value = Limit -> true ; (
        NextValue is Value+1,
        countUpTo2(NextValue, Limit)).

?- countUpTo2(1,10).                 % Outputs 1 to 10

% If a predicate returns multiple times it is often useful to loop
% through all the values it returns. Older Prologs used a hideous syntax
% called a ""failure-driven loop"" to do this, but newer ones use a higher
% order function.

%!    countTo2(+X:Int) is deterministic.
countTo2(X) :- forall(between(1,X,Y),writeln(Y)).

?- countTo2(10).                     % Outputs 1 to 10

% Lists are given in square brackets. Use memberchk to check membership.
% A group is safe if it doesn't include Joker or does include Batman.

%!     safe(Group:list(atom)) is deterministic.
safe(Group) :- memberchk(joker, Group) -> memberchk(batman, Group) ; true.

?- safe([robin]).                    % True
?- safe([joker]).                    % False
?- safe([joker, batman]).            % True

% The member predicate works like memberchk if both arguments are bound,
% but can accept free variables and thus can be used to loop through
% lists.

?- member(X, [1,2,3]).               % X = 1 ; X = 2 ; X = 3 .
?- forall(member(X,[1,2,3]),
       (Y is X+1, writeln(Y))).      % 2 3 4

% The maplist function can be used to generate lists based on other
% lists. Note that the output list is a free variable, causing an
% undefined value to be passed to plus, which is then bound by
% unification. Also notice the use of currying on the plus predicate -
% it's a 3 argument predicate, but we specify only the first, because
% the second and third are filled in by maplist.

?- maplist(plus(1), [2,3,4], Output).   % Output = [3, 4, 5].
```

##Ready For More?

* [SWI-Prolog](http://www.swi-prolog.org/)"
"[Hack](https://hacklang.org/) lets you write code quickly, while also having safety features built in, like static typechecking.

To run Hack code, [install HHVM](https://docs.hhvm.com/hhvm/installation/introduction), the open-source virtual machine.

```php
/* ==================================
 *           READ THE DOCS!
 * ==================================
 */

/* For more information on the Hack language:
 * - About Hack: https://hacklang.org/
 * - Documentation: https://docs.hhvm.com/hack/
 */

/* ==================================
 *           A NOTE ON PHP
 * ==================================
 */

// The Hack language began as a superset of PHP.
// Since then, the languages have (largely) diverged.
// You may encounter the .php extension, which is no longer recommended.

/* ==================================
 *              COMMENTS
 * ==================================
 */

// Hack has single-line comments...

/* Multi-line comments...
 *
 */

/**
 * ... and a special syntax for doc comments.
 *
 * Use doc comments to summarize the purpose of a definition, function, class or method.
 */

/* ==================================
 *             NAMESPACES
 * ==================================
 */

// Namespaces contain definitions of classes, interfaces, traits, functions, and constants.

namespace LearnHackinYMinutes {

  /* ==================================
   *                TYPES
   * ==================================
   */

  function demo_hack_types(): void {

    // Hack has five primitive types: bool, int, float, string, and null.
    $is_helpful = true; // bool
    $int_value = 10; // int
    $precise_value = 2.0; // float
    $hello_world = ""Hello World!""; // string
    $null_string = null; // null

    // Create a `shape` with the shape keyword, with a series of field names and values.
    $my_point = shape('x' => -3, 'y' => 6, 'visible' => true);

    // Create a `tuple` with the tuple keyword, with a series of two or more types as values.
    $apple_basket = tuple(""apples"", 25); // different types are OK

    // Use `arraykey` to represent either an integer or string.
    $the_answer = 42;
    $is_answer = process_key($the_answer);

    // Similarly, `num` represents either an int or float.
    $lucky_number = 7;
    $lucky_square = calculate_square($lucky_number);
  }

  function process_key(arraykey $the_answer): bool {
    if ($the_answer is int) {
      return true;
    } else {
      return false;
    } // true
  }

  function calculate_square(num $arg)[]: float {
    return ((float)$arg * $arg);
  }

  // Enums are limited to int or string (as an Arraykey), or other enum values.
  enum Permission: string {
    Read = 'R';
    Write = 'W';
    Execute = 'E';
    Delete = 'D';
  }

  // In contrast, an enum class can be of any value type!
  enum class Random: mixed {
    int X = 42;
    string S = 'foo';
  }

  /* ==================================
   *            HACK ARRAYS
   * ==================================
   */

  // The following line lets us use functions in the `C\` namespace.
  use namespace HH\Lib\C; // the `C` library operates on containers

  function demo_hack_arrays(): void {

    // vec: ordered
    $v = vec[1, 2, 3];
    $letters = vec['a', 'b', 'c'];

    $letters[0]; // returns 'a'
    $letters[] = 'd'; // appends 'd'

    // `inout` provides pass-by-reference behavior
    C\pop_back(inout $letters); // removes 'd'
    C\pop_front(inout $letters); // removes 'a'

    // keyset: ordered, without duplicates
    $k = keyset[1, 2, 3]; // values must be int or string
    $colors = keyset['red', 'blue', 'green'];

    // keyset keys are identical to their values
    $colors['blue']; // returns 'blue'.

    $colors[] = 'yellow'; // appends 'yellow'
    unset($colors['red']); // removes 'red'

    //  dict: ordered, by key-value
    $d = dict['a' => 1, 'b' => 3]; // keys must be int or string
    $alphabet = dict['a' => 1, 'b' => 2];

    $alphabet['a']; // indexing at 'a' returns `1`
    $alphabet['c'] = 3; // adds a new key-value pair of `c => 3`

    unset($alphabet['b']); // removes 'b'
  }

  /* ==================================
   *  THE HACK STANDARD LIBRARY (HSL)
   * ==================================
   */

  // The Hack Standard Library is a set of functions and classes for the Hack language.
  // Namespace use declarations are ideally at the top of your file but are placed here for instruction purposes.

  use namespace HH\Lib\Str; // The `Str` library operates on strings

  function demo_hack_standard_library(): void {

    $letters = vec['a', 'b', 'c'];
    $colors = keyset['red', 'blue', 'green'];
    $alphabet = dict['a' => 1, 'b' => 2];

    C\contains($letters, 'c'); // checks for a value; returns 'true'
    C\contains($colors, 'purple'); // checks for a value; returns 'false'
    C\contains_key($alphabet, 'a'); // checks for a key; returns 'true'
    C\contains($alphabet, 'd'); // checks for a value; returns 'false'

    Str\length(""foo""); // returns `3`
    Str\join(vec['foo', 'bar', 'baz'], '!'); // returns `foo!bar!baz`
  }

  /* ==================================
   *           HELLO WORLD!
   * ==================================
   */

  use namespace HH\Lib\IO; // the `IO` library is a standard API for input / output

  <<__EntryPoint>> // required attribute for the typical entry/main function
  async function main(): Awaitable<
    void,
  > { // does not need to be named 'main' / is an asynchronous function
    await IO\request_output()->writeAllAsync(
      ""Hello World!\n"",
    ); // prints 'Hello World'!
  }

  /* ==================================
   *             FUNCTIONS
   * ==================================
   */

  // Functions are defined globally.
  // When a function is defined in a class, we refer to the function as a method.

  // Functions have return types (here: `int`) and must return a value of
  // that type or return no value when a void return type annotation was used.

  function add_one(int $x): int {
    return $x + 1;
  }

  // Functions can also have defined, default values.
  function add_value(int $x, int $y = 1): int {
    return $x + $y;
  }

  // Functions can be variadic (unspecified length of arguments).
  function sum_ints(int $val, int ...$vals): int {
    $result = $val;

    foreach ($vals as $v) {
      $result += $v;
    }
    return $result;
  }

  // Functions can also be anonymous (defined with the `==>` arrow).
  // $f = (int $x): int ==> $x + 1;

  /* ==================================
   *           PIPE OPERATOR
   * ==================================
   */

  // The pipe operator, `|>`, evaluates the result of a left-hand expression
  // and stores the result in `$$`, the predefined pipe variable.

  use namespace HH\Lib\Vec;

  function demo_pipe_operator(): void {

    Vec\sort(Vec\map(vec[2, 1, 3], $a ==> $a * $a)); // vec[1,4,9]

    // the same result, but using the pipe operator and pipe variable:
    $x = vec[2, 1, 3]
      |> Vec\map($$, $a ==> $a * $a) // $$ with value vec[2,1,3]
      |> Vec\sort($$); // $$ with value vec[4,1,9]
  }

  /* ==================================
   *             ATTRIBUTES
   * ==================================
   */

  // Hack provides built-in attributes that can change runtime or static type checking behavior.
  // For example, we used the `__EntryPoint` attribute earlier in the ""Hello World!"" example.

  // As another example, `__Memoize` caches the result of a function.
  <<__Memoize>>
  async function do_expensive_task(): Awaitable<string> {
    $site_contents = await \HH\Asio\curl_exec(""http://hacklang.org"");
    return $site_contents;
  }

  /* ==================================
   *             CONTEXTS
   * ==================================
   */

  // Hack functions are attached to different contexts and capabilities.
  // A context is a grouping of capabilities; that is, a grouping of permissions.

  // To declare allowed contexts (and capabilities), use the Context List `[]`.
  // If contexts are not defined, your function includes permissions defined in Hack's `defaults` context.

  // Because the context list is NOT defined, the `defaults` context is implicitly declared.
  async function implicit_defaults_context(): Awaitable<void> {
    await IO\request_output()->writeAllAsync(
      ""Hello World!\n"",
    ); // prints 'Hello World'!
  }

  // In the function below, the context list is defined to have the `defaults` context.
  // A function can have multiple contexts [context1, context2, ...].
  // `defaults` includes most of the capabilities defined by the Hack language.
  async function explicit_defaults_context()[defaults]: Awaitable<void> {
    await IO\request_output()->writeAllAsync(""Hello World!\n"");
  }

  // You can also specify zero contexts to create a pure function (no capabilities).
  async function empty_context()[]: Awaitable<void> {
    // The following line is an error, as the function does not have IO capabilities.
    // await IO\request_output()->writeAllAsync(""Hello World!\n"");
  }

  /* ==================================
   *             GENERICS
   * ==================================
   */

  // Generics allow classes or methods to be parameterized to any set of types.
  // That's pretty cool!

  // Hack typically passes by value: use `inout` to pass by reference.
  function swap<T>(inout T $input1, inout T $input2): void {
    $temp = $input1;
    $input1 = $input2;
    $input2 = $temp;
  }

  /* ==================================
   *             CLASSES
   * ==================================
   */

  // Classes provide a way to group functionality and state together.
  // To define a class, use the `class` keyword. To instantiate, use `new`.
  // Like other languages, you can use `$this` to refer to the current instance.

  class Counter {
    private int $i = 0;

    public function increment(): void {
      $this->i += 1;
    }

    public function get(): int {
      return $this->i;
    }
  }

  // Properties and Methods can be static (not requiring instantiation).
  class Person {
    public static function favoriteProgrammingLanguage(): string {
      return ""Hack"";
    }
  }

  function demo_hack_classes(): void {
    // Use `new` to instantiate a class.
    $c1 = new Counter();

    // To call a static property or method, use `::`
    $typical_person = tuple(""Andrew"", Person::favoriteProgrammingLanguage());
  }

  // Abstract class can be defined, but not instantiated directly.
  abstract class Machine {
    public function openDoors(): void {
      return;
    }
    public function closeDoors(): void {
      return;
    }
  }

  /* ==================================
   *             INTERFACES
   * ==================================
   */

  // A class can implement a set of requirements via an interface.
  // An interface is a set of method declarations and constants.

  interface Plane {
    // A constant is a named value. Once defined, the value cannot be changed.
    const MAX_SPEED = 300;
    public function fly(): void;
  }

  /* ==================================
   *             TRAITS
   * ==================================
   */

  // A trait defines properties and method declarations.
  // Traits are recommended when abstracting code for reuse.
  // Traits are included in code via the `use` keyword.

  trait Airplane {
    // Introduce a class or interface requirement with the following syntax:
    require extends Machine; // abstract class
    require implements Plane; // interface

    public function takeOff(): void {
      $this->openDoors();
      $this->closeDoors();
      $this->fly();
    }
  }

  class Spaceship extends Machine implements Plane {
    use Airplane;

    public function fly(): void {
      // fly like the wind
    }
  }

  /* ==================================
   *             KEEP READING!
   * ==================================
   */

  /*  This is a simplified guide!
   *  There's much more to learn, including:
   * - Asynchronous Operations: https://docs.hhvm.com/hack/asynchronous-operations/introduction
   * - Reified Generics: https://docs.hhvm.com/hack/reified-generics/reified-generics
   * - XHP: https://docs.hhvm.com/hack/XHP/setup
   * - ... and more!
   */
}

```

## More Information

Visit the [Hack language reference](http://docs.hhvm.com/hack/) to learn more about the Hack language.

For more information on HHVM, including installation instructions, visit the [official HHVM website](http://hhvm.com/)."
"Bash is a name of the unix shell, which was also distributed as the shell
for the GNU operating system and as the default shell on most Linux distros.
Nearly all examples below can be a part of a shell script
or executed directly in the shell.

[Read more here.](https://www.gnu.org/software/bash/manual/bashref.html)

```bash
#!/usr/bin/env bash
# First line of the script is the shebang which tells the system how to execute
# the script: https://en.wikipedia.org/wiki/Shebang_(Unix)
# As you already figured, comments start with #. Shebang is also a comment.

# Simple hello world example:
echo ""Hello world!"" # => Hello world!

# Each command starts on a new line, or after a semicolon:
echo ""This is the first command""; echo ""This is the second command""
# => This is the first command
# => This is the second command

# Declaring a variable looks like this:
variable=""Some string""

# But not like this:
variable = ""Some string"" # => returns error ""variable: command not found""
# Bash will decide that `variable` is a command it must execute and give an error
# because it can't be found.

# Nor like this:
variable= ""Some string"" # => returns error: ""Some string: command not found""
# Bash will decide that ""Some string"" is a command it must execute and give an
# error because it can't be found. In this case the ""variable="" part is seen
# as a variable assignment valid only for the scope of the ""Some string""
# command.

# Using the variable:
echo ""$variable"" # => Some string
echo '$variable' # => $variable
# When you use a variable itself — assign it, export it, or else — you write
# its name without $. If you want to use the variable's value, you should use $.
# Note that ' (single quote) won't expand the variables!
# You can write variable without surrounding quotes but it's not recommended.

# Parameter expansion ${...}:
echo ""${variable}"" # => Some string
# This is a simple usage of parameter expansion such as two examples above.
# Parameter expansion gets a value from a variable.
# It ""expands"" or prints the value.
# During the expansion time the value or parameter can be modified.
# Below are other modifications that add onto this expansion.

# String substitution in variables:
echo ""${variable/Some/A}"" # => A string
# This will substitute the first occurrence of ""Some"" with ""A"".

# Substring from a variable:
length=7
echo ""${variable:0:length}"" # => Some st
# This will return only the first 7 characters of the value
echo ""${variable: -5}"" # => tring
# This will return the last 5 characters (note the space before -5).
# The space before minus is mandatory here.

# String length:
echo ""${#variable}"" # => 11

# Indirect expansion:
other_variable=""variable""
echo ${!other_variable} # => Some string
# This will expand the value of `other_variable`.

# The default value for variable:
echo ""${foo:-""DefaultValueIfFooIsMissingOrEmpty""}""
# => DefaultValueIfFooIsMissingOrEmpty
# This works for null (foo=) and empty string (foo=""""); zero (foo=0) returns 0.
# Note that it only returns default value and doesn't change variable value.

# Declare an array with 6 elements:
array=(one two three four five six)
# Print the first element:
echo ""${array[0]}"" # => ""one""
# Print all elements:
echo ""${array[@]}"" # => ""one two three four five six""
# Print the number of elements:
echo ""${#array[@]}"" # => ""6""
# Print the number of characters in third element
echo ""${#array[2]}"" # => ""5""
# Print 2 elements starting from fourth:
echo ""${array[@]:3:2}"" # => ""four five""
# Print all elements each of them on new line.
for item in ""${array[@]}""; do
    echo ""$item""
done

# Built-in variables:
# There are some useful built-in variables, like:
echo ""Last program's return value: $?""
echo ""Script's PID: $$""
echo ""Number of arguments passed to script: $#""
echo ""All arguments passed to script: $@""
echo ""Script's arguments separated into different variables: $1 $2...""

# Brace Expansion {...}
# used to generate arbitrary strings:
echo {1..10} # => 1 2 3 4 5 6 7 8 9 10
echo {a..z} # => a b c d e f g h i j k l m n o p q r s t u v w x y z
# This will output the range from the start value to the end value.
# Note that you can't use variables here:
from=1
to=10
echo {$from..$to} # => {$from..$to}

# Now that we know how to echo and use variables,
# let's learn some of the other basics of Bash!

# Our current directory is available through the command `pwd`.
# `pwd` stands for ""print working directory"".
# We can also use the built-in variable `$PWD`.
# Observe that the following are equivalent:
echo ""I'm in $(pwd)"" # execs `pwd` and interpolates output
echo ""I'm in $PWD"" # interpolates the variable

# If you get too much output in your terminal, or from a script, the command
# `clear` clears your screen:
clear
# Ctrl-L also works for clearing output.

# Reading a value from input:
echo ""What's your name?""
read name
# Note that we didn't need to declare a new variable.
echo ""Hello, $name!""

# We have the usual if structure.
# Condition is true if the value of $name is not equal to the current user's login username:
if [[ ""$name"" != ""$USER"" ]]; then
    echo ""Your name isn't your username""
else
    echo ""Your name is your username""
fi

# To use && and || with if statements, you need multiple pairs of square brackets:
read age
if [[ ""$name"" == ""Steve"" ]] && [[ ""$age"" -eq 15 ]]; then
    echo ""This will run if $name is Steve AND $age is 15.""
fi

if [[ ""$name"" == ""Daniya"" ]] || [[ ""$name"" == ""Zach"" ]]; then
    echo ""This will run if $name is Daniya OR Zach.""
fi
# There are other comparison operators for numbers listed below:
# -ne - not equal
# -lt - less than
# -gt - greater than
# -le - less than or equal to
# -ge - greater than or equal to

# There is also the `=~` operator, which tests a string against the Regex pattern:
email=me@example.com
if [[ ""$email"" =~ [a-z]+@[a-z]{2,}\.(com|net|org) ]]
then
    echo ""Valid email!""
fi

# There is also conditional execution
echo ""Always executed"" || echo ""Only executed if first command fails""
# => Always executed
echo ""Always executed"" && echo ""Only executed if first command does NOT fail""
# => Always executed
# => Only executed if first command does NOT fail

# A single ampersand & after a command runs it in the background. A background command's
# output is printed to the terminal, but it cannot read from the input.
sleep 30 &
# List background jobs
jobs # => [1]+  Running                 sleep 30 &
# Bring the background job to the foreground
fg
# Ctrl-C to kill the process, or Ctrl-Z to pause it
# Resume a background process after it has been paused with Ctrl-Z
bg
# Kill job number 2
kill %2
# %1, %2, etc. can be used for fg and bg as well

# Redefine command `ping` as alias to send only 5 packets
alias ping='ping -c 5'
# Escape the alias and use command with this name instead
\ping 192.168.1.1
# Print all aliases
alias -p

# Expressions are denoted with the following format:
echo $(( 10 + 5 )) # => 15

# Unlike other programming languages, bash is a shell so it works in the context
# of a current directory. You can list files and directories in the current
# directory with the ls command:
ls # Lists the files and subdirectories contained in the current directory

# This command has options that control its execution:
ls -l # Lists every file and directory on a separate line
ls -t # Sorts the directory contents by last-modified date (descending)
ls -R # Recursively `ls` this directory and all of its subdirectories

# Results (stdout) of the previous command can be passed as input (stdin) to the next command
# using a pipe |. Commands chained in this way are called a ""pipeline"", and are run concurrently.
# The `grep` command filters the input with provided patterns.
# That's how we can list .txt files in the current directory:
ls -l | grep ""\.txt""

# Use `cat` to print files to stdout:
cat file.txt

# We can also read the file using `cat`:
Contents=$(cat file.txt)
# ""\n"" prints a new line character
# ""-e"" to interpret the newline escape characters as escape characters
echo -e ""START OF FILE\n$Contents\nEND OF FILE""
# => START OF FILE
# => [contents of file.txt]
# => END OF FILE

# Use `cp` to copy files or directories from one place to another.
# `cp` creates NEW versions of the sources,
# so editing the copy won't affect the original (and vice versa).
# Note that it will overwrite the destination if it already exists.
cp srcFile.txt clone.txt
cp -r srcDirectory/ dst/ # recursively copy

# Look into `scp` or `sftp` if you plan on exchanging files between computers.
# `scp` behaves very similarly to `cp`.
# `sftp` is more interactive.

# Use `mv` to move files or directories from one place to another.
# `mv` is similar to `cp`, but it deletes the source.
# `mv` is also useful for renaming files!
mv s0urc3.txt dst.txt # sorry, l33t hackers...

# Since bash works in the context of a current directory, you might want to
# run your command in some other directory. We have cd for changing location:
cd ~    # change to home directory
cd      # also goes to home directory
cd ..   # go up one directory
        # (^^say, from /home/username/Downloads to /home/username)
cd /home/username/Documents   # change to specified directory
cd ~/Documents/..    # now in home directory (if ~/Documents exists)
cd -    # change to last directory
# => /home/username/Documents

# Use subshells to work across directories
(echo ""First, I'm here: $PWD"") && (cd someDir; echo ""Then, I'm here: $PWD"")
pwd # still in first directory

# Use `mkdir` to create new directories.
mkdir myNewDir
# The `-p` flag causes new intermediate directories to be created as necessary.
mkdir -p myNewDir/with/intermediate/directories
# if the intermediate directories didn't already exist, running the above
# command without the `-p` flag would return an error

# You can redirect command input and output (stdin, stdout, and stderr)
# using ""redirection operators"". Unlike a pipe, which passes output to a command,
# a redirection operator has a command's input come from a file or stream, or
# sends its output to a file or stream.

# Read from stdin until ^EOF$ and overwrite hello.py with the lines
# between ""EOF"" (which are called a ""here document""):
cat > hello.py << EOF
#!/usr/bin/env python
from __future__ import print_function
import sys
print(""#stdout"", file=sys.stdout)
print(""#stderr"", file=sys.stderr)
for line in sys.stdin:
    print(line, file=sys.stdout)
EOF
# Variables will be expanded if the first ""EOF"" is not quoted

# Run the hello.py Python script with various stdin, stdout, and
# stderr redirections:
python hello.py < ""input.in"" # pass input.in as input to the script

python hello.py > ""output.out"" # redirect output from the script to output.out

python hello.py 2> ""error.err"" # redirect error output to error.err

python hello.py > ""output-and-error.log"" 2>&1
# redirect both output and errors to output-and-error.log
# &1 means file descriptor 1 (stdout), so 2>&1 redirects stderr (2) to the current
# destination of stdout (1), which has been redirected to output-and-error.log.

python hello.py > /dev/null 2>&1
# redirect all output and errors to the black hole, /dev/null, i.e., no output

# The output error will overwrite the file if it exists,
# if you want to append instead, use "">>"":
python hello.py >> ""output.out"" 2>> ""error.err""

# Overwrite output.out, append to error.err, and count lines:
info bash 'Basic Shell Features' 'Redirections' > output.out 2>> error.err
wc -l output.out error.err

# Run a command and print its file descriptor (e.g. /dev/fd/123)
# see: man fd
echo <(echo ""#helloworld"")

# Overwrite output.out with ""#helloworld"":
cat > output.out <(echo ""#helloworld"")
echo ""#helloworld"" > output.out
echo ""#helloworld"" | cat > output.out
echo ""#helloworld"" | tee output.out >/dev/null

# Cleanup temporary files verbosely (add '-i' for interactive)
# WARNING: `rm` commands cannot be undone
rm -v output.out error.err output-and-error.log
rm -r tempDir/ # recursively delete
# You can install the `trash-cli` Python package to have `trash`
# which puts files in the system trash and doesn't delete them directly
# see https://pypi.org/project/trash-cli/ if you want to be careful

# Commands can be substituted within other commands using $( ):
# The following command displays the number of files and directories in the
# current directory.
echo ""There are $(ls | wc -l) items here.""

# The same can be done using backticks `` but they can't be nested -
# the preferred way is to use $( ).
echo ""There are `ls | wc -l` items here.""

# Bash uses a `case` statement that works similarly to switch in Java and C++:
case ""$Variable"" in
    # List patterns for the conditions you want to meet
    0) echo ""There is a zero."";;
    1) echo ""There is a one."";;
    *) echo ""It is not null."";;  # match everything
esac

# `for` loops iterate for as many arguments given:
# The contents of $Variable is printed three times.
for Variable in {1..3}
do
    echo ""$Variable""
done
# => 1
# => 2
# => 3


# Or write it the ""traditional for loop"" way:
for ((a=1; a <= 3; a++))
do
    echo $a
done
# => 1
# => 2
# => 3

# They can also be used to act on files..
# This will run the command `cat` on file1 and file2
for Variable in file1 file2
do
    cat ""$Variable""
done

# ..or the output from a command
# This will `cat` the output from `ls`.
for Output in $(ls)
do
    cat ""$Output""
done

# Bash can also accept patterns, like this to `cat`
# all the Markdown files in current directory
for Output in ./*.markdown
do
    cat ""$Output""
done

# while loop:
while [ true ]
do
    echo ""loop body here...""
    break
done
# => loop body here...

# You can also define functions
# Definition:
function foo ()
{
    echo ""Arguments work just like script arguments: $@""
    echo ""And: $1 $2...""
    echo ""This is a function""
    returnValue=0    # Variable values can be returned
    return $returnValue
}
# Call the function `foo` with two arguments, arg1 and arg2:
foo arg1 arg2
# => Arguments work just like script arguments: arg1 arg2
# => And: arg1 arg2...
# => This is a function
# Return values can be obtained with $?
resultValue=$?
# More than 9 arguments are also possible by using braces, e.g. ${10}, ${11}, ...

# or simply
bar ()
{
    echo ""Another way to declare functions!""
    return 0
}
# Call the function `bar` with no arguments:
bar # => Another way to declare functions!

# Calling your function
foo ""My name is"" $Name

# There are a lot of useful commands you should learn:
# prints last 10 lines of file.txt
tail -n 10 file.txt

# prints first 10 lines of file.txt
head -n 10 file.txt

# print file.txt's lines in sorted order
sort file.txt

# report or omit repeated lines, with -d it reports them
uniq -d file.txt

# prints only the first column before the ',' character
cut -d ',' -f 1 file.txt

# replaces every occurrence of 'okay' with 'great' in file.txt
# (regex compatible)
sed -i 's/okay/great/g' file.txt
# be aware that this -i flag means that file.txt will be changed
# -i or --in-place erase the input file (use --in-place=.backup to keep a back-up)

# print to stdout all lines of file.txt which match some regex
# The example prints lines which begin with ""foo"" and end in ""bar""
grep ""^foo.*bar$"" file.txt

# pass the option ""-c"" to instead print the number of lines matching the regex
grep -c ""^foo.*bar$"" file.txt

# Other useful options are:
grep -r ""^foo.*bar$"" someDir/ # recursively `grep`
grep -n ""^foo.*bar$"" file.txt # give line numbers
grep -rI ""^foo.*bar$"" someDir/ # recursively `grep`, but ignore binary files

# perform the same initial search, but filter out the lines containing ""baz""
grep ""^foo.*bar$"" file.txt | grep -v ""baz""

# if you literally want to search for the string,
# and not the regex, use `fgrep` (or `grep -F`)
fgrep ""foobar"" file.txt

# The `trap` command allows you to execute a command whenever your script
# receives a signal. Here, `trap` will execute `rm` if it receives any of the
# three listed signals.
trap ""rm $TEMP_FILE; exit"" SIGHUP SIGINT SIGTERM

# `sudo` is used to perform commands as the superuser
# usually it will ask interactively the password of superuser
NAME1=$(whoami)
NAME2=$(sudo whoami)
echo ""Was $NAME1, then became more powerful $NAME2""

# Read Bash shell built-ins documentation with the bash `help` built-in:
help
help help
help for
help return
help source
help .

# Read Bash manpage documentation with `man`
apropos bash
man 1 bash
man bash

# Read info documentation with `info` (`?` for help)
apropos info | grep '^info.*('
man info
info info
info 5 info

# Read bash info documentation:
info bash
info bash 'Bash Features'
info bash 6
info --apropos bash
```"
"**LDPL** is a powerful, C++ transpiled, open-source programming language designed
from the ground up to be excessively expressive, readable, fast and easy to learn.
It mimics plain English, in the likeness of older programming languages like COBOL,
with the desire that it can be understood by anybody. It's very portable and runs on a
plethora of different architectures and operating systems and it even supports UTF-8
out of the box.

[Read more here.](https://github.com/lartu/ldpl)

```coffeescript
# This is a single line comment in LDPL.
# LDPL doesn't have multi-line comments.

# LDPL is a case-insensitive language: dIsPlaY and DISPLAY are the same
# statement, and foo and FOO name the same variable.

# An LDPL source file is divided in two sections, the DATA section and
# the PROCEDURE section.

DATA:
# Within the DATA section, variables are declared.

myNumber is number          # Defines a real number.
myString is text            # Defines a string.
myList is number list       # Defines a list of numbers.
myMap  is number map        # Defines a map of numbers.

# LDPL understands four data types: two scalar types (NUMBER, TEXT)
# and two container types (LISTs and MAPs).
# LISTs can be TEXT LISTs or NUMBER LISTs, while MAPs can be
# TEXT MAPs and NUMBER MAPs. You can also chain many containers
# to create larger data types:
textListList is text list list
myMulticontainer is number list list map 
# Defines a map of lists of lists of numbers.

PROCEDURE:
# Within the PROCEDURE section, your code is written.

store -19.2 in myNumber         # Use the STORE statement to assign values
store ""Hi there"" in myString    # to variables.
push 890 to myList # Use PUSH - TO to append values to lists.
push 100 to myList
push 500 to myList
store 45 in myMap:""someIndex"" # Use the : operator to index containers.

push list to textListList # Push an empty list into a list of lists.
push ""LDPL is nice!"" to textListList:0 #Push text to the pushed list.

display ""Hello World!"" # Use the DISPLAY statement to print values.
# The display statement can receive multiple values separated by spaces.
display crlf ""How are you today?"" myNumber myString crlf
# CRLF is the standard line break value in LDPL.
display textListList:0:0 "" Isn't it?"" crlf

# IF statements in LDPL are extremely verbose:
if myNumber is equal to -19.2 and myList:0 is less than 900 then
    display ""Yes!"" crlf
else if myMap:""someIndex"" is not equal to 45 then
    display ""This is an else if!"" crlf
else
    display ""Else!"" crlf
end if
# Valid LDPL comparison operators are
# - IS EQUAL TO
# - IS NOT EQUAL TO
# - IS LESS THAN
# - IS GREATER THAN
# - IS LESS THAN OR EQUAL TO
# - IS GREATER THAN OR EQUAL TO
if ""Hi there!"" is not equal to ""Bye bye!"" then
    display ""Yep, those weren't equal."" crlf
end if
# LDPL normally doesn't understand inline expressions, so you
# cannot do stuff like:
# if myNumber - 9 * 2 is equal to 10 then
# LDPL will set your computer on fire and burst your screen if you do so.

# WHILE loops follow the same rules
store 0 in myNumber
while myNumber is less than 10 do
    display ""Loop number "" myNumber ""..."" crlf
    in myNumber solve myNumber + 1 # You can do math like this.
repeat
# You can use 'break' and 'continue' inside loops just like any other language.

# LDPL also has FOR loops and FOR EACH loops
for myNumber from 0 to 100 step 2 do
    display myNumber crlf
repeat

for each myNumber in myList do
    display myNumber
repeat

display ""Enter your name: ""
accept myString # Use ACCEPT to let the user input values.
display ""Hi there, "" myString crlf
display ""How old are you?: ""
accept myNumber
if myNumber is greater than 200 then
    display ""Woah, you are so old!"" crlf
end if

wait 1000 milliseconds # Pause the program for a whole second.

# Let's do some math
store 1.2 in myNumber
in myNumber solve myNumber * (10 / 7.2) # Operators are separated by spaces.
floor myNumber
display myNumber crlf
get random in myNumber # get a random number between 0 and 1 
                       # and store it in myNumber

# Functions in LDPL are called sub-procedures. Sub-procedures, like source
# files, are divided in sections. The sections found in sub-procedures are
# the PARAMETERS section, the LOCAL DATA section and the PROCEDURE section.
# All sections except the PROCEDURE section can be skipped if they aren't
# used. If no PARAMETERS nor LOCAL DATA sections are used, the PROCEDURE
# keyword may be omitted.
sub myFunction
    parameters:
        a is number # LDPL is pass by reference
        b is number
        result is number # Thus you can return values through a parameter.
    local data:
        c is number
    procedure:
        get random in c
        in result solve a + b * c
end sub

sub sayHello
    display ""Hi there!"" crlf
    return
    display ""This won't be displayed :(""
end sub

call myFunction with 1 2 myNumber
display myNumber crlf
call sayHello
call sayBye # sub-procedures may be called before they are declared

sub sayBye
    display ""Bye!""
end sub

# One of the greatest features of LDPL is the ability to create your
# own statements.

create statement ""say hi"" executing sayHello
say hi

create statement ""random add $ and $ in $"" executing myFunction
random add 1 and 2 in myNumber
display myNumber crlf

exit
```

## Further Reading

 * [LDPL Docs](https://docs.ldpl-lang.org)"
"MontiLang is a Stack-Oriented concatenative imperative programming language. Its syntax
is roughly based off of forth with similar style for doing arithmetic in [reverse polish notation.](https://en.wikipedia.org/wiki/Reverse_Polish_notation)

A good way to start with MontiLang is to read the documentation and examples at [montilang.ml](http://montilang.ml),
then download MontiLang or build from source code with the instructions provided.

```
/# Monti Reference sheet #/
/#
Comments are multiline
Nested comments are not supported 
#/
/# Whitespace is all arbitrary, indentation is optional #/
/# All programming in Monti is done by manipulating the parameter stack 
arithmetic and stack operations in MontiLang are similar to FORTH
https://en.wikipedia.org/wiki/Forth_(programming_language)
#/

/# in Monti, everything is either a string or a number. Operations treat all numbers
similarly to floats, but anything without a remainder is treated as type int #/

/# numbers and strings are added to the stack from left to right #/

/# Arithmetic works by manipulating data on the stack #/

5 3 + PRINT . /# 8 #/

/#  5 and 3 are pushed onto the stack
    '+' replaces top 2 items on stack with sum of top 2 items
    'PRINT' prints out the top item on the stack
    '.' pops the top item from the stack. 
    #/

6 7 * PRINT . /# 42 #/
1360 23 - PRINT . /# 1337 #/
12 12 / PRINT . /# 1 #/
13 2 % PRINT . /# 1 #/

37 NEG PRINT . /# -37 #/
-12 ABS PRINT . /# 12 #/
52 23 MAX PRINT . /# 52 #/
52 23 MIN PRINT . /# 23 #/

/# 'PSTACK' command prints the entire stack, 'CLEAR' clears the entire stack #/

3 6 8 PSTACK CLEAR /# [3, 6, 8] #/

/# Monti comes with some tools for stack manipulation #/

2 DUP PSTACK CLEAR /# [2, 2] - Duplicate the top item on the stack#/
2 6 SWAP PSTACK CLEAR /# [6, 2] - Swap top 2 items on stack #/
1 2 3 ROT PSTACK CLEAR /# [2, 3, 1] - Rotate top 3 items on stack #/
2 3 NIP PSTACK CLEAR /# [3] - delete second item from the top of the stack #/
4 5 6 TRIM PSTACK CLEAR /# [5, 6] - Deletes first item on stack #/
/# variables are assigned with the syntax 'VAR [name]'#/
/# When assigned, the variable will take the value of the top item of the stack #/

6 VAR six . /# assigns var 'six' to be equal to 6 #/
3 6 + VAR a . /# assigns var 'a' to be equal to 9 #/

/# the length of the stack can be calculated with the statement 'STKLEN' #/
1 2 3 4 STKLEN PRINT CLEAR /# 4 #/

/# strings are defined with | | #/

|Hello World!| VAR world . /# sets variable 'world' equal to string 'Hello world! #/ 

/# variables can be called by typing its name. when called, the value of the variable is pushed
to the top of the stack #/
world PRINT .

/# with the OUT statement, the top item on the stack can be printed without a newline #/

|world!| |Hello, | OUT SWAP PRINT CLEAR

/# Data types can be converted between strings and integers with the commands 'TOINT' and 'TOSTR'#/
|5| TOINT PSTACK . /# [5] #/
45 TOSTR PSTACK . /# ['45'] #/

/# User input is taken with INPUT and pushed to the stack. If the top item of the stack is a string, 
the string is used as an input prompt #/

|What is your name? | INPUT NIP 
|Hello, | OUT SWAP PRINT CLEAR


/# FOR loops have the syntax 'FOR [condition] [commands] ENDFOR' At the moment, [condition] can
only have the value of an integer. Either by using an integer, or a variable call to an integer.
[commands] will be interpereted the amount of time specified in [condition] #/
/# E.G: this prints out 1 to 10 #/

1 VAR a .
FOR 10
    a PRINT 1 + VAR a
ENDFOR

/# the syntax for while loops are similar. A number is evaluated as true if it is larger than
0. a string is true if its length > 0. Infinite loops can be used by using literals.
#/
10 var loop .
WHILE loop
    loop print 
    1 - var loop
ENDWHILE
/#
this loop would count down from 10.

IF statements are pretty much the same, but only are executed once.
#/
IF loop
 loop PRINT .
ENDIF

/# This would only print 'loop' if it is larger than 0 #/

/# If you would want to use the top item on the stack as loop parameters, this can be done with the ':' character #/

/# eg, if you wanted to print 'hello' 7 times, instead of using #/

FOR 7
    |hello| PRINT .
ENDFOR

/# this could be used #/
7
FOR : 
    |hello| PRINT .
ENDFOR

/# Equality and inequality statements use the top 2 items on the stack as parameters, and replace the top two items with the output #/
/# If it is true, the top 2 items are replaced with '1'. If false, with '0'. #/

7 3 > PRINT . /# 1 #/
2 10 > PRINT . /# 0 #/
5 9 <= PRINT . /# 1 #/
5 5 == PRINT . /# 1 #/
5 7 == PRINT . /# 0 #/
3 8 != PRINT . /# 1 #/

/# User defined commands have the syntax of 'DEF [name] [commands] ENDDEF'. #/
/# eg, if you wanted to define a function with the name of 'printseven' to print '7' 10 times, this could be used #/

DEF printseven
    FOR 10
       7 PRINT .
    ENDFOR
ENDDEF

/# to run the defined statement, simply type it and it will be run by the interpereter #/

printseven

/# Montilang supports AND, OR and NOT statements #/

1 0 AND PRINT . /# 0 #/
1 1 AND PRINT . /# 1 #/
1 0 OR PRINT . /# 1 #/
0 0 OR PRINT . /# 0 #/
1 NOT PRINT . /# 0 #/
0 NOT PRINT . /# 1 #/

/# Preprocessor statements are made inbetween '&' characters #/
/# currently, preprocessor statements can be used to make c++-style constants #/

&DEFINE LOOPSTR 20&
/# must have & on either side with no spaces, 'DEFINE' is case sensitive. #/
/# All statements are scanned and replaced before the program is run, regardless of where the statements are placed #/

FOR LOOPSTR 7 PRINT . ENDFOR /# Prints '7' 20 times. At run, 'LOOPSTR' in source code is replaced with '20' #/ 

/# Multiple files can be used with the &INCLUDE <filename>& Command that operates similar to c++, where the file specified is tokenized,
   and the &INCLUDE statement is replaced with the file #/
   
/# E.G, you can have a program be run through several files. If you had the file 'name.mt' with the following data:

[name.mt]
|Hello, | OUT . name PRINT .

a program that asks for your name and then prints it out can be defined as such: #/

|What is your name? | INPUT VAR name . &INCLUDE name.mt&

/# ARRAYS: #/

/# arrays are defined with the statement 'ARR'
When called, everything currently in the stack is put into one
array and all items on the stack are replaced with the new array. #/

2 3 4 ARR PSTACK . /# [[2, 3, 4]] #/

/# the statement 'LEN' adds the length of the last item on the stack to the stack.
This can be used on arrays, as well as strings. #/

3 4 5 ARR LEN PRINT . /# 3 #/

/# values can be appended to an array with the statement 'APPEND' #/

1 2 3 ARR 5 APPEND . PRINT . /# [1, 2, 3, 5] #/

/# an array at the top of the stack can be wiped with the statement 'WIPE' #/
3 4 5 ARR WIPE PRINT . /# [] #/

/# The last item of an array can be removed with the statement 'DROP' #/

3 4 5 ARR DROP PRINT . /# [3, 4]
/# arrays, like other datatypes can be stored in variables #/
5 6 7 ARR VAR list .
list PRINT . /# [5, 6, 7] #/

/# Values at specific indexes can be changed with the statement 'INSERT <index>' #/
4 5 6 ARR 
97 INSERT 1 . PRINT /# 4, 97, 6 #/

/# Values at specific indexes can be deleted with the statement 'DEL <index>' #/
1 2 3 ARR
DEL 1 PRINT . /# [1, 3] #/

/# items at certain indexes of an array can be gotten with the statement 'GET <index>' #/

1 2 3 ARR GET 2 PSTACK /# [[1, 2, 3], 3] #/
```

## Extra information

- [MontiLang.ml](http://montilang.ml/)
- [Github Page](https://github.com/lduck11007/MontiLang)"
"Jsonnet is a powerful templating language for JSON. Any valid JSON
document is a valid Jsonnet object. For an interactive demo/tutorial,
click [here](https://jsonnet.org/learning/tutorial.html)

```python
// single line comment

/*
    multiline comment
*/

# as well as python style comment

# define a variable.
# Variables have no effect in the generated JSON without being used.
local num1 = 1;
local num2 = 1 + 1;
local num3 = 5 - 2;
local num4 = 9 % 5;
local num5 = 10 / 2.0;
# jsonnet is a lazy language, if a variable is not used, it is not evaluated.
local num_runtime_error = 1 / 0;

# fields are valid identifiers without quotes
local obj1 = { a: 'letter a', B: 'letter B' };

local arr1 = ['a', 'b', 'c'];

# string literals use "" or '.
local str1 = 'a' + 'B';
# multiline text literal in between |||
# Each line must start with a white space.
local str_multiline = |||
  this is a
  multiline string
|||;
# Python-compatible string formatting is available via %
# When combined with ||| this can be used for templating text files.
local str_templating = |||
  %(f1)0.3f
||| % { f1: 1.2345678 };
assert str_templating == '1.235\n';

# if b then e else e. The else branch is optional and defaults to null
local var1 = if 3 < 2 then ""YES"";
assert var1 == null;

local obj2 = {
  # variable defined inside the object ends with ','
  local var_in_obj = 0,

  local vowels = ['a', 'e', 'i', 'o', 'u'],
  local numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],

  # [num] to look up an array element
  first_vowel: vowels[0],
  # can also slice the array like in Python
  even_numbers: numbers[1::2],

  # python-style list and object comprehensions are also supported
  double_numbers: [x * 2 for x in numbers],
  even_numbers_map: {
      # [ ] syntax in field name is to compute the field name dynamically
      [x + '_is_even']: true for x in numbers if x % 2 == 0
  },

  nested: {
    nested_field1: 'some-value',
    # self refers to the current object
    # [""field-name""] or .field-name can be used to look up a field
    nested_field2: self.nested_field1,
    nested_field3: self.nested_field1,
    # $ refers to outer-most object
    nested_field4: $.first_vowel,

    assert self.nested_field1 == self.nested_field2,
    assert self.nested_field1 == self.nested_field3,
  },

  special_field: 'EVERYTHING FEELS BAD',
};

local obj3 = {
  local var_in_obj = 1.234,
  local var_in_obj2 = { a: { b: 'c' } },

  concat_array: [1, 2, 3] + [4],
  # strings can be concat with +,
  # which implicitly converts one operand to string if needed.
  concat_string: '123' + 4,

  # == tests deep equality
  equals: { a: { b: 'c', d: {} } } == var_in_obj2,

  special_field: 'this feels good',
};

# objects can be merged with + where the right-hand side wins field conflicts
local obj4 = obj2 + obj3;
assert obj4.special_field == 'this feels good';

# define a function
# functions have positional parameters, named parameters, and default arguments
local my_function(x, y, z=1) = x + y - z;
local num6 = my_function(7, 8, 9);
local num7 = my_function(8, z=10, y=9);
local num8 = my_function(4, 5);
# inline anonymous function
local num9 = (function(x) x * x)(3);

local obj5 = {
  # define a method
  # fields defined with :: are hidden, which does not apper in generated JSON
  # function cannot be serialized so need to be hidden
  # if the object is used in the generated JSON.
  is_odd(x):: x % 2 == 1,
};
assert obj5 == {};

# a jsonnet document has to evaluate to something
# be it an object, list, number or just string literal
""FIN""

```

## Further Reading
There are a few but important concepts that are not touched in this example, including:

- Passing variables from command line: [Parameterize Entire Config](https://jsonnet.org/learning/tutorial.html#parameterize-entire-config)
- Import other jsonnet libraries/files: [Imports](https://jsonnet.org/learning/tutorial.html#imports)
- In depth example of OOP aspect of Jsonnet: [Object-Orientation](https://jsonnet.org/learning/tutorial.html#Object-Orientation)
- Useful standard library: [Stdlib](https://jsonnet.org/ref/stdlib.html)"
"Ah, C. Still **the** language of modern high-performance computing.

C is the lowest-level language most programmers will ever use, but
it more than makes up for it with raw speed. Just be aware of its manual
memory management and C will take you as far as you need to go.

> **About compiler flags**
>
> By default, gcc and clang are pretty quiet about compilation warnings and
> errors, which can be very useful information. Explicitly using stricter
> compiler flags is recommended. Here are some recommended defaults:
>
> `-Wall -Wextra -Werror -O2 -std=c99 -pedantic`
>
> For information on what these flags do as well as other flags, consult the man page for your C compiler (e.g. `man 1 gcc`) or just search online.

```c
// Single-line comments start with // - only available in C99 and later.

/*
Multi-line comments look like this. They work in C89 as well.
*/

/*
Multi-line comments don't nest /* Be careful */  // comment ends on this line...
*/ // ...not this one!

// Constants: #define <keyword>
// Constants are written in all-caps out of convention, not requirement
#define DAYS_IN_YEAR 365

// Enumeration constants are also ways to declare constants.
// All statements must end with a semicolon
enum days {SUN, MON, TUE, WED, THU, FRI, SAT};
// SUN gets 0, MON gets 1, TUE gets 2, etc.

// Enumeration values can also be specified
enum days {SUN = 1, MON, TUE, WED = 99, THU, FRI, SAT};
// MON gets 2 automatically, TUE gets 3, etc.
// WED get 99, THU gets 100, FRI gets 101, etc.

// Import headers with #include
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// File names between <angle brackets> tell the compiler to look in your system
// libraries for the headers.
// For your own headers, use double quotes instead of angle brackets, and
// provide the path:
#include ""my_header.h"" 		// local file
#include ""../my_lib/my_lib_header.h"" //relative path

// Declare function signatures in advance in a .h file, or at the top of
// your .c file.
void function_1();
int function_2(void);

// At a minimum, you must declare a 'function prototype' before its use in any function.
// Normally, prototypes are placed at the top of a file before any function definition.
int add_two_ints(int x1, int x2); // function prototype
// although `int add_two_ints(int, int);` is also valid (no need to name the args),
// it is recommended to name arguments in the prototype as well for easier inspection

// Function prototypes are not necessary if the function definition comes before
// any other function that calls that function. However, it's standard practice to
// always add the function prototype to a header file (*.h) and then #include that
// file at the top. This prevents any issues where a function might be called
// before the compiler knows of its existence, while also giving the developer a
// clean header file to share with the rest of the project.

// Your program's entry point is a function called ""main"". The return type can
// be anything, however most operating systems expect a return type of `int` for
// error code processing.
int main(void) {
  // your program
}

// The command line arguments used to run your program are also passed to main
// argc being the number of arguments - your program's name counts as 1
// argv is an array of character arrays - containing the arguments themselves
// argv[0] = name of your program, argv[1] = first argument, etc.
int main (int argc, char** argv)
{
  // print output using printf, for ""print formatted""
  // %d is an integer, \n is a newline
  printf(""%d\n"", 0); // => Prints 0

  // take input using scanf
  // '&' is used to define the location
  // where we want to store the input value
  int input;
  scanf(""%d"", &input);

  ///////////////////////////////////////
  // Types
  ///////////////////////////////////////

  // Compilers that are not C99-compliant require that variables MUST be
  // declared at the top of the current block scope.
  // Compilers that ARE C99-compliant allow declarations near the point where
  // the value is used.
  // For the sake of the tutorial, variables are declared dynamically under
  // C99-compliant standards.

  // ints are usually 4 bytes (use the `sizeof` operator to check)
  int x_int = 0;

  // shorts are usually 2 bytes (use the `sizeof` operator to check)
  short x_short = 0;

  // chars are defined as the smallest addressable unit for a processor.
  // This is usually 1 byte, but for some systems it can be more (ex. for TMS320 from TI it's 2 bytes).
  char x_char = 0;
  char y_char = 'y'; // Char literals are quoted with ''

  // longs are often 4 to 8 bytes; long longs are guaranteed to be at least
  // 8 bytes
  long x_long = 0;
  long long x_long_long = 0;

  // floats are usually 32-bit floating point numbers
  float x_float = 0.0f; // 'f' suffix here denotes floating point literal

  // doubles are usually 64-bit floating-point numbers
  double x_double = 0.0; // real numbers without any suffix are doubles

  // integer types may be unsigned (greater than or equal to zero)
  unsigned short ux_short;
  unsigned int ux_int;
  unsigned long long ux_long_long;

  // chars inside single quotes are integers in machine's character set.
  '0'; // => 48 in the ASCII character set.
  'A'; // => 65 in the ASCII character set.

  // sizeof(T) gives you the size of a variable with type T in bytes
  // sizeof(obj) yields the size of the expression (variable, literal, etc.).
  printf(""%zu\n"", sizeof(int)); // => 4 (on most machines with 4-byte words)

  // If the argument of the `sizeof` operator is an expression, then its argument
  // is not evaluated (except VLAs (see below)).
  // The value it yields in this case is a compile-time constant.
  int a = 1;
  // size_t is an unsigned integer type of at least 2 bytes used to represent
  // the size of an object.
  size_t size = sizeof(a++); // a++ is not evaluated
  printf(""sizeof(a++) = %zu where a = %d\n"", size, a);
  // prints ""sizeof(a++) = 4 where a = 1"" (on a 32-bit architecture)

  // Arrays must be initialized with a concrete size.
  char my_char_array[20]; // This array occupies 1 * 20 = 20 bytes
  int my_int_array[20]; // This array occupies 4 * 20 = 80 bytes
  // (assuming 4-byte words)

  // You can initialize an array of twenty ints that all equal 0 thusly:
  int my_array[20] = {0};
  // where the ""{0}"" part is called an ""array initializer"".
  // All elements (if any) past the ones in the initializer are initialized to 0:
  int my_array[5] = {1, 2};
  // So my_array now has five elements, all but the first two of which are 0:
  // [1, 2, 0, 0, 0]
  // NOTE that you get away without explicitly declaring the size
  // of the array IF you initialize the array on the same line:
  int my_array[] = {0};
  // NOTE that, when not declaring the size, the size of the array is the number
  // of elements in the initializer. With ""{0}"", my_array is now of size one: [0]
  // To evaluate the size of the array at run-time, divide its byte size by the
  // byte size of its element type:
  size_t my_array_size = sizeof(my_array) / sizeof(my_array[0]);
  // WARNING You should evaluate the size *before* you begin passing the array
  // to functions (see later discussion) because arrays get ""downgraded"" to
  // raw pointers when they are passed to functions (so the statement above
  // will produce the wrong result inside the function).

  // Indexing an array is like other languages -- or,
  // rather, other languages are like C
  my_array[0]; // => 0

  // Arrays are mutable; it's just memory!
  my_array[1] = 2;
  printf(""%d\n"", my_array[1]); // => 2

  // In C99 (and as an optional feature in C11), variable-length arrays (VLAs)
  // can be declared as well. The size of such an array need not be a compile
  // time constant:
  printf(""Enter the array size: ""); // ask the user for an array size
  int array_size;
  fscanf(stdin, ""%d"", &array_size);
  int var_length_array[array_size]; // declare the VLA
  printf(""sizeof array = %zu\n"", sizeof var_length_array);

  // Example:
  // > Enter the array size: 10
  // > sizeof array = 40

  // Strings are just arrays of chars terminated by a NULL (0x00) byte,
  // represented in strings as the special character '\0'.
  // (We don't have to include the NULL byte in string literals; the compiler
  //  inserts it at the end of the array for us.)
  char a_string[20] = ""This is a string"";
  printf(""%s\n"", a_string); // %s formats a string

  printf(""%d\n"", a_string[16]); // => 0
  // i.e., byte #17 is 0 (as are 18, 19, and 20)

  // If we have characters between single quotes, that's a character literal.
  // It's of type `int`, and *not* `char` (for historical reasons).
  int cha = 'a'; // fine
  char chb = 'a'; // fine too (implicit conversion from int to char)

  // Multi-dimensional arrays:
  int multi_array[2][5] = {
    {1, 2, 3, 4, 5},
    {6, 7, 8, 9, 0}
  };
  // access elements:
  int array_int = multi_array[0][2]; // => 3

  ///////////////////////////////////////
  // Operators
  ///////////////////////////////////////

  // Shorthands for multiple declarations:
  int i1 = 1, i2 = 2;
  float f1 = 1.0, f2 = 2.0;

  int b, c;
  b = c = 0;

  // Arithmetic is straightforward
  i1 + i2; // => 3
  i2 - i1; // => 1
  i2 * i1; // => 2
  i1 / i2; // => 0 (0.5, but truncated towards 0)

  // You need to cast at least one integer to float to get a floating-point result
  (float)i1 / i2; // => 0.5f
  i1 / (double)i2; // => 0.5 // Same with double
  f1 / f2; // => 0.5, plus or minus epsilon

  // Floating-point numbers are defined by IEEE 754, thus cannot store perfectly
  // exact values. For instance, the following does not produce expected results
  // because 0.1 might actually be 0.099999999999 inside the computer, and 0.3
  // might be stored as 0.300000000001.
  (0.1 + 0.1 + 0.1) != 0.3; // => 1 (true)
  // and it is NOT associative due to reasons mentioned above.
  1 + (1e123 - 1e123) != (1 + 1e123) - 1e123; // => 1 (true)
  // this notation is scientific notations for numbers: 1e123 = 1*10^123

  // It is important to note that most all systems have used IEEE 754 to
  // represent floating points. Even python, used for scientific computing,
  // eventually calls C which uses IEEE 754. It is mentioned this way not to
  // indicate that this is a poor implementation, but instead as a warning
  // that when doing floating point comparisons, a little bit of error (epsilon)
  // needs to be considered.

  // Modulo is there as well, but be careful if arguments are negative
  11 % 3;    // => 2 as 11 = 2 + 3*x (x=3)
  (-11) % 3; // => -2, as one would expect
  11 % (-3); // => 2 and not -2, and it's quite counter intuitive

  // Comparison operators are probably familiar, but
  // there is no Boolean type in C. We use ints instead.
  // (C99 introduced the _Bool type provided in stdbool.h)
  // 0 is false, anything else is true. (The comparison
  // operators always yield 0 or 1.)
  3 == 2; // => 0 (false)
  3 != 2; // => 1 (true)
  3 > 2;  // => 1
  3 < 2;  // => 0
  2 <= 2; // => 1
  2 >= 2; // => 1

  // C is not Python - comparisons do NOT chain.
  // Warning: The line below will compile, but it means `(0 < a) < 2`.
  // This expression is always true, because (0 < a) could be either 1 or 0.
  // In this case it's 1, because (0 < 1).
  int between_0_and_2 = 0 < a < 2;
  // Instead use:
  int between_0_and_2 = 0 < a && a < 2;

  // Logic works on ints
  !3; // => 0 (Logical not)
  !0; // => 1
  1 && 1; // => 1 (Logical and)
  0 && 1; // => 0
  0 || 1; // => 1 (Logical or)
  0 || 0; // => 0

  // Conditional ternary expression ( ? : )
  int e = 5;
  int f = 10;
  int z;
  z = (e > f) ? e : f; // => 10 ""if e > f return e, else return f.""

  // Increment and decrement operators:
  int j = 0;
  int s = j++; // Return j THEN increase j. (s = 0, j = 1)
  s = ++j; // Increase j THEN return j. (s = 2, j = 2)
  // same with j-- and --j

  // Bitwise operators!
  ~0x0F; // => 0xFFFFFFF0 (bitwise negation, ""1's complement"", example result for 32-bit int)
  0x0F & 0xF0; // => 0x00 (bitwise AND)
  0x0F | 0xF0; // => 0xFF (bitwise OR)
  0x04 ^ 0x0F; // => 0x0B (bitwise XOR)
  0x01 << 1; // => 0x02 (bitwise left shift (by 1))
  0x02 >> 1; // => 0x01 (bitwise right shift (by 1))

  // Be careful when shifting signed integers - the following are undefined:
  // - shifting into the sign bit of a signed integer (int a = 1 << 31)
  // - left-shifting a negative number (int a = -1 << 2)
  // - shifting by an offset which is >= the width of the type of the LHS:
  //   int a = 1 << 32; // UB if int is 32 bits wide

  ///////////////////////////////////////
  // Control Structures
  ///////////////////////////////////////

  if (0) {
    printf(""I am never run\n"");
  } else if (0) {
    printf(""I am also never run\n"");
  } else {
    printf(""I print\n"");
  }

  // While loops exist
  int ii = 0;
  while (ii < 10) { //ANY value less than ten is true.
    printf(""%d, "", ii++); // ii++ increments ii AFTER using its current value.
  } // => prints ""0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ""

  printf(""\n"");

  int kk = 0;
  do {
    printf(""%d, "", kk);
  } while (++kk < 10); // ++kk increments kk BEFORE using its current value.
  // => prints ""0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ""

  printf(""\n"");

  // For loops too
  int jj;
  for (jj=0; jj < 10; jj++) {
    printf(""%d, "", jj);
  } // => prints ""0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ""

  printf(""\n"");

  // *****NOTES*****:
  // Loops and Functions MUST have a body. If no body is needed:
  int i;
  for (i = 0; i <= 5; i++) {
    ; // use semicolon to act as the body (null statement)
  }
  // Or
  for (i = 0; i <= 5; i++);

  // branching with multiple choices: switch()
  switch (a) {
  case 0: // labels need to be integral *constant* expressions (such as enums)
    printf(""Hey, 'a' equals 0!\n"");
    break; // if you don't break, control flow falls over labels
  case 1:
    printf(""Huh, 'a' equals 1!\n"");
    break;
    // Be careful - without a ""break"", execution continues until the
    // next ""break"" is reached.
  case 3:
  case 4:
    printf(""Look at that.. 'a' is either 3, or 4\n"");
    break;
  default:
    // if `some_integral_expression` didn't match any of the labels
    fputs(""Error!\n"", stderr);
    exit(-1);
    break;
  }
  /*
    Using ""goto"" in C
  */
  typedef enum { false, true } bool;
  // for C don't have bool as data type before C99 :(
  bool disaster = false;
  int i, j;
  for(i=0; i<100; ++i)
  for(j=0; j<100; ++j)
  {
    if((i + j) >= 150)
        disaster = true;
    if(disaster)
        goto error;  // exit both for loops
  }
  error: // this is a label that you can ""jump"" to with ""goto error;""
  printf(""Error occurred at i = %d & j = %d.\n"", i, j);
  /*
    https://ideone.com/GuPhd6
    this will print out ""Error occurred at i = 51 & j = 99.""
  */
  /*
    it is generally considered bad practice to do so, except if
    you really know what you are doing. See
    https://en.wikipedia.org/wiki/Spaghetti_code#Meaning
  */

  ///////////////////////////////////////
  // Typecasting
  ///////////////////////////////////////

  // Every value in C has a type, but you can cast one value into another type
  // if you want (with some constraints).

  int x_hex = 0x01; // You can assign vars with hex literals
                    // binary is not in the standard, but allowed by some
                    // compilers (x_bin = 0b0010010110)

  // Casting between types will attempt to preserve their numeric values
  printf(""%d\n"", x_hex); // => Prints 1
  printf(""%d\n"", (short) x_hex); // => Prints 1
  printf(""%d\n"", (char) x_hex); // => Prints 1

  // If you assign a value greater than a types max val, it will rollover
  // without warning.
  printf(""%d\n"", (unsigned char) 257); // => 1 (Max char = 255 if char is 8 bits long)

  // For determining the max value of a `char`, a `signed char` and an `unsigned char`,
  // respectively, use the CHAR_MAX, SCHAR_MAX and UCHAR_MAX macros from <limits.h>

  // Integral types can be cast to floating-point types, and vice-versa.
  printf(""%f\n"", (double) 100); // %f always formats a double...
  printf(""%f\n"", (float)  100); // ...even with a float.
  printf(""%d\n"", (char)100.0);

  ///////////////////////////////////////
  // Pointers
  ///////////////////////////////////////

  // A pointer is a variable declared to store a memory address. Its declaration will
  // also tell you the type of data it points to. You can retrieve the memory address
  // of your variables, then mess with them.

  int x = 0;
  printf(""%p\n"", (void *)&x); // Use & to retrieve the address of a variable
  // (%p formats an object pointer of type void *)
  // => Prints some address in memory;

  // Pointers start with * in their declaration
  int *px, not_a_pointer; // px is a pointer to an int
  px = &x; // Stores the address of x in px
  printf(""%p\n"", (void *)px); // => Prints some address in memory
  printf(""%zu, %zu\n"", sizeof(px), sizeof(not_a_pointer));
  // => Prints ""8, 4"" on a typical 64-bit system

  // To retrieve the value at the address a pointer is pointing to,
  // put * in front to dereference it.
  // Note: yes, it may be confusing that '*' is used for _both_ declaring a
  // pointer and dereferencing it.
  printf(""%d\n"", *px); // => Prints 0, the value of x

  // You can also change the value the pointer is pointing to.
  // We'll have to wrap the dereference in parenthesis because
  // ++ has a higher precedence than *.
  (*px)++; // Increment the value px is pointing to by 1
  printf(""%d\n"", *px); // => Prints 1
  printf(""%d\n"", x); // => Prints 1

  // Arrays are a good way to allocate a contiguous block of memory
  int x_array[20]; //declares array of size 20 (cannot change size)
  int xx;
  for (xx = 0; xx < 20; xx++) {
    x_array[xx] = 20 - xx;
  } // Initialize x_array to 20, 19, 18,... 2, 1

  // Declare a pointer of type int and initialize it to point to x_array
  int* x_ptr = x_array;
  // x_ptr now points to the first element in the array (the integer 20).
  // This works because arrays often decay into pointers to their first element.
  // For example, when an array is passed to a function or is assigned to a pointer,
  // it decays into (implicitly converted to) a pointer.
  // Exceptions: when the array is the argument of the `&` (address-of) operator:
  int arr[10];
  int (*ptr_to_arr)[10] = &arr; // &arr is NOT of type `int *`!
  // It's of type ""pointer to array"" (of ten `int`s).
  // or when the array is a string literal used for initializing a char array:
  char otherarr[] = ""foobarbazquirk"";
  // or when it's the argument of the `sizeof` or `alignof` operator:
  int arraythethird[10];
  int *ptr = arraythethird; // equivalent with int *ptr = &arr[0];
  printf(""%zu, %zu\n"", sizeof(arraythethird), sizeof(ptr));
  // probably prints ""40, 4"" or ""40, 8""

  // Pointers are incremented and decremented based on their type
  // (this is called pointer arithmetic)
  printf(""%d\n"", *(x_ptr + 1)); // => Prints 19
  printf(""%d\n"", x_array[1]); // => Prints 19

  // You can also dynamically allocate contiguous blocks of memory with the
  // standard library function malloc, which takes one argument of type size_t
  // representing the number of bytes to allocate (usually from the heap, although this
  // may not be true on e.g. embedded systems - the C standard says nothing about it).
  int *my_ptr = malloc(sizeof(*my_ptr) * 20);
  for (xx = 0; xx < 20; xx++) {
    *(my_ptr + xx) = 20 - xx; // my_ptr[xx] = 20-xx
  } // Initialize memory to 20, 19, 18, 17... 2, 1 (as ints)

  // Be careful passing user-provided values to malloc! If you want
  // to be safe, you can use calloc instead (which, unlike malloc, also zeros out the memory)
  int* my_other_ptr = calloc(20, sizeof(int));

  // Note that there is no standard way to get the length of a
  // dynamically allocated array in C. Because of this, if your arrays are
  // going to be passed around your program a lot, you need another variable
  // to keep track of the number of elements (size) of an array. See the
  // functions section for more info.
  size_t size = 10;
  int *my_arr = calloc(size, sizeof(int));
  // Add an element to the array
  size++;
  my_arr = realloc(my_arr, sizeof(int) * size);
  if (my_arr == NULL) {
    //Remember to check for realloc failure!
    return
  }
  my_arr[10] = 5;

  // Dereferencing memory that you haven't allocated gives
  // ""unpredictable results"" - the program is said to invoke ""undefined behavior""
  printf(""%d\n"", *(my_ptr + 21)); // => Prints who-knows-what? It may even crash.

  // When you're done with a malloc'd block of memory, you need to free it,
  // or else no one else can use it until your program terminates
  // (this is called a ""memory leak""):
  free(my_ptr);

  // Strings are arrays of char, but they are usually represented as a
  // pointer-to-char (which is a pointer to the first element of the array).
  // It's good practice to use `const char *' when referring to a string literal,
  // since string literals shall not be modified (i.e. ""foo""[0] = 'a' is ILLEGAL.)
  const char *my_str = ""This is my very own string literal"";
  printf(""%c\n"", *my_str); // => 'T'

  // This is not the case if the string is an array
  // (potentially initialized with a string literal)
  // that resides in writable memory, as in:
  char foo[] = ""foo"";
  foo[0] = 'a'; // this is legal, foo now contains ""aoo""

  function_1();
} // end main function

///////////////////////////////////////
// Functions
///////////////////////////////////////

// Function declaration syntax:
// <return type> <function name>(<args>)

int add_two_ints(int x1, int x2)
{
  return x1 + x2; // Use return to return a value
}

/*
Functions are call by value. When a function is called, the arguments passed to
the function are copies of the original arguments (except arrays). Anything you
do to the arguments in the function do not change the value of the original
argument where the function was called.

Use pointers if you need to edit the original argument values (arrays are always
passed in as pointers).

Example: in-place string reversal
*/

// A void function returns no value
void str_reverse(char *str_in)
{
  char tmp;
  size_t ii = 0;
  size_t len = strlen(str_in); // `strlen()` is part of the c standard library
                               // NOTE: length returned by `strlen` DOESN'T
                               //       include the terminating NULL byte ('\0')
  // in C99 and newer versions, you can directly declare loop control variables
  // in the loop's parentheses. e.g., `for (size_t ii = 0; ...`
  for (ii = 0; ii < len / 2; ii++) {
    tmp = str_in[ii];
    str_in[ii] = str_in[len - ii - 1]; // ii-th char from end
    str_in[len - ii - 1] = tmp;
  }
}
//NOTE: string.h header file needs to be included to use strlen()

/*
char c[] = ""This is a test."";
str_reverse(c);
printf(""%s\n"", c); // => "".tset a si sihT""
*/
/*
as we can return only one variable
to change values of more than one variables we use call by reference
*/
void swapTwoNumbers(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}
/*
int first = 10;
int second = 20;
printf(""first: %d\nsecond: %d\n"", first, second);
swapTwoNumbers(&first, &second);
printf(""first: %d\nsecond: %d\n"", first, second);
// values will be swapped
*/

// Return multiple values.
// C does not allow for returning multiple values with the return statement. If
// you would like to return multiple values, then the caller must pass in the
// variables where they would like the returned values to go. These variables must
// be passed in as pointers such that the function can modify them.
int return_multiple( int *array_of_3, int *ret1, int *ret2, int *ret3)
{
    if(array_of_3 == NULL)
        return 0; //return error code (false)

    //de-reference the pointer so we modify its value
   *ret1 = array_of_3[0];
   *ret2 = array_of_3[1];
   *ret3 = array_of_3[2];

   return 1; //return error code (true)
}

/*
With regards to arrays, they will always be passed to functions
as pointers. Even if you statically allocate an array like `arr[10]`,
it still gets passed as a pointer to the first element in any function calls.
Again, there is no standard way to get the size of a dynamically allocated
array in C.
*/
// Size must be passed!
// Otherwise, this function has no way of knowing how big the array is.
void printIntArray(int *arr, size_t size) {
    int i;
    for (i = 0; i < size; i++) {
        printf(""arr[%d] is: %d\n"", i, arr[i]);
    }
}
/*
int my_arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int size = 10;
printIntArray(my_arr, size);
// will print ""arr[0] is: 1"" etc
*/

// if referring to external variables outside function, you should use the extern keyword.
int i = 0;
void testFunc() {
  extern int i; //i here is now using external variable i
}

// make external variables private to source file with static:
static int j = 0; //other files using testFunc2() cannot access variable j
void testFunc2() {
  extern int j;
}
// The static keyword makes a variable inaccessible to code outside the
// compilation unit. (On almost all systems, a ""compilation unit"" is a .c
// file.) static can apply both to global (to the compilation unit) variables,
// functions, and function-local variables. When using static with
// function-local variables, the variable is effectively global and retains its
// value across function calls, but is only accessible within the function it
// is declared in. Additionally, static variables are initialized to 0 if not
// declared with some other starting value.
//**You may also declare functions as static to make them private**

///////////////////////////////////////
// User-defined types and structs
///////////////////////////////////////

// Typedefs can be used to create type aliases
typedef int my_type;
my_type my_type_var = 0;

// Structs are just collections of data, the members are allocated sequentially,
// in the order they are written:
struct rectangle {
  int width;
  int height;
};

// It's not generally true that
// sizeof(struct rectangle) == sizeof(int) + sizeof(int)
// due to potential padding between the structure members (this is for alignment
// reasons). [1]

void function_1()
{
  struct rectangle my_rec = { 1, 2 }; // Fields can be initialized immediately

  // Access struct members with .
  my_rec.width = 10;
  my_rec.height = 20;

  // You can declare pointers to structs
  struct rectangle *my_rec_ptr = &my_rec;

  // Use dereferencing to set struct pointer members...
  (*my_rec_ptr).width = 30;

  // ... or even better: prefer the -> shorthand for the sake of readability
  my_rec_ptr->height = 10; // Same as (*my_rec_ptr).height = 10;
}

// You can apply a typedef to a struct for convenience
typedef struct rectangle rect;

int area(rect r)
{
  return r.width * r.height;
}

// Typedefs can also be defined right during struct definition
typedef struct {
  int width;
  int height;
} rect;
// Like before, doing this means one can type
rect r;
// instead of having to type
struct rectangle r;

// if you have large structs, you can pass them ""by pointer"" to avoid copying
// the whole struct:
int areaptr(const rect *r)
{
  return r->width * r->height;
}

///////////////////////////////////////
// Function pointers
///////////////////////////////////////
/*
At run time, functions are located at known memory addresses. Function pointers are
much like any other pointer (they just store a memory address), but can be used
to invoke functions directly, and to pass handlers (or callback functions) around.
However, definition syntax may be initially confusing.

Example: use str_reverse from a pointer
*/
void str_reverse_through_pointer(char *str_in) {
  // Define a function pointer variable, named f.
  void (*f)(char *); // Signature should exactly match the target function.
  f = &str_reverse; // Assign the address for the actual function (determined at run time)
  // f = str_reverse; would work as well - functions decay into pointers, similar to arrays
  (*f)(str_in); // Just calling the function through the pointer
  // f(str_in); // That's an alternative but equally valid syntax for calling it.
}

/*
As long as function signatures match, you can assign any function to the same pointer.
Function pointers are usually typedef'd for simplicity and readability, as follows:
*/

typedef void (*my_fnp_type)(char *);

// Then used when declaring the actual pointer variable:
// ...
// my_fnp_type f;


/////////////////////////////
// Printing characters with printf()
/////////////////////////////

//Special characters:
/*
'\a'; // alert (bell) character
'\n'; // newline character
'\t'; // tab character (left justifies text)
'\v'; // vertical tab
'\f'; // new page (form feed)
'\r'; // carriage return
'\b'; // backspace character
'\0'; // NULL character. Usually put at end of strings in C.
//   hello\n\0. \0 used by convention to mark end of string.
'\\'; // backslash
'\?'; // question mark
'\''; // single quote
'\""'; // double quote
'\xhh'; // hexadecimal number. Example: '\xb' = vertical tab character
'\0oo'; // octal number. Example: '\013' = vertical tab character

//print formatting:
""%d"";    // integer
""%3d"";   // integer with minimum of length 3 digits (right justifies text)
""%s"";    // string
""%f"";    // float
""%ld"";   // long
""%3.2f""; // minimum 3 digits left and 2 digits right decimal float
""%7.4s""; // (can do with strings too)
""%c"";    // char
""%p"";    // pointer. NOTE: need to (void *)-cast the pointer, before passing
         //                it as an argument to `printf`.
""%x"";    // hexadecimal
""%o"";    // octal
""%%"";    // prints %
*/

///////////////////////////////////////
// Order of Evaluation
///////////////////////////////////////

// From top to bottom, top has higher precedence
//---------------------------------------------------//
//        Operators                  | Associativity //
//---------------------------------------------------//
// () [] -> .                        | left to right //
// ! ~ ++ -- + = *(type) sizeof      | right to left //
// * / %                             | left to right //
// + -                               | left to right //
// << >>                             | left to right //
// < <= > >=                         | left to right //
// == !=                             | left to right //
// &                                 | left to right //
// ^                                 | left to right //
// |                                 | left to right //
// &&                                | left to right //
// ||                                | left to right //
// ?:                                | right to left //
// = += -= *= /= %= &= ^= |= <<= >>= | right to left //
// ,                                 | left to right //
//---------------------------------------------------//

/******************************* Header Files **********************************

Header files are an important part of C as they allow for the connection of C
source files and can simplify code and definitions by separating them into
separate files.

Header files are syntactically similar to C source files but reside in "".h""
files. They can be included in your C source file by using the precompiler
command #include ""example.h"", given that example.h exists in the same directory
as the C file.
*/

/* A safe guard to prevent the header from being defined too many times. This */
/* happens in the case of circle dependency, the contents of the header is    */
/* already defined.                                                           */
#ifndef EXAMPLE_H /* if EXAMPLE_H is not yet defined. */
#define EXAMPLE_H /* Define the macro EXAMPLE_H. */

/* Other headers can be included in headers and therefore transitively */
/* included into files that include this header.                       */
#include <string.h>

/* Like for c source files, macros can be defined in headers */
/* and used in files that include this header file.          */
#define EXAMPLE_NAME ""Dennis Ritchie""

/* Function macros can also be defined.  */
#define ADD(a, b) ((a) + (b))

/* Notice the parenthesis surrounding the arguments -- this is important to   */
/* ensure that a and b don't get expanded in an unexpected way (e.g. consider */
/* MUL(x, y) (x * y); MUL(1 + 2, 3) would expand to (1 + 2 * 3), yielding an  */
/* incorrect result)                                                          */

/* Structs and typedefs can be used for consistency between files. */
typedef struct Node
{
    int val;
    struct Node *next;
} Node;

/* So can enumerations. */
enum traffic_light_state {GREEN, YELLOW, RED};

/* Function prototypes can also be defined here for use in multiple files,  */
/* but it is bad practice to define the function in the header. Definitions */
/* should instead be put in a C file.                                       */
Node createLinkedList(int *vals, int len);

/* Beyond the above elements, other definitions should be left to a C source */
/* file. Excessive includes or definitions should also not be contained in   */
/* a header file but instead put into separate headers or a C file.          */

#endif /* End of the if precompiler directive. */

```

## Further Reading

Best to find yourself a copy of [K&R, aka ""The C Programming Language""](https://en.wikipedia.org/wiki/The_C_Programming_Language)
It is _the_ book about C, written by Dennis Ritchie, the creator of C, and Brian Kernighan. Be careful, though - it's ancient and it contains some
inaccuracies (well, ideas that are not considered good anymore) or now-changed practices.

Another good resource is [Learn C The Hard Way](http://learncodethehardway.org/c/) (not free).

If you have a question, read the [compl.lang.c Frequently Asked Questions](http://c-faq.com).

It's very important to use proper spacing, indentation and to be consistent with your coding style in general.
Readable code is better than clever code and fast code. For a good, sane coding style to adopt, see the
[Linux kernel coding style](https://www.kernel.org/doc/Documentation/process/coding-style.rst).

Other than that, Google is your friend.

[1] [Why isn't sizeof for a struct equal to the sum of sizeof of each member?](https://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member)"
"CMake is a cross-platform, open-source build system. This tool allows you to test, 
compile, and create packages of your source code.

The problem that CMake tries to solve is the problem of Makefiles and 
Autoconfigure on cross-platforms (different make interpreters have different 
commands) and the ease-of-use on linking 3rd party libraries.

CMake is an extensible, open-source system that manages the build process in 
an operating system and compiler-agnostic manner. Unlike many 
cross-platform systems, CMake is designed to be used in conjunction with the 
native build environment. Simple configuration files placed in each source 
directory (called CMakeLists.txt files) are used to generate standard build 
files (e.g., makefiles on Unix and projects/workspaces in Windows MSVC) which 
are used in the usual way.

```cmake
# In CMake, this is a comment

# To run our code, please perform the following commands:
#  - mkdir build && cd build
#  - cmake ..
#  - make
# 
# With those steps, we will follow the best practice to compile into a subdir
# and the second line will request to CMake to generate a new OS-dependent
# Makefile. Finally, run the native Make command.

#------------------------------------------------------------------------------
# Basic
#------------------------------------------------------------------------------
#
# The CMake file MUST be named as ""CMakeLists.txt"".

# Setup the minimum version required of CMake to generate the Makefile
cmake_minimum_required (VERSION 2.8)

# Raises a FATAL_ERROR if version < 2.8
cmake_minimum_required (VERSION 2.8 FATAL_ERROR)

# We define the name of our project, and this changes some directories
# naming convention generated by CMake. We can send the LANG of code
# as the second param
project (learncmake C)

# Set the project source dir (just convention)
set( LEARN_CMAKE_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR} )
set( LEARN_CMAKE_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR} )

# It's useful to set up the current version of our code in the build system
# using a `semver` style
set (LEARN_CMAKE_VERSION_MAJOR 1)
set (LEARN_CMAKE_VERSION_MINOR 0)
set (LEARN_CMAKE_VERSION_PATCH 0)

# Send the variables (version number) to the source code header
configure_file (
  ""${PROJECT_SOURCE_DIR}/TutorialConfig.h.in""
  ""${PROJECT_BINARY_DIR}/TutorialConfig.h""
)

# Include Directories
# In GCC, this will invoke the ""-I"" command
include_directories( include )

# Where are the additional libraries installed? Note: provide includes
# path here, subsequent checks will resolve everything else
set( CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ""${CMAKE_SOURCE_DIR}/CMake/modules/"" )

# Conditions
if ( CONDITION )
  # Output!

  # Incidental information
  message(STATUS ""My message"")

  # CMake Warning, continue processing
  message(WARNING ""My message"")

  # CMake Warning (dev), continue processing
  message(AUTHOR_WARNING ""My message"")

  # CMake Error, continue processing, but skip generation
  message(SEND_ERROR ""My message"")

  # CMake Error, stop processing and generation
  message(FATAL_ERROR ""My message"")
endif()

if( CONDITION )

elseif( CONDITION )

else( CONDITION )

endif( CONDITION )

# Loops
foreach(loop_var arg1 arg2 ...)
  COMMAND1(ARGS ...)
  COMMAND2(ARGS ...)
  ...
endforeach(loop_var)

foreach(loop_var RANGE total)
foreach(loop_var RANGE start stop [step])

foreach(loop_var IN [LISTS [list1 [...]]]
                    [ITEMS [item1 [...]]])

while(condition)
  COMMAND1(ARGS ...)
  COMMAND2(ARGS ...)
  ...
endwhile(condition)


# Logic Operations
if(FALSE AND (FALSE OR TRUE))
  message(""Don't display!"")
endif()

# Set a regular, cache, or environment variable to a given value.
# If the PARENT_SCOPE option is given, the variable will be set in the scope
# above the current scope.
# `set(<variable> <value>... [PARENT_SCOPE])`

# How to reference variables inside quoted and unquoted arguments?
# A variable reference is replaced by either the variable value or by the 
# empty string if the variable is not set.
${variable_name}

# Lists
# Setup the list of source files
set( LEARN_CMAKE_SOURCES 
  src/main.c
  src/imagem.c
  src/pather.c
)

# Calls the compiler
#
# ${PROJECT_NAME} refers to Learn_CMake 
add_executable( ${PROJECT_NAME} ${LEARN_CMAKE_SOURCES} )

# Link the libraries
target_link_libraries( ${PROJECT_NAME} ${LIBS} m )

# Where are the additional libraries installed? Note: provide includes
# path here, subsequent checks will resolve everything else
set( CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ""${CMAKE_SOURCE_DIR}/CMake/modules/"" )

# Compiler Condition (gcc ; g++)
if ( ""${CMAKE_C_COMPILER_ID}"" STREQUAL ""GNU"" )
  message( STATUS ""Setting the flags for ${CMAKE_C_COMPILER_ID} compiler"" )
  add_definitions( --std=c99 )
endif()

# Check for OS
if( UNIX )
    set( LEARN_CMAKE_DEFINITIONS
        ""${LEARN_CMAKE_DEFINITIONS} -Wall -Wextra -Werror -Wno-deprecated-declarations -Wno-unused-parameter -Wno-comment"" )
endif()
```

### More Resources

+ [CMake tutorial](https://cmake.org/cmake-tutorial/)
+ [CMake documentation](https://cmake.org/documentation/)
+ [Mastering CMake](http://amzn.com/1930934319/)
+ [An Introduction to Modern CMake](https://cliutils.gitlab.io/modern-cmake/)"
"[tmux](http://tmux.github.io)
is a terminal multiplexer: it enables a number of terminals
to be created, accessed, and controlled from a single screen. tmux
may be detached from a screen and continue running in the background
then later reattached.


```

  tmux [command]     # Run a command
                     # 'tmux' with no commands will create a new session

    new              # Create a new session
     -s ""Session""    # Create named session
     -n ""Window""     # Create named Window
     -c ""/dir""       # Start in target directory

    attach           # Attach last/available session
     -t ""#""          # Attach target session
     -d              # Detach the session from other instances

    ls               # List open sessions
     -a              # List all open sessions

    lsw              # List windows
     -a              # List all windows
     -s              # List all windows in session

    lsp              # List panes
     -a              # List all panes
     -s              # List all panes in session
     -t              # List all panes in target

    kill-window      # Kill current window
     -t ""#""          # Kill target window
     -a              # Kill all windows
     -a -t ""#""       # Kill all windows but the target

    kill-session     # Kill current session
     -t ""#""          # Kill target session
     -a              # Kill all sessions
     -a -t ""#""       # Kill all sessions but the target

```


### Key Bindings

The method of controlling an attached tmux session is via key
combinations called 'Prefix' keys.

```
----------------------------------------------------------------------
  (C-b) = Ctrl + b    # 'Prefix' combination required to use keybinds

  (M-1) = Meta + 1 -or- Alt + 1
----------------------------------------------------------------------

  ?                  # List all key bindings
  :                  # Enter the tmux command prompt
  r                  # Force redraw of the attached client
  c                  # Create a new window

  !                  # Break the current pane out of the window.
  %                  # Split the current pane into two, left and right
  ""                  # Split the current pane into two, top and bottom

  n                  # Change to the next window
  p                  # Change to the previous window
  {                  # Swap the current pane with the previous pane
  }                  # Swap the current pane with the next pane
  [                  # Enter Copy Mode to copy text or view history.

  s                  # Select a new session for the attached client
                     interactively
  w                  # Choose the current window interactively
  0 to 9             # Select windows 0 to 9

  d                  # Detach the current client
  D                  # Choose a client to detach

  &                  # Kill the current window
  x                  # Kill the current pane

  Up, Down           # Change to the pane above, below, left, or right
  Left, Right

  M-1 to M-5         # Arrange panes:
                       # 1) even-horizontal
                       # 2) even-vertical
                       # 3) main-horizontal
                       # 4) main-vertical
                       # 5) tiled

  C-Up, C-Down       # Resize the current pane in steps of one cell
  C-Left, C-Right

  M-Up, M-Down       # Resize the current pane in steps of five cells
  M-Left, M-Right

```


### Configuring ~/.tmux.conf

tmux.conf can be used to set options automatically on start up, much
like how .vimrc or init.el are used.

```
# Example tmux.conf
# 2015.12


### General
###########################################################################

# Scrollback/History limit
set -g history-limit 2048

# Index Start
set -g base-index 1

# Mouse
set-option -g -q mouse on

# Force reload of config file
unbind r
bind r source-file ~/.tmux.conf


### Keybinds
###########################################################################

# Unbind C-b as the default prefix
unbind C-b

# Set new default prefix
set-option -g prefix `

# Return to previous window when prefix is pressed twice
bind C-a last-window
bind ` last-window

# Allow swapping C-a and ` using F11/F12
bind F11 set-option -g prefix C-a
bind F12 set-option -g prefix `

# Keybind preference
setw -g mode-keys vi
set-option -g status-keys vi

# Moving between panes with vim movement keys
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R

# Window Cycle/Swap
bind e previous-window
bind f next-window
bind E swap-window -t -1
bind F swap-window -t +1

# Easy split pane commands
bind = split-window -h
bind - split-window -v
unbind '""'
unbind %

# Activate inner-most session (when nesting tmux) to send commands
bind a send-prefix


### Theme
###########################################################################

# Statusbar Color Palette
set-option -g status-justify left
set-option -g status-bg black
set-option -g status-fg white
set-option -g status-left-length 40
set-option -g status-right-length 80

# Pane Border Color Palette
set-option -g pane-active-border-fg green
set-option -g pane-active-border-bg black
set-option -g pane-border-fg white
set-option -g pane-border-bg black

# Message Color Palette
set-option -g message-fg black
set-option -g message-bg green

# Window Status Color Palette
setw -g window-status-bg black
setw -g window-status-current-fg green
setw -g window-status-bell-attr default
setw -g window-status-bell-fg red
setw -g window-status-activity-attr default
setw -g window-status-activity-fg yellow


### UI
###########################################################################

# Notification
setw -g monitor-activity on
set -g visual-activity on
set-option -g bell-action any
set-option -g visual-bell off

# Automatically set window titles
set-option -g set-titles on
set-option -g set-titles-string '#H:#S.#I.#P #W #T' # window number,program name,active (or not)

# Statusbar Adjustments
set -g status-left ""#[fg=red] #H#[fg=green]:#[fg=white]#S#[fg=green] |#[default]""

# Show performance counters in statusbar
# Requires https://github.com/thewtex/tmux-mem-cpu-load/
set -g status-interval 4
set -g status-right ""#[fg=green] | #[fg=white]#(tmux-mem-cpu-load)#[fg=green] | #[fg=cyan]%H:%M #[default]""

```


### References

[Tmux | Home](http://tmux.github.io)

[Tmux Manual page](http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man1/tmux.1?query=tmux)

[Gentoo Wiki](http://wiki.gentoo.org/wiki/Tmux)

[Archlinux Wiki](https://wiki.archlinux.org/index.php/Tmux)

[Display CPU/MEM % in statusbar](https://stackoverflow.com/questions/11558907/is-there-a-better-way-to-display-cpu-usage-in-tmux)

[tmuxinator - Manage complex tmux sessions](https://github.com/tmuxinator/tmuxinator)"
"Web pages are built with HTML, which specifies the content of a page.
CSS (Cascading Style Sheets) is a separate language which specifies
a page's **appearance**.

CSS code is made of static *rules*. Each rule takes one or more *selectors* and
gives specific *values* to a number of visual *properties*. Those properties are
then applied to the page elements indicated by the selectors.

This guide has been written with CSS 2 in mind, which is extended by the new
features of CSS 3.

**NOTE:** Because CSS produces visual results, in order to learn it, you need to
try everything in a CSS playground like [dabblet](http://dabblet.com/).
The main focus of this article is on the syntax and some general tips.

## Syntax

```css
/* comments appear inside slash-asterisk, just like this line!
   there are no ""one-line comments""; this is the only comment style */

/* ####################
   ## SELECTORS
   #################### */

/* the selector is used to target an element on a page. */
selector { property: value; /* more properties...*/ }

/*
Here is an example element:

<div class='class1 class2' id='anID' attr='value' otherAttr='en-us foo bar' />
*/

/* You can target it using one of its CSS classes */
.class1 { }

/* or both classes! */
.class1.class2 { }

/* or its name */
div { }

/* or its id */
#anID { }

/* or using the fact that it has an attribute! */
[attr] { font-size:smaller; }

/* or that the attribute has a specific value */
[attr='value'] { font-size:smaller; }

/* starts with a value (CSS 3) */
[attr^='val'] { font-size:smaller; }

/* or ends with a value (CSS 3) */
[attr$='ue'] { font-size:smaller; }

/* or contains a value in a space-separated list */
[otherAttr~='foo'] { }
[otherAttr~='bar'] { }

/* or contains a value in a dash-separated list, e.g., ""-"" (U+002D) */
[otherAttr|='en'] { font-size:smaller; }


/* You can combine different selectors to create a more focused selector. Don't
   put spaces between them. */
div.some-class[attr$='ue'] { }

/* You can select an element which is a child of another element */
div.some-parent > .class-name { }

/* or a descendant of another element. Children are the direct descendants of
   their parent element, only one level down the tree. Descendants can be any
   level down the tree. */
div.some-parent .class-name { }

/* Warning: the same selector without a space has another meaning.
   Can you guess what? */
div.some-parent.class-name { }

/* You may also select an element based on its adjacent sibling */
.i-am-just-before + .this-element { }

/* or any sibling preceding it */
.i-am-any-element-before ~ .this-element { }

/* There are some selectors called pseudo classes that can be used to select an
   element only when it is in a particular state */

/* for example, when the cursor hovers over an element */
selector:hover { }

/* or a link has been visited */
selector:visited { }

/* or hasn't been visited */
selected:link { }

/* or an element is in focus */
selected:focus { }

/* any element that is the first child of its parent */
selector:first-child {}

/* any element that is the last child of its parent */
selector:last-child {}

/* Just like pseudo classes, pseudo elements allow you to style certain parts of
    a document  */

/* matches a virtual first child of the selected element */
selector::before {}

/* matches a virtual last child of the selected element */
selector::after {}

/* At appropriate places, an asterisk may be used as a wildcard to select every
   element */
* { } /* all elements */
.parent * { } /* all descendants */
.parent > * { } /* all children */

/* Group any number of selectors to define styles that affect all selectors
   in the group */
selector1, selector2 { }

/* ####################
   ## PROPERTIES
   #################### */

selector {

    /* Units of length can be absolute or relative. */

    /* Relative units */
    width: 50%;       /* percentage of parent element width */
    font-size: 2em;   /* multiples of element's original font-size */
    font-size: 2rem;  /* or the root element's font-size */
    font-size: 2vw;   /* multiples of 1% of the viewport's width (CSS 3) */
    font-size: 2vh;   /* or its height */
    font-size: 2vmin; /* whichever of a vh or a vw is smaller */
    font-size: 2vmax; /* or greater */

    /* Absolute units */
    width: 200px;     /* pixels */
    font-size: 20pt;  /* points */
    width: 5cm;       /* centimeters */
    min-width: 50mm;  /* millimeters */
    max-width: 5in;   /* inches */

    /* Colors */
    color: #F6E;                    /* short hex format */
    color: #FF66EE;                 /* long hex format */
    color: tomato;                  /* a named color */
    color: rgb(255, 255, 255);      /* as rgb values */
    color: rgb(10%, 20%, 50%);      /* as rgb percentages */
    color: rgba(255, 0, 0, 0.3);    /* as rgba values (CSS 3) Note: 0 <= a <= 1 */
    color: transparent;             /* equivalent to setting the alpha to 0 */
    color: hsl(0, 100%, 50%);       /* as hsl percentages (CSS 3) */
    color: hsla(0, 100%, 50%, 0.3); /* as hsl percentages with alpha */

    /* Borders */
    border-width:5px;
    border-style:solid;
    border-color:red;      /* similar to how background-color is set */
    border: 5px solid red; /* this is a short hand approach for the same */
    border-radius:20px;    /* this is a CSS3 property */

    /* Images as backgrounds of elements */
    background-image: url(/img-path/img.jpg); /* quotes inside url() optional */

    /* Fonts */
    font-family: Arial;
    /* if the font family name has a space, it must be quoted */
    font-family: ""Courier New"";
    /* if the first one is not found, the browser uses the next, and so on */
    font-family: ""Courier New"", Trebuchet, Arial, sans-serif;
}
```

## Usage

Save a CSS stylesheet with the extension `.css`.

```html
<!-- You need to include the css file in your page's <head>. This is the
     recommended method. Refer to http://stackoverflow.com/questions/8284365 -->
<link rel='stylesheet' type='text/css' href='path/to/style.css'>

<!-- You can also include some CSS inline in your markup. -->
<style>
   a { color: purple; }
</style>

<!-- Or directly set CSS properties on the element. -->
<div style=""border: 1px solid red;"">
</div>
```

## Precedence or Cascade

An element may be targeted by multiple selectors and may have a property set on
it in more than once. In these cases, one of the rules takes precedence over
others. Rules with a more specific selector take precedence over a less specific
one, and a rule occurring later in the stylesheet overwrites a previous one
(which also means that if two different linked stylesheets contain rules for an
element and if the rules are of the same specificity, then order of linking
would take precedence and the sheet linked latest would govern styling) .

This process is called cascading, hence the name Cascading Style Sheets.

Given the following CSS:

```css
/* A */
p.class1[attr='value']

/* B */
p.class1 { }

/* C */
p.class2 { }

/* D */
p { }

/* E */
p { property: value !important; }
```

and the following markup:

```html
<p style='/*F*/ property:value;' class='class1 class2' attr='value'>
```

The precedence of style is as follows. Remember, the precedence is for each
**property**, not for the entire block.

* `E` has the highest precedence because of the keyword `!important`. It is
recommended that you avoid its usage.
* `F` is next, because it is an inline style.
* `A` is next, because it is more ""specific"" than anything else. It has 3
    specifiers: The name of the element `p`, its class `class1`, an attribute
    `attr='value'`.
* `C` is next, even though it has the same specificity as `B`.
    This is because it appears after `B`.
* `B` is next.
* `D` is the last one.

## Media Queries

CSS Media Queries are a feature in CSS 3 which allows you to specify when certain CSS rules should be applied, such as when printed, or when on a screen with certain dimensions or pixel density. They do not add to the selector's specificity.

```css
/* A rule that will be used on all devices */
h1 {
  font-size: 2em;
  color: white;
  background-color: black;
}

/* change the h1 to use less ink on a printer */
@media print {
  h1 {
    color: black;
    background-color: white;
  }
}

/* make the font bigger when shown on a screen at least 480px wide */
@media screen and (min-width: 480px) {
  h1 {
    font-size: 3em;
    font-weight: normal;
  }
}
```

Media queries can include these features:
`width`, `height`, `device-width`, `device-height`, `orientation`, `aspect-ratio`, `device-aspect-ratio`, `color`, `color-index`, `monochrome`, `resolution`, `scan`, `grid`. Most of these features can be prefixed with `min-` or `max-`.

The `resolution` feature is not supported by older devices, instead use `device-pixel-ratio`.

Many smartphones and tablets will attempt to render the page as if it were on a desktop unless you provide a `viewport` meta-tag.

```html
<head>
  <meta name=""viewport"" content=""width=device-width; initial-scale=1.0"">
</head>
```

## Compatibility

Most of the features in CSS 2 (and many in CSS 3) are available across all
browsers and devices. But it's always good practice to check before using
a new feature.

## Resources

* [CanIUse](http://caniuse.com) (Detailed compatibility info)
* [Dabblet](http://dabblet.com/) (CSS playground)
* [Mozilla Developer Network's CSS documentation](https://developer.mozilla.org/en-US/docs/Web/CSS) (Tutorials and reference)
* [Codrops' CSS Reference](http://tympanus.net/codrops/css_reference/) (Reference)
* [DevTips' CSS Basics](https://www.youtube.com/playlist?list=PLqGj3iMvMa4IOmy04kDxh_hqODMqoeeCy) (Tutorials)

## Further Reading

* [Understanding Style Precedence in CSS: Specificity, Inheritance, and the Cascade](http://www.vanseodesign.com/css/css-specificity-inheritance-cascaade/)
* [Selecting elements using attributes](https://css-tricks.com/almanac/selectors/a/attribute/)
* [QuirksMode CSS](http://www.quirksmode.org/css/)
* [Z-Index - The stacking context](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)
* [SASS](http://sass-lang.com/) and [LESS](http://lesscss.org/) for CSS pre-processing
* [CSS-Tricks](https://css-tricks.com)"
"LiveScript is a functional compile-to-JavaScript language which shares
most of the underlying semantics with its host language. Nice additions
comes with currying, function composition, pattern matching and lots of
other goodies heavily borrowed from languages like Haskell, F# and
Scala.

LiveScript is a fork of [Coco][], which is itself a fork of
[CoffeeScript][]. The language is stable, and a new version is in active
development to bring a plethora of new niceties!

[Coco]: http://satyr.github.io/coco/
[CoffeeScript]: http://coffeescript.org/

Feedback is always welcome, so feel free to reach me over at
[@kurisuwhyte](https://twitter.com/kurisuwhyte) :)


```coffeescript
# Just like its CoffeeScript cousin, LiveScript uses number symbols for
# single-line comments.

/*
 Multi-line comments are written C-style. Use them if you want comments
 to be preserved in the JavaScript output.
 */
```
```coffeescript
# As far as syntax goes, LiveScript uses indentation to delimit blocks,
# rather than curly braces, and whitespace to apply functions, rather
# than parenthesis.


########################################################################
## 1. Basic values
########################################################################

# Lack of value is defined by the keyword `void` instead of `undefined`
void            # same as `undefined` but safer (can't be overridden)

# No valid value is represented by Null.
null


# The most basic actual value is the logical type:
true
false

# And it has a plethora of aliases that mean the same thing:
on; off
yes; no


# Then you get numbers. These are double-precision floats like in JS.
10
0.4     # Note that the leading `0` is required

# For readability, you may use underscores and letter suffixes in a
# number, and these will be ignored by the compiler.
12_344km


# Strings are immutable sequences of characters, like in JS:
""Christina""             # apostrophes are okay too!
""""""Multi-line
   strings
   are
   okay
   too.""""""

# Sometimes you want to encode a keyword, the backslash notation makes
# this easy:
\keyword                # => 'keyword'


# Arrays are ordered collections of values.
fruits =
  * \apple
  * \orange
  * \pear

# They can be expressed more concisely with square brackets:
fruits = [ \apple, \orange, \pear ]

# You also get a convenient way to create a list of strings, using
# white space to delimit the items.
fruits = <[ apple orange pear ]>

# You can retrieve an item by their 0-based index:
fruits[0]       # => ""apple""

# Objects are a collection of unordered key/value pairs, and a few other
# things (more on that later).
person =
  name: ""Christina""
  likes:
    * ""kittens""
    * ""and other cute stuff""

# Again, you can express them concisely with curly brackets:
person = {name: ""Christina"", likes: [""kittens"", ""and other cute stuff""]}

# You can retrieve an item by their key:
person.name     # => ""Christina""
person[""name""]  # => ""Christina""


# Regular expressions use the same syntax as JavaScript:
trailing-space = /\s$/          # dashed-words become dashedWords

# Except you can do multi-line expressions too!
# (comments and whitespace just gets ignored)
funRE = //
        function\s+(.+)         # name
        \s* \((.*)\) \s*        # arguments
        { (.*) }                # body
        //


########################################################################
## 2. Basic operations
########################################################################

# Arithmetic operators are the same as JavaScript's:
1 + 2   # => 3
2 - 1   # => 1
2 * 3   # => 6
4 / 2   # => 2
3 % 2   # => 1


# Comparisons are mostly the same too, except that `==` is the same as
# JS's `===`, where JS's `==` in LiveScript is `~=`, and `===` enables
# object and array comparisons, and also stricter comparisons:
2 == 2          # => true
2 == ""2""        # => false
2 ~= ""2""        # => true
2 === ""2""       # => false

[1,2,3] == [1,2,3]        # => false
[1,2,3] === [1,2,3]       # => true

+0 == -0     # => true
+0 === -0    # => false

# Other relational operators include <, <=, > and >=

# Logical values can be combined through the logical operators `or`,
# `and` and `not`
true and false  # => false
false or true   # => true
not false       # => true


# Collections also get some nice additional operators
[1, 2] ++ [3, 4]                # => [1, 2, 3, 4]
'a' in <[ a b c ]>              # => true
'name' of { name: 'Chris' }     # => true


########################################################################
## 3. Functions
########################################################################

# Since LiveScript is functional, you'd expect functions to get a nice
# treatment. In LiveScript it's even more apparent that functions are
# first class:
add = (left, right) -> left + right
add 1, 2        # => 3

# Functions which take no arguments are called with a bang!
two = -> 2
two!

# LiveScript uses function scope, just like JavaScript, and has proper
# closures too. Unlike JavaScript, the `=` works as a declaration
# operator, and will always declare the variable on the left hand side.

# The `:=` operator is available to *reuse* a name from the parent
# scope.


# You can destructure arguments of a function to quickly get to
# interesting values inside a complex data structure:
tail = ([head, ...rest]) -> rest
tail [1, 2, 3]  # => [2, 3]

# You can also transform the arguments using binary or unary
# operators. Default arguments are also possible.
foo = (a = 1, b = 2) -> a + b
foo!    # => 3

# You could use it to clone a particular argument to avoid side-effects,
# for example:
copy = (^^target, source) ->
  for k,v of source => target[k] = v
  target
a = { a: 1 }
copy a, { b: 2 }        # => { a: 1, b: 2 }
a                       # => { a: 1 }


# A function may be curried by using a long arrow rather than a short
# one:
add = (left, right) --> left + right
add1 = add 1
add1 2          # => 3

# Functions get an implicit `it` argument, even if you don't declare
# any.
identity = -> it
identity 1      # => 1

# Operators are not functions in LiveScript, but you can easily turn
# them into one! Enter the operator sectioning:
divide-by-two = (/ 2)
[2, 4, 8, 16].map(divide-by-two) .reduce (+)


# Not only of function application lives LiveScript, as in any good
# functional language you get facilities for composing them:
double-minus-one = (- 1) . (* 2)

# Other than the usual `f . g` mathematical formulae, you get the `>>`
# and `<<` operators, that describe how the flow of values through the
# functions.
double-minus-one = (* 2) >> (- 1)
double-minus-one = (- 1) << (* 2)


# And talking about flow of value, LiveScript gets the `|>` and `<|`
# operators that apply a value to a function:
map = (f, xs) --> xs.map f
[1 2 3] |> map (* 2)            # => [2 4 6]

# You can also choose where you want the value to be placed, just mark
# the place with an underscore (_):
reduce = (f, xs, initial) --> xs.reduce f, initial
[1 2 3] |> reduce (+), _, 0     # => 6


# The underscore is also used in regular partial application, which you
# can use for any function:
div = (left, right) -> left / right
div-by-two = div _, 2
div-by-two 4      # => 2


# Last, but not least, LiveScript has back-calls, which might help
# with some callback-based code (though you should try more functional
# approaches, like Promises):
readFile = (name, f) -> f name
a <- readFile 'foo'
b <- readFile 'bar'
console.log a + b

# Same as:
readFile 'foo', (a) -> readFile 'bar', (b) -> console.log a + b


########################################################################
## 4. Patterns, guards and control-flow
########################################################################

# You can branch computations with the `if...else` expression:
x = if n > 0 then \positive else \negative

# Instead of `then`, you can use `=>`
x = if n > 0 => \positive
    else        \negative

# Complex conditions are better-off expressed with the `switch`
# expression, though:
y = {}
x = switch
  | (typeof y) is \number => \number
  | (typeof y) is \string => \string
  | 'length' of y         => \array
  | otherwise             => \object      # `otherwise` and `_` always matches.

# Function bodies, declarations and assignments get a free `switch`, so
# you don't need to type it again:
take = (n, [x, ...xs]) -->
                        | n == 0 => []
                        | _      => [x] ++ take (n - 1), xs


########################################################################
## 5. Comprehensions
########################################################################

# While the functional helpers for dealing with lists and objects are
# right there in the JavaScript's standard library (and complemented on
# the prelude-ls, which is a ""standard library"" for LiveScript),
# comprehensions will usually allow you to do this stuff faster and with
# a nice syntax:
oneToTwenty = [1 to 20]
evens       = [x for x in oneToTwenty when x % 2 == 0]

# `when` and `unless` can be used as filters in the comprehension.

# Object comprehension works in the same way, except that it gives you
# back an object rather than an Array:
copy = { [k, v] for k, v of source }


########################################################################
## 4. OOP
########################################################################

# While LiveScript is a functional language in most aspects, it also has
# some niceties for imperative and object oriented programming. One of
# them is class syntax and some class sugar inherited from CoffeeScript:
class Animal
  (@name, kind) ->
    @kind = kind
  action: (what) -> ""*#{@name} (a #{@kind}) #{what}*""

class Cat extends Animal
  (@name) -> super @name, 'cat'
  purr: -> @action 'purrs'

kitten = new Cat 'Mei'
kitten.purr!      # => ""*Mei (a cat) purrs*""

# Besides the classical single-inheritance pattern, you can also provide
# as many mixins as you would like for a class. Mixins are just plain
# objects:
Huggable =
  hug: -> @action 'is hugged'

class SnugglyCat extends Cat implements Huggable

kitten = new SnugglyCat 'Purr'
kitten.hug!     # => ""*Mei (a cat) is hugged*""
```

## Further reading

There's just so much more to LiveScript, but this should be enough to
get you started writing little functional things in it. The
[official website](http://livescript.net/) has a lot of information on the
language, and a nice online compiler for you to try stuff out!

You may also want to grab yourself some
[prelude.ls](http://gkz.github.io/prelude-ls/), and check out the `#livescript`
channel on the Freenode network."
"## AngularJS Tutorial.

AngularJS version 1.0 was released in 2012.
Miško Hevery, a Google employee, started to work with AngularJS in 2009.
The idea turned out very well, and the project is now officially supported by Google.

AngularJS is a JavaScript framework. It can be added to an HTML page with a ""script"" tag.
AngularJS extends HTML attributes with Directives, and binds data to HTML with Expressions.

##What You Should Already Know

Before you study AngularJS, you should have a basic understanding of:

- HTML
- CSS
- JavaScript

```html
// AngularJS is a JavaScript framework. It is a library written in JavaScript.
// AngularJS is distributed as a JavaScript file, and can be added to a web page with a script tag:
// <script src=""http://ajax.googleapis.com/ajax/libs/angularjs/1.3.14/angular.min.js""></script>

///////////////////////////////////
// AngularJS Extends HTML

//AngularJS extends HTML with ng-directives.
//The ng-app directive defines an AngularJS application.
//The ng-model directive binds the value of HTML controls (input, select, textarea) to application data.
//The ng-bind directive binds application data to the HTML view.
<!DOCTYPE html>
<html>
  <script src=""http://ajax.googleapis.com/ajax/libs/angularjs/1.3.14/angular.min.js""></script>
  <body>
    <div ng-app="""">
      <p>Name: <input type=""text"" ng-model=""name""></p>
      <p ng-bind=""name""></p>
    </div>
  </body>
</html>

/*
  * Example explained:
  * AngularJS starts automatically when the web page has loaded.
  * The ng-app directive tells AngularJS that the <div> element is the ""owner"" of an AngularJS application.
  * The ng-model directive binds the value of the input field to the application variable name.
  * The ng-bind directive binds the innerHTML of the <p> element to the application variable name.
*/
<tag> Here are content to be interpreted </tag>

///////////////////////////////////
// AngularJS Expressions

// AngularJS expressions are written inside double braces: {{ expression }}.
// AngularJS expressions binds data to HTML the same way as the ng-bind directive.
// AngularJS will ""output"" data exactly where the expression is written.
// AngularJS expressions are much like JavaScript expressions: They can contain literals, operators, and variables.
// Example {{ 5 + 5 }} or {{ firstName + "" "" + lastName }}
<!DOCTYPE html>
<html>
  <script src=""http://ajax.googleapis.com/ajax/libs/angularjs/1.3.14/angular.min.js""></script>
  <body>
    <div ng-app="""">
      <p>My first expression: {{ 5 + 5 }}</p>
    </div>
  </body>
</html>

//If you remove the ng-app directive, HTML will display the expression as it is, without solving it:
<!DOCTYPE html>
<html>
  <script src=""http://ajax.googleapis.com/ajax/libs/angularjs/1.3.14/angular.min.js""></script>
  <body>
    <div>
      <p>My first expression: {{ 5 + 5 }}</p>
    </div>
  </body>
</html>

// AngularJS expressions bind AngularJS data to HTML the same way as the ng-bind directive.
<!DOCTYPE html>
<html>
<script src=""http://ajax.googleapis.com/ajax/libs/angularjs/1.3.14/angular.min.js""></script>
  <body>
    <div ng-app="""">
      <p>Name: <input type=""text"" ng-model=""name""></p>
      <p>{{name}}</p>
    </div>
  </body>
</html>

// AngularJS numbers are like JavaScript numbers:
<div ng-app="""" ng-init=""quantity=1;cost=5"">
  <p>Total in dollar: {{ quantity * cost }}</p>
</div>

//AngularJS strings are like JavaScript strings:
<div ng-app="""" ng-init=""firstName='John';lastName='Doe'"">
  <p>The name is <span ng-bind=""firstName + ' ' + lastName""></span></p>
</div>

//AngularJS objects are like JavaScript objects:
<div ng-app="""" ng-init=""person={firstName:'John',lastName:'Doe'}"">
  <p>The name is {{ person.lastName }}</p>
</div>

//AngularJS arrays are like JavaScript arrays:
<div ng-app="""" ng-init=""points=[1,15,19,2,40]"">
  <p>The third result is {{ points[2] }}</p>
</div>

// Like JavaScript expressions, AngularJS expressions can contain literals, operators, and variables.
// Unlike JavaScript expressions, AngularJS expressions can be written inside HTML.
// AngularJS expressions do not support conditionals, loops, and exceptions, while JavaScript expressions do.
// AngularJS expressions support filters, while JavaScript expressions do not.

///////////////////////////////////
// AngularJS Directives


//AngularJS directives are extended HTML attributes with the prefix ng-.
//The ng-app directive initializes an AngularJS application.
//The ng-init directive initializes application data.
//The ng-model directive binds the value of HTML controls (input, select, textarea) to application data.
<div ng-app="""" ng-init=""firstName='John'"">
  <p>Name: <input type=""text"" ng-model=""firstName""></p>
  <p>You wrote: {{ firstName }}</p>
</div>

//Using ng-init is not very common. You will learn how to initialize data in the chapter about controllers.

//The ng-repeat directive repeats an HTML element:
<div ng-app="""" ng-init=""names=['Jani','Hege','Kai']"">
  <ul>
    <li ng-repeat=""x in names"">
      {{ x }}
    </li>
  </ul>
</div>

//The ng-repeat directive used on an array of objects:
<div ng-app="""" ng-init=""names=[
{name:'Jani',country:'Norway'},
{name:'Hege',country:'Sweden'},
{name:'Kai',country:'Denmark'}]"">
  <ul>
    <li ng-repeat=""x  in names"">
      {{ x.name + ', ' + x.country }}
    </li>
  </ul>
</div>

// AngularJS is perfect for database CRUD (Create Read Update Delete) applications.
// Just imagine if these objects were records from a database.

// The ng-app directive defines the root element of an AngularJS application.
// The ng-app directive will auto-bootstrap (automatically initialize) the application when a web page is loaded.
// Later you will learn how ng-app can have a value (like ng-app=""myModule""), to connect code modules.

// The ng-init directive defines initial values for an AngularJS application.
// Normally, you will not use ng-init. You will use a controller or module instead.
// You will learn more about controllers and modules later.

//The ng-model directive binds the value of HTML controls (input, select, textarea) to application data.
//The ng-model directive can also:
//Provide type validation for application data (number, email, required).
//Provide status for application data (invalid, dirty, touched, error).
//Provide CSS classes for HTML elements.
//Bind HTML elements to HTML forms.

//The ng-repeat directive clones HTML elements once for each item in a collection (in an array).

///////////////////////////////////
// AngularJS Controllers

// AngularJS controllers control the data of AngularJS applications.
// AngularJS controllers are regular JavaScript Objects.

// AngularJS applications are controlled by controllers.
// The ng-controller directive defines the application controller.
// A controller is a JavaScript Object, created by a standard JavaScript object constructor.

<div ng-app=""myApp"" ng-controller=""myCtrl"">

First Name: <input type=""text"" ng-model=""firstName""><br>
Last Name: <input type=""text"" ng-model=""lastName""><br>
<br>
Full Name: {{firstName + "" "" + lastName}}

</div>

<script>
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope) {
    $scope.firstName = ""John"";
    $scope.lastName = ""Doe"";
});
</script>

//Application explained:

//The AngularJS application is defined by  ng-app=""myApp"". The application runs inside the <div>.
//The ng-controller=""myCtrl"" attribute is an AngularJS directive. It defines a controller.
//The myCtrl function is a JavaScript function.
//AngularJS will invoke the controller with a $scope object.
//In AngularJS, $scope is the application object (the owner of application variables and functions).
//The controller creates two properties (variables) in the scope (firstName and lastName).
//The ng-model directives bind the input fields to the controller properties (firstName and lastName).

//The example above demonstrated a controller object with two properties: lastName and firstName.
//A controller can also have methods (variables as functions):
<div ng-app=""myApp"" ng-controller=""personCtrl"">

First Name: <input type=""text"" ng-model=""firstName""><br>
Last Name: <input type=""text"" ng-model=""lastName""><br>
<br>
Full Name: {{fullName()}}

</div>

<script>
var app = angular.module('myApp', []);
app.controller('personCtrl', function($scope) {
    $scope.firstName = ""John"";
    $scope.lastName = ""Doe"";
    $scope.fullName = function() {
        return $scope.firstName + "" "" + $scope.lastName;
    }
});
</script>

//In larger applications, it is common to store controllers in external files.
//Just copy the code between the <script> </script> tags into an external file named personController.js:

<div ng-app=""myApp"" ng-controller=""personCtrl"">

First Name: <input type=""text"" ng-model=""firstName""><br>
Last Name: <input type=""text"" ng-model=""lastName""><br>
<br>
Full Name: {{firstName + "" "" + lastName}}

</div>

<script src=""personController.js""></script>

// For the next example we will create a new controller file:
angular.module('myApp', []).controller('namesCtrl', function($scope) {
    $scope.names = [
        {name:'Jani',country:'Norway'},
        {name:'Hege',country:'Sweden'},
        {name:'Kai',country:'Denmark'}
    ];
});

//Save the file as  namesController.js:
//And then use the controller file in an application:

<div ng-app=""myApp"" ng-controller=""namesCtrl"">

<ul>
  <li ng-repeat=""x in names"">
    {{ x.name + ', ' + x.country }}
  </li>
</ul>

</div>

<script src=""namesController.js""></script>

///////////////////////////////////
// AngularJS Filters

// Filters can be added to expressions and directives using a pipe character.
// AngularJS filters can be used to transform data:

- **currency**:  Format a number to a currency format.
- **filter**:  Select a subset of items from an array.
- **lowercase**: Format a string to lower case.
- **orderBy**: Orders an array by an expression.
- **uppercase**: Format a string to upper case.

//A filter can be added to an expression with a pipe character (|) and a filter.
//(For the next two examples we will use the person controller from the previous chapter)
//The uppercase filter format strings to upper case:
<div ng-app=""myApp"" ng-controller=""personCtrl"">

<p>The name is {{ lastName | uppercase }}</p>

</div>

//The lowercase filter format strings to lower case:
<div ng-app=""myApp"" ng-controller=""personCtrl"">

<p>The name is {{ lastName | lowercase }}</p>

</div>

//The currency filter formats a number as currency:
<div ng-app=""myApp"" ng-controller=""costCtrl"">

<input type=""number"" ng-model=""quantity"">
<input type=""number"" ng-model=""price"">

<p>Total = {{ (quantity * price) | currency }}</p>

</div> 

//A filter can be added to a directive with a pipe character (|) and a filter.
//The orderBy filter orders an array by an expression:
<div ng-app=""myApp"" ng-controller=""namesCtrl"">

<ul>
  <li ng-repeat=""x in names | orderBy:'country'"">
    {{ x.name + ', ' + x.country }}
  </li>
</ul>

<div>

//An input filter can be added to a directive with a pipe character (|) 
//and filter followed by a colon and a model name.
//The filter selects a subset of an array:

<div ng-app=""myApp"" ng-controller=""namesCtrl"">

<p><input type=""text"" ng-model=""test""></p>

<ul>
  <li ng-repeat=""x in names | filter:test | orderBy:'country'"">
    {{ (x.name | uppercase) + ', ' + x.country }}
  </li>
</ul>

</div>

///////////////////////////////////
// AngularJS AJAX - $http

//$http is an AngularJS service for reading data from remote servers.

// The following data can be provided by a web server:
// http://www.w3schools.com/angular/customers.php
// **Check the URL to see the data format**

// AngularJS $http is a core service for reading data from web servers.
// $http.get(url) is the function to use for reading server data.
<div ng-app=""myApp"" ng-controller=""customersCtrl""> 

<ul>
  <li ng-repeat=""x in names"">
    {{ x.Name + ', ' + x.Country }}
  </li>
</ul>

</div>

<script>
var app = angular.module('myApp', []);
app.controller('customersCtrl', function($scope, $http) {
    $http.get(""http://www.w3schools.com/angular/customers.php"")
    .success(function(response) {$scope.names = response.records;});
});
</script>

Application explained:

// The AngularJS application is defined by ng-app. The application runs inside a <div>.
// The ng-controller directive names the controller object.
// The customersCtrl function is a standard JavaScript object constructor.
// AngularJS will invoke customersCtrl with a $scope and $http object.
// $scope is the application object (the owner of application variables and functions).
// $http is an XMLHttpRequest object for requesting external data.
// $http.get() reads JSON data from http://www.w3schools.com/angular/customers.php.
// If success, the controller creates a property (names) in the scope, with JSON data from the server.


// Requests for data from a different server (than the requesting page), are called cross-site HTTP requests.
// Cross-site requests are common on the web. Many pages load CSS, images, and scripts from different servers.
// In modern browsers, cross-site HTTP requests from scripts are restricted to same site for security reasons.
// The following line, in our PHP examples, has been added to allow cross-site access.
header(""Access-Control-Allow-Origin: *"");


///////////////////////////////////
// AngularJS Tables

// Displaying tables with angular is very simple:
<div ng-app=""myApp"" ng-controller=""customersCtrl""> 

<table>
  <tr ng-repeat=""x in names"">
    <td>{{ x.Name }}</td>
    <td>{{ x.Country }}</td>
  </tr>
</table>

</div>

<script>
var app = angular.module('myApp', []);
app.controller('customersCtrl', function($scope, $http) {
    $http.get(""http://www.w3schools.com/angular/customers.php"")
    .success(function (response) {$scope.names = response.records;});
});
</script>

// To sort the table, add an orderBy filter: 
<table>
  <tr ng-repeat=""x in names | orderBy : 'Country'"">
    <td>{{ x.Name }}</td>
    <td>{{ x.Country }}</td>
  </tr>
</table>

// To display the table index, add a <td> with $index: 
<table>
  <tr ng-repeat=""x in names"">
    <td>{{ $index + 1 }}</td>
    <td>{{ x.Name }}</td>
    <td>{{ x.Country }}</td>
  </tr>
</table>

// Using $even and $odd
<table>
  <tr ng-repeat=""x in names"">
    <td ng-if=""$odd"" style=""background-color:#f1f1f1"">{{ x.Name }}</td>
    <td ng-if=""$even"">{{ x.Name }}</td>
    <td ng-if=""$odd"" style=""background-color:#f1f1f1"">{{ x.Country }}</td>
    <td ng-if=""$even"">{{ x.Country }}</td>
  </tr>
</table>

///////////////////////////////////
// AngularJS HTML DOM

//AngularJS has directives for binding application data to the attributes of HTML DOM elements.

// The ng-disabled directive binds AngularJS application data to the disabled attribute of HTML elements.

<div ng-app="""" ng-init=""mySwitch=true"">

<p>
<button ng-disabled=""mySwitch"">Click Me!</button>
</p>

<p>
<input type=""checkbox"" ng-model=""mySwitch"">Button
</p>

</div>

//Application explained:

// The ng-disabled directive binds the application data mySwitch to the HTML button's disabled attribute.
// The ng-model directive binds the value of the HTML checkbox element to the value of mySwitch.
// If the value of mySwitch evaluates to true, the button will be disabled: 
<p>
<button disabled>Click Me!</button>
</p>

// If the value of mySwitch evaluates to false, the button will not be disabled: 
<p>
  <button>Click Me!</button>
</p>

// The ng-show directive shows or hides an HTML element.

<div ng-app="""">

<p ng-show=""true"">I am visible.</p>

<p ng-show=""false"">I am not visible.</p>

</div>

// The ng-show directive shows (or hides) an HTML element based on the value of ng-show.
// You can use any expression that evaluates to true or false:
<div ng-app="""">
<p ng-show=""hour > 12"">I am visible.</p>
</div>

///////////////////////////////////
// AngularJS Events

// AngularJS has its own HTML events directives.

// The ng-click directive defines an AngularJS click event.
<div ng-app=""myApp"" ng-controller=""myCtrl"">

<button ng-click=""count = count + 1"">Click me!</button>

<p>{{ count }}</p>

</div>
<script>
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope) {
    $scope.count = 0;
});
</script>

// The ng-hide directive can be used to set the visibility of a part of an application.
// The value ng-hide=""true"" makes an HTML element invisible.
// The value ng-hide=""false"" makes the element visible.
<div ng-app=""myApp"" ng-controller=""personCtrl"">

<button ng-click=""toggle()"">Toggle</button>

<p ng-hide=""myVar"">
First Name: <input type=""text"" ng-model=""firstName""><br>
Last Name: <input type=""text"" ng-model=""lastName""><br>
<br>
Full Name: {{firstName + "" "" + lastName}}
</p>

</div>

<script>
var app = angular.module('myApp', []);
app.controller('personCtrl', function($scope) {
    $scope.firstName = ""John"",
    $scope.lastName = ""Doe""
    $scope.myVar = false;
    $scope.toggle = function() {
        $scope.myVar = !$scope.myVar;
    };
});
</script>

//Application explained:

// The first part of the personController is the same as in the chapter about controllers.
// The application has a default property (a variable): $scope.myVar = false;
// The ng-hide directive sets the visibility, of a <p> element with two input fields, 
// according to the value (true or false) of myVar.
// The function toggle() toggles myVar between true and false.
// The value ng-hide=""true"" makes the element invisible.


// The ng-show directive can also be used to set the visibility of a part of an application.
// The value ng-show=""false"" makes an HTML element invisible.
// The value ng-show=""true"" makes the element visible.
// Here is the same example as above, using ng-show instead of ng-hide:
<div ng-app=""myApp"" ng-controller=""personCtrl"">

<button ng-click=""toggle()"">Toggle</button>

<p ng-show=""myVar"">
First Name: <input type=""text"" ng-model=""firstName""><br>
Last Name: <input type=""text"" ng-model=""lastName""><br>
<br>
Full Name: {{firstName + "" "" + lastName}}
</p>

</div>

<script>
var app = angular.module('myApp', []);
app.controller('personCtrl', function($scope) {
    $scope.firstName = ""John"",
    $scope.lastName = ""Doe""
    $scope.myVar = true;
    $scope.toggle = function() {
        $scope.myVar = !$scope.myVar;
    }
});
</script>

///////////////////////////////////
// AngularJS Modules

// An AngularJS module defines an application.
// The module is a container for the different parts of an application.
// The module is a container for the application controllers.
// Controllers always belong to a module.

// This application (""myApp"") has one controller (""myCtrl""):

<!DOCTYPE html>
<html>
<script src=""http://ajax.googleapis.com/ajax/libs/angularjs/1.3.14/angular.min.js""></script>
<body>

<div ng-app=""myApp"" ng-controller=""myCtrl"">
{{ firstName + "" "" + lastName }}
</div>

<script>
var app = angular.module(""myApp"", []);
app.controller(""myCtrl"", function($scope) {
    $scope.firstName = ""John"";
    $scope.lastName = ""Doe"";
});
</script>

</body>
</html>

// It is common in AngularJS applications to put the module and the controllers in JavaScript files.
// In this example, ""myApp.js"" contains an application module definition, while ""myCtrl.js"" contains the controller:

<!DOCTYPE html>
<html>
<script src=""http://ajax.googleapis.com/ajax/libs/angularjs/1.3.14/angular.min.js""></script>
<body>

<div ng-app=""myApp"" ng-controller=""myCtrl"">
{{ firstName + "" "" + lastName }}
</div>

<script src=""myApp.js""></script>
<script src=""myCtrl.js""></script>

</body>
</html>

//myApp.js
var app = angular.module(""myApp"", []); 

// The [] parameter in the module definition can be used to define dependent modules.

// myCtrl.js
app.controller(""myCtrl"", function($scope) {
    $scope.firstName  = ""John"";
    $scope.lastName= ""Doe"";
});

// Global functions should be avoided in JavaScript. They can easily be overwritten 
// or destroyed by other scripts.

// AngularJS modules reduces this problem, by keeping all functions local to the module.

// While it is common in HTML applications to place scripts at the end of the 
// <body> element, it is recommended that you load the AngularJS library either
// in the <head> or at the start of the <body>.

// This is because calls to angular.module can only be compiled after the library has been loaded.

<!DOCTYPE html>
<html>
<body>
<script src=""http://ajax.googleapis.com/ajax/libs/angularjs/1.3.14/angular.min.js""></script>

<div ng-app=""myApp"" ng-controller=""myCtrl"">
{{ firstName + "" "" + lastName }}
</div>

<script>
var app = angular.module(""myApp"", []);
app.controller(""myCtrl"", function($scope) {
    $scope.firstName = ""John"";
    $scope.lastName = ""Doe"";
});
</script>

</body>
</html>


///////////////////////////////////
// AngularJS Applications

// AngularJS modules define AngularJS applications.
// AngularJS controllers control AngularJS applications.
// The ng-app directive defines the application, the ng-controller directive defines the controller.
<div ng-app=""myApp"" ng-controller=""myCtrl"">
  First Name: <input type=""text"" ng-model=""firstName""><br>
  Last Name: <input type=""text"" ng-model=""lastName""><br>
  <br>
  Full Name: {{firstName + "" "" + lastName}}
</div>
<script>
  var app = angular.module('myApp', []);
  app.controller('myCtrl', function($scope) {
      $scope.firstName= ""John"";
      $scope.lastName= ""Doe"";
  });
</script>

// AngularJS modules define applications:
var app = angular.module('myApp', []);

// AngularJS controllers control applications:
app.controller('myCtrl', function($scope) {
    $scope.firstName= ""John"";
    $scope.lastName= ""Doe"";
});
```

## Source & References

**Examples**

- [http://www.w3schools.com/angular/angular_examples.asp](http://www.w3schools.com/angular/angular_examples.asp)

**References**

- [http://www.w3schools.com/angular/angular_ref_directives.asp](http://www.w3schools.com/angular/angular_ref_directives.asp)
- [http://www.w3schools.com/angular/default.asp](http://www.w3schools.com/angular/default.asp)
- [https://teamtreehouse.com/library/angular-basics/](https://teamtreehouse.com/library/angular-basics/)"
"Git is a distributed version control and source code management system.

It does this through a series of snapshots of your project, and it works
with those snapshots to provide you with functionality to version and
manage your source code.

## Versioning Concepts

### What is version control?

Version control is a system that records changes to a file(s), over time.

### Centralized Versioning vs. Distributed Versioning

* Centralized version control focuses on synchronizing, tracking, and backing
up files.
* Distributed version control focuses on sharing changes. Every change has a
unique id.
* Distributed systems have no defined structure. You could easily have a SVN
style, centralized system, with git.

[Additional Information](http://git-scm.com/book/en/Getting-Started-About-Version-Control)

### Why Use Git?

* Can work offline.
* Collaborating with others is easy!
* Branching is easy!
* Branching is fast!
* Merging is easy!
* Git is fast.
* Git is flexible.

## Git Architecture

### Repository

A set of files, directories, historical records, commits, and heads. Imagine it
as a source code data structure, with the attribute that each source code
""element"" gives you access to its revision history, among other things.

A git repository is comprised of the .git directory & working tree.

### .git Directory (component of repository)

The .git directory contains all the configurations, logs, branches, HEAD, and
more.
[Detailed List.](http://gitready.com/advanced/2009/03/23/whats-inside-your-git-directory.html)

### Working Tree (component of repository)

This is basically the directories and files in your repository. It is often
referred to as your working directory.

### Index (component of .git dir)

The Index is the staging area in git. It's basically a layer that separates
your working tree from the Git repository. This gives developers more power
over what gets sent to the Git repository.

### Commit

A git commit is a snapshot of a set of changes, or manipulations to your
Working Tree. For example, if you added 5 files, and removed 2 others, these
changes will be contained in a commit (or snapshot). This commit can then be
pushed to other repositories, or not!

### Branch

A branch is essentially a pointer to the last commit you made. As you go on
committing, this pointer will automatically update to point to the latest commit.

### Tag

A tag is a mark on specific point in history. Typically people use this
functionality to mark release points (v1.0, and so on).

### HEAD and head (component of .git dir)

HEAD is a pointer that points to the current branch. A repository only has 1
*active* HEAD.
head is a pointer that points to any commit. A repository can have any number
of heads.

### Stages of Git
* Modified - Changes have been made to a file but file has not been committed
to Git Database yet
* Staged - Marks a modified file to go into your next commit snapshot
* Committed - Files have been committed to the Git Database

### Conceptual Resources

* [Git For Computer Scientists](http://eagain.net/articles/git-for-computer-scientists/)
* [Git For Designers](http://hoth.entp.com/output/git_for_designers.html)

## Commands

### init

Create an empty Git repository. The Git repository's settings, stored
information, and more is stored in a directory (a folder) named "".git"".

```bash
$ git init
```

### config

To configure settings. Whether it be for the repository, the system itself,
or global configurations ( global config file is `~/.gitconfig` ).

```bash
# Set & Print Some Basic Config Variables (Global)
$ git config --global user.email ""MyEmail@Zoho.com""
$ git config --global user.name ""My Name""

$ git config --global user.email
$ git config --global user.name
```

[Learn More About git config.](http://git-scm.com/docs/git-config)

### help

To give you quick access to an extremely detailed guide of each command. Or to
just give you a quick reminder of some semantics.

```bash
# Quickly check available commands
$ git help

# Check all available commands
$ git help -a

# Command specific help - user manual
# git help <command_here>
$ git help add
$ git help commit
$ git help init
# or git <command_here> --help
$ git add --help
$ git commit --help
$ git init --help
```

### ignore files

To intentionally untrack file(s) & folder(s) from git. Typically meant for
private & temp files which would otherwise be shared in the repository.

```bash
$ echo ""temp/"" >> .gitignore
$ echo ""private_key"" >> .gitignore
```

### status

To show differences between the index file (basically your working copy/repo)
and the current HEAD commit.

```bash
# Will display the branch, untracked files, changes and other differences
$ git status

# To learn other ""tid bits"" about git status
$ git help status
```

### add

To add files to the staging area/index. If you do not `git add` new files to
the staging area/index, they will not be included in commits!

```bash
# add a file in your current working directory
$ git add HelloWorld.java

# add a file in a nested dir
$ git add /path/to/file/HelloWorld.c

# Regular Expression support!
$ git add ./*.java

# You can also add everything in your working directory to the staging area.
$ git add -A
```

This only adds a file to the staging area/index, it doesn't commit it to the
working directory/repo.

### branch

Manage your branches. You can view, edit, create, delete branches using this
command.

```bash
# list existing branches & remotes
$ git branch -a

# create a new branch
$ git branch myNewBranch

# delete a branch
$ git branch -d myBranch

# rename a branch
# git branch -m <oldname> <newname>
$ git branch -m myBranchName myNewBranchName

# edit a branch's description
$ git branch myBranchName --edit-description
```

### tag

Manage your tags

```bash
# List tags
$ git tag

# Create a annotated tag
# The -m specifies a tagging message, which is stored with the tag.
# If you don’t specify a message for an annotated tag,
# Git launches your editor so you can type it in.
$ git tag -a v2.0 -m 'my version 2.0'

# Show info about tag
# That shows the tagger information, the date the commit was tagged,
# and the annotation message before showing the commit information.
$ git show v2.0

# Push a single tag to remote
$ git push origin v2.0

# Push a lot of tags to remote
$ git push origin --tags
```

### checkout

Updates all files in the working tree to match the version in the index, or
specified tree.

```bash
# Checkout a repo - defaults to master branch
$ git checkout

# Checkout a specified branch
$ git checkout branchName

# Create a new branch & switch to it
# equivalent to ""git branch <name>; git checkout <name>""

$ git checkout -b newBranch
```

### clone

Clones, or copies, an existing repository into a new directory. It also adds
remote-tracking branches for each branch in the cloned repo, which allows you
to push to a remote branch.

```bash
# Clone learnxinyminutes-docs
$ git clone https://github.com/adambard/learnxinyminutes-docs.git

# shallow clone - faster cloning that pulls only latest snapshot
$ git clone --depth 1 https://github.com/adambard/learnxinyminutes-docs.git

# clone only a specific branch
$ git clone -b master-cn https://github.com/adambard/learnxinyminutes-docs.git --single-branch
```

### commit

Stores the current contents of the index in a new ""commit."" This commit
contains the changes made and a message created by the user.

```bash
# commit with a message
$ git commit -m ""Added multiplyNumbers() function to HelloWorld.c""

# signed commit with a message (user.signingkey must have been set
# with your GPG key e.g. git config --global user.signingkey 5173AAD5)
$ git commit -S -m ""signed commit message""

# automatically stage modified or deleted files, except new files, and then commit
$ git commit -a -m ""Modified foo.php and removed bar.php""

# change last commit (this deletes previous commit with a fresh commit)
$ git commit --amend -m ""Correct message""
```

### diff

Shows differences between a file in the working directory, index and commits.

```bash
# Show difference between your working dir and the index
$ git diff

# Show differences between the index and the most recent commit.
$ git diff --cached

# Show differences between your working dir and the most recent commit
$ git diff HEAD
```

### grep

Allows you to quickly search a repository.

Optional Configurations:

```bash
# Thanks to Travis Jeffery for these
# Set line numbers to be shown in grep search results
$ git config --global grep.lineNumber true

# Make search results more readable, including grouping
$ git config --global alias.g ""grep --break --heading --line-number""
```

```bash
# Search for ""variableName"" in all java files
$ git grep 'variableName' -- '*.java'

# Search for a line that contains ""arrayListName"" and, ""add"" or ""remove""
$ git grep -e 'arrayListName' --and \( -e add -e remove \)
```

Google is your friend; for more examples
[Git Grep Ninja](http://travisjeffery.com/b/2012/02/search-a-git-repo-like-a-ninja)

### log

Display commits to the repository.

```bash
# Show all commits
$ git log

# Show only commit message & ref
$ git log --oneline

# Show merge commits only
$ git log --merges

# Show all commits represented by an ASCII graph
$ git log --graph
```

### merge

""Merge"" in changes from external commits into the current branch.

```bash
# Merge the specified branch into the current.
$ git merge branchName

# Always generate a merge commit when merging
$ git merge --no-ff branchName
```

### mv

Rename or move a file

```bash
# Renaming a file
$ git mv HelloWorld.c HelloNewWorld.c

# Moving a file
$ git mv HelloWorld.c ./new/path/HelloWorld.c

# Force rename or move
# ""existingFile"" already exists in the directory, will be overwritten
$ git mv -f myFile existingFile
```

### pull

Pulls from a repository and merges it with another branch.

```bash
# Update your local repo, by merging in new changes
# from the remote ""origin"" and ""master"" branch.
# git pull <remote> <branch>
$ git pull origin master

# By default, git pull will update your current branch
# by merging in new changes from its remote-tracking branch
$ git pull

# Merge in changes from remote branch and rebase
# branch commits onto your local repo, like: ""git fetch <remote> <branch>, git
# rebase <remote>/<branch>""
$ git pull origin master --rebase
```

### push

Push and merge changes from a branch to a remote & branch.

```bash
# Push and merge changes from a local repo to a
# remote named ""origin"" and ""master"" branch.
# git push <remote> <branch>
$ git push origin master

# By default, git push will push and merge changes from
# the current branch to its remote-tracking branch
$ git push

# To link up current local branch with a remote branch, add -u flag:
$ git push -u origin master
# Now, anytime you want to push from that same local branch, use shortcut:
$ git push
```

### stash

Stashing takes the dirty state of your working directory and saves it on a
stack of unfinished changes that you can reapply at any time.

Let's say you've been doing some work in your git repo, but you want to pull
from the remote. Since you have dirty (uncommitted) changes to some files, you
are not able to run `git pull`. Instead, you can run `git stash` to save your
changes onto a stack!

```bash
$ git stash
Saved working directory and index state \
  ""WIP on master: 049d078 added the index file""
  HEAD is now at 049d078 added the index file
  (To restore them type ""git stash apply"")
```

Now you can pull!

```bash
git pull
```
`...changes apply...`

Now check that everything is OK

```bash
$ git status
# On branch master
nothing to commit, working directory clean
```

You can see what ""hunks"" you've stashed so far using `git stash list`.
Since the ""hunks"" are stored in a Last-In-First-Out stack, our most recent
change will be at top.

```bash
$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert ""added file_size""
stash@{2}: WIP on master: 21d80a5 added number to log
```

Now let's apply our dirty changes back by popping them off the stack.

```bash
$ git stash pop
# On branch master
# Changes not staged for commit:
#   (use ""git add <file>..."" to update what will be committed)
#
#      modified:   index.html
#      modified:   lib/simplegit.rb
#
```

`git stash apply` does the same thing

Now you're ready to get back to work on your stuff!

[Additional Reading.](http://git-scm.com/book/en/v1/Git-Tools-Stashing)

### rebase (caution)

Take all changes that were committed on one branch, and replay them onto
another branch.
*Do not rebase commits that you have pushed to a public repo*.

```bash
# Rebase experimentBranch onto master
# git rebase <basebranch> <topicbranch>
$ git rebase master experimentBranch
```

[Additional Reading.](http://git-scm.com/book/en/Git-Branching-Rebasing)

### reset (caution)

Reset the current HEAD to the specified state. This allows you to undo merges,
pulls, commits, adds, and more. It's a great command but also dangerous if you
don't know what you are doing.

```bash
# Reset the staging area, to match the latest commit (leaves dir unchanged)
$ git reset

# Reset the staging area, to match the latest commit, and overwrite working dir
$ git reset --hard

# Moves the current branch tip to the specified commit (leaves dir unchanged)
# all changes still exist in the directory.
$ git reset 31f2bb1

# Moves the current branch tip backward to the specified commit
# and makes the working dir match (deletes uncommitted changes and all commits
# after the specified commit).
$ git reset --hard 31f2bb1
```

### reflog (caution)

Reflog will list most of the git commands you have done for a given time period,
default 90 days.

This give you the chance to reverse any git commands that have gone wrong
(for instance, if a rebase has broken your application).

You can do this:

1. `git reflog` to list all of the git commands for the rebase

```
38b323f HEAD@{0}: rebase -i (finish): returning to refs/heads/feature/add_git_reflog
38b323f HEAD@{1}: rebase -i (pick): Clarify inc/dec operators
4fff859 HEAD@{2}: rebase -i (pick): Update java.html.markdown
34ed963 HEAD@{3}: rebase -i (pick): [yaml/en] Add more resources (#1666)
ed8ddf2 HEAD@{4}: rebase -i (pick): pythonstatcomp spanish translation (#1748)
2e6c386 HEAD@{5}: rebase -i (start): checkout 02fb96d
```
2. Select where to reset to, in our case its `2e6c386`, or `HEAD@{5}`
3. 'git reset --hard HEAD@{5}' this will reset your repo to that head
4. You can start the rebase again or leave it alone.

[Additional Reading.](https://git-scm.com/docs/git-reflog)

### revert

Revert can be used to undo a commit. It should not be confused with reset which
restores the state of a project to a previous point. Revert will add a new
commit which is the inverse of the specified commit, thus reverting it.

```bash
# Revert a specified commit
$ git revert <commit>
```

### rm

The opposite of git add, git rm removes files from the current working tree.

```bash
# remove HelloWorld.c
$ git rm HelloWorld.c

# Remove a file from a nested dir
$ git rm /pather/to/the/file/HelloWorld.c
```

### blame
Examine specific parts of the code's history and find out who was the last author to modify that line.

```bash
# find the authors on the latest modified lines
$ git blame google_python_style.vim
b88c6a1b (Google Python team  2019-12-30 13:45:23 -0800 12) "" See the License for the specific language governing permissions and
b88c6a1b (Google Python team  2019-12-30 13:45:23 -0800 13) "" limitations under the License.
b88c6a1b (Google Python team  2019-12-30 13:45:23 -0800 14) 
222e6da8 (mshields@google.com 2010-11-29 20:32:06 +0000 15) "" Indent Python in the Google way.
222e6da8 (mshields@google.com 2010-11-29 20:32:06 +0000 16) 
222e6da8 (mshields@google.com 2010-11-29 20:32:06 +0000 17) setlocal indentexpr=GetGooglePythonIndent(v:lnum)
```
## Further Information

* [tryGit - A fun interactive way to learn Git.](http://try.github.io/levels/1/challenges/1)

* [Learn Git Branching - the most visual and interactive way to learn Git on the web](http://learngitbranching.js.org/)

* [Udemy Git Tutorial: A Comprehensive Guide](https://blog.udemy.com/git-tutorial-a-comprehensive-guide/)

* [Git Immersion - A Guided tour that walks through the fundamentals of git](http://gitimmersion.com/)

* [git-scm - Video Tutorials](http://git-scm.com/videos)

* [git-scm - Documentation](http://git-scm.com/docs)

* [Atlassian Git - Tutorials & Workflows](https://www.atlassian.com/git/)

* [SalesForce Cheat Sheet](http://res.cloudinary.com/hy4kyit2a/image/upload/SF_git_cheatsheet.pdf)

* [Git - the simple guide](http://rogerdudler.github.io/git-guide/index.html)

* [Pro Git](http://www.git-scm.com/book/en/v2)

* [An introduction to Git and GitHub for Beginners (Tutorial)](http://product.hubspot.com/blog/git-and-github-tutorial-for-beginners)

* [The New Boston tutorial to Git covering basic commands and workflow](https://www.youtube.com/playlist?list=PL6gx4Cwl9DGAKWClAD_iKpNC0bGHxGhcx)"
"Haskell was designed as a practical, purely functional programming
language. It's famous for its monads and its type system, but I keep coming back
to it because of its elegance. Haskell makes coding a real joy for me.

```haskell
-- Single line comments start with two dashes.
{- Multiline comments can be enclosed
in a block like this.
-}

----------------------------------------------------
-- 1. Primitive Datatypes and Operators
----------------------------------------------------

-- You have numbers
3 -- 3

-- Math is what you would expect
1 + 1 -- 2
8 - 1 -- 7
10 * 2 -- 20
35 / 5 -- 7.0

-- Division is not integer division by default
35 / 4 -- 8.75

-- integer division
35 `div` 4 -- 8

-- Boolean values are primitives
True
False

-- Boolean operations
not True -- False
not False -- True
True && False -- False
True || False -- True
1 == 1 -- True
1 /= 1 -- False
1 < 10 -- True

-- In the above examples, `not` is a function that takes one value.
-- Haskell doesn't need parentheses for function calls...all the arguments
-- are just listed after the function. So the general pattern is:
-- func arg1 arg2 arg3...
-- See the section on functions for information on how to write your own.

-- Strings and characters
""This is a string.""
'a' -- character
'You cant use single quotes for strings.' -- error!

-- Strings can be concatenated
""Hello "" ++ ""world!"" -- ""Hello world!""

-- A string is a list of characters
['H', 'e', 'l', 'l', 'o'] -- ""Hello""

-- Lists can be indexed with the `!!` operator followed by an index
""This is a string"" !! 0 -- 'T'


----------------------------------------------------
-- 2. Lists and Tuples
----------------------------------------------------

-- Every element in a list must have the same type.
-- These two lists are equal:
[1, 2, 3, 4, 5]
[1..5]

-- Ranges are versatile.
['A'..'F'] -- ""ABCDEF""

-- You can create a step in a range.
[0,2..10] -- [0, 2, 4, 6, 8, 10]
[5..1] -- [] (Haskell defaults to incrementing)
[5,4..1] -- [5, 4, 3, 2, 1]

-- indexing into a list
[1..10] !! 3 -- 4 (zero-based indexing)

-- You can also have infinite lists in Haskell!
[1..] -- a list of all the natural numbers

-- Infinite lists work because Haskell has ""lazy evaluation"". This means
-- that Haskell only evaluates things when it needs to. So you can ask for
-- the 1000th element of your list and Haskell will give it to you:

[1..] !! 999 -- 1000

-- And now Haskell has evaluated elements 1 - 1000 of this list...but the
-- rest of the elements of this ""infinite"" list don't exist yet! Haskell won't
-- actually evaluate them until it needs to.

-- joining two lists
[1..5] ++ [6..10]

-- adding to the head of a list
0:[1..5] -- [0, 1, 2, 3, 4, 5]

-- more list operations
head [1..5] -- 1
tail [1..5] -- [2, 3, 4, 5]
init [1..5] -- [1, 2, 3, 4]
last [1..5] -- 5

-- list comprehensions
[x*2 | x <- [1..5]] -- [2, 4, 6, 8, 10]

-- with a conditional
[x*2 | x <- [1..5], x*2 > 4] -- [6, 8, 10]

-- Every element in a tuple can be a different type, but a tuple has a
-- fixed length.
-- A tuple:
(""haskell"", 1)

-- accessing elements of a pair (i.e. a tuple of length 2)
fst (""haskell"", 1) -- ""haskell""
snd (""haskell"", 1) -- 1

-- pair element accessing does not work on n-tuples (i.e. triple, quadruple, etc)
snd (""snd"", ""can't touch this"", ""da na na na"") -- error! see function below

----------------------------------------------------
-- 3. Functions
----------------------------------------------------
-- A simple function that takes two variables
add a b = a + b

-- Note that if you are using ghci (the Haskell interpreter)
-- You'll need to use `let`, i.e.
-- let add a b = a + b

-- Using the function
add 1 2 -- 3

-- You can also put the function name between the two arguments
-- with backticks:
1 `add` 2 -- 3

-- You can also define functions that have no letters! This lets
-- you define your own operators! Here's an operator that does
-- integer division
(//) a b = a `div` b
35 // 4 -- 8

-- Guards: an easy way to do branching in functions
fib x
  | x < 2 = 1
  | otherwise = fib (x - 1) + fib (x - 2)

-- Pattern matching is similar. Here we have given three different
-- equations that define fib. Haskell will automatically use the first
-- equation whose left hand side pattern matches the value.
fib 1 = 1
fib 2 = 2
fib x = fib (x - 1) + fib (x - 2)

-- Pattern matching on tuples
sndOfTriple (_, y, _) = y -- use a wild card (_) to bypass naming unused value

-- Pattern matching on lists. Here `x` is the first element
-- in the list, and `xs` is the rest of the list. We can write
-- our own map function:
myMap func [] = []
myMap func (x:xs) = func x:(myMap func xs)

-- Anonymous functions are created with a backslash followed by
-- all the arguments.
myMap (\x -> x + 2) [1..5] -- [3, 4, 5, 6, 7]

-- using fold (called `inject` in some languages) with an anonymous
-- function. foldl1 means fold left, and use the first value in the
-- list as the initial value for the accumulator.
foldl1 (\acc x -> acc + x) [1..5] -- 15

----------------------------------------------------
-- 4. More functions
----------------------------------------------------

-- partial application: if you don't pass in all the arguments to a function,
-- it gets ""partially applied"". That means it returns a function that takes the
-- rest of the arguments.

add a b = a + b
foo = add 10 -- foo is now a function that takes a number and adds 10 to it
foo 5 -- 15

-- Another way to write the same thing
foo = (10+)
foo 5 -- 15

-- function composition
-- the operator `.` chains functions together.
-- For example, here foo is a function that takes a value. It adds 10 to it,
-- multiplies the result of that by 4, and then returns the final value.
foo = (4*) . (10+)

-- 4*(10+5) = 60
foo 5 -- 60

-- fixing precedence
-- Haskell has an operator called `$`. This operator applies a function
-- to a given parameter. In contrast to standard function application, which
-- has highest possible priority of 10 and is left-associative, the `$` operator
-- has priority of 0 and is right-associative. Such a low priority means that
-- the expression on its right is applied as a parameter to the function on its left.

-- before
even (fib 7) -- false

-- equivalently
even $ fib 7 -- false

-- composing functions
even . fib $ 7 -- false


----------------------------------------------------
-- 5. Type signatures
----------------------------------------------------

-- Haskell has a very strong type system, and every valid expression has a type.

-- Some basic types:
5 :: Integer
""hello"" :: String
True :: Bool

-- Functions have types too.
-- `not` takes a boolean and returns a boolean:
-- not :: Bool -> Bool

-- Here's a function that takes two arguments:
-- add :: Integer -> Integer -> Integer

-- When you define a value, it's good practice to write its type above it:
double :: Integer -> Integer
double x = x * 2

----------------------------------------------------
-- 6. Control Flow and If Expressions
----------------------------------------------------

-- if-expressions
haskell = if 1 == 1 then ""awesome"" else ""awful"" -- haskell = ""awesome""

-- if-expressions can be on multiple lines too, indentation is important
haskell = if 1 == 1
            then ""awesome""
            else ""awful""

-- case expressions: Here's how you could parse command line arguments
case args of
  ""help"" -> printHelp
  ""start"" -> startProgram
  _ -> putStrLn ""bad args""

-- Haskell doesn't have loops; it uses recursion instead.
-- map applies a function over every element in a list

map (*2) [1..5] -- [2, 4, 6, 8, 10]

-- you can make a for function using map
for array func = map func array

-- and then use it
for [0..5] $ \i -> show i

-- we could've written that like this too:
for [0..5] show

-- You can use foldl or foldr to reduce a list
-- foldl <fn> <initial value> <list>
foldl (\x y -> 2*x + y) 4 [1,2,3] -- 43

-- This is the same as
(2 * (2 * (2 * 4 + 1) + 2) + 3)

-- foldl is left-handed, foldr is right-handed
foldr (\x y -> 2*x + y) 4 [1,2,3] -- 16

-- This is now the same as
(2 * 1 + (2 * 2 + (2 * 3 + 4)))

----------------------------------------------------
-- 7. Data Types
----------------------------------------------------

-- A data type is declared with a 'type constructor' on the left
-- and one or more 'data constructors' on the right, separated by
-- the pipe | symbol. This is a sum/union type. Each data constructor
-- is a (possibly nullary) function that creates an object of the type
-- named by the type constructor.

-- This is essentially an enum

data Color = Red | Blue | Green

-- Now you can use it in a function:

say :: Color -> String
say Red   = ""You are Red!""
say Blue  = ""You are Blue!""
say Green = ""You are Green!""

-- Note that the type constructor is used in the type signature
-- and the data constructors are used in the body of the function
-- Data constructors are primarily pattern-matched against

-- This next one is a traditional container type holding two fields
-- In a type declaration, data constructors take types as parameters
-- Data constructors can have the same name as type constructors
-- This is common where the type only has a single data constructor

data Point = Point Float Float

-- This can be used in a function like:

distance :: Point -> Point -> Float
distance (Point x y) (Point x' y') = sqrt $ dx + dy
    where dx = (x - x') ** 2
          dy = (y - y') ** 2
          
-- Types can have multiple data constructors with arguments, too

data Name = Mononym String
          | FirstLastName String String
          | FullName String String String

-- To make things clearer we can use record syntax

data Point2D = CartesianPoint2D { x :: Float, y :: Float } 
             | PolarPoint2D { r :: Float, theta :: Float }

myPoint = CartesianPoint2D { x = 7.0, y = 10.0 }

-- Using record syntax automatically creates accessor functions
-- (the name of the field)

xOfMyPoint = x myPoint

-- xOfMyPoint is equal to 7.0

-- Record syntax also allows a simple form of update

myPoint' = myPoint { x = 9.0 }

-- myPoint' is CartesianPoint2D { x = 9.0, y = 10.0 }

-- Even if a type is defined with record syntax, it can be declared like
-- a simple data constructor. This is fine:

myPoint'2 = CartesianPoint2D 3.3 4.0

-- It's also useful to pattern match data constructors in `case` expressions

distanceFromOrigin x = 
    case x of (CartesianPoint2D x y) -> sqrt $ x ** 2 + y ** 2
              (PolarPoint2D r _) -> r

-- Your data types can have type parameters too:

data Maybe a = Nothing | Just a

-- These are all of type Maybe
Just ""hello""    -- of type `Maybe String`
Just 1          -- of type `Maybe Int`
Nothing         -- of type `Maybe a` for any `a`

-- For convenience we can also create type synonyms with the 'type' keyword

type String = [Char]

-- Unlike `data` types, type synonyms need no constructor, and can be used 
-- anywhere a synonymous data type could be used. Say we have the 
-- following type synonyms and items with the following type signatures

type Weight = Float
type Height = Float
type Point = (Float, Float)
getMyHeightAndWeight :: Person -> (Height, Weight)
findCenter :: Circle -> Point
somePerson :: Person
someCircle :: Circle
distance :: Point -> Point -> Float

-- The following would compile and run without issue, 
-- even though it does not make sense semantically,
-- because the type synonyms reduce to the same base types

distance (getMyHeightAndWeight somePerson) (findCenter someCircle)

----------------------------------------------------
-- 8. Typeclasses
----------------------------------------------------

-- Typeclasses are one way Haskell does polymorphism
-- They are similar to interfaces in other languages
-- A typeclass defines a set of functions that must 
-- work on any type that is in that typeclass.

-- The Eq typeclass is for types whose instances can 
-- be tested for equality with one another.

class Eq a where  
    (==) :: a -> a -> Bool  
    (/=) :: a -> a -> Bool  
    x == y = not (x /= y)  
    x /= y = not (x == y)
    
-- This defines a typeclass that requires two functions, (==) and (/=)
-- It also declares that one function can be declared in terms of another
-- So it is enough that *either* the (==) function or the (/=) is defined
-- And the other will be 'filled in' based on the typeclass definition

-- To make a type a member of a type class, the instance keyword is used

instance Eq TrafficLight where  
    Red == Red = True  
    Green == Green = True  
    Yellow == Yellow = True  
    _ == _ = False 
    
-- Now we can use (==) and (/=) with TrafficLight objects

canProceedThrough :: TrafficLight -> Bool
canProceedThrough t = t /= Red

-- You can NOT create an instance definition for a type synonym

-- Functions can be written to take typeclasses with type parameters, 
-- rather than types, assuming that the function only relies on 
-- features of the typeclass

isEqual (Eq a) => a -> a -> Bool
isEqual x y = x == y

-- Note that x and y MUST be the same type, as they are both defined
-- as being of type parameter 'a'.
-- A typeclass does not state that different types in the typeclass can 
-- be mixed together.
-- So `isEqual Red 2` is invalid, even though 2 is an Int which is an 
-- instance of Eq, and Red is a TrafficLight which is also an instance of Eq

-- Other common typeclasses are:
-- Ord for types that can be ordered, allowing you to use >, <=, etc.
-- Read for types that can be created from a string representation
-- Show for types that can be converted to a string for display
-- Num, Real, Integral, Fractional for types that can do math
-- Enum for types that can be stepped through
-- Bounded for types with a maximum and minimum

-- Haskell can automatically make types part of Eq, Ord, Read, Show, Enum, 
-- and Bounded with the `deriving` keyword at the end of the type declaration

data Point = Point Float Float deriving (Eq, Read, Show)
    
-- In this case it is NOT necessary to create an 'instance' definition

----------------------------------------------------
-- 9. Haskell IO
----------------------------------------------------

-- While IO can't be explained fully without explaining monads,
-- it is not hard to explain enough to get going.

-- When a Haskell program is executed, `main` is
-- called. It must return a value of type `IO a` for some type `a`. For example:

main :: IO ()
main = putStrLn $ ""Hello, sky! "" ++ (say Blue)
-- putStrLn has type String -> IO ()

-- It is easiest to do IO if you can implement your program as
-- a function from String to String. The function
--    interact :: (String -> String) -> IO ()
-- inputs some text, runs a function on it, and prints out the
-- output.

countLines :: String -> String
countLines = show . length . lines

main' = interact countLines

-- You can think of a value of type `IO ()` as representing a
-- sequence of actions for the computer to do, much like a
-- computer program written in an imperative language. We can use
-- the `do` notation to chain actions together. For example:

sayHello :: IO ()
sayHello = do
   putStrLn ""What is your name?""
   name <- getLine -- this gets a line and gives it the name ""name""
   putStrLn $ ""Hello, "" ++ name

-- Exercise: write your own version of `interact` that only reads
--           one line of input.

-- The code in `sayHello` will never be executed, however. The only
-- action that ever gets executed is the value of `main`.
-- To run `sayHello` comment out the above definition of `main`
-- and replace it with:
--   main = sayHello

-- Let's understand better how the function `getLine` we just
-- used works. Its type is:
--    getLine :: IO String
-- You can think of a value of type `IO a` as representing a
-- computer program that will generate a value of type `a`
-- when executed (in addition to anything else it does). We can
-- name and reuse this value using `<-`. We can also
-- make our own action of type `IO String`:

action :: IO String
action = do
   putStrLn ""This is a line. Duh""
   input1 <- getLine
   input2 <- getLine
   -- The type of the `do` statement is that of its last line.
   -- `return` is not a keyword, but merely a function
   return (input1 ++ ""\n"" ++ input2) -- return :: String -> IO String

-- We can use this just like we used `getLine`:

main'' = do
    putStrLn ""I will echo two lines!""
    result <- action
    putStrLn result
    putStrLn ""This was all, folks!""

-- The type `IO` is an example of a ""monad"". The way Haskell uses a monad to
-- do IO allows it to be a purely functional language. Any function that
-- interacts with the outside world (i.e. does IO) gets marked as `IO` in its
-- type signature. This lets us reason about which functions are ""pure"" (don't
-- interact with the outside world or modify state) and which functions aren't.

-- This is a powerful feature, because it's easy to run pure functions
-- concurrently; so, concurrency in Haskell is very easy.


----------------------------------------------------
-- 10. The Haskell REPL
----------------------------------------------------

-- Start the repl by typing `ghci`.
-- Now you can type in Haskell code. Any new values
-- need to be created with `let`:

let foo = 5

-- You can see the type of any value or expression with `:t`:

> :t foo
foo :: Integer

-- Operators, such as `+`, `:` and `$`, are functions.
-- Their type can be inspected by putting the operator in parentheses:

> :t (:)
(:) :: a -> [a] -> [a]

-- You can get additional information on any `name` using `:i`:

> :i (+)
class Num a where
  (+) :: a -> a -> a
  ...
    -- Defined in ‘GHC.Num’
infixl 6 +

-- You can also run any action of type `IO ()`

> sayHello
What is your name?
Friend!
Hello, Friend!

```

There's a lot more to Haskell, including typeclasses and monads. These are the
big ideas that make Haskell such fun to code in. I'll leave you with one final
Haskell example: an implementation of a quicksort variant in Haskell:

```haskell
qsort [] = []
qsort (p:xs) = qsort lesser ++ [p] ++ qsort greater
    where lesser  = filter (< p) xs
          greater = filter (>= p) xs
```

There are two popular ways to install Haskell: The traditional [Cabal-based installation](http://www.haskell.org/platform/), and the newer [Stack-based process](https://www.stackage.org/install).

You can find a much gentler introduction from the excellent
[Learn you a Haskell](http://learnyouahaskell.com/) (or [up-to-date community version](https://learnyouahaskell.github.io/)),
[Happy Learn Haskell Tutorial](http://www.happylearnhaskelltutorial.com/) or
[Real World Haskell](http://book.realworldhaskell.org/)."
"Draw 3D models with code using [OpenSCAD](https://openscad.org/).

```
// Comments look like this

// 3D Primitives
cube(10);
cube([5, 10, 20]);
sphere(10);

// Transformations
translate([20, 0, 0]) cube(10);
rotate([0, 20, 30]) cube(10);

translate([20, 0, 0]) rotate([0, 20, 30]) cube(10);
rotate([0, 20, 30]) translate([20, 0, 0]) cube(10);

// Modifiers
//
//     * disable
//     ! show only
//     # highlight / debug
//     % transparent / background
//
// For example, show only the rotated cube at the origin, before we translate it.
translate([20, 0, 0]) !rotate([0, 20, 30]) cube(10);

// Formatting
// The following models are the same. The official docs prefer the second.
rotate([0, 20, 30]) translate([20, 0, 0]) cube(10);

rotate([0, 20, 30])
    translate([20, 0, 0])
    cube(10);

rotate([0, 20, 30]) {
    translate([20, 0, 0]) {
        cube(10);
    }
}

// Loops
num_cubes = 5;
r = 20;
cube_len = 5;

for (i = [0:num_cubes]) {
    echo(str(""Plot cube "", i));
    rotate([0, i * 360 / num_cubes, 0])
        translate([r, 0, 0])
        cube(cube_len, center=true);
}

// Boolean operations
//
//            union() - the sum of both shapes
//       difference() - the first shape, minus the second shape
//     intersection() - only parts of both shapes which intersect
//
cube_l = 20;
cube_w = 10;
cube_h = 10;

hole_pos_l = 10;
hole_pos_h = 5;
hole_r = 3;

difference() {
    cube([cube_l, cube_w, cube_h]);
    translate([hole_pos_l, 0, hole_pos_h])
        rotate([-90, 0, 0])
        cylinder(cube_w, r=hole_r);
}

// Functions calculate values
function inch2mm(i) = i * 25.4;

cube(inch2mm(2));

// Modules create objects you want to use later
module house(roof=""flat"", paint=[1,0,0]) {
    color(paint)
    if (roof==""flat"") {
        translate([0,-1,0]) cube();
    } else if (roof==""pitched"") {
        rotate([90,0,0])
            linear_extrude(height=1)
            polygon(points=[[0,0],[0,1],[0.5,1.5],[1,1],[1,0]]);
    }
    else if (roof==""domical"") {
        translate([0,-1,0]) {
            translate([0.5,0.5,1])
                sphere(r=0.5,$fn=20);
            cube();
        }
    }
}

house(""pitched"");
translate([2, 0, 0]) house(""domical"");

// Import modules and function from other files
include <filename> // Import the content of the file as if they were written in this file
use <filename>     // Import modules and functions, but do not execute any commands
```

## Further Reading
* Official docs https://openscad.org/documentation.html
* Cheat sheet https://openscad.org/cheatsheet/index.html
* Vim bindings https://github.com/sirtaj/vim-openscad"
"Textile is a lightweight markup language that uses a text formatting syntax to
convert plain text into structured HTML markup. The syntax is a shorthand
version of HTML that is designed to be easy to read and write. Textile is used
for writing articles, forum posts, readme documentation, and any other type of
written content published online.

- [Comments](#comments)
- [Paragraphs](#paragraphs)
- [Headings](#headings)
- [Simple Text Styles](#simple-text-styles)
- [Lists](#lists)
- [Code blocks](#code-blocks)
- [Horizontal rule](#horizontal-rule)
- [Links](#links)
- [Images](#images)
- [Footnotes and Endnotes](#footnotes-and-endnotes)
- [Tables](#tables)
- [Character Conversions](#character-conversions)
- [CSS](#css)
- [Spans and Divs](#spans-and-divs)
- [Additional Info](#additional-info)

## Comments

```
###. Comments begin with three (3) '#' signs followed by a full-stop period '.'.
Comments can span multiple lines until a blank line is reached.

###..
Multi-line comments (including blank lines) are indicated by three (3) '#'
signs followed by two (2) full-stop periods '..'.

This line is also part of the above comment.

The comment continues until the next block element is reached

p. This line is not commented

<!-- HTML comments are also…

respected -->

```

## Paragraphs

```
###. Paragraphs are a one or multiple adjacent lines of text separated by one or
multiple blank lines. They can also be indicated explicitly with a 'p. '

This is a paragraph. I'm typing in a paragraph isn't this fun?

Now I'm in paragraph 2.
I'm still in paragraph 2 too!
Line breaks without blank spaces are equivalent to a <br /> in XHTML.

p. I'm an explicitly defined paragraph

 Lines starting with a blank space are not wrapped in <p>..</p> tags.

###. Paragraphs (and all block elements) can be aligned using shorthand:

p<. Left aligned paragraph (default).

p>. Right aligned paragraph.

p=. Centered paragraph.

p<>. Justified paragraph.

h3>. Right aligned <h3>


###. Paragraphs can be indented using a parentheses for each em
Indentation utilizes padding-[left/right] css styles.

p(. Left indent 1em.

p((. Left indent 2em.

p))). Right indent 3em.

h2). This is equivalent to <h2 style=""padding-right: 1em;"">..</h2>


###. Block quotes use the tag 'bq.'

bq. This is a block quote.

bq.:http://someurl.com You can include a citation URL immediately after the '.'

bq.. Multi-line blockquotes containing

blank lines are indicated using two periods

p. Multi-line blockquotes continue until a new block element is reached.

bq. You can add a footer to a blockquote using html:
<footer>citation text</footer>


###. Preformatted text blocks:

pre. This text is preformatted.  <= those two spaces will carry through.

pre.. This is a multi-line preformatted…

…text block that includes blank lines

p. End a multi-line preformatted text block with a new block element.

```

## Headings

You can create HTML elements `<h1>` through `<h6>` easily by prepending the
text you want to be in that element by 'h#.' where # is the level 1-6.
A blank line is required after headings.


```
h1. This is an <h1>

h2. This is an <h2>

h3. This is an <h3>

h4. This is an <h4>

h5. This is an <h5>

h6. This is an <h6>

```


## Simple text styles

```
###. Bold and strong text are indicated using asterisks:

*This is strong text*
**This is bold text**
This is [*B*]old text within a word.

*Strong* and **Bold** usually display the same in browsers
but they use different HTML markup, thus the distinction.

###. Italics and emphasized text are indicated using underscores.

_This is Emphasized text_
__This is Italics text__
This is It[_al_]ics within a word.

_Emphasized_ and __Italics__ text typically display the same in browsers,
but again, they use different HTML markup and thus the distinction.

###. Superscripts and Subscripts use carats and tildes:

Superscripts are 2 ^and^ to none, but subscripts are CO ~2~ L too.
Note the spaces around the superscripts and subscripts.

To avoid the spaces, add square brackets around them:
2[^and^] and CO[~2~]L

###. Insertions and deletions are indicated using -/+ symbols:
This is -deleted- text and this is +inserted+ text.

###. Citations are indicated using double '?':

??This is a cool citation??

```

## Lists

```
###. Unordered lists can be made using asterisks '*' to indicate levels:

* Item
** Sub-Item
* Another item
** Another sub-item
** Yet another sub-item
*** Three levels deep

###. Ordered lists are done with a pound sign '#':

# Item one
# Item two
## Item two-a
## Item two-b
# Item three
** Mixed unordered list within ordered list

###. Ordered lists can start above 1 and can continue after another block:

#5 Item 5
# Item 6

additional paragraph

#_ Item 7 continued from above
# Item 8

###. Definition lists are indicated with a dash and assignment:

- First item := first item definition
- Second := second def.
- Multi-line :=
Multi-line
definition =:
```

## Code blocks

```
Code blocks use the 'bc.' shorthand:

bc. This is code
    So is this

This is outside of the code block

bc.. This is a multi-line code block

Blank lines are included in the multi-line code block

p. End a multi-line code block with any block element

p. Indicate @inline code@ using the '@' symbol.

```

## Horizontal rule

Horizontal rules (`<hr/>`) are easily added with two hyphens

```
--
```

## Links

```
###. Link text is in quotes, followed by a colon and the URL:

""Link text"":http://linkurl.com/ plain text.

""Titles go in parentheses at the end of the link text""(mytitle):http://url.com
###. produces <a href... title=""mytitle"">...</a>

###. Use square brackets when the link text or URL might be ambiguous:
[""Textile on Wikipedia"":http://en.wikipedia.org/wiki/Textile_(markup_language)]

###. Named links are useful if the same URL is referenced multiple times.
Multiple ""references"":txstyle to the ""txstyle"":txstyle website.

[txstyle]https://txstyle.org/

```

## Images

```
###. Images can be included by surrounding its URL with exclamation marks (!)
Alt text is included in parenthesis after the URL, and they can be linked too:

!http://imageurl.com!

!http://imageurl.com(image alt-text)!

!http://imageurl.com(alt-text)!:http://image-link-url.com

```

## Footnotes and Endnotes

```
A footnote is indicated with the reference id in square brackets.[1]

fn1. Footnote text with a ""link"":http://link.com.

A footnote without a link.[2!]

fn2. The corresponding unlinked footnote.

A footnote with a backlink from the footnote back to the text.[3]

fn3^. This footnote links back to the in-text citation.


Endnotes are automatically numbered[#first] and are indicated using square[#second]
brackets and a key value[#first]. They can also be unlinked[#unlinkednote!]

###. Give the endnotes text:

note#first. This is the first endnote text.

note#second. This is the second text.

note#unlinkednote. This one isn't linked from the text.

### Use the notelist block to place the list of notes in the text:
This list will start with #1. Can also use alpha or Greeks.
notelist:1. ###. start at 1 (then 2, 3, 4...)
notelist:c. ###. start at c (then d, e, f...)
notelist:α. ###. start at α (then β, γ, δ...)

###. The notelist syntax is as follows:

notelist.    Notes with backlinks to every citation made to them.
notelist+.   Notes with backlinks to every citation made to them,
               followed by the unreferenced notes.
notelist^.   Notes with one backlink to the first citation made to each note.
notelist^+.  Notes with one backlink to the first citation made to each note,
               followed by unreferenced notes.
notelist!.   Notes with no backlinks to the citations.
notelist!+.  Notes with no backlinks to the citations, followed by 
               unreferenced notes.
```

## Tables


```
###. Tables are simple to define using the pipe '|' symbol

| A | simple | table | row |
| And | another | table | row |
| With an | | empty | cell |

###. Headers are preceded by '|_.'
|_. First Header |_. Second Header |
| Content Cell | Content Cell |

###. The <thead> tag is added when |^. above and |-. below the heading are used.

|^.
|_. First Header |_. Second Header |
|-.
| Content Cell | Content Cell |
| Content Cell | Content Cell |

###. The <tfoot> tag is added when |~. above and |-. below the footer are used.

|~.
|\2=. A footer, centered & across two columns |
|-.
| Content Cell | Content Cell |
| Content Cell | Content Cell |

###. Attributes are be applied either to individual cells, rows, or to
the entire table. Cell attributes are placed within each cell:

|a|{color:red}. styled|cell|

###. Row attributes are placed at the beginning of a row,
followed by a dot and a space:

(rowclass). |a|classy|row|

###. Table attributes are specified by placing the special 'table.' block
modifier immediately before the table:

table(tableclass).
|a|classy|table|
|a|classy|table|

###. Spanning rows and columns:
A backslash \ is used for a column span:

|\2. spans two cols |
| col 1 | col 2 |

###. A forward slash / is used for a row span:

|/3. spans 3 rows | row a |
| row b |
| row c |

###. Vertical alignments within a table cell:

|^. top alignment|
|-. middle alignment|
|~. bottom alignment|

###. Horizontal alignments within a table cell

|:\1. |400|
|=. center alignment |
| no alignment |
|>. right alignment |

```
or, for the same results

```
Col 1 | Col2 | Col3
:-- | :-: | --:
Ugh this is so ugly | make it | stop
```


## Character Conversions

### Registered, Trademark, Copyright Symbols

```
RegisteredTrademark(r), Trademark(tm), Copyright (c)
```

### Acronyms

```
###. Acronym definitions can be provided in parentheses:

EPA(Environmental Protection Agency) and CDC(Center for Disease Control)
```

### Angle Brackets and Ampersand

```
### Angled brackets < and > and ampersands & are automatically escaped:
< => &lt;
> => &gt;
& => &amp;
```

### Ellipses

```
p. Three consecutive periods are translated into ellipses...automatically
```

### Em and En dashes

```
###. En dashes (short) is a hyphen surrounded by spaces:

This line uses an en dash to separate Oct - Nov 2018.

###. Em dashes (long) are two hyphens with or without spaces:

This is an em dash--used to separate clauses.
But we can also use it with spaces -- which is a less-used convention.
That last hyphen between 'less' and 'used' is not converted between words.
```

## Fractions and other Math Symbols

```
One quarter: (1/4) => ¼
One half: (1/2) => ½
Three quarters: (3/4) => ¾
Degree: (o) => °
Plus/minus: (+/-) => ±
```
### Multiplication/Dimension

```
p. Numbers separated by the letter 'x' translate to the multiplication
or dimension symbol '×':
3 x 5 => 3 × 5
```

### Quotes and Apostrophes

```
###. Straight quotes and apostrophes are automatically converted to
their curly equivalents:

""these"", 'these', and this'n are converted to their HTML entity equivalents.
Leave them straight using '==' around the text: ==""straight quotes""==.
```

## CSS

```
p{color:blue}. CSS Styles are enclosed in curly braces '{}'
p(my-class). Classes are enclosed in parenthesis
p(#my-id). IDs are enclosed in parentheses and prefaced with a pound '#'.
```

## Spans and Divs

```
%spans% are enclosed in percent symbols
div. Divs are indicated by the 'div.' shorthand
```
---

## For More Info

* TxStyle Textile Documentation: [https://txstyle.org/](https://txstyle.org/)
* promptworks Textile Reference Manual: [https://www.promptworks.com/textile](https://www.promptworks.com/textile)
* Redmine Textile Formatting: [http://www.redmine.org/projects/redmine/wiki/RedmineTextFormattingTextile](http://www.redmine.org/projects/redmine/wiki/RedmineTextFormattingTextile)"
"Dhall is a programmable configuration language that provides a non-repetitive
alternative to YAML.

You can think of Dhall as: JSON + functions + types + imports

Note that while Dhall is programmable, Dhall is not Turing-complete.  Many
of Dhall's features take advantage of this restriction to provide stronger
safety guarantees and more powerful tooling.

```haskell
-- Single-line comment

{- Multi-line comment

   Unicode is fine 🙂

   This file is a valid Dhall expression that evaluates to a large record
   collecting the results of each step.

   You can view the results by interpreting the file:

       $ dhall --file learndhall.dhall

   {- Comments can be nested -}
-}

let greeting = ""Hello, world!""

let fruits = ""🍋🍓🍍🍉🍌""

let interpolation = ""Enjoy some delicious fruit: ${fruits}""

let multilineText {- Inline comments work, too -} =
        ''
        Leading whitespace is stripped from multi-line text literals.

        That means you can freely indent or dedent a text literal without
        changing the result.

            Relative indentation within the literal is still preserved.

        Other than that, the text literal is preserved verbatim, similar to a
        ""literal"" YAML multiline string.
        ''

let bool = True

-- Type annotations on bindings are optional, but helpful, so we'll use them
let annotation : Bool = True

let renderedBool : Text = if bool then ""True"" else ""False""

-- Natural numbers are non-negative and are unsigned
let naturalNumber : Natural = 42

-- Integers may be negative, but require an explicit sign, even if positive
let positiveInteger : Integer = +1

let negativeInteger : Integer = -12

let pi : Double = 3.14159265359

{- You can use a wider character range for identifiers (such as quotation
   marks and whitespace) if you quote them using backticks
-}
let `Avogadro's Number` : Double = 6.0221409e+23

let origin : { x : Double, y : Double } = { x = 0.0, y = 0.0 }

let somePrimes : List Natural = [ 2, 3, 5, 7, 11 ]

{- A schema is the same thing as a type

   Types begin with an uppercase letter by convention, but this convention is
   not enforced
-}
let Profile : Type
        = { person :
              { name : Text
              , age  : Natural
              }
          , address :
              { country : Text
              , state   : Text
              , city    : Text
              }
          }

let john : Profile =
        { person =
            { name = ""John Doe""
            , age  = 67
            }
        , address =
            { country = ""United States""
            , state   = ""Pennsylvania""
            , city    = ""Philadelphia""
            }
        }

let philadelphia : Text = john.address.city

{- Enum alternatives also begin with an uppercase letter by convention.  This
   convention is not enforced
-}
let DNA : Type = < Adenine | Cytosine | Guanine | Thymine >

let dnaSequence : List DNA = [ DNA.Thymine, DNA.Guanine, DNA.Guanine ]

let compactDNASequence : List DNA =
        let a = DNA.Adenine
        let c = DNA.Cytosine
        let g = DNA.Guanine
        let t = DNA.Thymine
        in  [ c, t, t, a, t, c, g, g, c ]

-- You can transform enums by providing a record with one field per alternative
let theLetterG : Text =
            merge
            { Adenine  = ""A""
            , Cytosine = ""C""
            , Guanine  = ""G""
            , Thymine  = ""T""
            }
            DNA.Guanine

let presentOptionalValue : Optional Natural = Some 1

let absentOptionalValue : Optional Natural = None Natural

let points : List { x : Double, y : Double } =
        [ { x = 1.1, y = -4.2 }
        , { x = 4.4, y = -3.0 }
        , { x = 8.2, y = -5.5 }
        ]

{- `Natural -> List Natural` is the type of a function whose input type is a
   `Natural` and whose output type is a `List Natural`

   All functions in Dhall are anonymous functions (a.k.a. ""lambdas""),
   which you can optionally give a name

   For example, the following function is equivalent to this Python code:

       lambda n : [ n, n + 1 ]

   ... and this JavaScript code:

       function (n) { return [ n, n + 1 ]; }
-}
let exampleFunction : Natural -> List Natural =
        \(n : Natural) -> [ n, n + 1 ]

-- Dhall also supports Unicode syntax, but this tutorial will stick to ASCII
let unicodeFunction : Natural → List Natural =
        λ(n : Natural) → [ n, n + 1 ]

-- You don't need to parenthesize function arguments
let exampleFunctionApplication : List Natural =
        exampleFunction 2

let functionOfMultipleArguments : Natural -> Natural -> List Natural =
        \(x : Natural) -> \(y : Natural) -> [ x, y ]

let functionAppliedToMultipleArguments : List Natural =
        functionOfMultipleArguments 2 3

{- Same as `exampleFunction` except we gave the function's input type a
   name: ""n""
-}
let namedArgumentType : forall (n : Natural) -> List Natural =
        \(n : Natural) -> [ n, n + 1 ]

{- If you name a function's input type, you can use that name later within the
   same type

   This lets you write a function that works for more than one type of input
   (a.k.a. a ""polymorphic"" function)
-}
let duplicate : forall (a : Type) -> a -> List a =
        \(a : Type) -> \(x : a) -> [ x, x ] 

let duplicatedNumber : List Natural =
        duplicate Natural 2

let duplicatedBool : List Bool =
        duplicate Bool False

{- The language also has some built-in polymorphic functions, such as:

       List/head : forall (a : Type) -> List a -> Optional a
-}
let firstPrime : Optional Natural = List/head Natural somePrimes

let functionOfARecord : { x : Natural, y : Natural } -> List Natural =
        \(args : { x : Natural, y : Natural }) -> [ args.x, args.y ]

let functionAppliedToARecord : List Natural =
        functionOfARecord { x = 2, y = 5 }

{- All type conversions are explicit

   `Natural/show` is a built-in function of the following type:

       Natural/show : Natural -> Text

   ... that converts `Natural` numbers to their `Text` representation
-}
let typeConversion : Natural -> Text =
        \(age : Natural) -> ""I am ${Natural/show age} years old!""

-- A ""template"" is the same thing as a function whose output type is `Text`
let mitLicense : { year : Natural, copyrightHolder : Text } -> Text =
        \(args : { year : Natural, copyrightHolder : Text }) ->
''
Copyright ${Natural/show args.year} ${args.copyrightHolder}

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the ""Software""), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
''

-- Template instantiation is the same thing as function application
let templatedLicense : Text =
        mitLicense { year = 2019, copyrightHolder = ""Jane Smith"" }

{- You can import expressions by URL

   Also, like Bash, you can import code from your local filesystem (not shown)

   Security-conscious users can pin remotely-imported expressions by adding a
   semantic integrity check.  The interpreter rejects any attempt to tamper with
   an expression pinned in this way.  However, behavior-preserving refactors
   of imported content will not perturb the hash.

   Imported expressions pinned in this way are also locally cached in a
   content-addressable store (typically underneath `~/.cache/dhall`)
-}
let Natural/sum : List Natural -> Natural =
      https://prelude.dhall-lang.org/Natural/sum
      sha256:33f7f4c3aff62e5ecf4848f964363133452d420dcde045784518fb59fa970037

let twentyEight : Natural = Natural/sum somePrimes

-- A ""package"" is the same thing as a (possibly nested) record that you can import
let Prelude = https://prelude.dhall-lang.org/package.dhall

let false : Bool = Prelude.Bool.not True

-- You can import the raw contents of a file by adding `as Text` to an import
let sourceCode : Text = https://prelude.dhall-lang.org/Bool/not as Text

-- You can import environment variables, too:
let presentWorkingDirectory = env:PWD as Text

-- You can provide a fallback expression if an import fails
let home : Optional Text = Some env:HOME ? None Text

-- Fallback expressions can contain alternative imports of their own
let possiblyCustomPrelude =
        env:DHALL_PRELUDE
      ? https://prelude.dhall-lang.org/package.dhall

{- Tie everything together by auto-generating configurations for 10 build users
   using the `generate` function:

       Prelude.List.generate
           : Natural -> forall (a : Type) -> (Natural -> a) -> List a
-}
let buildUsers =
        let makeUser = \(user : Text) ->
              let home       = ""/home/${user}""
              let privateKey = ""${home}/.ssh/id_ed25519""
              let publicKey  = ""${privateKey}.pub""
              in  { home = home
                  , privateKey = privateKey
                  , publicKey = publicKey
                  }

        let buildUser =
                \(index : Natural) -> makeUser ""build${Natural/show index}""

        let Config =
              { home : Text
              , privateKey : Text
              , publicKey : Text
              }

        in  Prelude.List.generate 10 Config buildUser

-- Present all of the results in a final record
in  { greeting = greeting
    , fruits = fruits
    , interpolation = interpolation
    , multilineText = multilineText
    , bool = bool
    , annotation = annotation
    , renderedBool = renderedBool
    , naturalNumber = naturalNumber
    , positiveInteger = positiveInteger
    , negativeInteger = negativeInteger
    , pi = pi
    , `Avogadro's Number` = `Avogadro's Number`
    , origin = origin
    , somePrimes = somePrimes
    , john = john
    , philadelphia = philadelphia
    , dnaSequence = dnaSequence
    , compactDNASequence = compactDNASequence
    , theLetterG = theLetterG
    , presentOptionalValue = presentOptionalValue
    , absentOptionalValue = absentOptionalValue
    , points = points
    , exampleFunction = exampleFunction
    , unicodeFunction = unicodeFunction
    , exampleFunctionApplication = exampleFunctionApplication
    , functionOfMultipleArguments = functionOfMultipleArguments
    , functionAppliedToMultipleArguments = functionAppliedToMultipleArguments
    , namedArgumentType = namedArgumentType
    , duplicate = duplicate
    , duplicatedNumber = duplicatedNumber
    , duplicatedBool = duplicatedBool
    , firstPrime = firstPrime
    , functionOfARecord = functionOfARecord
    , functionAppliedToARecord = functionAppliedToARecord
    , typeConversion = typeConversion
    , mitLicense = mitLicense
    , templatedLicense = templatedLicense
    , twentyEight = twentyEight
    , false = false
    , sourceCode = sourceCode
    , presentWorkingDirectory = presentWorkingDirectory
    , home = home
    , buildUsers = buildUsers
    }
```

To learn more, visit the official website, which also lets you try the
language live in your browser:

* [https://dhall-lang.org](http://dhall-lang.org/)"
"Mercurial is a free, distributed source control management tool. It offers
you the power to efficiently handle projects of any size while using an
intuitive interface. It is easy to use and hard to break, making it ideal for
anyone working with versioned files.

## Versioning Concepts

### What is version control?

Version control is a system that keeps track fo changes to a set of file(s)
and/or directorie(s) over time.

### Why use Mercurial?

* Distributed Architecture - Traditionally version control systems such as CVS
and Subversion are a client server architecture with a central server to
store the revision history of a project. Mercurial however is a truly
distributed architecture, giving each developer a full local copy of the
entire development history. It works independently of a central server.
* Fast - Traditionally version control systems such as CVS and Subversion are a
client server architecture with a central server to store the revision history
of a project. Mercurial however is a truly distributed architecture, giving
each developer a full local copy of the entire development history. It works
independently of a central server.
* Platform Independent - Mercurial was written to be highly platform
independent. Much of Mercurial is written in Python, with small performance
critical parts written in portable C. Binary releases are available for all
major platforms.
* Extensible - The functionality of Mercurial can be increased with extensions,
either by activating the official ones which are shipped with Mercurial or
downloading some [from the wiki](https://www.mercurial-scm.org/wiki/UsingExtensions) or by [writing your own](https://www.mercurial-scm.org/wiki/WritingExtensions). Extensions are written in
Python and can change the workings of the basic commands, add new commands and
access all the core functions of Mercurial.
* Easy to use - The Mercurial command set is consistent with what subversion
users would expect, so they are likely to feel right at home. Most dangerous
actions are part of extensions that need to be enabled to be used.
* Open Source - Mercurial is free software licensed under the terms of the [GNU
General Public License Version 2](http://www.gnu.org/licenses/gpl-2.0.txt) or
any later version.

## Terminology

| Term | Definition |
| ------------- | ---------------------------------- |
| Repository | A repository is a collection of revisions |
| hgrc | A configuration file which stores the defaults for a repository. |
| revision | A committed changeset: has a REV number |
| changeset | Set of changes saved as diffs |
| diff | Changes between file(s) |
| tag | A named named revision |
| parent(s) | Immediate ancestor(s) of a revision |
| branch | A child of a revision |
| head | A head is a changeset with no child changesets |
| merge | The process of merging two HEADS |
| tip | The latest revision in any branch |
| patch | All of the diffs between two revisions |
| bundle | Patch with permis­sions and rename support |

## Commands

### init

Create a new repository in the given directory, the settings and stored
information are in a directory named `.hg`.

```bash
$ hg init
```

### help

Will give you access to a very detailed description of each command.

```bash 
# Quickly check what commands are available
$ hg help

# Get help on a specific command
# hg help <command>
$ hg help add
$ hg help commit
$ hg help init
```

### status

Show the differences between what is on disk and what is committed to the current
branch or tag.

```bash
# Will display the status of files
$ hg status

# Get help on the status subcommand
$ hg help status
```

### add

Will add the specified files to the repository on the next commit.

```bash
# Add a file in the current directory
$ hg add filename.rb

# Add a file in a sub directory
$ hg add foo/bar/filename.rb

# Add files by pattern
$ hg add *.rb
```

### branch

Set or show the current branch name.

*Branch names are permanent and global. Use 'hg bookmark' to create a
light-weight bookmark instead. See 'hg help glossary' for more information
about named branches and bookmarks.*

```bash
# With no argument it shows the current branch name
$ hg branch

# With a name argument it will change the current branch.
$ hg branch new_branch
marked working directory as branch new_branch
(branches are permanent and global, did you want a bookmark?)
```

### tag

Add one or more tags for the current or given revision.

Tags are used to name particular revisions of the repository and are very
useful to compare different revisions, to go back to significant earlier
versions or to mark branch points as releases, etc. Changing an existing tag
is normally disallowed; use -f/--force to override.

```bash
# List tags
$ hg tags
tip                                2:efc8222cd1fb
v1.0                               0:37e9b57123b3

# Create a new tag on the current revision
$ hg tag v1.1

# Create a tag on a specific revision
$ hg tag -r efc8222cd1fb v1.1.1
```

### clone

Create a copy of an existing repository in a new directory.

If no destination directory name is specified, it defaults to the basename of
the source.

```bash
# Clone a remote repo to a local directory
$ hg clone https://some-mercurial-server.example.com/reponame

# Clone a local repo to a remote server
$ hg clone . ssh://username@some-mercurial-server.example.com/newrepo

# Clone a local repo to a local repo
$ hg clone . /tmp/some_backup_dir
```

### commit / ci

Commit changes to the given files into the repository. 

```bash
# Commit with a message
$ hg commit -m 'This is a commit message'

# Commit all added / removed files in the current tree
$ hg commit -A 'Adding and removing all existing files in the tree'

# amend the parent of the working directory with a new commit that contains the
# changes in the parent in addition to those currently reported by 'hg status',
$ hg commit --amend -m ""Correct message""
```

### diff

Show differences between revisions for the specified files using the unified
diff format.

```bash
# Show the diff between the current directory and a previous revision
$ hg diff -r 10

# Show the diff between two previous revisions
$ hg diff -r 30 -r 20
```

### grep

Search revision history for a pattern in specified files.

```bash
# Search files for a specific phrase
$ hg grep ""TODO:""
```

### log / history

Show revision history of entire repository or files. If no revision range is
specified, the default is ""tip:0"" unless --follow is set, in which case the
working directory parent is used as the starting revision.

```bash
# Show the history of the entire repository
$ hg log

# Show the history of a single file
$ hg log myfile.rb

# Show the revision changes as an ASCII art DAG with the most recent changeset
# at the top.
$ hg log -G
```

### merge

Merge another revision into working directory.

```bash
# Merge changesets to local repository
$ hg merge

# Merge from a named branch or revision into the current local branch
$ hg merge branchname_or_revision

# After successful merge, commit the changes
hg commit
```

### move / mv / rename

Rename files; equivalent of copy + remove. Mark dest as copies of sources;
mark sources for deletion. If dest is a directory, copies are put in that
directory. If dest is a file, there can only be one source.

```bash
# Rename a single file
$ hg mv foo.txt bar.txt

# Rename a directory
$ hg mv some_directory new_directory
```

### pull

Pull changes from a remote repository to a local one.

```bash
# List remote paths
$ hg paths
remote1 = http://path/to/remote1
remote2 = http://path/to/remote2

# Pull from remote 1
$ hg pull remote1

# Pull from remote 2
$ hg pull remote2
```

### push

Push changesets from the local repository to the specified destination.

```bash
# List remote paths
$ hg paths
remote1 = http://path/to/remote1
remote2 = http://path/to/remote2

# Pull from remote 1
$ hg push remote1

# Pull from remote 2
$ hg push remote2
```

### rebase

Move changeset (and descendants) to a different branch.

Rebase uses repeated merging to graft changesets from one part of history
(the source) onto another (the destination). This can be useful for
linearizing *local* changes relative to a master development tree.

* Draft the commits back to the source revision.
* -s is the source, ie. what you are rebasing.
* -d is the destination, which is where you are sending it.

```bash
# Put the commits into draft status
# This will draft all subsequent commits on the relevant branch
$ hg phase --draft --force -r 1206

# Rebase from from revision 102 over revision 208
$ hg rebase -s 102 -d 208
```

### revert

Restore files to their checkout state. With no revision specified, revert the
specified files or directories to the contents they had in the parent of the
working directory. This restores the contents of files to an unmodified state
and unschedules adds, removes, copies, and renames. If the working directory
has two parents, you must explicitly specify a revision.

```bash
# Reset a specific file to its checked out state
$ hg revert oops_i_did_it_again.txt

# Revert a specific file to its checked out state without leaving a .orig file
# around
$ hg revert -C oops_i_did_it_again.txt

# Revert all changes
$ hg revert -a
```

### rm / remove

Remove the specified files on the next commit.

```bash
# Remove a specific file
$ hg remove go_away.txt

# Remove a group of files by pattern
$ hg remove *.txt
```

## Further information

* [Learning Mercurial in Workflows](https://www.mercurial-scm.org/guide)
* [Mercurial Quick Start](https://www.mercurial-scm.org/wiki/QuickStart)
* [Mercurial: The Definitive Guide by Bryan O'Sullivan](http://hgbook.red-bean.com/)"
"HQ9+ is a joke programming language created by Cliff Biffle. It has only four commands and it isn't Turing-complete.

```
There is only 4 commands, represented by next characters
H: print ""Hello, world!""
Q: print the program's source code (a Quine)
9: print the lyrics to ""99 Bottles of Beer""
+: add one to the accumulator (the value of the accumulator cannot be accessed)
Any other character is ignored.

Ok. Let's write some program:
  HQ9

Result:
  Hello world!
  HQ9

HQ9+ is very simple, but allows you to do some things that are very difficult
in other languages. For example, here is a program that creates three copies of
itself on the screen:
  QQQ

This produces:
  QQQ
  QQQ
  QQQ
```

And that's all. There are a lot of interpreters for HQ9+. Below you can find one of them

+ [One of online interpreters](https://almnet.de/esolang/hq9plus.php)
+ [HQ9+ official website](http://cliffle.com/esoterica/hq9plus.html)"
"MATLAB stands for MATrix LABoratory. It is a powerful numerical computing language commonly used in engineering and mathematics.

If you have any feedback please feel free to reach me at
[@the_ozzinator](https://twitter.com/the_ozzinator), or
[osvaldo.t.mendoza@gmail.com](mailto:osvaldo.t.mendoza@gmail.com).

```matlab
%% Code sections start with two percent signs. Section titles go on the same line.
% Comments start with a percent sign.

%{
Multi line comments look
something
like
this
%}

% Two percent signs denote the start of a new code section
% Individual code sections can be run by moving the cursor to the section followed by
% either clicking the ""Run Section"" button
% or     using Ctrl+Shift+Enter (Windows) or Cmd+Shift+Return (macOS)

%% This is the start of a code section
%  One way of using sections is to separate expensive but unchanging start-up code like loading data
load myFile.mat y

%% This is another code section
%  This section can be edited and run repeatedly on its own, and is helpful for exploratory programming and demos
A = A * 2;
plot(A);

%% Code sections are also known as code cells or cell mode (not to be confused with cell arrays)


% commands can span multiple lines, using '...':
 a = 1 + 2 + ...
 + 4

% commands can be passed to the operating system
!ping google.com

who % Displays all variables in memory
whos % Displays all variables in memory, with their types
clear % Erases all your variables from memory
clear('A') % Erases a particular variable
openvar('A') % Open variable in variable editor

clc % Erases the writing on your Command Window
diary % Toggle writing Command Window text to file
ctrl-c % Abort current computation

edit('myfunction.m') % Open function/script in editor
type('myfunction.m') % Print the source of function/script to Command Window

profile on 	% turns on the code profiler
profile off 	% turns off the code profiler
profile viewer 	% Open profiler

help command 	% Displays documentation for command in Command Window
doc command 	% Displays documentation for command in Help Window
lookfor command % Searches for command in the first commented line of all functions
lookfor command -all % searches for command in all functions


% Output formatting
format short 	% 4 decimals in a floating number
format long 	% 15 decimals
format bank 	% only two digits after decimal point - for financial calculations
fprintf('text') % print ""text"" to the screen
disp('text') 	% print ""text"" to the screen

% Variables & Expressions
myVariable = 4 	% Notice Workspace pane shows newly created variable
myVariable = 4; % Semi colon suppresses output to the Command Window
4 + 6  		% ans = 10
8 * myVariable 	% ans = 32
2 ^ 3 		% ans = 8
a = 2; b = 3;
c = exp(a)*sin(pi/2) % c = 7.3891

% Calling functions can be done in either of two ways:
% Standard function syntax:
load('myFile.mat', 'y') % arguments within parentheses, separated by commas
% Command syntax:
load myFile.mat y 	% no parentheses, and spaces instead of commas
% Note the lack of quote marks in command form: inputs are always passed as
% literal text - cannot pass variable values. Also, can't receive output:
[V,D] = eig(A);  % this has no equivalent in command form
[~,D] = eig(A);  % if you only want D and not V



% Logicals
1 > 5 % ans = 0
10 >= 10 % ans = 1
3 ~= 4 % Not equal to -> ans = 1
3 == 3 % equal to -> ans = 1
3 > 1 && 4 > 1 % AND -> ans = 1
3 > 1 || 4 > 1 % OR -> ans = 1
~1 % NOT -> ans = 0

% Logicals can be applied to matrices:
A > 5
% for each element, if condition is true, that element is 1 in returned matrix
A( A > 5 )
% returns a vector containing the elements in A for which condition is true

% Strings
a = 'MyString'
length(a) % ans = 8
a(2) % ans = y
[a,a] % ans = MyStringMyString


% Cells
a = {'one', 'two', 'three'}
a(1) % ans = 'one' - returns a cell
char(a(1)) % ans = one - returns a string

% Structures
A.b = {'one','two'};
A.c = [1 2];
A.d.e = false;

% Vectors
x = [4 32 53 7 1]
x(2) % ans = 32, indices in MATLAB start 1, not 0
x(2:3) % ans = 32 53
x(2:end) % ans = 32 53 7 1

x = [4; 32; 53; 7; 1] % Column vector

x = [1:10] % x = 1 2 3 4 5 6 7 8 9 10
x = [1:2:10] % Increment by 2, i.e. x = 1 3 5 7 9

% Matrices
A = [1 2 3; 4 5 6; 7 8 9]
% Rows are separated by a semicolon; elements are separated with space or comma
% A =

%     1     2     3
%     4     5     6
%     7     8     9

A(2,3) % ans = 6, A(row, column)
A(6) % ans = 8
% (implicitly concatenates columns into vector, then indexes into that)


A(2,3) = 42 % Update row 2 col 3 with 42
% A =

%     1     2     3
%     4     5     42
%     7     8     9

A(2:3,2:3) % Creates a new matrix from the old one
%ans =

%     5     42
%     8     9

A(:,1) % All rows in column 1
%ans =

%     1
%     4
%     7

A(1,:) % All columns in row 1
%ans =

%     1     2     3

[A ; A] % Concatenation of matrices (vertically)
%ans =

%     1     2     3
%     4     5    42
%     7     8     9
%     1     2     3
%     4     5    42
%     7     8     9

% this is the same as
vertcat(A,A);


[A , A] % Concatenation of matrices (horizontally)

%ans =

%     1     2     3     1     2     3
%     4     5    42     4     5    42
%     7     8     9     7     8     9

% this is the same as
horzcat(A,A);


A(:, [3 1 2]) % Rearrange the columns of original matrix
%ans =

%     3     1     2
%    42     4     5
%     9     7     8

size(A) % ans = 3 3

A(1, :) =[] % Delete the first row of the matrix
A(:, 1) =[] % Delete the first column of the matrix

transpose(A) % Transpose the matrix, which is the same as:
A.' % Concise version of transpose (without taking complex conjugate)
ctranspose(A) % Hermitian transpose the matrix, which is the same as:
A'  % Concise version of complex transpose
    % (the transpose, followed by taking complex conjugate of each element)





% Element by Element Arithmetic vs. Matrix Arithmetic
% On their own, the arithmetic operators act on whole matrices. When preceded
% by a period, they act on each element instead. For example:
A * B % Matrix multiplication
A .* B % Multiply each element in A by its corresponding element in B

% There are several pairs of functions, where one acts on each element, and
% the other (whose name ends in m) acts on the whole matrix.
exp(A) % exponentiate each element
expm(A) % calculate the matrix exponential
sqrt(A) % take the square root of each element
sqrtm(A) %  find the matrix whose square is A


% Plotting
x = 0:.10:2*pi; % Creates a vector that starts at 0 and ends at 2*pi with increments of .1
y = sin(x);
plot(x,y)
xlabel('x axis')
ylabel('y axis')
title('Plot of y = sin(x)')
axis([0 2*pi -1 1]) % x range from 0 to 2*pi, y range from -1 to 1

plot(x,y1,'-',x,y2,'--',x,y3,':') % For multiple functions on one plot
legend('Line 1 label', 'Line 2 label') % Label curves with a legend

% Alternative method to plot multiple functions in one plot.
% while 'hold' is on, commands add to existing graph rather than replacing it
plot(x, y)
hold on
plot(x, z)
hold off

loglog(x, y) % A log-log plot
semilogx(x, y) % A plot with logarithmic x-axis
semilogy(x, y) % A plot with logarithmic y-axis

fplot (@(x) x^2, [2,5]) % plot the function x^2 from x=2 to x=5

grid on % Show grid; turn off with 'grid off'
axis square % Makes the current axes region square
axis equal % Set aspect ratio so data units are the same in every direction

scatter(x, y); % Scatter-plot
hist(x); % Histogram
stem(x); % Plot values as stems, useful for displaying discrete data
bar(x); % Plot bar graph

z = sin(x);
plot3(x,y,z); % 3D line plot

pcolor(A) % Heat-map of matrix: plot as grid of rectangles, coloured by value
contour(A) % Contour plot of matrix
mesh(A) % Plot as a mesh surface

h = figure % Create new figure object, with handle h
figure(h) % Makes the figure corresponding to handle h the current figure
close(h) % close figure with handle h
close all % close all open figure windows
close % close current figure window

shg % bring an existing graphics window forward, or create new one if needed
clf clear % clear current figure window, and reset most figure properties

% Properties can be set and changed through a figure handle.
% You can save a handle to a figure when you create it.
% The function get returns a handle to the current figure
h = plot(x, y); % you can save a handle to a figure when you create it
set(h, 'Color', 'r')
% 'y' yellow; 'm' magenta, 'c' cyan, 'r' red, 'g' green, 'b' blue, 'w' white, 'k' black
set(h, 'LineStyle', '--')
 % '--' is solid line, '---' dashed, ':' dotted, '-.' dash-dot, 'none' is no line
get(h, 'LineStyle')


% The function gca returns a handle to the axes for the current figure
set(gca, 'XDir', 'reverse'); % reverse the direction of the x-axis

% To create a figure that contains several axes in tiled positions, use subplot
subplot(2,3,1); % select the first position in a 2-by-3 grid of subplots
plot(x1); title('First Plot') % plot something in this position
subplot(2,3,2); % select second position in the grid
plot(x2); title('Second Plot') % plot something there


% To use functions or scripts, they must be on your path or current directory
path % display current path
addpath /path/to/dir % add to path
rmpath /path/to/dir % remove from path
cd /path/to/move/into % change directory


% Variables can be saved to .mat files
save('myFileName.mat') % Save the variables in your Workspace
load('myFileName.mat') % Load saved variables into Workspace

% M-file Scripts
% A script file is an external file that contains a sequence of statements.
% They let you avoid repeatedly typing the same code in the Command Window
% Have .m extensions

% M-file Functions
% Like scripts, and have the same .m extension
% But can accept input arguments and return an output
% Also, they have their own workspace (ie. different variable scope).
% Function name should match file name (so save this example as double_input.m).
% 'help double_input.m' returns the comments under line beginning function
function output = double_input(x)
	%double_input(x) returns twice the value of x
	output = 2*x;
end
double_input(6) % ans = 12


% You can also have subfunctions and nested functions.
% Subfunctions are in the same file as the primary function, and can only be
% called by functions in the file. Nested functions are defined within another
% functions, and have access to both its workspace and their own workspace.

% If you want to create a function without creating a new file you can use an
% anonymous function. Useful when quickly defining a function to pass to
% another function (eg. plot with fplot, evaluate an indefinite integral
% with quad, find roots with fzero, or find minimum with fminsearch).
% Example that returns the square of its input, assigned to the handle sqr:
sqr = @(x) x.^2;
sqr(10) % ans = 100
doc function_handle % find out more

% User input
a = input('Enter the value: ')

% Stops execution of file and gives control to the keyboard: user can examine
% or change variables. Type 'return' to continue execution, or 'dbquit' to exit
keyboard

% Reading in data (also xlsread/importdata/imread for excel/CSV/image files)
fopen(filename)

% Output
disp(a) % Print out the value of variable a
disp('Hello World') % Print out a string
fprintf % Print to Command Window with more control

% Conditional statements (the parentheses are optional, but good style)
if (a > 23)
	disp('Greater than 23')
elseif (a == 23)
	disp('a is 23')
else
	disp('neither condition met')
end

% Looping
% NB. looping over elements of a vector/matrix is slow!
% Where possible, use functions that act on whole vector/matrix at once
for k = 1:5
	disp(k)
end

k = 0;
while (k < 5)
	k = k + 1;
end

% Timing code execution: 'toc' prints the time since 'tic' was called
tic
A = rand(1000);
A*A*A*A*A*A*A;
toc

% Connecting to a MySQL Database
dbname = 'database_name';
username = 'root';
password = 'root';
driver = 'com.mysql.jdbc.Driver';
dburl = ['jdbc:mysql://localhost:8889/' dbname];
javaclasspath('mysql-connector-java-5.1.xx-bin.jar'); %xx depends on version, download available at http://dev.mysql.com/downloads/connector/j/
conn = database(dbname, username, password, driver, dburl);
sql = ['SELECT * from table_name where id = 22'] % Example sql statement
a = fetch(conn, sql) %a will contain your data


% Common math functions
sin(x)
cos(x)
tan(x)
asin(x)
acos(x)
atan(x)
exp(x)
sqrt(x)
log(x)
log10(x)
abs(x) %If x is complex, returns magnitude
min(x)
max(x)
ceil(x)
floor(x)
round(x)
rem(x)
rand % Uniformly distributed pseudorandom numbers
randi % Uniformly distributed pseudorandom integers
randn % Normally distributed pseudorandom numbers

%Complex math operations
abs(x) 	 % Magnitude of complex variable x
phase(x) % Phase (or angle) of complex variable x
real(x)  % Returns the real part of x (i.e returns a if x = a +jb)
imag(x)  % Returns the imaginary part of x (i.e returns b if x = a+jb)
conj(x)  % Returns the complex conjugate 


% Common constants
pi
NaN
inf

% Solving matrix equations (if no solution, returns a least squares solution)
% The \ and / operators are equivalent to the functions mldivide and mrdivide
x=A\b % Solves Ax=b. Faster and more numerically accurate than using inv(A)*b.
x=b/A % Solves xA=b

inv(A) % calculate the inverse matrix
pinv(A) % calculate the pseudo-inverse

% Common matrix functions
zeros(m,n) % m x n matrix of 0's
ones(m,n) % m x n matrix of 1's
diag(A) % Extracts the diagonal elements of a matrix A
diag(x) % Construct a matrix with diagonal elements listed in x, and zeroes elsewhere
eye(m,n) % Identity matrix
linspace(x1, x2, n) % Return n equally spaced points, with min x1 and max x2
inv(A) % Inverse of matrix A
det(A) % Determinant of A
eig(A) % Eigenvalues and eigenvectors of A
trace(A) % Trace of matrix - equivalent to sum(diag(A))
isempty(A) % Tests if array is empty
all(A) % Tests if all elements are nonzero or true
any(A) % Tests if any elements are nonzero or true
isequal(A, B) % Tests equality of two arrays
numel(A) % Number of elements in matrix
triu(x) % Returns the upper triangular part of x
tril(x) % Returns the lower triangular part of x
cross(A,B) %  Returns the cross product of the vectors A and B
dot(A,B) % Returns scalar product of two vectors (must have the same length)
transpose(A) % Returns the transpose of A
fliplr(A) % Flip matrix left to right
flipud(A) % Flip matrix up to down

% Matrix Factorisations
[L, U, P] = lu(A) % LU decomposition: PA = LU,L is lower triangular, U is upper triangular, P is permutation matrix
[P, D] = eig(A) % eigen-decomposition: AP = PD, P's columns are eigenvectors and D's diagonals are eigenvalues
[U,S,V] = svd(X) % SVD: XV = US, U and V are unitary matrices, S has non-negative diagonal elements in decreasing order

% Common vector functions
max     % largest component
min     % smallest component
length  % length of a vector
sort    % sort in ascending order
sum     % sum of elements
prod    % product of elements
mode    % modal value
median  % median value
mean    % mean value
std     % standard deviation
perms(x) % list all permutations of elements of x
find(x) % Finds all non-zero elements of x and returns their indexes, can use comparison operators, 
        % i.e. find( x == 3 ) returns indexes of elements that are equal to 3
        % i.e. find( x >= 3 ) returns indexes of elements greater than or equal to 3


% Classes
% MATLAB can support object-oriented programming. 
% Classes must be put in a file of the class name with a .m extension. 
% To begin, we create a simple class to store GPS waypoints.
% Begin WaypointClass.m
classdef WaypointClass % The class name.
  properties % The properties of the class behave like Structures
    latitude 
    longitude 
  end
  methods 
    % This method that has the same name of the class is the constructor. 
    function obj = WaypointClass(lat, lon)
      obj.latitude = lat;
      obj.longitude = lon;
    end

    % Other functions that use the Waypoint object
    function r = multiplyLatBy(obj, n)
      r = n*[obj.latitude];
    end

    % If we want to add two Waypoint objects together without calling
    % a special function we can overload MATLAB's arithmetic like so:
    function r = plus(o1,o2)
      r = WaypointClass([o1.latitude] +[o2.latitude], ...
                        [o1.longitude]+[o2.longitude]);
    end
  end
end
% End WaypointClass.m

% We can create an object of the class using the constructor
a = WaypointClass(45.0, 45.0)

% Class properties behave exactly like MATLAB Structures.
a.latitude = 70.0
a.longitude = 25.0

% Methods can be called in the same way as functions
ans = multiplyLatBy(a,3)

% The method can also be called using dot notation. In this case, the object 
% does not need to be passed to the method.
ans = a.multiplyLatBy(1/3)

% MATLAB functions can be overloaded to handle objects. 
% In the method above, we have overloaded how MATLAB handles 
% the addition of two Waypoint objects.
b = WaypointClass(15.0, 32.0)
c = a + b

```

## More on MATLAB

* [The official website](http://www.mathworks.com/products/matlab/)
* [The official MATLAB Answers forum](http://www.mathworks.com/matlabcentral/answers/)
* [Loren on the Art of MATLAB](http://blogs.mathworks.com/loren/)
* [Cleve's Corner](http://blogs.mathworks.com/cleve/)"
"Neat is basically a smaller version of D1 with some experimental syntax and a focus on terseness without losing the basic C-like syntax.

[Read more here.](https://github.com/FeepingCreature/fcc/wiki)

```c
// single line comments start with //
/*
  multiline comments look like this
*/
/+
  or this
  /+ these can be nested too, same as D +/
+/

// Module name. This has to match the filename/directory.
module LearnNeat;

// Make names from another module visible in this one.
import std.file;
// You can import multiple things at once.
import std.math, std.util;
// You can even group up imports!
import std.(process, socket);

// Global functions!
void foo() { }

// Main function, same as in C.
// string[] == ""array of strings"".
// ""string"" is just an alias for char[],
void main(string[] args) {
  // Call functions with ""function expression"".
  writeln ""Hello World"";
  // You can do it like in C too... if you really want.
  writeln (""Hello World"");
  // Declare a variable with ""type identifier""
  string arg = (""Hello World"");
  writeln arg;
  // (expression, expression) forms a tuple.
  // There are no one-value tuples though.
  // So you can always use () in the mathematical sense.
  // (string) arg; <- is an error

  /*
    byte: 8 bit signed integer
      char: 8 bit UTF-8 byte component.
    short: 16 bit signed integer
    int: 32 bit signed integer
    long: 64 bit signed integer

    float: 32 bit floating point
    double: 64 bit floating point
    real: biggest native size floating point (80 bit on x86).

    bool: true or false
  */
  int a = 5;
  bool b = true;
  // as in C, && and || are short-circuit evaluating.
  b = b && false;
  assert(b == false);
  // """" are ""format strings"". So $variable will be substituted at runtime
  // with a formatted version of the variable.
  writeln ""$a"";
  // This will just print $a.
  writeln `$a`;
  // you can format expressions with $()
  writeln ""$(2+2)"";
  // Note: there is no special syntax for characters.
  char c = ""a"";
  // Cast values by using type: expression.
  // There are three kinds of casts:
  // casts that just specify conversions that would be happening automatically
  // (implicit casts)
  float f = float:5;
  float f2 = 5; // would also work
  // casts that require throwing away information or complicated computation -
  // those must always be done explicitly
  // (conversion casts)
  int i = int:f;
  // int i = f; // would not work!
  // and, as a last attempt, casts that just reinterpret the raw data.
  // Those only work if the types have the same size.
  string s = ""Hello World"";
  // Arrays are (length, pointer) pairs.
  // This is a tuple type. Tuple types are (type, type, type).
  // The type of a tuple expression is a tuple type. (duh)
  (int, char*) array = (int, char*): s;
  // You can index arrays and tuples using the expression[index] syntax.
  writeln ""pointer is $(array[1]) and length is $(array[0])"";
  // You can slice them using the expression[from .. to] syntax.
  // Slicing an array makes another array.
  writeln ""$(s[0..5]) World"";
  // Alias name = expression gives the expression a name.
  // As opposed to a variable, aliases do not have an address
  // and can not be assigned to. (Unless the expression is assignable)
  alias range = 0 .. 5;
  writeln ""$(s[range]) World"";
  // You can iterate over ranges.
  for int i <- range {
    write ""$(s[i])"";
  }
  writeln "" World"";
  // Note that if ""range"" had been a variable, it would be 'empty' now!
  // Range variables can only be iterated once.
  // The syntax for iteration is ""expression <- iterable"".
  // Lots of things are iterable.
  for char c <- ""Hello"" { write ""$c""; }
  writeln "" World"";
  // For loops are ""for test statement"";
  alias test = char d <- ""Hello"";
  for test write ""$d"";
  writeln "" World\t\x05""; // note: escapes work
  // Pointers: function the same as in C, btw. The usual.
  // Do note: the pointer star sticks with the TYPE, not the VARIABLE!
  string* p;
  assert(p == null); // default initializer
  p = &s;
  writeln ""$(*p)"";
  // Math operators are (almost) standard.
  int x = 2 + 3 * 4 << 5;
  // Note: XOR is ""xor"". ^ is reserved for exponentiation (once I implement that).
  int y = 3 xor 5;
  int z = 5;
  assert(z++ == 5);
  assert(++z == 7);
  writeln ""x $x y $y z $z"";
  // As in D, ~ concatenates.
  string hewo = ""Hello "" ~ ""World"";
  // == tests for equality, ""is"" tests for identity.
  assert  (hewo == s);
  assert !(hewo is s);
  // same as
  assert  (hewo !is s);

  // Allocate arrays using ""new array length""
  int[] integers = new int[] 10;
  assert(integers.length == 10);
  assert(integers[0] == 0); // zero is default initializer
  integers = integers ~ 5; // This allocates a new array!
  assert(integers.length == 11);

  // This is an appender array.
  // Instead of (length, pointer), it tracks (capacity, length, pointer).
  // When you append to it, it will use the free capacity if it can.
  // If it runs out of space, it reallocates - but it will free the old array automatically.
  // This makes it convenient for building arrays.
  int[auto~] appender;
  appender ~= 2;
  appender ~= 3;
  appender.free(); // same as {mem.free(appender.ptr); appender = null;}

  // Scope variables are automatically freed at the end of the current scope.
  scope int[auto~] someOtherAppender;
  // This is the same as:
  int[auto~] someOtherAppender2;
  onExit { someOtherAppender2.free; }

  // You can do a C for loop too
  // - but why would you want to?
  for (int i = 0; i < 5; ++i) { }
  // Otherwise, for and while are the same.
  while int i <- 0..4 {
    assert(i == 0);
    break; // continue works too
  } then assert(false); // if we hadn't break'd, this would run at the end
  // This is the height of loopdom - the produce-test-consume loop.
  do {
    int i = 5;
  } while (i == 5) {
    assert(i == 5);
    break; // otherwise we'd go back up to do {
  }

  // This is a nested function.
  // Nested functions can access the surrounding function.
  string returnS() { return s; }
  writeln returnS();

  // Take the address of a function using &
  // The type of a global function is ReturnType function(ParameterTypeTuple).
  void function() foop = &foo;

  // Similarly, the type of a nested function is ReturnType delegate(ParameterTypeTuple).
  string delegate() returnSp = &returnS;
  writeln returnSp();
  // Class member functions and struct member functions also fit into delegate variables.
  // In general, delegates are functions that carry an additional context pointer.
  // (""fat pointers"" in C)

  // Allocate a ""snapshot"" with ""new delegate"".
  // Snapshots are not closures! I used to call them closures too,
  // but then my Haskell-using friends yelled at me so I had to stop.
  // The difference is that snapshots ""capture"" their surrounding context
  // when ""new"" is used.
  // This allows things like this
  int delegate(int) add(int a) {
    int add_a(int b) { return a + b; }
    // This does not work - the context of add_a becomes invalid
    // when add returns.
    // return &add_a;
    // Instead:
    return new &add_a;
  }
  int delegate(int) dg = add 2;
  assert (dg(3) == 5);
  // or
  assert (((add 2) 3) == 5);
  // or
  assert (add 2 3 == 5);
  // add can also be written as
  int delegate(int) add2(int a) {
    // this is an implicit, nameless nested function.
    return new λ(int b) { return a + b; }
  }
  // or even
  auto add3(int a) { return new λ(int b) -> a + b; }
  // hahahaaa
  auto add4 = λ(int a) -> new λ(int b) -> a + b;
  assert(add4 2 3 == 5);
  // If your keyboard doesn't have a λ (you poor sod)
  // you can use \ too.
  auto add5 = \(int a) -> new \(int b) -> a + b;
  // Note!
  auto nestfun = λ() { } // There is NO semicolon needed here!
  // ""}"" can always substitute for ""};"".
  // This provides syntactic consistency with built-in statements.


  // This is a class.
  // Note: almost all elements of Neat can be used on the module level
  //       or just as well inside a function.
  class C {
    int a;
    void writeA() { writeln ""$a""; }
    // It's a nested class - it exists in the context of main().
    // so if you leave main(), any instances of C become invalid.
    void writeS() { writeln ""$s""; }
  }
  C cc = new C;
  // cc is a *reference* to C. Classes are always references.
  cc.a = 5; // Always used for property access.
  auto ccp = &cc;
  (*ccp).a = 6;
  // or just
  ccp.a = 7;
  cc.writeA();
  cc.writeS(); // to prove I'm not making things up
  // Interfaces work same as in D, basically. Or Java.
  interface E { void doE(); }
  // Inheritance works same as in D, basically. Or Java.
  class D : C, E {
    override void writeA() { writeln ""hahahahaha no""; }
    override void doE() { writeln ""eeeee""; }
    // all classes inherit from Object. (toString is defined in Object)
    override string toString() { return ""I am a D""; }
  }
  C cd = new D;
  // all methods are always virtual.
  cd.writeA();
  E e = E:cd; // dynamic class cast!
  e.doE();
  writeln ""$e""; // all interfaces convert to Object implicitly.

  // Templates!
  // Templates are parameterized namespaces, taking a type as a parameter.
  template Templ(T) {
    alias hi = 5, hii = 8;
    // Templates always have to include something with the same name as the template
    // - this will become the template's _value_.
    // Static ifs are evaluated statically, at compile-time.
    // Because of this, the test has to be a constant expression,
    // or something that can be optimized to a constant.
    static if (types-equal (T, int)) {
      alias Templ = hi;
    } else {
      alias Templ = hii;
    }
  }
  assert(Templ!int == 5);
  assert(Templ!float == 8);
}
```

## Topics Not Covered

 * Extended iterator types and expressions
 * Standard library
 * Conditions (error handling)
 * Macros"
"[Vim](http://www.vim.org)
(Vi IMproved) is a clone of the popular vi editor for Unix. It is a text
editor designed for speed and increased productivity, and is ubiquitous in most
unix-based systems. It has numerous keybindings for speedy navigation to
specific points in the file, and for fast editing.

`vimtutor` is a an excellent application that teaches you how to use `Vim`. It comes with the vim package during installation. You should be able to just run ""vimtutor"" on the command line to open this tutor. It will guide you through all the major features in `vim`.


## Basics of navigating Vim

```
    vim <filename>    # Open <filename> in vim
    :help <topic>     # Open up built-in help docs about <topic> if any exists
    :q                # Quit vim
    :w                # Save current file
    :wq               # Save file and quit vim
    ZZ                # Save file and quit vim
    :q!               # Quit vim without saving file
                      # ! *forces* :q to execute, hence quitting vim without saving
    ZQ                # Quit vim without saving file
    :x                # Save file(only when the file is modified) and quit vim

    u                 # Undo
    CTRL+R            # Redo

    h                 # Move left one character
    j                 # Move down one line
    k                 # Move up one line
    l                 # Move right one character

    Ctrl+B            # Move back one full screen
    Ctrl+F            # Move forward one full screen
    Ctrl+D            # Move forward 1/2 a screen
    Ctrl+U            # Move back 1/2 a screen

    # Moving within the line

    0                 # Move to beginning of line
    $                 # Move to end of line
    ^                 # Move to first non-blank character in line

    # Searching in the text

    /word             # Highlights all occurrences of word after cursor
    ?word             # Highlights all occurrences of word before cursor
    n                 # Moves cursor to next occurrence of word after search
    N                 # Moves cursor to previous occurrence of word

    :%s/foo/bar/g     # Change 'foo' to 'bar' on every line in the file
    :s/foo/bar/g      # Change 'foo' to 'bar' on the current line
    :%s/\n/\r/g       # Replace new line characters with new line characters
    :'<,'>s/foo/bar/g # Change 'foo' to 'bar on every line in the current visual selection

    # Jumping to characters

    f<character>      # Jump forward and land on <character>
    t<character>      # Jump forward and land right before <character>

    # For example,
    f<                # Jump forward and land on <
    t<                # Jump forward and land right before <

    # Moving by word

    w                 # Move forward by one word
    b                 # Move back by one word
    e                 # Move to end of current word

    # Other characters for moving around

    gg                # Go to the top of the file
    G                 # Go to the bottom of the file
    :NUM              # Go to line number NUM (NUM is any number)
    H                 # Move to the top of the screen
    M                 # Move to the middle of the screen
    L                 # Move to the bottom of the screen
```

## Help docs:

Vim has built in help documentation that can accessed with `:help <topic>`.
For example `:help navigation` will pull up documentation about how to navigate
your workspace!

`:help` can also be used without an option. This will bring up a default help dialog
that aims to make getting started with vim more approachable!

## Modes:

Vim is based on the concept on **modes**.

- Command Mode - vim starts up in this mode, used to navigate and write commands
- Insert Mode  - used to make changes in your file
- Visual Mode  - used to highlight text and do operations to them
- Ex Mode      - used to drop down to the bottom with the ':' prompt to enter commands

```
    i                 # Puts vim into insert mode, before the cursor position
    a                 # Puts vim into insert mode, after the cursor position
    v                 # Puts vim into visual mode
    :                 # Puts vim into ex mode
    <esc>             # 'Escapes' from whichever mode you're in, into Command mode

    # Copying and pasting text
                      # Operations use the vim register by default
                      # Think of it as vim's private clipboard

                      # Yank ~ copy text into vim register
    y                 # Yank whatever is selected
    yy                # Yank the current line

                      # Delete ~ yank text and delete from file
    d                 # Delete whatever is selected
    dd                # Delete the current line

    p                 # Paste text in vim register after the current cursor position
    P                 # Paste text in vim register before the current cursor position

    x                 # Delete character under current cursor position
```

## The 'Grammar' of vim

Vim can be thought of as a set of commands in a
'Verb-Modifier-Noun' format, where:

- Verb     - your action
- Modifier - how you're doing your action
- Noun     - the object on which your action acts on

A few important examples of 'Verbs', 'Modifiers', and 'Nouns':

```
    # 'Verbs'

    d                 # Delete
    c                 # Change
    y                 # Yank (copy)
    v                 # Visually select

    # 'Modifiers'

    i                 # Inside
    a                 # Around
    NUM               # Number (NUM is any number)
    f                 # Searches for something and lands on it
    t                 # Searches for something and stops before it
    /                 # Finds a string from cursor onwards
    ?                 # Finds a string before cursor

    # 'Nouns'

    w                 # Word
    s                 # Sentence
    p                 # Paragraph
    b                 # Block

    # Sample 'sentences' or commands

    d2w               # Delete 2 words
    cis               # Change inside sentence
    yip               # Yank inside paragraph (copy the para you're in)
    ct<               # Change to open bracket
                      # Change the text from where you are to the next open bracket
    d$                # Delete till end of line
```

## Some shortcuts and tricks

        <!--TODO: Add more!-->
```
    >                 # Indent selection by one block
    <                 # Dedent selection by one block
    :earlier 15m      # Reverts the document back to how it was 15 minutes ago
    :later 15m        # Reverse above command
    ddp               # Swap position of consecutive lines, dd then p
    .                 # Repeat previous action
    :w !sudo tee %    # Save the current file as root
    :set syntax=c     # Set syntax highlighting to 'c'
    :sort             # Sort all lines
    :sort!            # Sort all lines in reverse
    :sort u           # Sort all lines and remove duplicates
    ~                 # Toggle letter case of selected text
    u                 # Selected text to lower case
    U                 # Selected text to upper case
    J                 # Join the current line with the next line
    
    # Fold text
    zf                # Create fold from selected text
    zd                # Delete fold on the current line
    zD                # Recursively delete nested or visually selected folds
    zE                # Eliminate all folds in the window
    zo                # Open current fold
    zO                # Recursively open nested or visually selected folds
    zc                # Close current fold
    zC                # Recursively close nested or visually selected folds
    zR                # Open all folds
    zM                # Close all folds
    za                # Toggle open/close current fold
    zA                # Recursively toggle open/close nested fold
    [z                # Move to the start of the current fold
    ]z                # Move to the end of the current fold
    zj                # Move to the start of the next fold
    zk                # Move to the end of the previous fold
```

## Macros

Macros are basically recordable actions.
When you start recording a macro, it records **every** action and command
you use, until you stop recording. On invoking a macro, it applies the exact
same sequence of actions and commands again on the text selection.

```
    qa                # Start recording a macro named 'a'
    q                 # Stop recording
    @a                # Play back the macro
```

### Configuring ~/.vimrc

The .vimrc file can be used to configure Vim on startup.

Here's a sample ~/.vimrc file:

```
"" Example ~/.vimrc
"" 2015.10

"" Required for vim to be iMproved
set nocompatible

"" Determines filetype from name to allow intelligent auto-indenting, etc.
filetype indent plugin on

"" Enable syntax highlighting
syntax on

"" Better command-line completion
set wildmenu

"" Use case insensitive search except when using capital letters
set ignorecase
set smartcase

"" When opening a new line and no file-specific indenting is enabled,
"" keep same indent as the line you're currently on
set autoindent

"" Display line numbers on the left
set number

"" Indentation options, change according to personal preference

"" Number of visual spaces per TAB
set tabstop=4

"" Number of spaces in TAB when editing
set softtabstop=4

"" Number of spaces indented when reindent operations (>> and <<) are used
set shiftwidth=4

"" Convert TABs to spaces
set expandtab

"" Enable intelligent tabbing and spacing for indentation and alignment
set smarttab
```

### References

[Vim | Home](http://www.vim.org/index.php)

`$ vimtutor`

[A vim Tutorial and Primer](https://danielmiessler.com/study/vim/)

[What are the dark corners of Vim your mom never told you about? (Stack Overflow thread)](http://stackoverflow.com/questions/726894/what-are-the-dark-corners-of-vim-your-mom-never-told-you-about)

[Arch Linux Wiki](https://wiki.archlinux.org/index.php/Vim)"
"> The content of this document is largely inspired by [""Learn Solidity in Y Minutes""](https:#github.com/adambard/learnxinyminutes-docs/blob/master/solidity.html.markdown)

Vyper lets you program on [Ethereum](https:#www.ethereum.org/), a
blockchain-based virtual machine that allows the creation and
execution of smart contracts, without requiring centralized or trusted parties. It was
designed to improve upon Solidity, another smart contract language for Ethereum, by
limiting unsafe practices and enhancing readability; Vyper seeks to optimize the
security and auditability of smart contracts.

Vyper is an experimental, statically typed, contract programming language meant to
resemble Python. Like objects in OOP, each contract contains state variables, functions,
and common data types. Contract-specific features include event notifiers for listeners,
and custom global variables, global constants.

Some Ethereum contract examples include crowdfunding, voting, and blind auctions.

---

## Table of Contents

- Intro
- Example
1. Data types and associated methods
2. Data structures
3. Simple operators
4. Global variables of note
5. Functions and more
    a. functions
    b. events
6. Branching and loops
7. Objects/contracts
    a. calling external contracts
    b. ERC20 built-in
    c. following an interface
8. Other keywords
    a. selfdestruct
9. Contract design notes
    a. obfuscation
    b. storage optimization
    c. data access in blockchain
    d. cron job
    e. observer pattern
10. Security
11. Style notes
12. Natspec comments
- Other documents

---

## Intro

From [the docs](https://media.readthedocs.org/pdf/vyper/latest/vyper.pdf)
the foundational tenants of Vyper are:

1. *Security*
2. *Language and compiler simplicity*
3. *Auditability*

This allows for the following features:

1. *Bounds and overflow checking*
   - On the arithmetic and array level
   - There are no dynamic arrays in Vyper
2. *Support for signed integers and decimal fixed point numbers*
3. *Decidability* - You can always compute precise upper bound on gas cost
4. *Strong typing* - for built-in and custom types
5. *Small and understandable compiler code*
6. *Limited support for pure functions*
    - Anything marked `@constant` is not allowed to change the state

Following the principles and goals, Vyper does not provide the following features:

1. *Modifiers* (defining parts of functions elsewhere)
2. *Class inheritance*
3. *Inline assembly*
4. *Function overloading*
5. *Operator overloading*
6. *Recursive calling*
7. *Infinite-length loops*
8. *Binary fixed point* (decimal fixed point is used for its exactness)

WITH THE RAPID CHANGES IN ETHEREUM, THIS DOCUMENT IS UNLIKELY TO STAY UP TO
DATE, SO YOU SHOULD FOLLOW THE LATEST VYPER DOCS AND ETHEREUM BLOG FOR THE LATEST.
ALL CODE HERE IS PROVIDED AS IS, WITH SUBSTANTIAL RISK OF ERRORS OR DEPRECATED CODE
PATTERNS.

This document primarily discusses syntax, and so excludes many
popular design patterns.

As Vyper and Ethereum are under active development, experimental or beta
features are typically marked, and subject to change. Pull requests welcome.

This document describes Vyper version `0.1.0-beta.8`.

*All of the following code exists for educational purposes only!*
*None of the following code should be used in production as-is!*

## Example

```python
# First, a simple todo list contract
# Implements CRUD operations for tasks

# todo.vy (note .vy extension)
### **** START EXAMPLE **** ###

# Start with Natspec comment
# used for documentation

# @title SimpleBank v1
# @author kennyp
# @notice This is a simple bank.

# Vyper contracts must obey a particular order:
#   struct -> interface -> events -> globals and constants -> functions
# Additionally, like Python, Vyper functions must be defined in the file
#    before they're called.

# Structs

struct Task:
    done: bool
    deleted: bool
    task: string[100]
    metadata: bytes32

# Interfaces

contract AnotherContract():
    def fetch() -> bytes32: constant
    def inform(_taskId: uint256, _status: uint256) -> bool: modifying

# Events

# Events - publicize actions to external listeners
# `indexed` means that it's easier to search/filter on this field
TaskStatus: event({_taskId: indexed(uint256), _status: uint256})

# Global Variables

# State variables are values which are permanently stored in contract storage
# State vars consist of any value persisting beyond any function's scope
#   and are permanently stored in contract storage

# You can define your own, custom, unmutable constants
CREATED: constant(uint256) = 0
COMPLETED: constant(uint256) = 1
DELETED: constant(uint256) = 2

# The `public` built-in allows for this address to be read externally
#   without defining a `get()` constant function
owner: public(address)
other: public(address)

# uint256 means ""unsigned positive integer between 0 and 2^256 - 1""
# Overflow protection is built-in to Vyper
taskCount: uint256
tasks: map(uint256, Task) # dictionary: key=uint256, value: Task struct

# Private Functions

# Start each function with Pythonic decorators
# These decorators resemble Natspec but are actually enforced by Vyper's compiler
# These decorators are:
# @public XOR @private (either one or the other)
#   @public (if any contract/user can call it)
#   @private (if only internal functions can call it)
# @payable (if the function is payable i.e. accepting ETH)
# @constant (if the function is not modifying anything on-chain)
@private
def _changeTaskStatus( \
        _sender: address, \
        _taskId: uint256, \
        _status: uint256, \
    ):
    # backslashes (\) allow for multi-line code
    # Natspec comments are particularly helpful for documentation and readability
    # Natspec can be included using familiar Pythonic docstring syntax
    """"""
    @notice
    @dev `_sender` MUST be `self.owner`
    @param _sender Who is triggering this function
    @param _task The description of the task (only useful when task added)
    """"""
    # NOTE: Private functions do not have access to `msg.sender`
    # SIDE NOTE: `msg.sender` refers to whoever immediately called the function of
    #   immediate scope. In other words, if I call a function that calls another
    #   in-contract, public function, then `msg.sender` turns from my address to
    #   the address of the current contract.
    assert _sender == self.owner # failed assertions cause calls/transactions to fail
    # Note that unlike Solidity, `self.` is required to query the contract's state
    # Control flow is Pythonic, as is much of Vyper:
    _task: string[100] # initialized to default value
    _data: bytes32 = sha3(convert(_sender, bytes32)) # owner is obfuscated (but still visible in logs)
    if _status == CREATED: # control flow mimics python
        # How a new struct is instantiated:
        self.tasks[_taskId] = Task({ \
            done: False, deleted: False, task: _task, metadata: _data \
        })
    elif _status == COMPLETED:
        # Modifying an existing struct:
        self.tasks[_taskId].done = True
    elif _status == DELETED:
        self.tasks[_taskId].deleted = True
    AnotherContract(self.other).inform(_taskId, _status) # modifying external call
    log.TaskStatus(_taskId, _status) # emit an event

# Public Functions

# Pythonic constructor - can receive none or many arguments
@public
def __init__(_owner: address, _other_contract: address):
    """"""
    @dev Called once and only upon contract depoyment
    """"""
    self.owner = _owner
    self.other = _other_contract

# NOTE: Pythonic whitespace rules are mandated in Vyper

@public
def addTask(_task: string[100]) -> uint256:
    """"""
    @notice Adds a task to contract
    @param _task Description of task
    @return Id of newly minted task
    """"""
    # msg.sender gives the address of who/what contract is calling this function
    self._changeTaskStatus(msg.sender, self.taskCount, CREATED)
    self.tasks[self.taskCount].task = _task
    self.taskCount += 1
    return self.taskCount - 1

@public
def addSpecialTask(_task: string[100]) -> uint256:
    """"""
    @notice Adds a task with metadata pulled from elsewhere
    @param _task Description of task
    @return Id of newly minted task
    """"""
    self._changeTaskStatus(msg.sender, self.taskCount, CREATED)
    self.tasks[self.taskCount].task = _task
    self.tasks[self.taskCount].metadata = AnotherContract(self.other).fetch()
    self.taskCount += 1
    return self.taskCount - 1

@public
def completeTask(_taskId: uint256):
    """"""
    @notice Marks a task as ""completed""
    @param _taskId Id of task to complete
    """"""
    self._changeTaskStatus(msg.sender, _taskId, COMPLETED)

@public
def deleteTask(_taskId: uint256):
    """"""
    @notice Adds a task to contract
    @param _taskId Id of task to delete
    """"""
    self._changeTaskStatus(msg.sender, _taskId, DELETED)

@public
@constant # allows function to run locally/off blockchain
def getTask(_taskId: uint256) -> string[100]:
    """"""
    @notice Getter for a task's description
    @param _taskId Id of task with desired description
    @return Description of task
    """"""
    return self.tasks[_taskId].task

### **** END EXAMPLE **** ###


# Now, the basics of Vyper


# ---


# 1. DATA TYPES AND ASSOCIATED METHODS
# uint256 used for currency amount and for dates (in unix time)
x: uint256

# int of 128 bits, cannot be changed after contract deployment
# with 'constant', compiler replaces each occurrence with actual value
a: constant(int128) = 5

# All state variables (those outside a function)
#   are by default 'internal' and accessible inside contract
# Need to explicitly set to 'public' to allow external contracts to access
#   A getter is automatically created, but NOT a setter
# Can only be called in the contract's scope (not within functions)
# Add 'public' field to indicate publicly/externally accessible
a: public(int128)

# No random functions built in, use other contracts for randomness

# Type casting is limited but exists
b: int128 = 5
x: uint256 = convert(b, uint256)

# Types of accounts:
# Contract Account: f(creator_addr, num_transactions)=address set on contract creation
# External Account: (person/external entity): f(public_key)=address

# Addresses - An address type can hold an Ethereum address which
#   equates to 20 bytes or 160 bits. It returns in hexadecimal notation
#   with a leading 0x. No arithmetic allowed
owner: public(address)

# Members can be invoked on all addresses:
owner.balance # returns balance of address as `wei_value`
owner.codesize # returns code size of address as `int128`
owner.is_contract # `True` if Contract Account

# All addresses can be sent ether via `send()` built-in
@public
@payable
def sendWei(any_addr: address):
    send(any_addr, msg.value)

# Bytes available
a: bytes[2]
b: bytes[32]
c: bytes32
# `b` and `c` are 2 different types

# Bytes are preferable to strings since Vyper currently offers better
#   support for bytes i.e. more built-ins to deal with `bytes32`, `bytes32`
#   can be returned from functions and strings[] can't be, UTF8 (string encoding)
#   uses more storage, etc.

# There are no dynamically sized bytes, similar to how there are no
#   dynamic arrays

# Fixed-size byte arrays (Strings)
a: string[100]
b: string[8]
c: string[108] = concat(a, b) # check the latest docs for more built-ins

# Time
t1: timedelta
t2: timestamp
# Both types are built-in ""custom type"" variants of `uint256`
# `timedelta` values can be added but not `timestamp` values

# Money
m: wei_value
# Also has the base type `uint256` like `timestamp` and `timedelta`
# 1 unit of WEI (a small amount of ETH i.e. ether)

# Custom types
# specify units used in the contract:
units: {
    cm: ""centimeter"",
    km: ""kilometer""
}
# usage:
a: int128(cm)
b: uint256(km)

# BY DEFAULT: all values are set to 0 on instantiation

# `clear()` can be called on most types
#   Does NOT destroy value, but sets value to 0, the initial value


# ---


# 2. DATA STRUCTURES
# Arrays
bytes32[5] nicknames; # static array
bytes32[] names; # dynamic array
uint newLength = names.push(""John""); # adding returns new length of the array
# Length
names.length; # get length
names.length = 1; # lengths can be set (for dynamic arrays in storage only)

# Multidimensional Arrays
# At initialization, array dimensions must be hard-coded or constants
# Initialize a 10-column by 3-row, multidimensional fixed array
ls: (uint256[10])[3] # parentheses are optional
@public
def setToThree():
    # Multidimensional Array Access and Write
    # access indices are reversed
    # set element in row 2 (3rd row) column 5 (6th column) to 3
    self.ls[2][5] = 3

# Dictionaries (any simple type to any other type including structs)
theMap: map(uint256, bytes32)
theMap[5] = sha3(""charles"")
# theMap[255] result is 0, all non-set key values return zeroes
# To make read public, make a getter that accesses the mapping
@public
def getMap(_idx: uint256) -> bytes32:
    """"""
    @notice Get the value of `theMap` at `_idx`
    """"""
    return self.theMap[_idx]

self.getMap(5) # returns sha3(""charles"") in bytes32

# Nested mappings
aMap: map(address, map(address, uint256))
# NOTE: Mappings are only allowed as state variables
# NOTE: Mappings are not iterable; can only be accessed

# To delete (reset the mapping's value to default at a key)
clear(balances[""John""])
clear(balances); # sets all elements to 0

# Unlike other languages, CANNOT iterate through all elements in
#   mapping, without knowing source keys - can build data structure
#   on top to do this

# Structs
struct Struct:
    owner: address
    _balance: uint256 # balance is a reserved keyword, is a member for addresses

exampleStruct: Struct

@public
def foo() -> uint256:
    self.exampleStruct = Struct({owner: msg.sender, _balance: 5})
    self.exampleStruct._balance = 10
    self.exampleStruct._balance = 5 # set to new value
    clear(self.exampleStruct._balance)
    clear(self.exampleStruct)
    return self.exampleStruct._balance


# Data locations: Memory vs. storage vs. calldata - all complex types (arrays,
# structs) have a data location
# 'memory' does not persist, 'storage' does
# Default is 'storage' for local and state variables; 'memory' for func params
# stack holds small local variables

# for most types, can explicitly set which data location to use


# ---


# 3. SIMPLE OPERATORS
# Comparisons, bit operators and arithmetic operators are provided
# exponentiation: **
# modulo: %
# maximum: max(x, y)
# AND: bitwise_and(x, y)
# bitwise shift: shift(x, _shift)
#   where x,y are uint256
#         _shift is int128

# 4. GLOBAL VARIABLES OF NOTE
# ** self **
self # address of contract
# often used at end of contract life to transfer remaining balance to party:
self.balance # balance of current contract
self.someFunction() # calls func externally via call, not via internal jump

# ** msg - Current message received by the contract **
# Ethereum programmers take NOTE: this `msg` object is smaller than elsewhere
msg.sender # address of sender
msg.value # amount of ether provided to this contract in wei, the function should be marked `@payable`
msg.gas # remaining gas

# ** tx - This transaction **
# Ethereum programmers take NOTE: this `tx` object is smaller than elsewhere
tx.origin # address of sender of the transaction

# ** block - Information about current block **
block.timestamp # time at current block (uses Unix time)
# Note that `block.timestamp` can be manipulated by miners, so be careful
block.number # current block number
block.difficulty # current block difficulty

# ** storage - Persistent storage hash **
storage['abc'] = 'def'; # maps 256 bit words to 256 bit words


# ---


# 5. FUNCTIONS AND MORE

# A. FUNCTIONS
# Simple function
function increment(uint x) returns (uint) {
    x += 1;
    return x;
}

# Functions can return many arguments
@public
@constant
def increment(x: uint256, y: uint256) -> (uint256, uint256):
    x += 1
    y += 1
    return  (x, y)

# Call previous function
@public
@constant
def willCall() -> (uint256, uint256):
    return  self.increment(1,1)

# One should never have to call a function / hold any logic outside
#   outside the scope of a function in Vyper

# '@constant'
# indicates that function does not/cannot change persistent vars
# Constant function execute locally, not on blockchain
y: uint256
@public
@constant
def increment(x: uint256) -> uint256:
    x += 1
    y += 1 # this line would fail
    # y is a state variable => can't be changed in a constant function


# 'Function Decorators'
# Used like python decorators but are REQUIRED by Vyper
# @public - visible externally and internally (default for function)
# @private - only visible in the current contract
# @constant - doesn't change state
# @payable - receive ether/ETH
# @nonrentant(<unique_key>) - Function can only be called once, both externally
#                             and internally. Used to prevent reentrancy attacks

# Functions hare not hoisted
# Functions cannot be assigned to a variable
# Functions cannot be recursive

# All functions that receive ether must be marked 'payable'
@public
@payable
def depositEther():
    self.balances[msg.sender] += msg.value


# B. EVENTS
# Events are notify external parties; easy to search and
#   access events from outside blockchain (with lightweight clients)
#   typically declare after contract parameters

# Declare
LogSent: event({_from: indexed(address), address: indexed(_to), _amount: uint256})
# Call
log.LogSent(from, to, amount)

/**
For an external party (a contract or external entity), to watch using
the Web3 Javascript library:

# The following is Javascript code, not Vyper code
Coin.LogSent().watch({}, '', function(error, result) {
    if (!error) {
        console.log(""Coin transfer: "" + result.args.amount +
            "" coins were sent from "" + result.args.from +
            "" to "" + result.args.to + ""."");
        console.log(""Balances now:\n"" +
            ""Sender: "" + Coin.balances.call(result.args.from) +
            ""Receiver: "" + Coin.balances.call(result.args.to));
    }
}
**/

# Common paradigm for one contract to depend on another (e.g., a
#   contract that depends on current exchange rate provided by another)


# ---


# 6. BRANCHING AND LOOPS

# All basic logic blocks from Python work - including if/elif/else, for,
#   while, break, continue, return - but no switch

# Syntax same as Python, but no type conversion from non-boolean
# to boolean (comparison operators must be used to get the boolean val)

# REMEMBER: Vyper does not allow resursive calls or infinite loops


# ---


# 7. OBJECTS/CONTRACTS
# REMEMBER: Vyper does not allow for inheritance or imports

# A. CALLING EXTERNAL CONTRACTS
# You must define an interface to an external contract in the current contract

contract InfoFeed():
    def getInfo() -> uint256: constant

info: uint256

@public
def __init__(_source: address):
    self.info = InfoFeed(_source).getInfo()


# B. ERC20 BUILT-IN
# Using the `ERC20` keyword implies that the contract at the address
#   follows the ERC20 token standard, allowing you to safely call
#   functions like `transfer()`, etc.

tokenAddress: address(ERC20)

@public
def transferIt(_to: address, _amt: uint256(wei)):
    self.tokenAddress.transfer(_to, _amt)


# C. FOLLOWING AN INTERFACE
# Vyper is experimenting with using the following syntax at the top of
#   a `.vy` file to specify what interfaces are followed by the contract
# This allows interfaces to be better organized, registered, and recognized

import interfaces.some_interface as SomeInterface
implements: SomeInterface
# <rest of contract>


# ---


# 8. OTHER KEYWORDS

# A. selfdestruct()
# selfdestruct current contract, sending funds to address (often creator)
selfdestruct(SOME_ADDRESS);

# removes storage/code from current/future blocks
# helps thin clients, but previous data persists in blockchain

# Common pattern, lets owner end the contract and receive remaining funds
@public
def endItAll() {
    assert msg.sender == self.creator # Only let the contract creator do this
    selfdestruct(self.creator) # Makes contract inactive, returns funds

# May want to deactivate contract manually, rather than selfdestruct
#   (ether sent to selfdestructed contract is lost)


# B. sha3()
# Encrypts strings and other data
# Very important on the blockchain
# Takes 1 argument, `concat()` can be called beforehand
# All strings passed are concatenated before hash action
sha3(concat(""ab"", ""cd"")) # returns bytes32


# ---


# 9. CONTRACT DESIGN NOTES

# A. Obfuscation
# All variables are publicly viewable on blockchain, so anything
#   that is private needs to be obfuscated (e.g., hashed w/secret)
# Oftentimes, a ""commit-reveal"" scheme is employed

# Step 1. Commit
# Place a commitment by sending output of `sha3()`
sha3(""a secret""); # bytes32 commit
sha3(concat(""secret"", ""other secret"", ""salt"")); # commit multiple things
# The `sha3()` calculation should occur off-chain, only the bytes32
#   output should be inputted into some `commit()` function
commits: map(address, bytes32)
@public
def commit(commitment: bytes32):
    self.commits[msg.sender] = commitment

# Step 2. Reveal
# Send your previously committed data so the contract can check
#   if your commitment was honest
@public
def reveal(_secret: string[100], _salt: string[100]) -> bool:
    return sha3(concat(_secret, _salt)) == self.commits[msg.sender]


# B. Storage optimization
# Writing to blockchain can be expensive, as data stored forever; encourages
#   smart ways to use memory (eventually, compilation will be better, but for now
#   benefits to planning data structures - and storing min amount in blockchain)

# Cost can often be high for items like multidimensional arrays
#   (cost is for storing data - not declaring unfilled variables)


# C. Data access in blockchain
# Cannot restrict human or computer from reading contents of
#   transaction or transaction's state

# While 'private' prevents other *contracts* from reading data
#   directly - any other party can still read data in blockchain

# All data to start of time is stored in blockchain, so
#   anyone can observe all previous data and changes


# D. Cron Job
# Contracts must be manually called to handle time-based scheduling;
#   can create external code to regularly ping or provide incentives
#   (ether) for others to ping


# E. Observer Pattern
# An Observer Pattern lets you register as a subscriber and
#   register a function which is called by the oracle (note, the oracle
#   pays for this action to be run)
# Some similarities to subscription in Pub/sub

# This is an abstract contract, both client and server classes import,
#   the client should implement

### **** START EXAMPLE **** ###

contract SomeOracleCallback():
    def oracleCallback(_value: uint256, _time: timestamp, _info: bytes32): modifying

MAX_SUBS: constant(uint256) = 100
numSubs: public(uint256) # number of subscribers
subs: map(uint256, address) # enumerates subscribers

@public
def addSub(_sub: address) -> uint256:
    """"""
    @notice Add subscriber
    @param _sub Address to add
    @return Id of newly added subscriber
    """"""
    self.subs[self.numSubs] = _sub
    self.numSubs += 1
    return self.numSubs - 1

@private
def notify(_value: uint256, _time: timestamp, _info: bytes32) -> bool:
    """"""
    @notice Notify all subscribers
    @dev Check `numSubs` first; Watch out for gas costs!
    @param _value whatever
    @param _time what have you
    @param _info what else
    @return True upon successful completion
    """"""
    j: uint256
    for i in range(MAX_SUBS):
        j = convert(i, uint256) # `i` is int128 by default
        if j == self.numSubs:
            return True
        SomeOracleCallback(self.subs[j]).oracleCallback(_value, _time, _info)

@public
def doSomething():
    """"""
    @notice Do something and notify subscribers
    """"""
    # ...something...
    whatever: uint256 = 6
    what_have_you: timestamp
    what_else: bytes32 = sha3(""6"")
    self.notify(whatever, what_have_you, what_else)

# Now, your client contract can addSubscriber by importing SomeOracleCallback
# and registering with Some Oracle

### **** END EXAMPLE **** ###


# ---


# 10. SECURITY
# Bugs can be disastrous in Ethereum contracts - and even popular patterns in
#   Vyper may be found to be antipatterns

# See security links at the end of this doc


# ---


# 11. STYLE NOTES
# Based on Python's PEP8 style guide
# Full Style guide: http:#solidity.readthedocs.io/en/develop/style-guide.html

# Quick summary:
# 4 spaces for indentation
# Two lines separate contract declarations (and other top level declarations)
# Avoid extraneous spaces in parentheses
# Can omit curly braces for one line statement (if, for, etc)
# else should be placed on own line

# Specific to Vyper:
# arguments: snake_case
# events, interfaces, structs: PascalCase
# public functions: camelCase
# private functions: _prefaceWithUnderscore


# ---


# 12. NATSPEC COMMENTS
# used for documentation, commenting, and external UIs

# Contract natspec - always above contract definition
# @title Contract title
# @author Author name

# Function natspec
# Should include in docstring of functions in typical Pythonic fashion
# @notice Information about what function does; shown when function to execute
# @dev Function documentation for developer

# Function parameter/return value natspec
# @param someParam Some description of what the param does
# @return Description of the return value

```

## Additional resources
- [Installation](https://vyper.readthedocs.io/en/latest/installing-vyper.html)
- [Vyper Docs](https://media.readthedocs.org/pdf/vyper/latest/vyper.pdf)
- [Vyper GitHub (under active dev)](https://github.com/ethereum/vyper)
- [Tools and Resources](https://github.com/ethereum/vyper/wiki/Vyper-tools-and-resources)
- [Online Compiler](https://vyper.online/)

## Sample contracts
- [Uniswap](https://github.com/Uniswap/contracts-vyper)
- [Generalized Governance](https://github.com/kpeluso/gdg)
- [Dynamic Arrays](https://github.com/kpeluso/vyper-dynamic-array)

## Security
Vyper is secure by design, but it may be helpful to understand what Vyper is
protecting you from.
- [Thinking About Smart Contract Security](https:#blog.ethereum.org/2016/06/19/thinking-smart-contract-security/)
- [Smart Contract Security](https:#blog.ethereum.org/2016/06/10/smart-contract-security/)
- [Hacking Distributed Blog](http:#hackingdistributed.com/)

## Style
- [Vyper Style Guide WIP](https://github.com/ethereum/vyper/issues/905)
  - Heavily derived from [Solidity's style guide](http:#solidity.readthedocs.io/en/latest/style-guide.html) ...
  - ... which, in turn, is heavily derived from Python's [PEP 8](https:#www.python.org/dev/peps/pep-0008/) style guide.

## Editors
- [Vyper for VS Code (alpha)](https://github.com/p-/vscode-vyper)

## Future To Dos
- Update to current Vyper release
- List of common design patterns

*Feel free to send a pull request with any edits - or email* `pelusoken -/at-/ gmail`"
"```
Module Module1

    Sub Main()
        'A Quick Overview of Visual Basic Console Applications before we dive
        'in to the deep end.
        'Apostrophe starts comments.
        'To Navigate this tutorial within the Visual Basic Compiler, I've put
        'together a navigation system.
        'This navigation system is explained however as we go deeper into this
        'tutorial, you'll understand what it all means.
        Console.Title = (""Learn X in Y Minutes"")
        Console.WriteLine(""NAVIGATION"") 'Display
        Console.WriteLine("""")
        Console.ForegroundColor = ConsoleColor.Green
        Console.WriteLine(""1. Hello World Output"")
        Console.WriteLine(""2. Hello World Input"")
        Console.WriteLine(""3. Calculating Whole Numbers"")
        Console.WriteLine(""4. Calculating Decimal Numbers"")
        Console.WriteLine(""5. Working Calculator"")
        Console.WriteLine(""6. Using Do While Loops"")
        Console.WriteLine(""7. Using For While Loops"")
        Console.WriteLine(""8. Conditional Statements"")
        Console.WriteLine(""9. Select A Drink"")
        Console.WriteLine(""50. About"")
        Console.WriteLine(""Please Choose A Number From The Above List"")
        Dim selection As String = Console.ReadLine
        'The ""Case"" in the Select statement is optional.
        'For example, ""Select selection"" instead of ""Select Case selection""
        'will also work.
        Select Case selection
            Case ""1"" 'HelloWorld Output
                Console.Clear() 'Clears the application and opens the private sub
                HelloWorldOutput() 'Name Private Sub, Opens Private Sub
            Case ""2"" 'Hello Input
                Console.Clear()
                HelloWorldInput()
            Case ""3"" 'Calculating Whole Numbers
                Console.Clear()
                CalculatingWholeNumbers()
            Case ""4"" 'Calculating Decimal Numbers
                Console.Clear()
                CalculatingDecimalNumbers()
            Case ""5"" 'Working Calculator
                Console.Clear()
                WorkingCalculator()
            Case ""6"" 'Using Do While Loops
                Console.Clear()
                UsingDoWhileLoops()
            Case ""7"" 'Using For While Loops
                Console.Clear()
                UsingForLoops()
            Case ""8"" 'Conditional Statements
                Console.Clear()
                ConditionalStatement()
            Case ""9"" 'If/Else Statement
                Console.Clear()
                IfElseStatement() 'Select a drink
            Case ""50"" 'About msg box
                Console.Clear()
                Console.Title = (""Learn X in Y Minutes :: About"")
                MsgBox(""This tutorial is by Brian Martin (@BrianMartinn"")
                Console.Clear()
                Main()
                Console.ReadLine()

        End Select
    End Sub

    'One - I'm using numbers to help with the above navigation when I come back
    'later to build it.

    'We use private subs to separate different sections of the program.
    Private Sub HelloWorldOutput()
        'Title of Console Application
        Console.Title = ""Hello World Output | Learn X in Y Minutes""
        'Use Console.Write("""") or Console.WriteLine("""") to print outputs.
        'Followed by Console.Read() alternatively Console.Readline()
        'Console.ReadLine() prints the output to the console.
        Console.WriteLine(""Hello World"")
        Console.ReadLine()
    End Sub

    'Two
    Private Sub HelloWorldInput()
        Console.Title = ""Hello World YourName | Learn X in Y Minutes""
        'Variables
        'Data entered by a user needs to be stored.
        'Variables also start with a Dim and end with an As VariableType.

        'In this tutorial, we want to know what your name, and make the program
        'respond to what is said.
        Dim username As String
        'We use string as string is a text based variable.
        Console.WriteLine(""Hello, What is your name? "") 'Ask the user their name.
        username = Console.ReadLine() 'Stores the users name.
        Console.WriteLine(""Hello "" + username) 'Output is Hello 'Their name'
        Console.ReadLine() 'Pauses the execution for user to read 
       
        'The above will ask you a question followed by printing your answer.
        'Other variables include Integer and we use Integer for whole numbers.
    End Sub

    'Three
    Private Sub CalculatingWholeNumbers()
        Console.Title = ""Calculating Whole Numbers | Learn X in Y Minutes""
        Console.Write(""First number: "") 'Enter a whole number, 1, 2, 50, 104, etc
        Dim a As Integer = Console.ReadLine()
        Console.Write(""Second number: "") 'Enter second whole number.
        Dim b As Integer = Console.ReadLine()
        Dim c As Integer = a + b
        Console.WriteLine(c)
        Console.ReadLine()
        'The above is a simple calculator
    End Sub

    'Four
    Private Sub CalculatingDecimalNumbers()
        Console.Title = ""Calculating with Double | Learn X in Y Minutes""
        'Of course we would like to be able to add up decimals.
        'Therefore we could change the above from Integer to Double.

        'Enter a floating-point number, 1.2, 2.4, 50.1, 104.9, etc
        Console.Write(""First number: "")
        Dim a As Double = Console.ReadLine
        Console.Write(""Second number: "") 'Enter second floating-point number.
        Dim b As Double = Console.ReadLine
        Dim c As Double = a + b
        Console.WriteLine(c)
        Console.ReadLine()
        'Therefore the above program can add up 1.1 - 2.2
    End Sub

    'Five
    Private Sub WorkingCalculator()
        Console.Title = ""The Working Calculator | Learn X in Y Minutes""
        'However if you'd like the calculator to subtract, divide, multiple and
        'add up.
        'Copy and paste the above again.
        Console.Write(""First number: "")
        Dim a As Double = Console.ReadLine
        Console.Write(""Second number: "") 'Enter second floating-point number.
        Dim b As Double = Console.ReadLine
        Dim c As Double = a + b
        Dim d As Double = a * b
        Dim e As Double = a - b
        Dim f As Double = a / b

        'By adding the below lines we are able to calculate the subtract,
        'multiply as well as divide the a and b values
        Console.Write(a.ToString() + "" + "" + b.ToString())
        'We want to pad the answers to the left by 3 spaces.
        Console.WriteLine("" = "" + c.ToString.PadLeft(3))
        Console.Write(a.ToString() + "" * "" + b.ToString())
        Console.WriteLine("" = "" + d.ToString.PadLeft(3))
        Console.Write(a.ToString() + "" - "" + b.ToString())
        Console.WriteLine("" = "" + e.ToString.PadLeft(3))
        Console.Write(a.ToString() + "" / "" + b.ToString())
        Console.WriteLine("" = "" + f.ToString.PadLeft(3))
        Console.ReadLine()

    End Sub

    'Six
    Private Sub UsingDoWhileLoops()
        'Just as the previous private sub
        'This Time We Ask If The User Wishes To Continue (Yes or No?)
        'We're using Do While Loop as we're unsure if the user wants to use the
        'program more than once.
        Console.Title = ""UsingDoWhileLoops | Learn X in Y Minutes""
        Dim answer As String 'We use the variable ""String"" as the answer is text
        Do 'We start the program with
            Console.Write(""First number: "")
            Dim a As Double = Console.ReadLine
            Console.Write(""Second number: "")
            Dim b As Double = Console.ReadLine
            Dim c As Double = a + b
            Dim d As Double = a * b
            Dim e As Double = a - b
            Dim f As Double = a / b

            Console.Write(a.ToString() + "" + "" + b.ToString())
            Console.WriteLine("" = "" + c.ToString.PadLeft(3))
            Console.Write(a.ToString() + "" * "" + b.ToString())
            Console.WriteLine("" = "" + d.ToString.PadLeft(3))
            Console.Write(a.ToString() + "" - "" + b.ToString())
            Console.WriteLine("" = "" + e.ToString.PadLeft(3))
            Console.Write(a.ToString() + "" / "" + b.ToString())
            Console.WriteLine("" = "" + f.ToString.PadLeft(3))
            Console.ReadLine()
            'Ask the question, does the user wish to continue? Unfortunately it
            'is case sensitive.
            Console.Write(""Would you like to continue? (yes / no) "")
            'The program grabs the variable and prints and starts again.
            answer = Console.ReadLine
            'The command for the variable to work would be in this case ""yes""
        Loop While answer = ""yes""

    End Sub

    'Seven
    Private Sub UsingForLoops()
        'Sometimes the program only needs to run once.
        'In this program we'll be counting down from 10.

        Console.Title = ""Using For Loops | Learn X in Y Minutes""
        'Declare Variable and what number it should count down in Step -1,
        'Step -2, Step -3, etc.
        For i As Integer = 10 To 0 Step -1
            Console.WriteLine(i.ToString) 'Print the value of the counter
        Next i 'Calculate new value
        Console.WriteLine(""Start"") 'Lets start the program baby!!
        Console.ReadLine() 'POW!! - Perhaps I got a little excited then :)
    End Sub

    'Eight
    Private Sub ConditionalStatement()
        Console.Title = ""Conditional Statements | Learn X in Y Minutes""
        Dim userName As String
        Console.WriteLine(""Hello, What is your name? "") 'Ask the user their name.
        userName = Console.ReadLine() 'Stores the users name.
        If userName = ""Adam"" Then
            Console.WriteLine(""Hello Adam"")
            Console.WriteLine(""Thanks for creating this useful site"")
            Console.ReadLine()
        Else
            Console.WriteLine(""Hello "" + userName)
            Console.WriteLine(""Have you checked out www.learnxinyminutes.com"")
            Console.ReadLine() 'Ends and prints the above statement.
        End If
    End Sub

    'Nine
    Private Sub IfElseStatement()
        Console.Title = ""If / Else Statement | Learn X in Y Minutes""
        'Sometimes it is important to consider more than two alternatives.
        'Sometimes there are a good few others.
        'When this is the case, more than one if statement would be required.
        'An if statement is great for vending machines. Where the user enters a code.
        'A1, A2, A3, etc to select an item.
        'All choices can be combined into a single if block.

        Dim selection As String 'Declare a variable for selection
        Console.WriteLine(""Please select a product form our lovely vending machine."")
        Console.WriteLine(""A1. for 7Up"")
        Console.WriteLine(""A2. for Fanta"")
        Console.WriteLine(""A3. for Dr. Pepper"")
        Console.WriteLine(""A4. for Diet Coke"")

        selection = Console.ReadLine() 'Store a selection from the user
        If selection = ""A1"" Then
            Console.WriteLine(""7up"")
        ElseIf selection = ""A2"" Then
            Console.WriteLine(""fanta"")
        ElseIf selection = ""A3"" Then
            Console.WriteLine(""dr. pepper"")
        ElseIf selection = ""A4"" Then
            Console.WriteLine(""diet coke"")
        Else
            Console.WriteLine(""Sorry, I don't have any "" + selection)
        End If
        Console.ReadLine()

    End Sub

End Module

```"
"p5.js is a JavaScript library that starts with the original goal of [Processing](https://processing.org), to make coding accessible for artists, designers, educators, and beginners, and reinterprets this for today's web.
Since p5 is a JavaScript library, you should learn [Javascript](https://learnxinyminutes.com/docs/javascript/) first.

```js
///////////////////////////////////
// p5.js has two important functions to work with.

function setup() {
    // the setup function gets executed just once when the window is loaded
}
function draw() {
    // the draw function gets called every single frame. This means that for a frameRate(30) it would get called 30 times per second.
}

// the following code explains all features

function setup() {
    createCanvas(640, 480); // creates a new canvas element with 640px as width as 480px as height
    background(128); // changes the background color of the canvas, can accept rgb values like background(100,200,20) else grayscale values like background(0) = black or background(255) = white
}

function draw() {
    ellipse(10, 10, 50, 50); // creates a ellipse at the 10px from the left and 10px from the top with width and height as 50 each, so its basically a circle.
    //remember in p5.js the origin is at the top-left corner of the canvas

    if (mouseIsPressed) {
        // mouseIsPressed is a boolean variable that changes to true if the mouse button is pressed down at that instant

        fill(0); // fill refers to the innner color or filling color of whatever shape you are going to draw next
    } else {
        fill(255); // you can give in rgb values like fill(72, 240, 80) to get colors, else a single values determines the grayscale where fill(255) stands for #FFF(white) and fill(0) stands for #000(black)
    }

    ellipse(mouseX, mouseY, 80, 80);
    // mouseX is the x-coordinate of the mouse's current position and mouseY is the y-coordinate of the mouse's current position

    // the above code creates a circle wherever mouse's current position and fills it either black or white based on the mouseIsPressed
}
```

## Further Reading

- [p5.js | get started](http://p5js.org/get-started/) The official documentation
- [Code! Programming for Beginners with p5.js - YouTube](https://www.youtube.com/watch?v=yPWkPOfnGsw&vl=en) Introduction and Coding challenges using Processing and p5.js by Coding Train"
"ColdFusion is a scripting language for web development.
[Read more here.](http://www.adobe.com/products/coldfusion-family.html)

### CFML
_**C**old**F**usion **M**arkup **L**anguage_  
ColdFusion started as a tag-based language. Almost all functionality is available using tags.

```cfm
<em>HTML tags have been provided for output readability</em>

<!--- Comments start with ""<!---"" and end with ""--->"" --->
<!---
    Comments can
    also
    span
    multiple lines
--->

<!--- CFML tags have a similar format to HTML tags. --->
<h1>Simple Variables</h1>
<!--- Variable Declaration: Variables are loosely typed, similar to javascript --->
<p>Set <b>myVariable</b> to ""myValue""</p>
<cfset myVariable = ""myValue"" />
<p>Set <b>myNumber</b> to 3.14</p>
<cfset myNumber = 3.14 />

<!--- Displaying simple data --->
<!--- Use <cfoutput> for simple values such as strings, numbers, and expressions --->
<p>Display <b>myVariable</b>: <cfoutput>#myVariable#</cfoutput></p><!--- myValue --->
<p>Display <b>myNumber</b>: <cfoutput>#myNumber#</cfoutput></p><!--- 3.14 --->

<hr />

<h1>Complex Variables</h1>
<!--- Declaring complex variables --->
<!--- Declaring an array of 1 dimension: literal or bracket notation --->
<p>Set <b>myArray1</b> to an array of 1 dimension using literal or bracket notation</p>
<cfset myArray1 = [] />
<!--- Declaring an array of 1 dimension: function notation --->
<p>Set <b>myArray2</b> to an array of 1 dimension using function notation</p>
<cfset myArray2 = ArrayNew(1) />

<!--- Outputting complex variables --->
<p>Contents of <b>myArray1</b></p>
<cfdump var=""#myArray1#"" /> <!--- An empty array object --->
<p>Contents of <b>myArray2</b></p>
<cfdump var=""#myArray2#"" /> <!--- An empty array object --->

<!--- Operators --->
<!--- Arithmetic --->
<h1>Operators</h1>
<h2>Arithmetic</h2>
<p>1 + 1 = <cfoutput>#1 + 1#</cfoutput></p>
<p>10 - 7 = <cfoutput>#10 - 7#<br /></cfoutput></p>
<p>15 * 10 = <cfoutput>#15 * 10#<br /></cfoutput></p>
<p>100 / 5 = <cfoutput>#100 / 5#<br /></cfoutput></p>
<p>120 % 5 = <cfoutput>#120 % 5#<br /></cfoutput></p>
<p>120 mod 5 = <cfoutput>#120 mod 5#<br /></cfoutput></p>

<hr />

<!--- Comparison --->
<h2>Comparison</h2>
<h3>Standard Notation</h3>
<p>Is 1 eq 1? <cfoutput>#1 eq 1#</cfoutput></p>
<p>Is 15 neq 1? <cfoutput>#15 neq 1#</cfoutput></p>
<p>Is 10 gt 8? <cfoutput>#10 gt 8#</cfoutput></p>
<p>Is 1 lt 2? <cfoutput>#1 lt 2#</cfoutput></p>
<p>Is 10 gte 5? <cfoutput>#10 gte 5#</cfoutput></p>
<p>Is 1 lte 5? <cfoutput>#1 lte 5#</cfoutput></p>

<h3>Alternative Notation</h3>
<p>Is 1 == 1? <cfoutput>#1 eq 1#</cfoutput></p>
<p>Is 15 != 1? <cfoutput>#15 neq 1#</cfoutput></p>
<p>Is 10 > 8? <cfoutput>#10 gt 8#</cfoutput></p>
<p>Is 1 < 2? <cfoutput>#1 lt 2#</cfoutput></p>
<p>Is 10 >= 5? <cfoutput>#10 gte 5#</cfoutput></p>
<p>Is 1 <= 5? <cfoutput>#1 lte 5#</cfoutput></p>

<hr />

<!--- Control Structures --->
<h1>Control Structures</h1>

<cfset myCondition = ""Test"" />

<p>Condition to test for: ""<cfoutput>#myCondition#</cfoutput>""</p>

<cfif myCondition eq ""Test"">
    <cfoutput>#myCondition#. We're testing.</cfoutput>
<cfelseif myCondition eq ""Production"">
    <cfoutput>#myCondition#. Proceed Carefully!!!</cfoutput>
<cfelse>
    myCondition is unknown
</cfif>

<hr />

<!--- Loops --->
<h1>Loops</h1>
<h2>For Loop</h2>
<cfloop from=""0"" to=""10"" index=""i"">
	<p>Index equals <cfoutput>#i#</cfoutput></p>
</cfloop>

<h2>For Each Loop (Complex Variables)</h2>

<p>Set <b>myArray3</b> to [5, 15, 99, 45, 100]</p>

<cfset myArray3 = [5, 15, 99, 45, 100] />

<cfloop array=""#myArray3#"" index=""i"">
	<p>Index equals <cfoutput>#i#</cfoutput></p>
</cfloop>

<p>Set <b>myArray4</b> to [""Alpha"", ""Bravo"", ""Charlie"", ""Delta"", ""Echo""]</p>

<cfset myArray4 = [""Alpha"", ""Bravo"", ""Charlie"", ""Delta"", ""Echo""] />

<cfloop array=""#myArray4#"" index=""s"">
	<p>Index equals <cfoutput>#s#</cfoutput></p>
</cfloop>

<h2>Switch Statement</h2>

<p>Set <b>myArray5</b> to [5, 15, 99, 45, 100]</p>

<cfset myArray5 = [5, 15, 99, 45, 100] />

<cfloop array=""#myArray5#"" index=""i"">
	<cfswitch expression=""#i#"">
		<cfcase value=""5,15,45"" delimiters="","">
			<p><cfoutput>#i#</cfoutput> is a multiple of 5.</p>
		</cfcase>
		<cfcase value=""99"">
			<p><cfoutput>#i#</cfoutput> is ninety-nine.</p>
		</cfcase>
		<cfdefaultcase>
			<p><cfoutput>#i#</cfoutput> is not 5, 15, 45, or 99.</p>
		</cfdefaultcase> 
	</cfswitch> 
</cfloop>

<hr />

<h1>Converting types</h1>

<style>
	table.table th, table.table td {
		border: 1px solid #000000;
		padding: 2px;
	}
	
	table.table th {
		background-color: #CCCCCC;
	}
</style>

<table class=""table"" cellspacing=""0"">
	<thead>
		<tr>
			<th>Value</th>
			<th>As Boolean</th>
			<th>As number</th>
			<th>As date-time</th>
			<th>As string</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>""Yes""</th>
			<td>TRUE</td>
			<td>1</td>
			<td>Error</td>
			<td>""Yes""</td>
		</tr>
		<tr>
			<th>""No""</th>
			<td>FALSE</td>
			<td>0</td>
			<td>Error</td>
			<td>""No""</td>
		</tr>
		<tr>
			<th>TRUE</th>
			<td>TRUE</td>
			<td>1</td>
			<td>Error</td>
			<td>""Yes""</td>
		</tr>
		<tr>
			<th>FALSE</th>
			<td>FALSE</td>
			<td>0</td>
			<td>Error</td>
			<td>""No""</td>
		</tr>
		<tr>
			<th>Number</th>
			<td>True if Number is not 0; False otherwise.</td>
			<td>Number</td>
			<td>See &#34;Date-time values&#34; earlier in this chapter.</td>
			<td>String representation of the number (for example, &#34;8&#34;).</td>
		</tr>
		<tr>
			<th>String</th>
			<td>If ""Yes"", True <br>If ""No"", False <br>If it can be converted to 0, False <br>If it can be converted to any other number, True</td>
			<td>If it represents a number (for example, &#34;1,000&#34; or &#34;12.36E-12&#34;), it is converted to the corresponding number.</td>
			<td>If it represents a date-time (see next column), it is converted to the numeric value of the corresponding date-time object. <br>If it is an ODBC date, time, or timestamp (for example &#34;{ts &#39;2001-06-14 11:30:13&#39;}&#34;, or if it is expressed in a standard U.S. date or time format, including the use of full or abbreviated month names, it is converted to the corresponding date-time value. <br>Days of the week or unusual punctuation result in an error. <br>Dashes, forward-slashes, and spaces are generally allowed.</td>
			<td>String</td>
		</tr>
		<tr>
			<th>Date</th>
			<td>Error</td>
			<td>The numeric value of the date-time object.</td>
			<td>Date</td>
			<td>An ODBC timestamp.</td>
		</tr>
	</tbody>
</table>

<hr />

<h1>Components</h1>

<em>Code for reference (Functions must return something to support IE)</em>
```
```cfs
<cfcomponent>
	<cfset this.hello = ""Hello"" />
	<cfset this.world = ""world"" />

	<cffunction name=""sayHello"">
		<cfreturn this.hello & "", "" & this.world & ""!"" />
	</cffunction>
	
	<cffunction name=""setHello"">
		<cfargument name=""newHello"" type=""string"" required=""true"" />
		
		<cfset this.hello = arguments.newHello />
		 
		<cfreturn true />
	</cffunction>
	
	<cffunction name=""setWorld"">
		<cfargument name=""newWorld"" type=""string"" required=""true"" />
		
		<cfset this.world = arguments.newWorld />
		 
		<cfreturn true />
	</cffunction>
	
	<cffunction name=""getHello"">
		<cfreturn this.hello />
	</cffunction>
	
	<cffunction name=""getWorld"">
		<cfreturn this.world />
	</cffunction>
</cfcomponent>

<cfset this.hello = ""Hello"" />
<cfset this.world = ""world"" />

<cffunction name=""sayHello"">
	<cfreturn this.hello & "", "" & this.world & ""!"" />
</cffunction>

<cffunction name=""setHello"">
	<cfargument name=""newHello"" type=""string"" required=""true"" />
	
	<cfset this.hello = arguments.newHello />
	 
	<cfreturn true />
</cffunction>

<cffunction name=""setWorld"">
	<cfargument name=""newWorld"" type=""string"" required=""true"" />
	
	<cfset this.world = arguments.newWorld />
	 
	<cfreturn true />
</cffunction>

<cffunction name=""getHello"">
	<cfreturn this.hello />
</cffunction>

<cffunction name=""getWorld"">
	<cfreturn this.world />
</cffunction>


<b>sayHello()</b>
<cfoutput><p>#sayHello()#</p></cfoutput>
<b>getHello()</b>
<cfoutput><p>#getHello()#</p></cfoutput>
<b>getWorld()</b>
<cfoutput><p>#getWorld()#</p></cfoutput>
<b>setHello(""Hola"")</b>
<cfoutput><p>#setHello(""Hola"")#</p></cfoutput>
<b>setWorld(""mundo"")</b>
<cfoutput><p>#setWorld(""mundo"")#</p></cfoutput>
<b>sayHello()</b>
<cfoutput><p>#sayHello()#</p></cfoutput>
<b>getHello()</b>
<cfoutput><p>#getHello()#</p></cfoutput>
<b>getWorld()</b>
<cfoutput><p>#getWorld()#</p></cfoutput>
```

### CFScript
_**C**old**F**usion **S**cript_  
In recent years, the ColdFusion language has added script syntax to mirror tag functionality. When using an up-to-date CF server, almost all functionality is available using scrypt syntax.

## Further Reading

The links provided here below are just to get an understanding of the topic, feel free to Google and find specific examples.

1. [Coldfusion Reference From Adobe](https://helpx.adobe.com/coldfusion/cfml-reference/topics.html)
2. [Open Source Documentation](http://cfdocs.org/)"
"MoonScript is a dynamic scripting language that compiles into Lua. It gives
you the power of one of the fastest scripting languages combined with a
rich set of features.

See [the MoonScript website](https://moonscript.org/) to see official guides on installation for all platforms.

```moon
-- Two dashes start a comment. Comments can go until the end of the line.
-- MoonScript transpiled to Lua does not keep comments.

-- As a note, MoonScript does not use 'do', 'then', or 'end' like Lua would and
-- instead uses an indented syntax, much like Python.

--------------------------------------------------
-- 1. Assignment
--------------------------------------------------

hello = ""world""
a, b, c = 1, 2, 3
hello = 123 -- Overwrites `hello` from above.

x = 0
x += 10 -- x = x + 10

s = ""hello ""
s ..= ""world"" -- s = s .. ""world""

b = false
b and= true or false -- b = b and (true or false)

--------------------------------------------------
-- 2. Literals and Operators
--------------------------------------------------

-- Literals work almost exactly as they would in Lua. Strings can be broken in
-- the middle of a line without requiring a \.

some_string = ""exa
mple"" -- local some_string = ""exa\nmple""

-- Strings can also have interpolated values, or values that are evaluated and
-- then placed inside of a string.

some_string = ""This is an #{some_string}"" -- Becomes 'This is an exa\nmple'

--------------------------------------------------
-- 2.1. Function Literals
--------------------------------------------------

-- Functions are written using arrows:

my_function = -> -- compiles to `function() end`
my_function() -- calls an empty function

-- Functions can be called without using parenthesis. Parentheses may still be
-- used to have priority over other functions.

func_a = -> print ""Hello World!""
func_b = ->
	value = 100
	print ""The value: #{value}""

-- If a function needs no parameters, it can be called with either `()` or `!`.

func_a!
func_b()

-- Functions can use arguments by preceding the arrow with a list of argument
-- names bound by parentheses.

sum = (x, y)-> x + y -- The last expression is returned from the function.
print sum(5, 10)

-- Lua has an idiom of sending the first argument to a function as the object,
-- like a 'self' object. Using a fat arrow (=>) instead of a skinny arrow (->)
-- automatically creates a `self` variable. `@x` is a shorthand for `self.x`.

func = (num)=> @value + num

-- Default arguments can also be used with function literals:

a_function = (name = ""something"", height=100)->
	print ""Hello, I am #{name}.\nMy height is #{height}.""

-- Because default arguments are calculated in the body of the function when
-- transpiled to Lua, you can reference previous arguments.

some_args = (x = 100, y = x + 1000)-> print(x + y)

--------------------------------------------------
-- Considerations
--------------------------------------------------

-- The minus sign plays two roles, a unary negation operator and a binary
-- subtraction operator. It is recommended to always use spaces between binary
-- operators to avoid the possible collision.

a = x - 10 --  a = x - 10
b = x-10 -- b = x - 10
c = x -y -- c = x(-y)
d = x- z -- d = x - z

-- When there is no space between a variable and string literal, the function
-- call takes priority over following expressions:

x = func""hello"" + 100 -- func(""hello"") + 100
y = func ""hello"" + 100 -- func(""hello"" + 100)

-- Arguments to a function can span across multiple lines as long as the
-- arguments are indented. The indentation can be nested as well.

my_func 5, -- called as my_func(5, 8, another_func(6, 7, 9, 1, 2), 5, 4)
	8, another_func 6, 7, -- called as
		9, 1, 2,		  -- another_func(6, 7, 9, 1, 2)
	5, 4

-- If a function is used at the start of a block, the indentation can be
-- different than the level of indentation used in a block:

if func 1, 2, 3, -- called as func(1, 2, 3, ""hello"", ""world"")
		""hello"",
		""world""
	print ""hello""

--------------------------------------------------
-- 3. Tables
--------------------------------------------------

-- Tables are defined by curly braces, like Lua:

some_values = {1, 2, 3, 4}

-- Tables can use newlines instead of commas.

some_other_values = {
	5, 6
	7, 8
}

-- Assignment is done with `:` instead of `=`:

profile = {
	name: ""Bill""
	age: 200
	""favorite food"": ""rice""
}

-- Curly braces can be left off for `key: value` tables.

y = type: ""dog"", legs: 4, tails: 1

profile =
	height: ""4 feet"",
	shoe_size: 13,
	favorite_foods: -- nested table
		foo: ""ice cream"", 
		bar: ""donuts""

my_function dance: ""Tango"", partner: ""none"" -- :( forever alone

-- Tables constructed from variables can use the same name as the variables
-- by using `:` as a prefix operator.

hair = ""golden""
height = 200
person = {:hair, :height}

-- Like in Lua, keys can be non-string or non-numeric values by using `[]`.

t =
	[1 + 2]: ""hello""
	""hello world"": true -- Can use string literals without `[]`.

--------------------------------------------------
-- 3.1. Table Comprehensions
--------------------------------------------------

-- List Comprehensions

-- Creates a copy of a list but with all items doubled. Using a star before a
-- variable name or table can be used to iterate through the table's values.

items = {1, 2, 3, 4}
doubled = [item * 2 for item in *items]
-- Uses `when` to determine if a value should be included.

slice = [item for item in *items when item > 1 and item < 3]

-- `for` clauses inside of list comprehensions can be chained.

x_coords = {4, 5, 6, 7}
y_coords = {9, 2, 3}

points = [{x,y} for x in *x_coords for y in *y_coords]

-- Numeric for loops can also be used in comprehensions:

evens = [i for i=1, 100 when i % 2 == 0]

-- Table Comprehensions are very similar but use `{` and `}` and take two
-- values for each iteration.

thing = color: ""red"", name: ""thing"", width: 123
thing_copy = {k, v for k, v in pairs thing}

-- Tables can be ""flattened"" from key-value pairs in an array by using `unpack`
-- to return both values, using the first as the key and the second as the
-- value.

tuples = {{""hello"", ""world""}, {""foo"", ""bar""}}
table = {unpack tuple for tuple in *tuples}

-- Slicing can be done to iterate over only a certain section of an array. It
-- uses the `*` notation for iterating but appends `[start, end, step]`.

-- The next example also shows that this syntax can be used in a `for` loop as
-- well as any comprehensions.

for item in *points[1, 10, 2]
	print unpack item

-- Any undesired values can be left off. The second comma is not required if
-- the step is not included.

words = {""these"", ""are"", ""some"", ""words""}
for word in *words[,3] 
	print word

--------------------------------------------------
-- 4. Control Structures
--------------------------------------------------

have_coins = false
if have_coins
	print ""Got coins""
else
	print ""No coins""

-- Use `then` for single-line `if`
if have_coins then ""Got coins"" else ""No coins""

-- `unless` is the opposite of `if`
unless os.date(""%A"") == ""Monday""
	print ""It is not Monday!""

-- `if` and `unless` can be used as expressions
is_tall = (name)-> if name == ""Rob"" then true else false
message = ""I am #{if is_tall ""Rob"" then ""very tall"" else ""not so tall""}""
print message -- ""I am very tall""

-- `if`, `elseif`, and `unless` can evaluate assignment as well as expressions.
if x = possibly_nil! -- sets `x` to `possibly_nil()` and evaluates `x`
	print x

-- Conditionals can be used after a statement as well as before. This is
-- called a ""line decorator"".

is_monday = os.date(""%A"") == ""Monday""
print(""It IS Monday!"") if isMonday
print(""It is not Monday.."") unless isMonday
--print(""It IS Monday!"" if isMonday) -- Not a statement, does not work

--------------------------------------------------
-- 4.1 Loops
--------------------------------------------------

for i = 1, 10
	print i

for i = 10, 1, -1 do print i -- Use `do` for single-line loops.

i = 0
while i < 10
	continue if i % 2 == 0 -- Continue statement; skip the rest of the loop.
	print i

-- Loops can be used as a line decorator, just like conditionals
print ""item: #{item}"" for item in *items

-- Using loops as an expression generates an array table. The last statement
-- in the block is coerced into an expression and added to the table.
my_numbers = for i = 1, 6 do i -- {1, 2, 3, 4, 5, 6}

-- use `continue` to filter out values
odds = for i in *my_numbers
	continue if i % 2 == 0 -- acts opposite to `when` in comprehensions!
	i -- Only added to return table if odd

-- A `for` loop returns `nil` when it is the last statement of a function
-- Use an explicit `return` to generate a table.
print_squared = (t) -> for x in *t do x*x -- returns `nil`
squared = (t) -> return for x in *t do x*x -- returns new table of squares

-- The following does the same as `(t) -> [i for i in *t when i % 2 == 0]`
-- But list comprehension generates better code and is more readable!

filter_odds = (t) -> 
	return for x in *t
		if x % 2 == 0 then x else continue
evens = filter_odds(my_numbers) -- {2, 4, 6}

--------------------------------------------------
-- 4.2 Switch Statements
--------------------------------------------------

-- Switch statements are a shorthand way of writing multiple `if` statements
-- checking against the same value. The value is only evaluated once.

name = ""Dan""

switch name
	when ""Dave""
		print ""You are Dave.""
	when ""Dan""
		print ""You are not Dave, but Dan.""
	else
		print ""You are neither Dave nor Dan.""

-- Switches can also be used as expressions, as well as compare multiple
-- values. The values can be on the same line as the `when` clause if they
-- are only one expression.

b = 4
next_even = switch b
	when 1 then 2
	when 2, 3 then 4
	when 4, 5 then 6
	else error ""I can't count that high! D:""

--------------------------------------------------
-- 5. Object Oriented Programming
--------------------------------------------------

-- Classes are created using the `class` keyword followed by an identifier,
-- typically written using CamelCase. Values specific to a class can use @ as
-- the identifier instead of `self.value`.

class Inventory
	new: => @items = {}
	add_item: (name)=> -- note the use of fat arrow for classes!
		@items[name] = 0 unless @items[name]
		@items[name] += 1

-- The `new` function inside of a class is special because it is called when
-- an instance of the class is created.

-- Creating an instance of the class is as simple as calling the class as a
-- function. Calling functions inside of the class uses \ to separate the
-- instance from the function it is calling.

inv = Inventory!
inv\add_item ""t-shirt""
inv\add_item ""pants""

-- Values defined in the class - not the new() function - will be shared across
-- all instances of the class.

class Person
	clothes: {}
	give_item: (name)=>
		table.insert @clothes name

a = Person!
b = Person!

a\give_item ""pants""
b\give_item ""shirt""

-- prints out both ""pants"" and ""shirt""

print item for item in *a.clothes

-- Class instances have a value `.__class` that are equal to the class object
-- that created the instance.

assert(b.__class == Person)

-- Variables declared in class body the using the `=` operator are locals,
-- so these ""private"" variables are only accessible within the current scope.

class SomeClass
	x = 0
	reveal: ->
		x += 1
		print x

a = SomeClass!
b = SomeClass!
print a.x -- nil
a.reveal! -- 1
b.reveal! -- 2

--------------------------------------------------
-- 5.1 Inheritance
--------------------------------------------------

-- The `extends` keyword can be used to inherit properties and methods from
-- another class.

class Backpack extends Inventory
	size: 10
	add_item: (name)=>
		error ""backpack is full"" if #@items > @size
		super name -- calls Inventory.add_item with `name`.

-- Because a `new` method was not added, the `new` method from `Inventory` will
-- be used instead. If we did want to use a constructor while still using the
-- constructor from `Inventory`, we could use the magical `super` function
-- during `new()`.

-- When a class extends another, it calls the method `__inherited` on the 
-- parent class (if it exists). It is always called with the parent and the
-- child object.

class ParentClass
	@__inherited: (child)=>
		print ""#{@__name} was inherited by #{child.__name}""
	a_method: (a, b) => print a .. ' ' .. b

-- Will print 'ParentClass was inherited by MyClass'

class MyClass extends ParentClass
	a_method: =>
		super ""hello world"", ""from MyClass!"" 
		assert super == ParentClass

--------------------------------------------------
-- 6. Scope
--------------------------------------------------

-- All values are local by default. The `export` keyword can be used to
-- declare the variable as a global value.

export var_1, var_2
var_1, var_3 = ""hello"", ""world"" -- var_3 is local, var_1 is not.

export this_is_global_assignment = ""Hi!""

-- Classes can also be prefixed with `export` to make them global classes.
-- Alternatively, all CamelCase variables can be exported automatically using
-- `export ^`, and all values can be exported using `export *`.

-- `do` lets you manually create a scope, for when you need local variables.

do
	x = 5
print x -- nil

-- Here we use `do` as an expression to create a closure.

counter = do 
	i = 0
	->
		i += 1
		return i

print counter!  -- 1
print counter!  -- 2

-- The `local` keyword can be used to define variables
-- before they are assigned.

local var_4
if something
	var_4 = 1
print var_4 -- works because `var_4` was set in this scope, not the `if` scope.

-- The `local` keyword can also be used to shadow an existing variable.

x = 10
if false
	local x
	x = 12
print x -- 10

-- Use `local *` to forward-declare all variables. 
-- Alternatively, use `local ^` to forward-declare all CamelCase values.

local *

first = ->
	second!

second = ->
	print data

data = {}

--------------------------------------------------
-- 6.1 Import
--------------------------------------------------

-- Values from a table can be brought to the current scope using the `import`
-- and `from` keyword. Names in the `import` list can be preceded by `\` if
-- they are a module function.

import insert from table -- local insert = table.insert
import \add from state: 100, add: (value)=> @state + value
print add 22

-- Like tables, commas can be excluded from `import` lists to allow for longer
-- lists of imported items.

import
	asdf, gh, jkl
	antidisestablishmentarianism
	from {}

--------------------------------------------------
-- 6.2 With
--------------------------------------------------

-- The `with` statement can be used to quickly call and assign values in an
-- instance of a class or object.

file = with File ""lmsi15m.moon"" -- `file` is the value of `set_encoding()`.
	\set_encoding ""utf8""

create_person = (name, relatives)->
	with Person!
		.name = name
		\add_relative relative for relative in *relatives
me = create_person ""Ryan"", {""sister"", ""sister"", ""brother"", ""dad"", ""mother""}

with str = ""Hello"" -- assignment as expression! :D
	print ""original: #{str}""
	print ""upper: #{\upper!}""

--------------------------------------------------
-- 6.3 Destructuring
--------------------------------------------------

-- Destructuring can take arrays, tables, and nested tables and convert them
-- into local variables.

obj2 =
	numbers: {1, 2, 3, 4}
	properties:
		color: ""green""
		height: 13.5

{numbers: {first, second}, properties: {:color}} = obj2

print first, second, color -- 1 2 green

-- `first` and `second` return [1] and [2] because they are as an array, but
-- `:color` is like `color: color` so it sets itself to the `color` value.

-- Destructuring can be used in place of `import`.

{:max, :min, random: rand} = math -- rename math.random to rand

-- Destructuring can be done anywhere assignment can be done.

for {left, right} in *{{""hello"", ""world""}, {""egg"", ""head""}}
	print left, right
```

## Additional Resources

- [Language Guide](https://moonscript.org/reference/)
- [Online Compiler](https://moonscript.org/compiler/)"
"You can read all about Chapel at [Cray's official Chapel website](https://chapel-lang.org).
In short, Chapel is an open-source, high-productivity, parallel-programming
language in development at Cray Inc., and is designed to run on multi-core PCs
as well as multi-kilocore supercomputers.

More information and support can be found at the bottom of this document.

```chapel
// Comments are C-family style

// one line comment
/*
 multi-line comment
*/

// Basic printing

write(""Hello, "");
writeln(""World!"");

// write and writeln can take a list of things to print.
// Each thing is printed right next to the others, so include your spacing!
writeln(""There are "", 3, "" commas (\"",\"") in this line of code"");

// Different output channels:
stdout.writeln(""This goes to standard output, just like plain writeln() does"");
stderr.writeln(""This goes to standard error"");


// Variables don't have to be explicitly typed as long as
// the compiler can figure out the type that it will hold.
// 10 is an int, so myVar is implicitly an int
var myVar = 10;
myVar = -10;
var mySecondVar = myVar;
// var anError; would be a compile-time error.

// We can (and should) explicitly type things.
var myThirdVar: real;
var myFourthVar: real = -1.234;
myThirdVar = myFourthVar;

// Types

// There are a number of basic types.
var myInt: int = -1000; // Signed ints
var myUint: uint = 1234; // Unsigned ints
var myReal: real = 9.876; // Floating point numbers
var myImag: imag = 5.0i; // Imaginary numbers
var myCplx: complex = 10 + 9i; // Complex numbers
myCplx = myInt + myImag; // Another way to form complex numbers
var myBool: bool = false; // Booleans
var myStr: string = ""Some string...""; // Strings
var singleQuoteStr = 'Another string...'; // String literal with single quotes

// Some types can have sizes.
var my8Int: int(8) = 10; // 8 bit (one byte) sized int;
var my64Real: real(64) = 1.516; // 64 bit (8 bytes) sized real

// Typecasting.
var intFromReal = myReal : int;
var intFromReal2: int = myReal : int;

// Type aliasing.
type chroma = int;        // Type of a single hue
type RGBColor = 3*chroma; // Type representing a full color
var black: RGBColor = (0,0,0);
var white: RGBColor = (255, 255, 255);

// Constants and Parameters

// A const is a constant, and cannot be changed after set in runtime.
const almostPi: real = 22.0/7.0;

// A param is a constant whose value must be known statically at
// compile-time.
param compileTimeConst: int = 16;

// The config modifier allows values to be set at the command line.
// Set with --varCmdLineArg=Value or --varCmdLineArg Value at runtime.
config var varCmdLineArg: int = -123;
config const constCmdLineArg: int = 777;

// config param can be set at compile-time.
// Set with --set paramCmdLineArg=value at compile-time.
config param paramCmdLineArg: bool = false;
writeln(varCmdLineArg, "", "", constCmdLineArg, "", "", paramCmdLineArg);

// References

// ref operates much like a reference in C++. In Chapel, a ref cannot
// be made to alias a variable other than the variable it is initialized with.
// Here, refToActual refers to actual.
var actual = 10;
ref refToActual = actual;
writeln(actual, "" == "", refToActual); // prints the same value
actual = -123; // modify actual (which refToActual refers to)
writeln(actual, "" == "", refToActual); // prints the same value
refToActual = 99999999; // modify what refToActual refers to (which is actual)
writeln(actual, "" == "", refToActual); // prints the same value

// Operators

// Math operators:
var a: int, thisInt = 1234, thatInt = 5678;
a = thisInt + thatInt;  // Addition
a = thisInt * thatInt;  // Multiplication
a = thisInt - thatInt;  // Subtraction
a = thisInt / thatInt;  // Division
a = thisInt ** thatInt; // Exponentiation
a = thisInt % thatInt;  // Remainder (modulo)

// Logical operators:
var b: bool, thisBool = false, thatBool = true;
b = thisBool && thatBool; // Logical and
b = thisBool || thatBool; // Logical or
b = !thisBool;            // Logical negation

// Relational operators:
b = thisInt > thatInt;           // Greater-than
b = thisInt >= thatInt;          // Greater-than-or-equal-to
b = thisInt < a && a <= thatInt; // Less-than, and, less-than-or-equal-to
b = thisInt != thatInt;          // Not-equal-to
b = thisInt == thatInt;          // Equal-to

// Bitwise operators:
a = thisInt << 10;     // Left-bit-shift by 10 bits;
a = thatInt >> 5;      // Right-bit-shift by 5 bits;
a = ~thisInt;          // Bitwise-negation
a = thisInt ^ thatInt; // Bitwise exclusive-or

// Compound assignment operators:
a += thisInt;          // Addition-equals (a = a + thisInt;)
a *= thatInt;          // Times-equals (a = a * thatInt;)
b &&= thatBool;        // Logical-and-equals (b = b && thatBool;)
a <<= 3;               // Left-bit-shift-equals (a = a << 10;)

// Unlike other C family languages, there are no
// pre/post-increment/decrement operators, such as:
//
// ++j, --j, j++, j--

// Swap operator:
var old_this = thisInt;
var old_that = thatInt;
thisInt <=> thatInt; // Swap the values of thisInt and thatInt
writeln((old_this == thatInt) && (old_that == thisInt));

// Operator overloads can also be defined, as we'll see with procedures.

// Tuples

// Tuples can be of the same type or different types.
var sameTup: 2*int = (10, -1);
var sameTup2 = (11, -6);
var diffTup: (int,real,complex) = (5, 1.928, myCplx);
var diffTupe2 = (7, 5.64, 6.0+1.5i);

// Tuples can be accessed using square brackets or parentheses, and are
// 1-indexed.
writeln(""("", sameTup[1], "","", sameTup(2), "")"");
writeln(diffTup);

// Tuples can also be written into.
diffTup(1) = -1;

// Tuple values can be expanded into their own variables.
var (tupInt, tupReal, tupCplx) = diffTup;
writeln(diffTup == (tupInt, tupReal, tupCplx));

// They are also useful for writing a list of variables, as is common in debugging.
writeln((a,b,thisInt,thatInt,thisBool,thatBool));

// Control Flow

// if - then - else works just like any other C-family language.
if 10 < 100 then
  writeln(""All is well"");

if -1 < 1 then
  writeln(""Continuing to believe reality"");
else
  writeln(""Send mathematician, something is wrong"");

// You can use parentheses if you prefer.
if (10 > 100) {
  writeln(""Universe broken. Please reboot universe."");
}

if a % 2 == 0 {
  writeln(a, "" is even."");
} else {
  writeln(a, "" is odd."");
}

if a % 3 == 0 {
  writeln(a, "" is even divisible by 3."");
} else if a % 3 == 1 {
  writeln(a, "" is divided by 3 with a remainder of 1."");
} else {
  writeln(b, "" is divided by 3 with a remainder of 2."");
}

// Ternary: if - then - else in a statement.
var maximum = if thisInt < thatInt then thatInt else thisInt;

// select statements are much like switch statements in other languages.
// However, select statements do not cascade like in C or Java.
var inputOption = ""anOption"";
select inputOption {
  when ""anOption"" do writeln(""Chose 'anOption'"");
  when ""otherOption"" {
    writeln(""Chose 'otherOption'"");
    writeln(""Which has a body"");
  }
  otherwise {
    writeln(""Any other Input"");
    writeln(""the otherwise case does not need a do if the body is one line"");
  }
}

// while and do-while loops also behave like their C counterparts.
var j: int = 1;
var jSum: int = 0;
while (j <= 1000) {
  jSum += j;
  j += 1;
}
writeln(jSum);

do {
  jSum += j;
  j += 1;
} while (j <= 10000);
writeln(jSum);

// for loops are much like those in Python in that they iterate over a
// range. Ranges (like the 1..10 expression below) are a first-class object
// in Chapel, and as such can be stored in variables.
for i in 1..10 do write(i, "", "");
writeln();

var iSum: int = 0;
for i in 1..1000 {
  iSum += i;
}
writeln(iSum);

for x in 1..10 {
  for y in 1..10 {
    write((x,y), ""\t"");
  }
  writeln();
}

// Ranges and Domains

// For-loops and arrays both use ranges and domains to define an index set that
// can be iterated over. Ranges are single dimensional integer indices, while
// domains can be multi-dimensional and represent indices of different types.

// They are first-class citizen types, and can be assigned into variables.
var range1to10: range = 1..10;  // 1, 2, 3, ..., 10
var range2to11 = 2..11; // 2, 3, 4, ..., 11
var rangeThisToThat: range = thisInt..thatInt; // using variables
var rangeEmpty: range = 100..-100; // this is valid but contains no indices

// Ranges can be unbounded.
var range1toInf: range(boundedType=BoundedRangeType.boundedLow) = 1.. ; // 1, 2, 3, 4, 5, ...
var rangeNegInfTo1 = ..1; // ..., -4, -3, -2, -1, 0, 1

// Ranges can be strided (and reversed) using the by operator.
var range2to10by2: range(stridable=true) = 2..10 by 2; // 2, 4, 6, 8, 10
var reverse2to10by2 = 2..10 by -2; // 10, 8, 6, 4, 2

var trapRange = 10..1 by -1; // Do not be fooled, this is still an empty range
writeln(""Size of range "", trapRange, "" = "", trapRange.length);

// Note: range(boundedType= ...) and range(stridable= ...) are only
// necessary if we explicitly type the variable.

// The end point of a range can be determined using the count (#) operator.
var rangeCount: range = -5..#12; // range from -5 to 6

// Operators can be mixed.
var rangeCountBy: range(stridable=true) = -5..#12 by 2; // -5, -3, -1, 1, 3, 5
writeln(rangeCountBy);

// Properties of the range can be queried.
// In this example, printing the first index, last index, number of indices,
// stride, and if 2 is include in the range.
writeln((rangeCountBy.first, rangeCountBy.last, rangeCountBy.length,
           rangeCountBy.stride, rangeCountBy.member(2)));

for i in rangeCountBy {
  write(i, if i == rangeCountBy.last then ""\n"" else "", "");
}

// Rectangular domains are defined using the same range syntax,
// but they are required to be bounded (unlike ranges).
var domain1to10: domain(1) = {1..10};        // 1D domain from 1..10;
var twoDimensions: domain(2) = {-2..2,0..2}; // 2D domain over product of ranges
var thirdDim: range = 1..16;
var threeDims: domain(3) = {thirdDim, 1..10, 5..10}; // using a range variable

// Domains can also be resized
var resizedDom = {1..10};
writeln(""before, resizedDom = "", resizedDom);
resizedDom = {-10..#10};
writeln(""after, resizedDom = "", resizedDom);

// Indices can be iterated over as tuples.
for idx in twoDimensions do
  write(idx, "", "");
writeln();

// These tuples can also be deconstructed.
for (x,y) in twoDimensions {
  write(""("", x, "", "", y, "")"", "", "");
}
writeln();

// Associative domains act like sets.
var stringSet: domain(string); // empty set of strings
stringSet += ""a"";
stringSet += ""b"";
stringSet += ""c"";
stringSet += ""a""; // Redundant add ""a""
stringSet -= ""c""; // Remove ""c""
writeln(stringSet.sorted());

// Associative domains can also have a literal syntax
var intSet = {1, 2, 4, 5, 100};

// Both ranges and domains can be sliced to produce a range or domain with the
// intersection of indices.
var rangeA = 1.. ; // range from 1 to infinity
var rangeB =  ..5; // range from negative infinity to 5
var rangeC = rangeA[rangeB]; // resulting range is 1..5
writeln((rangeA, rangeB, rangeC));

var domainA = {1..10, 5..20};
var domainB = {-5..5, 1..10};
var domainC = domainA[domainB];
writeln((domainA, domainB, domainC));

// Arrays

// Arrays are similar to those of other languages.
// Their sizes are defined using domains that represent their indices.
var intArray: [1..10] int;
var intArray2: [{1..10}] int; // equivalent

// They can be accessed using either brackets or parentheses
for i in 1..10 do
  intArray[i] = -i;
writeln(intArray);

// We cannot access intArray[0] because it exists outside
// of the index set, {1..10}, we defined it to have.
// intArray[11] is illegal for the same reason.
var realDomain: domain(2) = {1..5,1..7};
var realArray: [realDomain] real;
var realArray2: [1..5,1..7] real;   // equivalent
var realArray3: [{1..5,1..7}] real; // equivalent

for i in 1..5 {
  for j in realDomain.dim(2) {   // Only use the 2nd dimension of the domain
    realArray[i,j] = -1.61803 * i + 0.5 * j;  // Access using index list
    var idx: 2*int = (i,j);                   // Note: 'index' is a keyword
    realArray[idx] = - realArray[(i,j)];      // Index using tuples
  }
}

// Arrays have domains as members, and can be iterated over as normal.
for idx in realArray.domain {  // Again, idx is a 2*int tuple
  realArray[idx] = 1 / realArray[idx[1], idx[2]]; // Access by tuple and list
}

writeln(realArray);

// The values of an array can also be iterated directly.
var rSum: real = 0;
for value in realArray {
  rSum += value; // Read a value
  value = rSum;  // Write a value
}
writeln(rSum, ""\n"", realArray);

// Associative arrays (dictionaries) can be created using associative domains.
var dictDomain: domain(string) = { ""one"", ""two"" };
var dict: [dictDomain] int = [""one"" => 1, ""two"" => 2];
dict[""three""] = 3; // Adds 'three' to 'dictDomain' implicitly
for key in dictDomain.sorted() do
  writeln(dict[key]);

// Arrays can be assigned to each other in a few different ways.
// These arrays will be used in the example.
var thisArray : [0..5] int = [0,1,2,3,4,5];
var thatArray : [0..5] int;

// First, simply assign one to the other. This copies thisArray into
// thatArray, instead of just creating a reference. Therefore, modifying
// thisArray does not also modify thatArray.

thatArray = thisArray;
thatArray[1] = -1;
writeln((thisArray, thatArray));

// Assign a slice from one array to a slice (of the same size) in the other.
thatArray[4..5] = thisArray[1..2];
writeln((thisArray, thatArray));

// Operations can also be promoted to work on arrays. 'thisPlusThat' is also
// an array.
var thisPlusThat = thisArray + thatArray;
writeln(thisPlusThat);

// Moving on, arrays and loops can also be expressions, where the loop
// body expression is the result of each iteration.
var arrayFromLoop = for i in 1..10 do i;
writeln(arrayFromLoop);

// An expression can result in nothing, such as when filtering with an if-expression.
var evensOrFives = for i in 1..10 do if (i % 2 == 0 || i % 5 == 0) then i;

writeln(arrayFromLoop);

// Array expressions can also be written with a bracket notation.
// Note: this syntax uses the forall parallel concept discussed later.
var evensOrFivesAgain = [i in 1..10] if (i % 2 == 0 || i % 5 == 0) then i;

// They can also be written over the values of the array.
arrayFromLoop = [value in arrayFromLoop] value + 1;


// Procedures

// Chapel procedures have similar syntax functions in other languages.
proc fibonacci(n : int) : int {
  if n <= 1 then return n;
  return fibonacci(n-1) + fibonacci(n-2);
}

// Input parameters can be untyped to create a generic procedure.
proc doublePrint(thing): void {
  write(thing, "" "", thing, ""\n"");
}

// The return type can be inferred, as long as the compiler can figure it out.
proc addThree(n) {
  return n + 3;
}

doublePrint(addThree(fibonacci(20)));

// It is also possible to take a variable number of parameters.
proc maxOf(x ...?k) {
  // x refers to a tuple of one type, with k elements
  var maximum = x[1];
  for i in 2..k do maximum = if maximum < x[i] then x[i] else maximum;
  return maximum;
}
writeln(maxOf(1, -10, 189, -9071982, 5, 17, 20001, 42));

// Procedures can have default parameter values, and
// the parameters can be named in the call, even out of order.
proc defaultsProc(x: int, y: real = 1.2634): (int,real) {
  return (x,y);
}

writeln(defaultsProc(10));
writeln(defaultsProc(x=11));
writeln(defaultsProc(x=12, y=5.432));
writeln(defaultsProc(y=9.876, x=13));

// The ? operator is called the query operator, and is used to take
// undetermined values like tuple or array sizes and generic types.
// For example, taking arrays as parameters. The query operator is used to
// determine the domain of A. This is uesful for defining the return type,
// though it's not required.
proc invertArray(A: [?D] int): [D] int{
  for a in A do a = -a;
  return A;
}

writeln(invertArray(intArray));

// We can query the type of arguments to generic procedures.
// Here we define a procedure that takes two arguments of
// the same type, yet we don't define what that type is.
proc genericProc(arg1 : ?valueType, arg2 : valueType): void {
  select(valueType) {
    when int do writeln(arg1, "" and "", arg2, "" are ints"");
    when real do writeln(arg1, "" and "", arg2, "" are reals"");
    otherwise writeln(arg1, "" and "", arg2, "" are somethings!"");
  }
}

genericProc(1, 2);
genericProc(1.2, 2.3);
genericProc(1.0+2.0i, 3.0+4.0i);

// We can also enforce a form of polymorphism with the where clause
// This allows the compiler to decide which function to use.
// Note: That means that all information needs to be known at compile-time.
// The param modifier on the arg is used to enforce this constraint.
proc whereProc(param N : int): void
 where (N > 0) {
  writeln(""N is greater than 0"");
}

proc whereProc(param N : int): void
 where (N < 0) {
  writeln(""N is less than 0"");
}

whereProc(10);
whereProc(-1);

// whereProc(0) would result in a compiler error because there
// are no functions that satisfy the where clause's condition.
// We could have defined a whereProc without a where clause
// that would then have served as a catch all for all the other cases
// (of which there is only one).

// where clauses can also be used to constrain based on argument type.
proc whereType(x: ?t) where t == int {
  writeln(""Inside 'int' version of 'whereType': "", x);
}

proc whereType(x: ?t) {
  writeln(""Inside general version of 'whereType': "", x);
}

whereType(42);
whereType(""hello"");

// Intents

/* Intent modifiers on the arguments convey how those arguments are passed to the procedure.

     * in: copy arg in, but not out
     * out: copy arg out, but not in
     * inout: copy arg in, copy arg out
     * ref: pass arg by reference
*/
proc intentsProc(in inarg, out outarg, inout inoutarg, ref refarg) {
  writeln(""Inside Before: "", (inarg, outarg, inoutarg, refarg));
  inarg = inarg + 100;
  outarg = outarg + 100;
  inoutarg = inoutarg + 100;
  refarg = refarg + 100;
  writeln(""Inside After: "", (inarg, outarg, inoutarg, refarg));
}

var inVar: int = 1;
var outVar: int = 2;
var inoutVar: int = 3;
var refVar: int = 4;
writeln(""Outside Before: "", (inVar, outVar, inoutVar, refVar));
intentsProc(inVar, outVar, inoutVar, refVar);
writeln(""Outside After: "", (inVar, outVar, inoutVar, refVar));

// Similarly, we can define intents on the return type.
// refElement returns a reference to an element of array.
// This makes more practical sense for class methods where references to
// elements in a data-structure are returned via a method or iterator.
proc refElement(array : [?D] ?T, idx) ref : T {
  return array[idx];
}

var myChangingArray : [1..5] int = [1,2,3,4,5];
writeln(myChangingArray);
ref refToElem = refElement(myChangingArray, 5); // store reference to element in ref variable
writeln(refToElem);
refToElem = -2; // modify reference which modifies actual value in array
writeln(refToElem);
writeln(myChangingArray);

// Operator Definitions

// Chapel allows for operators to be overloaded.
// We can define the unary operators:
// + - ! ~
// and the binary operators:
// + - * / % ** == <= >= < > << >> & | ˆ by
// += -= *= /= %= **= &= |= ˆ= <<= >>= <=>

// Boolean exclusive or operator.
proc ^(left : bool, right : bool): bool {
  return (left || right) && !(left && right);
}

writeln(true  ^ true);
writeln(false ^ true);
writeln(true  ^ false);
writeln(false ^ false);

// Define a * operator on any two types that returns a tuple of those types.
proc *(left : ?ltype, right : ?rtype): (ltype, rtype) {
  writeln(""\tIn our '*' overload!"");
  return (left, right);
}

writeln(1 * ""a""); // Uses our * operator.
writeln(1 * 2);   // Uses the default * operator.

//  Note: You could break everything if you get careless with your overloads.
//  This here will break everything. Don't do it.

/*
    proc +(left: int, right: int): int {
      return left - right;
    }
*/

// Iterators

// Iterators are sisters to the procedure, and almost everything about
// procedures also applies to iterators. However, instead of returning a single
// value, iterators may yield multiple values to a loop.
//
// This is useful when a complicated set or order of iterations is needed, as
// it allows the code defining the iterations to be separate from the loop
// body.
iter oddsThenEvens(N: int): int {
  for i in 1..N by 2 do
    yield i; // yield values instead of returning.
  for i in 2..N by 2 do
    yield i;
}

for i in oddsThenEvens(10) do write(i, "", "");
writeln();

// Iterators can also yield conditionally, the result of which can be nothing
iter absolutelyNothing(N): int {
  for i in 1..N {
    if N < i { // Always false
      yield i;     // Yield statement never happens
    }
  }
}

for i in absolutelyNothing(10) {
  writeln(""Woa there! absolutelyNothing yielded "", i);
}

// We can zipper together two or more iterators (who have the same number
// of iterations) using zip() to create a single zipped iterator, where each
// iteration of the zipped iterator yields a tuple of one value yielded
// from each iterator.
for (positive, negative) in zip(1..5, -5..-1) do
  writeln((positive, negative));

// Zipper iteration is quite important in the assignment of arrays,
// slices of arrays, and array/loop expressions.
var fromThatArray : [1..#5] int = [1,2,3,4,5];
var toThisArray : [100..#5] int;

// Some zipper operations implement other operations.
// The first statement and the loop are equivalent.
toThisArray = fromThatArray;
for (i,j) in zip(toThisArray.domain, fromThatArray.domain) {
  toThisArray[i] = fromThatArray[j];
}

// These two chunks are also equivalent.
toThisArray = [j in -100..#5] j;
writeln(toThisArray);

for (i, j) in zip(toThisArray.domain, -100..#5) {
  toThisArray[i] = j;
}
writeln(toThisArray);

// This is very important in understanding why this statement exhibits a
// runtime error.

/*
  var iterArray : [1..10] int = [i in 1..10] if (i % 2 == 1) then i;
*/

// Even though the domain of the array and the loop-expression are
// the same size, the body of the expression can be thought of as an iterator.
// Because iterators can yield nothing, that iterator yields a different number
// of things than the domain of the array or loop, which is not allowed.

// Classes

// Classes are similar to those in C++ and Java, allocated on the heap.
class MyClass {

// Member variables
  var memberInt : int;
  var memberBool : bool = true;

// Explicitly defined initializer.
// We also get the compiler-generated initializer, with one argument per field.
// Note that soon there will be no compiler-generated initializer when we
// define any initializer(s) explicitly.
  proc init(val : real) {
    this.memberInt = ceil(val): int;
  }

// Explicitly defined deinitializer.
// If we did not write one, we would get the compiler-generated deinitializer,
// which has an empty body.
  proc deinit() {
    writeln(""MyClass deinitializer called "", (this.memberInt, this.memberBool));
  }

// Class methods.
  proc setMemberInt(val: int) {
    this.memberInt = val;
  }

  proc setMemberBool(val: bool) {
    this.memberBool = val;
  }

  proc getMemberInt(): int{
    return this.memberInt;
  }

  proc getMemberBool(): bool {
    return this.memberBool;
  }
} // end MyClass

// Call compiler-generated initializer, using default value for memberBool.
var myObject = new MyClass(10);
    myObject = new MyClass(memberInt = 10); // Equivalent
writeln(myObject.getMemberInt());

// Same, but provide a memberBool value explicitly.
var myDiffObject = new MyClass(-1, true);
    myDiffObject = new MyClass(memberInt = -1,
                                memberBool = true); // Equivalent
writeln(myDiffObject);

// Call the initializer we wrote.
var myOtherObject = new MyClass(1.95);
    myOtherObject = new MyClass(val = 1.95); // Equivalent
writeln(myOtherObject.getMemberInt());

// We can define an operator on our class as well, but
// the definition has to be outside the class definition.
proc +(A : MyClass, B : MyClass) : MyClass {
  return new MyClass(memberInt = A.getMemberInt() + B.getMemberInt(),
                      memberBool = A.getMemberBool() || B.getMemberBool());
}

var plusObject = myObject + myDiffObject;
writeln(plusObject);

// Destruction.
delete myObject;
delete myDiffObject;
delete myOtherObject;
delete plusObject;

// Classes can inherit from one or more parent classes
class MyChildClass : MyClass {
  var memberComplex: complex;
}

// Here's an example of generic classes.
class GenericClass {
  type classType;
  var classDomain: domain(1);
  var classArray: [classDomain] classType;

// Explicit constructor.
  proc GenericClass(type classType, elements : int) {
    this.classDomain = {1..#elements};
  }

// Copy constructor.
// Note: We still have to put the type as an argument, but we can
// default to the type of the other object using the query (?) operator.
// Further, we can take advantage of this to allow our copy constructor
// to copy classes of different types and cast on the fly.
  proc GenericClass(other : GenericClass(?otherType),
                     type classType = otherType) {
    this.classDomain = other.classDomain;
    // Copy and cast
    for idx in this.classDomain do this[idx] = other[idx] : classType;
  }

// Define bracket notation on a GenericClass
// object so it can behave like a normal array
// i.e. objVar[i] or objVar(i)
  proc this(i : int) ref : classType {
    return this.classArray[i];
  }

// Define an implicit iterator for the class
// to yield values from the array to a loop
// i.e. for i in objVar do ...
  iter these() ref : classType {
    for i in this.classDomain do
      yield this[i];
  }
} // end GenericClass

// We can assign to the member array of the object using the bracket
// notation that we defined.
var realList = new GenericClass(real, 10);
for i in realList.classDomain do realList[i] = i + 1.0;

// We can iterate over the values in our list with the iterator
// we defined.
for value in realList do write(value, "", "");
writeln();

// Make a copy of realList using the copy constructor.
var copyList = new GenericClass(realList);
for value in copyList do write(value, "", "");
writeln();

// Make a copy of realList and change the type, also using the copy constructor.
var copyNewTypeList = new GenericClass(realList, int);
for value in copyNewTypeList do write(value, "", "");
writeln();


// Modules

// Modules are Chapel's way of managing name spaces.
// The files containing these modules do not need to be named after the modules
// (as in Java), but files implicitly name modules.
// For example, this file implicitly names the learnChapelInYMinutes module

module OurModule {

// We can use modules inside of other modules.
// Time is one of the standard modules.
  use Time;

// We'll use this procedure in the parallelism section.
  proc countdown(seconds: int) {
    for i in 1..seconds by -1 {
      writeln(i);
      sleep(1);
    }
  }

// It is possible to create arbitrarily deep module nests.
// i.e. submodules of OurModule
  module ChildModule {
    proc foo() {
      writeln(""ChildModule.foo()"");
    }
  }

  module SiblingModule {
    proc foo() {
      writeln(""SiblingModule.foo()"");
    }
  }
} // end OurModule

// Using OurModule also uses all the modules it uses.
// Since OurModule uses Time, we also use Time.
use OurModule;

// At this point we have not used ChildModule or SiblingModule so
// their symbols (i.e. foo) are not available to us. However, the module
// names are available, and we can explicitly call foo() through them.
SiblingModule.foo();
OurModule.ChildModule.foo();

// Now we use ChildModule, enabling unqualified calls.
use ChildModule;
foo();

// Parallelism

// In other languages, parallelism is typically done with
// complicated libraries and strange class structure hierarchies.
// Chapel has it baked right into the language.

// We can declare a main procedure, but all the code above main still gets
// executed.
proc main() {

// A begin statement will spin the body of that statement off
// into one new task.
// A sync statement will ensure that the progress of the main
// task will not progress until the children have synced back up.

  sync {
    begin { // Start of new task's body
      var a = 0;
      for i in 1..1000 do a += 1;
      writeln(""Done: "", a);
    } // End of new tasks body
    writeln(""spun off a task!"");
  }
  writeln(""Back together"");

  proc printFibb(n: int) {
    writeln(""fibonacci("",n,"") = "", fibonacci(n));
  }

// A cobegin statement will spin each statement of the body into one new
// task. Notice here that the prints from each statement may happen in any
// order.
  cobegin {
    printFibb(20); // new task
    printFibb(10); // new task
    printFibb(5);  // new task
    {
      // This is a nested statement body and thus is a single statement
      // to the parent statement, executed by a single task.
      writeln(""this gets"");
      writeln(""executed as"");
      writeln(""a whole"");
    }
  }

// A coforall loop will create a new task for EACH iteration.
// Again we see that prints happen in any order.
// NOTE: coforall should be used only for creating tasks!
// Using it to iterating over a structure is very a bad idea!
  var num_tasks = 10; // Number of tasks we want
  coforall taskID in 1..#num_tasks {
    writeln(""Hello from task# "", taskID);
  }

// forall loops are another parallel loop, but only create a smaller number
// of tasks, specifically --dataParTasksPerLocale= number of tasks.
  forall i in 1..100 {
    write(i, "", "");
  }
  writeln();

// Here we see that there are sections that are in order, followed by
// a section that would not follow (e.g. 1, 2, 3, 7, 8, 9, 4, 5, 6,).
// This is because each task is taking on a chunk of the range 1..10
// (1..3, 4..6, or 7..9) doing that chunk serially, but each task happens
// in parallel. Your results may depend on your machine and configuration

// For both the forall and coforall loops, the execution of the
// parent task will not continue until all the children sync up.

// forall loops are particularly useful for parallel iteration over arrays.
// Lets run an experiment to see how much faster a parallel loop is
  use Time; // Import the Time module to use Timer objects
  var timer: Timer;
  var myBigArray: [{1..4000,1..4000}] real; // Large array we will write into

// Serial Experiment:
  timer.start(); // Start timer
  for (x,y) in myBigArray.domain { // Serial iteration
    myBigArray[x,y] = (x:real) / (y:real);
  }
  timer.stop(); // Stop timer
  writeln(""Serial: "", timer.elapsed()); // Print elapsed time
  timer.clear(); // Clear timer for parallel loop

// Parallel Experiment:
  timer.start(); // start timer
  forall (x,y) in myBigArray.domain { // Parallel iteration
    myBigArray[x,y] = (x:real) / (y:real);
  }
  timer.stop(); // Stop timer
  writeln(""Parallel: "", timer.elapsed()); // Print elapsed time
  timer.clear();

// You may have noticed that (depending on how many cores you have)
// the parallel loop went faster than the serial loop.

// The bracket style loop-expression described
// much earlier implicitly uses a forall loop.
  [val in myBigArray] val = 1 / val; // Parallel operation

// Atomic variables, common to many languages, are ones whose operations
// occur uninterrupted. Multiple threads can therefore modify atomic
// variables and can know that their values are safe.
// Chapel atomic variables can be of type bool, int,
// uint, and real.
  var uranium: atomic int;
  uranium.write(238);      // atomically write a variable
  writeln(uranium.read()); // atomically read a variable

// Atomic operations are described as functions, so you can define your own.
  uranium.sub(3); // atomically subtract a variable
  writeln(uranium.read());

  var replaceWith = 239;
  var was = uranium.exchange(replaceWith);
  writeln(""uranium was "", was, "" but is now "", replaceWith);

  var isEqualTo = 235;
  if uranium.compareExchange(isEqualTo, replaceWith) {
    writeln(""uranium was equal to "", isEqualTo,
             "" so replaced value with "", replaceWith);
  } else {
    writeln(""uranium was not equal to "", isEqualTo,
             "" so value stays the same...  whatever it was"");
  }

  sync {
    begin { // Reader task
      writeln(""Reader: waiting for uranium to be "", isEqualTo);
      uranium.waitFor(isEqualTo);
      writeln(""Reader: uranium was set (by someone) to "", isEqualTo);
    }

    begin { // Writer task
      writeln(""Writer: will set uranium to the value "", isEqualTo, "" in..."");
      countdown(3);
      uranium.write(isEqualTo);
    }
  }

// sync variables have two states: empty and full.
// If you read an empty variable or write a full variable, you are waited
// until the variable is full or empty again.
  var someSyncVar$: sync int; // varName$ is a convention not a law.
  sync {
    begin { // Reader task
      writeln(""Reader: waiting to read."");
      var read_sync = someSyncVar$;
      writeln(""Reader: value is "", read_sync);
    }

    begin { // Writer task
      writeln(""Writer: will write in..."");
      countdown(3);
      someSyncVar$ = 123;
    }
  }

// single vars can only be written once. A read on an unwritten single
// results in a wait, but when the variable has a value it can be read
// indefinitely.
  var someSingleVar$: single int; // varName$ is a convention not a law.
  sync {
    begin { // Reader task
      writeln(""Reader: waiting to read."");
      for i in 1..5 {
        var read_single = someSingleVar$;
        writeln(""Reader: iteration "", i,"", and the value is "", read_single);
      }
    }

    begin { // Writer task
      writeln(""Writer: will write in..."");
      countdown(3);
      someSingleVar$ = 5; // first and only write ever.
    }
  }

// Here's an example using atomics and a sync variable to create a
// count-down mutex (also known as a multiplexer).
  var count: atomic int; // our counter
  var lock$: sync bool;   // the mutex lock

  count.write(2);       // Only let two tasks in at a time.
  lock$.writeXF(true);  // Set lock$ to full (unlocked)
  // Note: The value doesn't actually matter, just the state
  // (full:unlocked / empty:locked)
  // Also, writeXF() fills (F) the sync var regardless of its state (X)

  coforall task in 1..#5 { // Generate tasks
    // Create a barrier
    do {
      lock$;                 // Read lock$ (wait)
    } while (count.read() < 1); // Keep waiting until a spot opens up

    count.sub(1);          // decrement the counter
    lock$.writeXF(true); // Set lock$ to full (signal)

    // Actual 'work'
    writeln(""Task #"", task, "" doing work."");
    sleep(2);

    count.add(1);        // Increment the counter
    lock$.writeXF(true); // Set lock$ to full (signal)
  }

// We can define the operations + * & | ^ && || min max minloc maxloc
// over an entire array using scans and reductions.
// Reductions apply the operation over the entire array and
// result in a scalar value.
  var listOfValues: [1..10] int = [15,57,354,36,45,15,456,8,678,2];
  var sumOfValues = + reduce listOfValues;
  var maxValue = max reduce listOfValues; // 'max' give just max value

// maxloc gives max value and index of the max value.
// Note: We have to zip the array and domain together with the zip iterator.
  var (theMaxValue, idxOfMax) = maxloc reduce zip(listOfValues,
                                                  listOfValues.domain);

  writeln((sumOfValues, maxValue, idxOfMax, listOfValues[idxOfMax]));

// Scans apply the operation incrementally and return an array with the
// values of the operation at that index as it progressed through the
// array from array.domain.low to array.domain.high.
  var runningSumOfValues = + scan listOfValues;
  var maxScan = max scan listOfValues;
  writeln(runningSumOfValues);
  writeln(maxScan);
} // end main()
```

Who is this tutorial for?
-------------------------

This tutorial is for people who want to learn the ropes of chapel without
having to hear about what fiber mixture the ropes are, or how they were
braided, or how the braid configurations differ between one another. It won't
teach you how to develop amazingly performant code, and it's not exhaustive.
Refer to the [language specification](https://chapel-lang.org/docs/latest/language/spec.html) and
the [module documentation](https://chapel-lang.org/docs/latest/) for more
details.

Occasionally check back here and on the [Chapel site](https://chapel-lang.org)
to see if more topics have been added or more tutorials created.

### What this tutorial is lacking:

 * Exposition of the [standard modules](https://chapel-lang.org/docs/latest/modules/standard.html)
 * Multiple Locales (distributed memory system)
 * Records
 * Parallel iterators

Your input, questions, and discoveries are important to the developers!
-----------------------------------------------------------------------

The Chapel language is still in active development, so there are
occasional hiccups with performance and language features. The more information
you give the Chapel development team about issues you encounter or features you
would like to see, the better the language becomes.
There are several ways to interact with the developers:
+ [Gitter chat](https://gitter.im/chapel-lang/chapel)
+ [sourceforge email lists](https://sourceforge.net/p/chapel/mailman)

If you're really interested in the development of the compiler or contributing
to the project, [check out the master GitHub repository](https://github.com/chapel-lang/chapel).
It is under the [Apache 2.0 License](http://www.apache.org/licenses/LICENSE-2.0).

Installing the Compiler
-----------------------

[The Official Chapel documentation details how to download and compile the Chapel compiler.](https://chapel-lang.org/docs/usingchapel/QUICKSTART.html)

Chapel can be built and installed on your average 'nix machine (and cygwin).
[Download the latest release version](https://github.com/chapel-lang/chapel/releases/)
and it's as easy as

 1. `tar -xvf chapel-<VERSION>.tar.gz`
 2. `cd chapel-<VERSION>`
 3. `source util/setchplenv.bash # or .sh or .csh or .fish`
 4. `make`
 5. `make check # optional`

You will need to `source util/setchplenv.EXT` from within the Chapel directory
(`$CHPL_HOME`) every time your terminal starts so it's suggested that you drop
that command in a script that will get executed on startup (like .bashrc).

Chapel is easily installed with Brew for macOS

 1. `brew update`
 2. `brew install chapel`

Compiling Code
--------------

Builds like other compilers:

`chpl myFile.chpl -o myExe`

Notable arguments:

 * `--fast`: enables a number of optimizations and disables array bounds
   checks. Should only enable when application is stable.
 * `--set <Symbol Name>=<Value>`: set config param `<Symbol Name>` to `<Value>`
   at compile-time.
 * `--main-module <Module Name>`: use the main() procedure found in the module
   `<Module Name>` as the executable's main.
 * `--module-dir <Directory>`: includes `<Directory>` in the module search path."
"Reason is a syntax over OCaml that is easier to get started for programmers who are familiar with C-style syntax like JavaScript. BuckleScript is part of the toolchain which compiles Reason to JavaScript so you can write statically typed code for anywhere that JavaScript runs.

```javascript
/* Comments start with slash-star, and end with star-slash */

/*----------------------------------------------
 * Variable and function declaration
 *----------------------------------------------
 * Variables and functions use the let keyword and end with a semi-colon
 * `let` bindings are immutable
 */

let x = 5;
/* - Notice we didn't add a type, Reason will infer x is an int */

/* A function like this, take two arguments and add them together */
let add = (a, b) => a + b;
/* - This doesn't need a type annotation either! */

/*----------------------------------------------
 * Type annotation
 *----------------------------------------------
 * Types don't need to be explicitly annotated in most cases but when you need
 * to, you can add the type after the name
 */

/* A type can be explicitly written like so */
let x: int = 5;

/* The add function from before could be explicitly annotated too */
let add2 = (a: int, b: int): int => a + b;

/* A type can be aliased using the type keyword */
type companyId = int;
let myId: companyId = 101;

/* Mutation is not encouraged in Reason but it's there if you need it
   If you need to mutate a let binding, the value must be wrapped in a `ref()`*/
let myMutableNumber = ref(120);

/* To access the value (and not the ref container), use `^` */
let copyOfMyMutableNumber = myMutableNumber^;

/* To assign a new value, use the `:=` operator */
myMutableNumber := 240;

/*----------------------------------------------
 * Basic types and operators
 *----------------------------------------------
 */

/* > String */

/* Use double quotes for strings */
let greeting = ""Hello world!"";

/* A string can span multiple lines */
let aLongerGreeting = ""Look at me,
I'm a multi-line string
"";

/* A quoted string can be used for string interpolation and special chars
   Use the `js` annotation for unicode */
let world = {js|🌍|js};

/* The `j` annotation is used for string interpolation */
let helloWorld = {j|hello, $world|j};

/* Concatenate strings with ++ */
let name = ""John "" ++ ""Wayne"";
let emailSubject = ""Hi "" ++ name ++ "", you're a valued customer"";

/* > Char */

/* Use a single character for the char type */
let lastLetter = 'z';
/* - Char doesn't support Unicode or UTF-8 */

/* > Boolean */

/* A boolean can be either true or false */
let isLearning = true;

true && false;  /* - : bool = false;  Logical and */
true || true;   /* - : bool = true;   Logical or  */
!true;          /* - : bool = false;  Logical not */

/* Greater than `>`, or greater than or equal to `>=` */
'a' > 'b'; /* - bool : false */

/* Less than `<`, or less than or equal to `<=` */
1 < 5; /* - : bool = true */

/* Structural equal */
""hello"" == ""hello""; /* - : bool = true */

/* Referential equal */
""hello"" === ""hello""; /* - : bool = false */
/* - This is false because they are two different ""hello"" string literals */

/* Structural unequal */
lastLetter != 'a'; /* -: bool = true */

/* Referential unequal */
lastLetter !== lastLetter; /* - : bool = false */

/* > Integer */
/* Perform math operations on integers */

1 + 1;          /* - : int = 2  */
25 - 11;        /* - : int = 11 */
5 * 2 * 3;      /* - : int = 30 */
8 / 2;          /* - : int = 4  */

/* > Float */
/* Operators on floats have a dot after them */

1.1 +. 1.5;     /* - : float = 2.6  */
18.0 -. 24.5;   /* - : float = -6.5 */
2.5 *. 2.0;     /* - : float = 5.   */
16.0 /. 4.0;    /* - : float = 4.   */

/* > Tuple
 * Tuples have the following attributes
  - immutable
  - ordered
  - fix-sized at creation time
  - heterogeneous (can contain different types of values)
 A tuple is 2 or more values */

let teamMember = (""John"", 25);

/* Type annotation matches the values */
let position2d: (float, float) = (9.0, 12.0);

/* Pattern matching is a great tool to retrieve just the values you care about
   If we only want the y value, let's use `_` to ignore the value */
let (_, y) = position2d;
y +. 1.0; /* - : float = 13. */

/* > Record */

/* A record has to have an explicit type */
type trainJourney = {
  destination: string,
  capacity: int,
  averageSpeed: float,
};

/* Once the type is declared, Reason can infer it whenever it comes up */
let firstTrip = {destination: ""London"", capacity: 45, averageSpeed: 120.0};

/* Access a property using dot notation */
let maxPassengers = firstTrip.capacity;

/* If you define the record type in a different file, you have to reference the
   filename, if trainJourney was in a file called Trips.re */
let secondTrip: Trips.trainJourney = {
  destination: ""Paris"",
  capacity: 50,
  averageSpeed: 150.0,
};

/* Records are immutable by default */
/* But the contents of a record can be copied using the spread operator */
let newTrip = {...secondTrip, averageSpeed: 120.0};

/* A record property can be mutated explicitly with the `mutable` keyword */
type breakfastCereal = {
  name: string,
  mutable amount: int,
};

let tastyMuesli = {name: ""Tasty Muesli TM"", amount: 500};

tastyMuesli.amount = 200;
/* - tastyMuesli now has an amount of 200 */

/* Punning is used to avoid redundant typing */
let name = ""Just As Good Muesli"";
let justAsGoodMuesli = {name, amount: 500};
/* - justAsGoodMuesli.name is now ""Just As Good Muesli"", it's equivalent
   to { name: name, amount: 500 } */

/* > Variant
   Mutually exclusive states can be expressed with variants */

type authType =
  | GitHub
  | Facebook
  | Google
  | Password;
/* - The constructors must be capitalized like so */
/* - Like records, variants should be named if declared in a different file */

let userPreferredAuth = GitHub;

/* Variants work great with a switch statement */
let loginMessage =
  switch (userPreferredAuth) {
  | GitHub => ""Login with GitHub credentials.""
  | Facebook => ""Login with your Facebook account.""
  | Google => ""Login with your Google account""
  | Password => ""Login with email and password.""
  };

/* > Option
   An option can be None or Some('a) where 'a is the type */

let userId = Some(23);

/* A switch handles the two cases */
let alertMessage =
  switch (userId) {
  | Some(id) => ""Welcome, your ID is"" ++ string_of_int(id)
  | None => ""You don't have an account!""
  };
/* - Missing a case, `None` or `Some`, would cause an error */

/* > List
  * Lists have the following attributes
   - immutable
   - ordered
   - fast at prepending items
   - fast at splitting

  * Lists in Reason are linked lists
 */

/* A list is declared with square brackets */
let userIds = [1, 4, 8];

/* The type can be explicitly set with list('a) where 'a is the type */
type idList = list(int);
type attendanceList = list(string);

/* Lists are immutable */
/* But the contents of a list can be copied using the spread operator */
let newUserIds = [101, 102, ...userIds];

/* > Array
 * Arrays have the following attributes
  - mutable
  - fast at random access & updates */

/* An array is declared with `[|` and ends with `|]` */
let languages = [|""Reason"", ""JavaScript"", ""OCaml""|];

/*----------------------------------------------
 * Function
 *----------------------------------------------
 */

/* Reason functions use the arrow syntax, the expression is returned */
let signUpToNewsletter = email => ""Thanks for signing up "" ++ email;

/* Call a function like this */
signUpToNewsletter(""hello@reason.org"");

/* For longer functions, use a block */
let getEmailPrefs = email => {
  let message = ""Update settings for "" ++ email;
  let prefs = [""Weekly News"", ""Daily Notifications""];

  (message, prefs);
};
/* - the final tuple is implicitly returned */

/* > Labeled Arguments */

/* Arguments can be labeled with the ~ symbol */
let moveTo = (~x, ~y) => {/* Move to x,y */};

moveTo(~x=7.0, ~y=3.5);

/* Labeled arguments can also have a name used within the function */
let getMessage = (~message as msg) => ""=="" ++ msg ++ ""=="";

getMessage(~message=""You have a message!"");
/* - The caller specifies ~message but internally the function can make use */

/* The following function also has explicit types declared */
let showDialog = (~message: string): unit => {
  () /* Show the dialog */;
};
/* - The return type is `unit`, this is a special type that is equivalent to
   specifying that this function doesn't return a value
   the `unit` type can also be represented as `()` */

/* > Currying
   Functions can be curried and are partially called, allowing for easy reuse */

let div = (denom, numr) => numr / denom;
let divBySix = div(6);
let divByTwo = div(2);

div(3, 24);     /* - : int = 8  */
divBySix(128);  /* - : int = 21 */
divByTwo(10);   /* - : int = 5  */

/* > Optional Labeled Arguments */

/* Use `=?` syntax for optional labeled arguments */
let greetPerson = (~name, ~greeting=?, ()) => {
  switch (greeting) {
  | Some(greet) => greet ++ "" "" ++ name
  | None => ""Hi "" ++ name
  };
};
/* - The third argument, `unit` or `()` is required because if we omitted it,
   the function would be curried so greetPerson(~name=""Kate"") would create
   a partial function, to fix this we add `unit` when we declare and call it */

/* Call greetPerson without the optional labeled argument */
greetPerson(~name=""Kate"", ());

/* Call greetPerson with all arguments */
greetPerson(~name=""Marco"", ~greeting=""How are you today,"");

/* > Pipe */
/* Functions can be called with the pipeline operator */

/* Use `->` to pass in the first argument (pipe-first) */
3->div(24);     /* - : int = 8 */
/* - This is equivalent to div(3, 24); */

36->divBySix;   /* - : int = 6 */
/* - This is equivalent to divBySix(36); */

/* Use `|>` to pass in the last argument (pipe-last) */
24 |> div(3);   /* - : int = 8 */
/* - This is equivalent to div(3, 24); */

36 |> divBySix; /* - : int = 6 */
/* - This is equivalent to divBySix(36); */

/* Pipes make it easier to chain code together */
let addOne = a => a + 1;
let divByTwo = a => a / 2;
let multByThree = a => a * 3;

let pipedValue = 3->addOne->divByTwo->multByThree; /* - : int = 6 */

/*----------------------------------------------
 * Control Flow & Pattern Matching
 *----------------------------------------------
 */

/* > If-else */
/* In Reason, `If` is an expression when evaluate will return the result */

/* greeting will be ""Good morning!"" */
let greeting = if (true) {""Good morning!""} else {""Hello!""};

/* Without an else branch the expression will return `unit` or `()` */
if (false) {
  showDialog(~message=""Are you sure you want to leave?"");
};
/* - Because the result will be of type `unit`, both return types should be of
   the same type if you want to assign the result. */

/* > Destructuring */
/* Extract properties from data structures easily */

let aTuple = (""Teacher"", 101);

/* We can extract the values of a tuple */
let (name, classNum) = aTuple;

/* The properties of a record can be extracted too */
type person = {
  firstName: string,
  age: int,
};
let bjorn = {firstName: ""Bjorn"", age: 28};

/* The variable names have to match with the record property names */
let {firstName, age} = bjorn;

/* But we can rename them like so */
let {firstName: bName, age: bAge} = bjorn;

let {firstName: cName, age: _} = bjorn;

/* > Switch
   Pattern matching with switches is an important tool in Reason
   It can be used in combination with destructuring for an expressive and
   concise tool */

/* Lets take a simple list */
let firstNames = [""James"", ""Jean"", ""Geoff""];

/* We can pattern match on the names for each case we want to handle */
switch (firstNames) {
| [] => ""No names""
| [first] => ""Only "" ++ first
| [first, second] => ""A couple of names "" ++ first ++ "","" ++ second
| [first, second, third] =>
  ""Three names, "" ++ first ++ "", "" ++ second ++ "", "" ++ third
| _ => ""Lots of names""
};
/* - The `_` is a catch all at the end, it signifies that we don't care what
   the value is so it will match every other case */

/* > When clause */

let isJohn = a => a == ""John"";
let maybeName = Some(""John"");

/* When can add more complex logic to a simple switch */
let aGreeting =
  switch (maybeName) {
  | Some(name) when isJohn(name) => ""Hi John! How's it going?""
  | Some(name) => ""Hi "" ++ name ++ "", welcome.""
  | None => ""No one to greet.""
  };

/* > Exception */

/* Define a custom exception */
exception Under_Age;

/* Raise an exception within a function */
let driveToTown = (driver: person) =>
  if (driver.age >= 15) {
    ""We're in town"";
  } else {
    raise(Under_Age);
  };

let evan = {firstName: ""Evan"", age: 14};

/* Pattern match on the exception Under_Age */
switch (driveToTown(evan)) {
| status => print_endline(status)
| exception Under_Age =>
  print_endline(evan.firstName ++ "" is too young to drive!"")
};

/* Alternatively, a try block can be used */
/* - With Reason exceptions can be avoided with optionals and are seldom used */
let messageToEvan =
  try (driveToTown(evan)) {
  | Under_Age => evan.firstName ++ "" is too young to drive!""
  };

/*----------------------------------------------
 * Object
 *----------------------------------------------
 * Objects are similar to Record types but aren't as rigid
 * An object resembles a class
 */

/* An object may be typed like a record but contains a dot */
type surfaceComputer = {
  .
  color: string,
  capacity: int,
};
/* - A single dot signifies a closed object, an object that uses this type
   must have the exact shape */

let surfaceBook: surfaceComputer = {pub color = ""blue""; pub capacity = 512};

/* But an object doesn't require a type */
let house = {
  /* A private property */
  val temp = ref(18.0);
  /* Public properties */
  pub temperature = temp;
  /* A private method only accessible from within house */
  pri setThermostat = v => temp := v;
  /* A public method that calls the private setThermostat method */
  pub arriveHome = () => this#setThermostat(22.0)
};

house#temperature; /* - : float = 18. */
house#arriveHome();
house#temperature; /* - : float = 22. */

/*----------------------------------------------
 * Module
 *----------------------------------------------
 * Modules are used to organize your code and provide namespacing.
 * Each file is a module by default
 */

/* Create a module */
module Staff = {
  type role =
    | Delivery
    | Sales
    | Other;
  type member = {
    name: string,
    role,
  };

  let getRoleDirectionMessage = staff =>
    switch (staff.role) {
    | Delivery => ""Deliver it like you mean it!""
    | Sales => ""Sell it like only you can!""
    | Other => ""You're an important part of the team!""
    };
};

/* A module can be accessed with dot notation */
let newEmployee: Staff.member = {name: ""Laura"", role: Staff.Delivery};

/* Using the module name can be tiresome so the module's contents can be opened
   into the current scope with `open` */
open Staff;

let otherNewEmployee: member = {name: ""Fred"", role: Other};

/* A module can be extended using the `include` keyword, include copies
   the contents of the module into the scope of the new module */
module SpecializedStaff = {
  include Staff;

  /* `member` is included so there's no need to reference it explicitly */
  let ceo: member = {name: ""Reggie"", role: Other};

  let getMeetingTime = staff =>
    switch (staff) {
    | Other => 11_15 /* - : int = 1115; Underscores are for formatting only  */
    | _ => 9_30
    };
};
```

## Further Reading

- [Official Reason Docs](https://reasonml.github.io/docs/en/what-and-why)
- [Official BuckleScript Docs](https://bucklescript.github.io/docs/en/what-why)
- [Try Reason](https://reasonml.github.io/en/try)
- [Get Started with Reason by Nik Graf](https://egghead.io/courses/get-started-with-reason)"
"[Zig][ziglang] aims to be a replacement for the C programming language.

**WARNING**: this document expects you to understand a few basic concepts in computer science, such as pointers, stack and heap memory, etc.

**WARNING**: Zig isn't considered as ready for production. Bugs are expected.
DO NOT TRY ZIG AS YOUR FIRST PROGRAMMING EXPERIENCE.
The compiler, even the language and its libraries aren't ready, yet.
You've been warned.

Prior knowledge of C is recommended.


## Quick overview: Zig compared to C

- Syntax is mostly the same, with some improvements (less ambiguity).
- Zig introduces namespaces.
- Try and catch mechanism, which is both convenient, efficient and optional.
- Most of the C undefined behaviors (UBs) are fixed.
- Compared to C, raw pointers are safer to use and less likely to be needed.
  * The type system distinguishes between a pointer to a single value, or multiple values, etc.
  * Slices are preferred, which is a structure with a pointer and a runtime known size, which characterizes most uses of pointers in the first place.
- Some arbitrary language limitations are removed. For example, enumerations, structures and unions can have functions.
- Simple access to SIMD operations (basic maths on vectors).
- Zig provides both low-level features of C and the one provided through compiler extensions.
  For example: packed structures.
- An extensive standard library, including data structures and algorithms.
- Cross-compilation capability is provided by default, without any dependency.
  Different libc are provided to ease the process.
  Cross-compilation works from, and to, any operating system and architecture.

## Zig language


```
//! Top-level documentation.

/// Documentation comment.

// Simple comment.
```


### Hello world.
```
// Import standard library, reachable through the ""std"" constant.
const std = @import(""std"");

// ""info"" now refers to the ""std.log.info"" function.
const info = std.log.info;

// Usual hello world.
// syntax: [pub] fn <function-name>(<arguments>) <return-type> { <body> }
pub fn main() void {
    // Contrary to C functions, Zig functions have a fixed number of arguments.
    // In C: ""printf"" takes any number of arguments.
    // In Zig: std.log.info takes a format and a list of elements to print.
    info(""hello world"", .{});  // .{} is an empty anonymous tuple.
}
```

### Booleans, integers and float.
```
// Booleans.
// Keywords are preferred to operators for boolean operations.
print(""{}\n{}\n{}\n"", .{
    true and false,
    true or false,
    !true,
});

// Integers.
const one_plus_one: i32 = 1 + 1;
print(""1 + 1 = {}\n"", .{one_plus_one}); // 2

// Floats.
const seven_div_three: f32 = 7.0 / 3.0;
print(""7.0 / 3.0 = {}\n"", .{seven_div_three}); // 2.33333325e+00

// Integers have arbitrary value lengths.
var myvar: u10 = 5; // 10-bit unsigned integer
// Useful for example to read network packets, or complex binary formats.

// Number representation is greatly improved compared to C.
const one_billion = 1_000_000_000;         // Decimal.
const binary_mask = 0b1_1111_1111;         // Binary. Ex: network mask.
const permissions = 0o7_5_5;               // Octal.  Ex: Unix permissions.
const big_address = 0xFF80_0000_0000_0000; // Hexa.   Ex: IPv6 address.


// Overflow operators: tell the compiler when it's okay to overflow.
var i: u8 = 0;  // ""i"" is an unsigned 8-bit integer
i  -= 1;        // runtime overflow error (unsigned value always are positive)
i -%= 1;        // okay (wrapping operator), i == 255

// Saturation operators: values will stick to their lower and upper bounds.
var i: u8 = 200;   // ""i"" is an unsigned 8-bit integer (values: from 0 to 255)
i  +| 100 == 255   // u8: won't go higher than 255
i  -| 300 == 0     // unsigned, won't go lower than 0
i  *| 2   == 255   // u8: won't go higher than 255
i <<| 8   == 255   // u8: won't go higher than 255
```

### Arrays.
```
// An array is a well-defined structure with a length attribute (len).

// 5-byte array with undefined content (stack garbage).
var array1: [5]u8 = undefined;

// 5-byte array with defined content.
var array2 = [_]u8{ 1, 2, 3, 4, 5 };
// [_] means the compiler knows the length at compile-time.

// 1000-byte array with defined content (0).
var array3 = [_]u8{0} ** 1000;

// Another 1000-byte array with defined content.
// The content is provided by the ""foo"" function, called at compile-time and
// allows complex initializations.
var array4 = [_]u8{foo()} ** 1000;

// In any case, array.len gives the length of the array,
// array1.len and array2.len produce 5, array3.len and array4.len produce 1000.


// Modifying and accessing arrays content.

// Array of 10 32-bit undefined integers.
var some_integers: [10]i32 = undefined;

some_integers[0] = 30; // first element of the array is now 30

var x = some_integers[0]; // ""x"" now equals to 30, its type is inferred.
var y = some_integers[1]; // Second element of the array isn't defined.
                          // ""y"" got a stack garbage value (no runtime error).

// Array of 10 32-bit undefined integers.
var some_integers: [10]i32 = undefined;

var z = some_integers[20]; // index > array size, compilation error.

// At runtime, we loop over the elements of ""some_integers"" with an index.
// Index i = 20, then we try:
try some_integers[i]; // Runtime error 'index out of bounds'.
                      // ""try"" keyword is necessary when accessing an array with
                      // an index, since there is a potential runtime error.
                      // More on that later.
```

### Multidimensional arrays.
```

const mat4x4 = [4][4]f32{
    [_]f32{ 1.0, 0.0, 0.0, 0.0 },
    [_]f32{ 0.0, 1.0, 0.0, 1.0 },
    [_]f32{ 0.0, 0.0, 1.0, 0.0 },
    [_]f32{ 0.0, 0.0, 0.0, 1.0 },
};

// Access the 2D array then the inner array through indexes.
try expect(mat4x4[1][1] == 1.0);

// Here we iterate with for loops.
for (mat4x4) |row, row_index| {
    for (row) |cell, column_index| {
        // ...
    }
}
```

### Strings.
```

// Simple string constant.
const greetings = ""hello"";
// ... which is equivalent to:
const greetings: *const [5:0]u8 = ""hello"";
// In words: ""greetings"" is a constant value, a pointer on a constant array of 5
// elements (8-bit unsigned integers), with an extra '0' at the end.
// The extra ""0"" is called a ""sentinel value"".

print(""string: {s}\n"", .{greetings});

// This represents rather faithfully C strings. Although, Zig strings are
// structures, no need for ""strlen"" to compute their size.
// greetings.len == 5
```

### Slices.
```

// A slice is a pointer and a size, an array without compile-time known size.
// Slices have runtime out-of-band verifications.

const array = [_]u8{1,2,3,4,5};     // [_] = array with compile-time known size.
const slice = array[0..array.len];  // ""slice"" represents the whole array.
                                    // slice[10] gives a runtime error.
```

### Pointers.
```

// Pointer on a value can be created with ""&"".
const x: i32 = 1;
const pointer: *i32 = &x;  // ""pointer"" is a pointer on the i32 var ""x"".
print(""1 = {}, {}\n"", .{x, pointer});

// Pointer values are accessed and modified with "".*"".
if (pointer.* == 1) {
    print(""x value == {}\n"", .{pointer.*});
}

// "".?"" is a shortcut for ""orelse unreachable"".
const foo = pointer.?; // Get the pointed value, otherwise crash.
```

### Optional values (?<type>).
```
// An optional is a value than can be of any type or null.

// Example: ""optional_value"" can either be ""null"" or an unsigned 32-bit integer.
var optional_value: ?u32 = null; // optional_value == null
optional_value = 42;             // optional_value != null

// ""some_function"" returns ?u32
var x = some_function();
if (x) |value| {
    // In case ""some_function"" returned a value.
    // Do something with 'value'.
}
```

### Errors.
```
// Zig provides an unified way to express errors.

// Errors are defined in error enumerations, example:
const Error = error {
    WatchingAnyNetflixTVShow,
    BeOnTwitter,
};

// Normal enumerations are expressed the same way, but with ""enum"" keyword.
const SuccessStory = enum {
    DoingSport,
    ReadABook,
};


// Error union (!).
// Either the value ""mylife"" is an an error or a normal value.
var mylife: Error!SuccessStory = Error.BeOnTwitter;
// mylife is an error. Sad.

mylife = SuccessStory.ReadABook;
// Now mylife is an enum.


// Zig ships with many pre-defined errors. Example:
const value: anyerror!u32 = error.Broken;


// Handling errors.

// Some error examples.
const Error = error {
    UnExpected,
    Authentication,
};

// ""some_function"" can either return an ""Error"" or an integer.
fn some_function() Error!u8 {
    return Error.UnExpected; // It returns an error.
}

// Errors can be ""catch"" without intermediate variable.
var value = some_function() catch |err| switch(err) {
    Error.UnExpected     => return err,   // Returns the error.
    Error.Authentication => unreachable,  // Not expected. Crashes the program.
    else                 => unreachable,
};

// An error can be ""catch"" without giving it a name.
const unwrapped = some_function() catch 1234; // ""unwrapped"" = 1234

// ""try"" is a very handy shortcut for ""catch |err| return err"".
var value = try some_function();
// If ""some_function"" fails, the current function stops and returns the error.
// ""value"" can only have a valid value, the error already is handled with ""try"".
```

### Control flow.

```
// Conditional branching.

if (condition) {
    ...
}
else {
    ...
}

// Ternary.
var value = if (condition) x else y;

// Shortcut for ""if (x) x else 0""
var value = x orelse 0;

// If ""a"" is an optional, which may contain a value.
if (a) |value| {
    print(""value: {}\n"", .{value});
}
else {
    print(""'a' is null\n"", .{});
}

// Get a pointer on the value (if it exists).
if (a) |*value| { value.* += 1; }


// Loops.

// Syntax examples:
//   while (condition) statement
//   while (condition) : (end-of-iteration-statement) statement
//
//   for (iterable) statement
//   for (iterable) |capture| statement
//   for (iterable) statement else statement

// Note: loops work the same way over arrays or slices.

// Simple ""while"" loop.
while (i < 10) { i += 1; }

// While loop with a ""continue expression""
// (expression executed as the last expression of the loop).
while (i < 10) : (i += 1) { ... }
// Same, with a more complex continue expression (block of code).
while (i * j < 2000) : ({ i *= 2; j *= 3; }) { ... }

// To iterate over a portion of a slice, reslice.
for (items[0..1]) |value| { sum += value; }

// Loop over every item of an array (or slice).
for (items) |value| { sum += value; }

// Iterate and get pointers on values instead of copies.
for (items) |*value| { value.* += 1; }

// Iterate with an index.
for (items) |value, i| { print(""val[{}] = {}\n"", .{i, value}); }

// Iterate with pointer and index.
for (items) |*value, i| { print(""val[{}] = {}\n"", .{i, value}); value.* += 1; }


// Break and continue are supported.
for (items) |value| {
    if (value == 0)  { continue; }
    if (value >= 10) { break;    }
    // ...
}

// For loops can also be used as expressions.
// Similar to while loops, when you break from a for loop,
// the else branch is not evaluated.
var sum: i32 = 0;
// The ""for"" loop has to provide a value, which will be the ""else"" value.
const result = for (items) |value| {
    if (value != null) {
        sum += value.?; // ""result"" will be the last ""sum"" value.
    }
} else 0;                  // Last value.
```

### Labels.
```

// Labels are a way to name an instruction, a location in the code.
// Labels can be used to ""continue"" or ""break"" in a nested loop.
outer: for ([_]i32{ 1, 2, 3, 4, 5, 6, 7, 8 }) |_| {
    for ([_]i32{ 1, 2, 3, 4, 5 }) |_| {
        count += 1;
        continue :outer; // ""continue"" for the first loop.
    }
} // count = 8
outer: for ([_]i32{ 1, 2, 3, 4, 5, 6, 7, 8 }) |_| {
    for ([_]i32{ 1, 2, 3, 4, 5 }) |_| {
        count += 1;
        break :outer; // ""break"" for the first loop.
    }
} // count = 1


// Labels can also be used to return a value from a block.
var y: i32 = 5;
const x = blk: {
    y += 1;
    break :blk y; // Now ""x"" equals 6.
};
// Relevant in cases like ""for else"" expression (explained in the following).

// For loops can be used as expressions.
// When you break from a for loop, the else branch is not evaluated.
// WARNING: counter-intuitive.
//      The ""for"" loop will run, then the ""else"" block will run.
//      The ""else"" keyword has to be followed by the value to give to ""result"".
//      See later for another form.
var sum: u8 = 0;
const result = for (items) |value| {
    sum += value;
} else 8; // result = 8

// In this case, the ""else"" keyword is followed by a value, too.
// However, the syntax is different: it is labeled.
// Instead of a value, there is a label followed by a block of code, which
// allows to do stuff before returning the value (see the ""break"" invocation).
const result = for (items) |value| { // First: loop.
    sum += value;
} else blk: {                        // Second: ""else"" block.
    std.log.info(""executed AFTER the loop!"", .{});
    break :blk sum; // The ""sum"" value will replace the label ""blk"".
};
```

### Switch.
```

// As a switch in C, but slightly more advanced.
// Syntax:
//   switch (value) {
//       pattern => expression,
//       pattern => expression,
//       else    => expression
//   };

// A switch only checking for simple values.
var x = switch(value) {
    Error.UnExpected     => return err,
    Error.Authentication => unreachable,
    else                 => unreachable,
};

// A slightly more advanced switch, accepting a range of values:
const foo: i32 = 0;
const bar = switch (foo) {
  0                        => ""zero"",
  1...std.math.maxInt(i32) => ""positive"",
  else                     => ""negative"",
};
```

### Structures.
```

// Structure containing a single value.
const Full = struct {
    number: u16,
};

// Packed structure, with guaranteed in-memory layout.
const Divided = packed struct {
    half1: u8,
    quarter3: u4,
    quarter4: u4,
};

// Point is a constant representing a structure containing two u32, ""x"" and ""y"".
// ""x"" has a default value, which wasn't possible in C.
const Point = struct {
    x: u32 = 1, // default value
    y: u32,
};

// Variable ""p"" is a new Point, with x = 1 (default value) and y = 2.
var p = Point{ .y = 2 };

// Fields are accessed as usual with the dot notation: variable.field.
print(""p.x: {}\n"", .{p.x}); // 1
print(""p.y: {}\n"", .{p.y}); // 2


// A structure can also contain public constants and functions.
const Point = struct {
    pub const some_constant = 30;

    x: u32,
    y: u32,

    // This function ""init"" creates a Point and returns it.
    pub fn init() Point {
        return Point{ .x = 0, .y = 0 };
    }
};


// How to access a structure public constant.
// The value isn't accessed from an ""instance"" of the structure, but from the
// constant representing the structure definition (Point).
print(""constant: {}\n"", .{Point.some_constant});

// Having an ""init"" function is rather idiomatic in the standard library.
// More on that later.
var p = Point.init();
print(""p.x: {}\n"", .{p.x}); // p.x = 0
print(""p.y: {}\n"", .{p.y}); // p.y = 0


// Structures often have functions to modify their state, similar to
// object-oriented programming.
const Point = struct {
    const Self = @This(); // Refers to its own type (later called ""Point"").

    x: u32,
    y: u32,

    // Take a look at the signature. First argument is of type *Self: ""self"" is
    // a pointer on the instance of the structure.
    // This allows the same ""dot"" notation as in OOP, like ""instance.set(x,y)"".
    // See the following example.
    pub fn set(self: *Self, x: u32, y: u32) void {
        self.x = x;
        self.y = y;
    }

    // Again, look at the signature. First argument is of type Self (not *Self),
    // this isn't a pointer. In this case, ""self"" refers to the instance of the
    // structure, but can't be modified.
    pub fn getx(self: Self) u32 {
        return self.x;
    }

    // PS: two previous functions may be somewhat useless.
    //     Attributes can be changed directly, no need for accessor functions.
    //     It was just an example.
};

// Let's use the previous structure.
var p = Point{ .x = 0, .y = 0 }; // ""p"" variable is a Point.

p.set(10, 30); // x and y attributes of ""p"" are modified via the ""set"" function.
print(""p.x: {}\n"", .{p.x}); // 10
print(""p.y: {}\n"", .{p.y}); // 30

// In C:
//   1. We would have written something like: point_set(p, 10, 30).
//   2. Since all functions are in the same namespace, it would have been
//      very cumbersome to create functions with different names for different
//      structures. Many long names, painful to read.
//
// In Zig, structures provide namespaces for their own functions.
// Different structures can have the same names for their functions,
// which brings clarity.
```

### Tuples.
```
// A tuple is a list of elements, possibly of different types.

const foo = .{ ""hello"", true, 42 };
// foo.len == 3
```

### Enumerations.
```

const Type = enum { ok, not_ok };

const CardinalDirections = enum { North, South, East, West };
const direction: CardinalDirections = .North;
const x = switch (direction) {
  // shorthand for CardinalDirections.North
  .North => true,
  else => false
};

// Switch statements need exhaustiveness.
// WARNING: won't compile. East and West are missing.
const x = switch (direction) {
  .North => true,
  .South => true,
};


// Switch statements need exhaustiveness.
// Won't compile: East and West are missing.
const x = switch (direction) {
  .North => true,
  .South => true,
  .East,          // Its value is the same as the following pattern: false.
  .West => false,
};


// Enumerations are like structures: they can have functions.
```

### Unions.
```

const Bar = union {
  boolean: bool,
  int: i16,
  float: f32,
};

// Both syntaxes are equivalent.
const foo = Bar{ .int = 42 };
const foo: Bar = .{ .int = 42 };

// Unions, like enumerations and structures, can have functions.
```

### Tagged unions.
```

// Unions can be declared with an enum tag type, allowing them to be used in
// switch expressions.

const MaybeEnum = enum {
    success,
    failure,
};

const Maybe = union(MaybeEnum) {
    success: u8,
    failure: []const u8,
};

// First value: success!
const yay = Maybe{ .success = 42 };
switch (yay) {
    .success => |value|     std.log.info(""success: {}"", .{value}),
    .failure => |err_msg|   std.log.info(""failure: {}"", .{err_msg}),
}

// Second value: failure! :(
const nay = Maybe{ .failure = ""I was too lazy"" };
switch (nay) {
    .success => |value|     std.log.info(""success: {}"", .{value}),
    .failure => |err_msg|   std.log.info(""failure: {}"", .{err_msg}),
}
```

### Defer and errdefer.
```

// Make sure that an action (single instruction or block of code) is executed
// before the end of the scope (function, block of code).
// Even on error, that action will be executed.
// Useful for memory allocations, and resource management in general.

pub fn main() void {
    // Should be executed at the end of the function.
    defer print(""third!\n"", .{});

    {
        // Last element of its scope: will be executed right away.
        defer print(""first!\n"", .{});
    }

    print(""second!\n"", .{});
}

fn hello_world() void {
    defer print(""end of function\n"", .{}); // after ""hello world!""

    print(""hello world!\n"", .{});
}

// errdefer executes the instruction (or block of code) only on error.
fn second_hello_world() !void {
    errdefer print(""2. something went wrong!\n"", .{}); // if ""foo"" fails.
    defer    print(""1. second hello world\n"", .{});    // executed after ""foo""

    try foo();
}
// Defer statements can be seen as stacked: first one is executed last.
```

### Memory allocators.
Memory isn't managed directly in the standard library, instead an ""allocator"" is asked every time an operation on memory is required.
Thus, the standard library lets developers handle memory as they need, through structures called ""allocators"", handling all memory operations.

**NOTE**: the choice of the allocator isn't in the scope of this document.
A whole book could be written about it.
However, here are some examples, to get an idea of what you can expect:
- page_allocator.
  Allocate a whole page of memory each time we ask for some memory.
  Very simple, very dumb, very wasteful.
- GeneralPurposeAllocator.
  Get some memory first and manage some buckets of memory in order to
  reduce the number of allocations.
  A bit complex. Can be combined with other allocators.
  Can detect leaks and provide useful information to find them.
- FixedBufferAllocator.
  Use a fixed buffer to get its memory, don't ask memory to the kernel.
  Very simple, limited and wasteful (can't deallocate), but very fast.
- ArenaAllocator.
  Allow to free all allocated memory at once.
  To use in combinations with another allocator.
  Very simple way of avoiding leaks.

A first example.
```
// ""!void"" means the function doesn't return any value except for errors.
// In this case we try to allocate memory, and this may fail.
fn foo() !void {
    // In this example we use a page allocator.
    var allocator = std.heap.page_allocator;

    // ""list"" is an ArrayList of 8-bit unsigned integers.
    // An ArrayList is a contiguous, growable list of elements in memory.
    var list = try ArrayList(u8).initAllocated(allocator);
    defer list.deinit(); // Free the memory at the end of the scope. Can't leak.
    // ""defer"" allows to express memory release right after its allocation,
    // regardless of the complexity of the function (loops, conditions, etc.).

    list.add(5); // Some memory is allocated here, with the provided allocator.

    for (list.items) |item| {
        std.debug.print(""item: {}\n"", .{item});
    }
}
```

### Memory allocation combined with error management and defer.
```

fn some_memory_allocation_example() !void {
    // Memory allocation may fail, so we ""try"" to allocate the memory and
    // in case there is an error, the current function returns it.
    var buf = try page_allocator.alloc(u8, 10);
    // Defer memory release right after the allocation.
    // Will happen even if an error occurs.
    defer page_allocator.free(buf);

    // Second allocation.
    // In case of a failure, the first allocation is correctly released.
    var buf2 = try page_allocator.alloc(u8, 10);
    defer page_allocator.free(buf2);

    // In case of failure, both previous allocations are correctly deallocated.
    try foo();
    try bar();

    // ...
}
```

### Memory allocators: a taste of the standard library.
```

// Allocators: 4 main functions to know
//   single_value = create (type)
//   destroy (single_value)
//   slice = alloc (type, size)
//   free (slice)

// Page Allocator
fn page_allocator_fn() !void {
    var slice = try std.heap.page_allocator.alloc(u8, 3);
    defer std.heap.page_allocator.free(slice);

    // playing_with_a_slice(slice);
}

// GeneralPurposeAllocator
fn general_purpose_allocator_fn() !void {
    // GeneralPurposeAllocator has to be configured.
    // In this case, we want to track down memory leaks.
    const config = .{.safety = true};
    var gpa = std.heap.GeneralPurposeAllocator(config){};
    defer _ = gpa.deinit();

    const allocator = gpa.allocator();

    var slice = try allocator.alloc(u8, 3);
    defer allocator.free(slice);

    // playing_with_a_slice(slice);
}

// FixedBufferAllocator
fn fixed_buffer_allocator_fn() !void {
    var buffer = [_]u8{0} ** 1000; // array of 1000 u8, all initialized at zero.
    var fba  = std.heap.FixedBufferAllocator.init(buffer[0..]);
    // Side note: buffer[0..] is a way to create a slice from an array.
    //            Since the function takes a slice and not an array, this makes
    //            the type system happy.

    var allocator = fba.allocator();

    var slice = try allocator.alloc(u8, 3);
    // No need for ""free"", memory cannot be freed with a fixed buffer allocator.
    // defer allocator.free(slice);

    // playing_with_a_slice(slice);
}

// ArenaAllocator
fn arena_allocator_fn() !void {
    // Reminder: arena doesn't allocate memory, it uses an inner allocator.
    // In this case, we combine the arena allocator with the page allocator.
    var arena = std.heap.arena_allocator.init(std.heap.page_allocator);
    defer arena.deinit(); // end of function = all allocations are freed.

    var allocator = arena.allocator();

    const slice = try allocator.alloc(u8, 3);
    // No need for ""free"", memory will be freed anyway.

    // playing_with_a_slice(slice);
}


// Combining the general purpose and arena allocators. Both are very useful,
// and their combinations should be in everyone's favorite cookbook.
fn gpa_arena_allocator_fn() !void {
    const config = .{.safety = true};
    var gpa = std.heap.GeneralPurposeAllocator(config){};
    defer _ = gpa.deinit();

    const gpa_allocator = gpa.allocator();

    var arena = arena_allocator.init(gpa_allocator);
    defer arena.deinit();

    const allocator = arena.allocator();

    var slice = try allocator.alloc(u8, 3);
    defer allocator.free(slice);

    // playing_with_a_slice(slice);
}
```

### Comptime.
```

// Comptime is a way to avoid the pre-processor.
// The idea is simple: run code at compilation.

inline fn max(comptime T: type, a: T, b: T) T {
    return if (a > b) a else b;
}

var res = max(u64, 1, 2);
var res = max(f32, 10.50, 32.19);


// Comptime: creating generic structures.

fn List(comptime T: type) type {
    return struct {
        items: []T,

        fn init()   ... { ... }
        fn deinit() ... { ... }
        fn do()     ... { ... }
    };
}

const MyList = List(u8);


// use
var list = MyList{
    .items = ... // memory allocation
};

list.items[0] = 10;
```

### Conditional compilation.
```
const available_os = enum { OpenBSD, Linux };
const myos = available_os.OpenBSD;


// The following switch is based on a constant value.
// This means that the only possible outcome is known at compile-time.
// Thus, there is no need to build the rest of the possibilities.
// Similar to the ""#ifdef"" in C, but without requiring a pre-processor.
const string = switch (myos) {
   .OpenBSD => ""OpenBSD is awesome!"",
   .Linux => ""Linux rocks!"",
};

// Also works in this case.
const myprint = switch(myos) {
    .OpenBSD => std.debug.print,
    .Linux => std.log.info,
}
```

### Testing our functions.
```
const std = @import(""std"");
const expect = std.testing.expect;

// Function to test.
pub fn some_function() bool {
    return true;
}

// This ""test"" block can be run with ""zig test"".
// It will test the function at compile-time.
test ""returns true"" {
    expect(false == some_function());
}
```

### Compiler built-ins.
The compiler has special functions called ""built-ins"", starting with an ""@"".
There are more than a hundred built-ins, allowing very low-level stuff:
- compile-time errors, logging, verifications
- type coercion and conversion, even in an unsafe way
- alignment management
- memory tricks (such as getting the byte offset of a field in a struct)
- calling functions at compile-time
- including C headers to transparently call C functions
- atomic operations
- embed files into the executable (@embedFile)
- frame manipulations (for async functions, for example)
- etc.

Example: enums aren't integers, they have to be converted with a built-in.
```
const Value = enum { zero, stuff, blah };
if (@enumToInt(Value.zero)  == 0) { ... }
if (@enumToInt(Value.stuff) == 1) { ... }
if (@enumToInt(Value.blah)  == 2) { ... }
```


### A few ""not yourself in the foot"" measures in the Zig language.

- Namespaces: names conflicts are easily avoided.
  In practice, that means an unified API between different structures (data types).
- Enumerations aren't integers. Comparing an enumeration to an integer requires a conversion.
- Explicit casts, coercion exists but is limited.
  Types are slightly more enforced than in C, just a taste:
    Pointers aren't integers, explicit conversion is necessary.
    You won't lose precision by accident, implicit coercions are only authorized in case no precision can be lost.
    Unions cannot be reinterpreted (in an union with an integer and a float, one cannot take a value for another by accident).
    Etc.
- Removing most of the C undefined behaviors (UBs), and when the compiler encounters one, it stops.
- Slice and Array structures are preferred to pointers.
  Types enforced by the compiler are less prone to errors than pointer manipulations.
- Numerical overflows produce an error, unless explicitly accepted using wrapping operators.
- Try and catch mechanism.
  It's both handy, trivially implemented (simple error enumeration), and it takes almost no space nor computation time.
- Unused variables are considered as errors by the compiler.
- Many pointer types exist in order to represent what is pointed.
  Example: is this a single value or an array, is the length known, etc.
- Structures need a value for their attributes, and it still is possible to give an undefined value (stack garbage), but at least it is explicitly undefined.


## Further Reading

For a start, some concepts are presented on the [Zig learn website][ziglearn].

The [official website][zigdoc] provides a reference documentation to the language.

For now, documentation for standard library is WIP.

[ziglang]: https://ziglang.org
[ziglearn]: https://ziglearn.org/
[zigdoc]: https://ziglang.org/documentation/"
"Hjson is an attempt to make [JSON](https://learnxinyminutes.com/docs/json/) more human readable.

Hjson is a syntax extension to JSON. 
It's NOT a proposal to replace JSON or to incorporate it into the JSON spec itself. 
It's intended to be used like a user interface for humans, 
to read and edit before passing the JSON data to the machine.

Let's take a look at examples to see the key syntax differences!

```
{
    # Comments are totally supported!
    
    // With forward slashes too!
    
    /*
        Even block style comments, neat!
    /*
    
    # Strings do not require quotes!
    # Just keep it to a single line
    human: readable
    quotes: ""are fine too""
    
    # Notice that commas are also not required!
    # If using commas, strings DO require quotes!
    object: {
        name: Hjson
        properties: [
            readable
            exciting
            fun
        ]
        with_commas: [
            ""quoted"",
            ""quoty"",
            ""quote""
        ]
        details: [""this"", ""is"", ""fine"", ""too""]
    }
    
    # Multiline quotes with proper whitespace handling are supported!
    diary:
        '''
        I wish JSON was more human readable.
        If only there was a JSON for my needs!
        Oh wait.. there is! It's called Hjson.
        '''
    
    # Backslashes are interpreted as an escape character ONLY in quoted strings
    slash: This will not have a new line\n
    slash-quoted: ""This will definitely have a new line\n""

    # Make sure to use quotes when mixing whitespace with important punctuation
    example1: ""If, you're, going, to, comma in a string, use, quotes!""
    example2: ""Also if you want to use {} or [] or any JSON relevant punctuation!""
    example3: [because, this, is, totally, BROKEN!]
    example4: this is technically OK though: {}[],:
    
    # Enjoy working with Hjson!
    party-time: {
        Hjson-lovers: [
            me
            my mom
            ""my dad""
        ]
        Hjson-power-level: 9000
        supported: {
            python: yes
            java: yes
            javascript: yes
            c++: yes
            Go: yes
            C#: yes
            Rust: yes
        }
        partial-support: [""C"", ""Kotlin"", ""Ruby"", ""Rust""]
    }
    
}
```

## Further Reading

* [Hjson.github.io](https://hjson.github.io/) Main Hjson site including editor support, how-to, etc.
* [Hjson Packages](https://github.com/hjson/) Various Hjson packages for different applications."
"# A special character (including a blank or tab) may be prevented from having
# its special meaning by preceding it with a backslash `\'.
# this will display the last history commands
echo !!
# this will not
echo \!\!

# Single quotes prevents expanding special characters too, but some
# characters like `!' and backslash have higher priority
# `$' (variable value) will not expands
echo '$1 tip'
# `!' (history) will expands
echo '!!'

# Strings enclosed by back-quotes will be executed and replaced by the result.
echo `ls`

# Semi-colon separate commands
echo 'first line'; echo 'second line'

# There is also conditional execution
echo ""Always executed"" || echo ""Only executed if first command fails""
echo ""Always executed"" && echo ""Only executed if first command does NOT fail""

# Parenthesised commands are always executed in a subshell,

# example: create a project and then informs you that it finished while
# it does the installation.
make && ( espeak ""BOSS, compilation finished""; make install )

# prints the home directory but leaving you where you were
(cd; pwd); pwd

# Read tcsh man-page documentation
man tcsh

# --- Variables ---------------------------------------------------------------
# The shell maintains a list of variables, each of which has as value a list of
# zero or more words. The values of shell variables can be displayed and
# changed with the `set' and `unset' commands.
# The system maintains its own list of ``environment'' variables.
# These can be displayed and changed with `printenv', `setenv' and `unsetenv'.
# The syntax of setenv is similar to POSIX sh.

# Assign a value or nothing will create a variable
# Assign nothing
set var
# Assign a numeric value
# the '@' denotes the expression is arithmetic; it works similar to 'set' but
# the right value can be a numeric expression.
@ var = 1 + 2
# Assign a string value
set var = ""Hello, I am the contents of 'var' variable""
# Assign the output of a program
set var = `ls`

# Remove a variable
unset var
# Prints 1 (true) if the variable `var' exists otherwise prints 0 (false)
echo $?var
# Print all variables and their values
set

# Prints the contents of 'var'
echo $var;
echo ""$var"";
# Prints the string `$var'
echo \$var
echo '$var'
# braces can be used to separate variable from the rest when its needed
set num = 12; echo ""There ${num}th element""

# Prints the number of characters of the value: 6
set var = '123456'; echo $%var

### LISTs
# Assign a list of values
set var = ( one two three four five )
# Print all the elements: one two three four five
echo $var
echo $var[*]
# Print the count of elements: 5
echo $#var
# Print indexed element; prints the second element: two
echo $var[2]
# Print range of elements; prints 2nd up to 3rd: two, three
echo $var[2-3]
# Prints all elements starting from the 3rd: three four five
echo $var[3-]
# Prints print all up to 3rd element: one two three
echo $var[-3]

### Special Variables
# $argv         list of command-line arguments
# $argv[0]      this file-name (the file of the script file)
# $# $0, $n, $* are the same as $#argv, $argv[0], $argv[n], $argv[*]
# $status, $?   the exit code of the last command that executed
# $_            the previous command line
# $!            the PID of the last background process started by this shell
# $$            script's PID

# $path, $PATH  the list of directories that will search for executable to run
# $home, $HOME  user's home directory, also the `~' can be used instead
# $uid          user's login ID
# $user         user's login name
# $gid          the user's group ID
# $group        the user's group-name
# $cwd, $PWD    the Current/Print Working Directory
# $owd          the previous working directory
# $tcsh         tcsh version
# $tty          the current tty; ttyN for linux console, pts/N for terminal
#               emulators under X
# $term         the terminal type
# $verbose      if set, causes the words of each command to be printed.
#               can be set by the `-v' command line option too.
# $loginsh      if set, it is a login shell

# TIP: $?0 is always false in interactive shells
# TIP: $?prompt is always false in non-interactive shells
# TIP: if `$?tcsh' is unset; you run the original `csh' or something else;
#      try `echo $shell'
# TIP: $verbose this is useful to debugging scripts
# NOTE: $PWD and $PATH are synchronised with $cwd and $pwd automatically.

# --- Variable modifiers ------------------------------------------------------
# Syntax: ${var}:m[:mN]
# Where <m> is:
# h : the directory  t : the filenane  r : remove extension   e : the extension
# u : uppercase the first lowercase letter
# l : lowercase the first uppercase letter
# p : print but do not execute it (hist)
# q : quote the substituted words, preventing further substitutions
# x : like q, but break into words at white spaces
# g : apply the following modifier once to each word
# a  : apply the following modifier as many times as possible to single word
# s/l/r/ : search for `l' and replace with `r', not regex; the `&' in the r is
# replaced by l
# & : Repeat the previous substitution

# start with this file
set f = ~/Documents/Alpha/beta.txt
# prints ~/Documents/Alpha/beta
echo $f:r
# prints ~/Documents/Alpha
echo $f:h
# prints beta.txt
echo $f:t
# prints txt
echo $f:e
# prints beta
echo $f:t:r
# prints Beta
echo $f:t:r:u
# prints Biota
echo $f:t:r:u:s/eta/iota/

# --- Redirection -------------------------------------------------------------

# Create file.txt and write the standard output to it
echo 'this string' > file.txt
# Create file.txt and write the standard output and standard error to it
echo 'this string' >& file.txt
# Append the standard output to file.txt
echo 'this string' >> file.txt
# Append the standard output and standard error to file.txt
echo 'this string' >>& file.txt
# Redirect the standard input from file.txt
cat < file.txt
# Input from keyboard; this stores the input line to variable `x'
set x = $<
# Document here;
cat << LABEL
...text here...
LABEL

# TIP: this is how to get standard error separated:
(grep 'AGP' /usr/src/linux/Documentation/* > output-file.txt) >& error-file.txt

# example: read a name from standard input and display a greetings message
echo -n ""Enter your name? ""
set name = $<
echo ""Greetings $name""

# --- Expressions ------------------------------------------------------------

# Operators:
# ==  equal         !=  not equal    !  not
#  >  greater than   <  less than   >=  greater or equal  <= less or equal
# &&  logical AND   ||  logical OR

if ( $name != $user ) then
    echo ""Your name isn't your username""
else
    echo ""Your name is your username""
endif

# single-line form
if ( $name != $user ) echo ""Your name isn't your username""

# NOTE: if $name is empty, tcsh sees the above condition as:
# if ( != $user ) ...
# which is invalid syntax
# so the ""safe"" way to use potentially empty variables in tcsh is:
# if ( ""$name"" != $user ) ...
# which, when $name is empty, is seen by tcsh as:
# if ( """" != $user ) ...
# which works as expected

# There is also conditional execution
echo ""Always executed"" || echo ""Only executed if first command fails""
echo ""Always executed"" && echo ""Only executed if first command does NOT fail""

# To use && and || with if statements, you don't need multiple pairs of
# square brackets:
if ( ""$name"" == ""Steve"" && ""$age"" == 15 ) then
    echo ""This will run if $name is Steve AND $age is 15.""
endif

if ( ""$name"" == ""Daniya"" || ""$name"" == ""Zach"" ) then
    echo ""This will run if $name is Daniya OR Zach.""
endif

# String matching operators ( `=~' and `!~' )
# The ‘==’ ‘!=’ ‘=~’ and ‘!~’ operators compare their arguments as strings;
# all others operate on numbers. The operators ‘=~’ and ‘!~’ are like ‘!=’
# and ‘==’ except that the right hand side is a glob-pattern against which
# the left hand operand is matched.

if ( $user =~ ni[ck]* ) echo ""Greetings Mr. Nicholas.""
if ( $user !~ ni[ck]* ) echo ""Hey, get out of Nicholas PC.""

# Arithmetic expressions are denoted with the following format:
@ result = 10 + 5
echo $result

# Arithmetic Operators
# +, -, *, /, %
#
# Arithmetic Operators which must be parenthesised
# !, ~, |, &, ^, ~, <<, >>,
# Compare and logical operators
#
# All operators are same as in C.

# It is non so well documented that numeric expressions require spaces
# in-between; Also, `@' has its own parser, it seems that work well when the
# expression is parenthesised otherwise the primary parser seems it is active.
# Parenthesis require spaces around, this is documented.

# wrong
@ x = $y+1
@ x = 0644 & 022;      echo $x
@ x = (0644 & 022) +1; echo $x
@ x = (0644 & 022)+ 1; echo $x
@ x = ( ~077 );        echo $x

# correct
@ x = $y + 1
@ x = ( 0644 & 022 ) + 1; echo $x
@ x = ( ~ 077 );          echo $x
@ x = ( ~ 077 | 022 );    echo $x
@ x = ( ! 0 );            echo $x

# C's operators ++ and -- are supported if there is not assignment
@ result ++

# None shell created to do mathematics;
# Except for the basic operations, use an external command with backslashes.
#
# I suggest the calc as the best option.
# (http://www.isthe.com/chongo/tech/comp/calc/)
#
# The standard Unix's bc as second option
# (https://www.gnu.org/software/bc/manual/html_mono/bc.html)
#
# The standard Unix's AWK as third option
# (https://www.gnu.org/software/gawk/manual/gawk.html)

# You can also use `perl', `php' or even several BASICs, but prefer the
# above utilities for faster load-and-run results.

# real example: (that I answer in StackExchange)
# REQ: x := 1001b OR 0110b

# in `tcsh' expression (by using octal)
@ x = ( 011 | 06 ); echo $x

# the same by using `calc' (and using binary as the original req)
set x = `calc '0b1001 | 0b110'`; echo $x

# --- File Inquiry Operators --------------------------------------------------
# NOTE: The builtin `filetest' command do the same thing.

#### Boolean operators
# -r  read access    -w  write access    -x  execute access    -e  existence
# -f  plain file     -d  directory       -l  symbolic link     -p  named pipe
# -S  socket file
# -o  ownership      -z  zero size       -s  non-zero size
# -u  SUID is set    -g  SGID is set     -k  sticky is set
# -b  block device   -c  char device
# -t  file (digit) is an open file descriptor for a terminal device

# if the file `README' exists, displays a message
if ( -e README ) echo ""I have already README file""

# if the `less' program is installed, use this instead of `more'
if ( -e `where less` ) then
	alias more 'less'
endif

#### Non-boolean operators
# -Z  returns the file size in bytes
# -M  returns the modification time (mtime)    -M: returns mtime string
# -A  returns the lass access time (atime)     -A: returns atime string
# -U  returns the owners user ID               -U: returns the owners user-name
# -G  returns the group ID                     -G: returns the group-name
# -P  returns the permissions as octal number  -Pmode returns perm. AND mode

# this will display the date as Unix-time integer: 1498511486
filetest -M README.md

# This will display ""Tue Jun 27 00:11:26 2017""
filetest -M: README.md

# --- Basic Commands ----------------------------------------------------------

# Navigate though file system with `chdir' (cd)
cd path # change working directory
cd      # change to home directory
cd -    # change to previous directory
cd ..   # go up one directory

# Examples:
cd ~/Downloads # go to my `Downloads' directory

# Use `mkdir` to create new directories.
mkdir newdir
# The `-p` flag causes new intermediate directories to be created as necessary.
mkdir -p ~/.backup/saves

# which & where
# find if csh points to tcsh
ls -lha `which csh`
# find if csh is installed on more than one directory
where csh

# --- Pipe-lines --------------------------------------------------------------
# A pipeline is a sequence of processes chained together by their standard
# streams, so that the output of each process (stdout) feeds directly as input
# (stdin) to the next one. This `pipes' are created with the `|' special
# character and it is one of the most powerful characteristics of Unix.

# example:
ls -l | grep key | less
# ""ls -l"" produces a process, the output (stdout) of which is piped to the
# input (stdin) of the process for ""grep key""; and likewise for the process
# for ""less"".

# the `ls', the `grep' and the `less' are programs of Unix and they have their
# own man-page. The `pipe' mechanism is part of the kernel but the syntax
# and the control is job of the shell, the tcsh in our case.

# NOTE: `pipe' mechanism has Windows too, but it is buggy and I sign it for all
# versions until Windows XP SP3 API32 which was the last one that I worked on.
# Microsoft still denied it but is well known bug since it is a common method
# for inter-process communication. For small I/O it will work well.
# tcsh, along with grep, gcc and perl is one of the first Unix programs that
# ported to DOS (with EMX DOS extender) and later to Windows (1998).

# example: this will convert tcsh to PostScript and will show it with okular
zcat /usr/man/man1/tcsh.1.gz | groff -Tps -man | okular -

# a better version
zcat `locate -b -n 1 '\tcsh.1.gz'` | groff -Tps -man | okular -

# even better
set page = tcsh; set loc = (locate -b -n 1 ""\\\\""${page}"".1.gz"");
 zcat `eval $loc` | groff -Tps -man | okular -

# the same, modified to create man page pdf
set page = tcsh; set loc = (locate -b -n 1 ""\\\\""${page}"".1.gz"");
 zcat `eval $loc` | groff -Tps -man | ps2pdf - ${page}.pdf

# the same, but now shows the ${page}.pdf too
set page = tcsh; set loc = (locate -b -n 1 ""\\\\""${page}"".1.gz"");
 zcat `eval $loc` | groff -Tps -man | ps2pdf - ${page}.pdf && okular tcsh.pdf

# NOTE: `okular' is the default application of KDE environment and it shows
# postcript and pdf files. You can replace it with your lovely pdf viewer.
# zcat, locate, groff, are common programs in all Unices. `ps2pdf' program
# is part of `ghostscript' package that is widely used.

# --- Control Flow ------------------------------------------------------------

#### IF-THEN-ELSE-ENDIF
# Syntax:
# if ( expr ) then
#    ...
# [else if ( expr2 ) then
#    ...]
# [else
#    ...]
# endif
#
# If the specified expr is true then the commands to the first else are
# executed; otherwise if expr2 is true then the commands to the second else
# are executed, etc.
# Any number of else-if pairs are possible; only one endif is needed.
#
# Single-line form:
#
# if ( expr ) command
#
# If `expr' evaluates true, then command is executed.
# `command' must be a simple command, not an alias, a pipeline, a command list
# or a parenthesized command list. With few words, avoid to use it.
#
# BUG: Input/output redirection occurs even if expr is false and command is
# thus not executed.
#

# check if we are in non-interactive shell and quit if true
if ( $?USER == 0 || $?prompt == 0 ) exit

# check if we are a login shell
if ( $?loginsh ) then
	# check if you are on linux console (not X's terminal)
	if ( $tty =~ tty* ) then
		# enable keypad application keys (man console_codes)
		echo '\033='
	endif
endif

#### SWITCH-ENDSW
# Syntax:
# switch ( expr )
# case pattern:
#     ...
#     [breaksw]
# [default:
#     ...]
# endsw
#
# tcsh uses a case statement that works similarly to switch in C.
# Each case label is successively matched, against the specified string which
# is first command and filename  expanded. The file  metacharacters `*', `?'
# and `[...]' may be used in the case labels. If none of the labels match the
# execution begins after the default label if its defined.
# The command `breaksw' causes execution to continue after the endsw. Otherwise
# control may fall through case labels and default labels as in C.

switch ( $var )
case *.[1-9]:
case *.[1-9].gz:
	echo ""$var is a man-page.""
	breaksw
case *gz:
	echo ""$var is gzipped""
	breaksw
default:
	file $var
endsw

#### FOREACH-END
# Syntax:
# foreach name ( wordlist )
#	...
#   [break | continue]
# end
#
# Successively sets the variable `name' to each member of `wordlist' and
# executes the sequence of commands between this command and the matching
# `end' keyword. The `continue' keyword jump to the next element back to
# top; and the `break' keyword terminates the loop.
#
# BUG: `foreach' doesn't ignore here documents when looking for its end.

# example: counting 1 to 10
foreach i ( `seq 1 10` )
    echo $i
end

# example: type all files in the list
foreach f ( a.txt b.txt c.txt )
	cat $f
end

# example: convert wma to ogg
foreach f ( *.wma )
	ffmpeg -i ""$f"" ""$f:r"".ogg
end

#### WHILE-END
# while ( expr )
#     ...
#     [break | continue]
# end
#
# Executes the commands between the `while' and the matching `end' while `expr'
# evaluates non-zero. `break' and `continue' may be used to terminate or
# continue the loop prematurely.

# count from 1 to 10
set num = 1
while ( $num <= 10 )
	echo $num
	@ num ++
end

# print all directories of CWD
set lst = ( * )
while ( $#lst )
	if ( -d $lst[1] ) echo $lst[1] is directory
	shift lst
end

# separate command-line arguments to options or parameters
set options
set params
set lst = ( $* )
while ( $#lst )
	if ( ""$lst[1]"" =~ '-*' ) then
		set options = ( $options $lst[1] )
	else
		set params = ( $params $lst[1] )
	endif
	shift lst
end
echo 'options =' $options
echo 'parameters =' $params

#### REPEAT
# Syntax: repeat count command
#
# The specified command, which is subject to the same restrictions as the
# command in the one line if statement above, is executed count times.
# I/O redirections occur exactly once, even if count is 0.
#
# TIP: in most cases prefer `while'

repeat 3 echo ""ding dong""

# --- Functions ---------------------------------------------------------------
# tcsh has no functions but its expression syntax is advanced enough to use
# `alias' as functions. Another method is recursion

# Alias argument selectors; the ability to define an alias to take arguments
# supplied to it and apply them to the commands that it refers to.
# Tcsh is the only shell that provides this feature.
#
# \!#   argument selector for all arguments, including the alias/command
#       itself; arguments need not be supplied.
# \!*   argument selector for all arguments, excluding the alias/command;
#       arguments need not be supplied.
# \!$   argument selector for the last argument; argument need not be supplied,
#       but if none is supplied, the alias name is considered to be the
#       last argument.
# \!^   argument selector for first argument; argument MUST be supplied.
# \!:n  argument selector for the nth argument; argument MUST be supplied;
#       n=0 refers to the alias/command name.
# \!:m-n   argument selector for the arguments from the mth to the nth;
#       arguments MUST be supplied.
# \!:n-$   argument selector for the arguments from the nth to the last;
#       at least argument n MUST be supplied.

# Alias the cd command so that when you change directories, the contents
# are immediately displayed.
alias cd 'cd \!* && ls'

# --- Recursion method --- begin ---
#!/bin/tcsh -f
set todo = option1
if ( $#argv > 0 ) then
	set todo = $argv[1]
endif

switch ( $todo )
case option1:
#	...
	$0 results
	breaksw
case option2:
#	...
	$0 results
	breaksw
case results:
	echo ""print the results here""
#	...
	breaksw
default:
	echo ""Unknown option: $todo""
#	exit 0
endsw
# --- Recursion method --- end ---

# --- examples ----------------------------------------------------------------

# this script prints available power-states if no argument is set;
# otherwise it set the state of the $argv[1]
# --- power-state script --- begin --------------------------------------------
#!/bin/tcsh -f
# get parameter (""help"" for none)
set todo = help
if ( $#argv > 0 ) then
	set todo = $argv[1]
endif
# available options
set opts = `cat /sys/power/state`
# is known?
foreach o ( $opts )
	if ( $todo == $o ) then
		# found; execute it
		echo -n $todo > /sys/power/state
		break
	endif
end
# print help and exit
echo ""usage: $0 [option]""
echo ""available options on kernel: $opts""
# --- power-state script --- end ----------------------------------------------

# Guess the secret number game
# --- secretnum.csh --- begin -------------------------------------------------
#!/bin/tcsh -f
set secret=`shuf -i1-100 -n1`
echo ""I have a secret number from 1 up to 100""
while ( 1 )
	echo -n ""Guess: ""
	set guess = $<
	if ( $secret == $guess ) then
		echo ""You found it""
		exit 1
	else
		if ( $secret > $guess ) then
			echo ""its greater""
		else if ( $secret < $guess ) then
				echo ""its lesser""
			endif
		endif
	endif
end
# --- secretnum.csh --- end ---------------------------------------------------

# -----------------------------------------------------------------------------
# Appendices

#### About [T]CSH:
# * CSH is notorious about its bugs;
# * It was also famous about its advanced interactive mode.
# * TCSH is famous that have the most advanced completion subsystem.
# * TCSH is famous that have the most advanced aliases subsystem; aliases
#   can take parameters and often used as functions!
# * TCSH is well known that preferred by people  (me too) because of better
#   syntax. All shells are using Thomson's syntax with exception of [t]csh,
#   fish and plan9's shells (rc, ex).
# * It is smaller and consume far less memory than bash, zsh even mksh!
#   (memusage reports)
# * TCSH still has bugs; less but have; if you write readable clean code you'll
#   find none; well almost none... This has to do with the implementation of
#   csh; that no means the other shells has good implementation.
# * no one well known shell is capable for regular programming; if your script
#   getting big, use a programming language, or at least PHP or Perl (good
#   script languages).
#
# Advises:
# 1. Do not use redirection in single-line if (it is well documented bug)
#    In most cases avoid to use single-line IFs.
# 2. Do not mess up with other shells code, c-shell is not compatible with
#    other shells and has different abilities and priorities.
# 3. Use spaces as you'll use them to write readable code in any language.
#    A bug of csh was `set x=1' worked, `set x = 1' worked, `set x =1' did not!
# 4. It is well documented that numeric expressions require spaces in-between;
#    also parenthesise all bit-wise and unary operators.
# 5. Do not write a huge weird expression with several quotes, backslashes etc
#    It is bad practice for generic programming, it is dangerous in any shell.
# 6. Help tcsh, report the bug here <https://bugs.gw.com/>
# 7. Read the man page, `tcsh' has huge number of options, and variables.
#
#    I suggest the following options enabled by default
#    --------------------------------------------------
# Even in non-interactive shells
#    set echo_style=both
#    set backslash_quote
#    set parseoctal
#    unset noclobber
#
# Whatever...
#    set inputmode=insert
#    set autolist
#    set listjobs
#    set padhour
#    set color
#    set colorcat
#    set nobeep
#    set cdtohome
#
#    set histdup
#    set histlit
#    set nohistclop
#
#    unset compat_expr
#    unset noglob
#    unset autologout
#    unset time
#    unset tperiod
#
# NOTE: If the `backslash_quote' is set, it may create compatibility issues
# with other tcsh scripts which was written without it.
#
# NOTE: The same for `parseoctal', but it is better to fix the problematic
# scripts.
#
# NOTE: **for beginners only**
# This enable automatically rescan `path' directories if need to. (like bash)
#    set autorehash

#### common aliases
#    alias hist  'history 20'
#    alias ll    'ls --color -lha'
#    alias today ""date '+%d%h%y'
#    alias ff    'find . -name '

#### a nice prompt
#    set prompt = ""%B%{\033[35m%}%t %{\033[32m%}%n@%m%b %C4 %# ""
```"
"Logtalk is an object-oriented logic programming language that extends and leverages Prolog with modern code encapsulation and code reuse mechanisms without compromising its declarative programming features. Logtalk is implemented in highly portable code and can use most modern and standards compliant Prolog implementations as a back-end compiler.

To keep its size reasonable, this tutorial necessarily assumes that the reader have a working knowledge of Prolog and is biased towards describing Logtalk object-oriented features.

# Syntax

Logtalk uses standard Prolog syntax with the addition of a few operators and directives for a smooth learning curve and wide portability. One important consequence is that Prolog code can be easily encapsulated in objects with little or no changes. Moreover, Logtalk can transparently interpret most Prolog modules as Logtalk objects.

The main operators are:

* `::/2` - sending a message to an object
* `::/1` - sending a message to _self_ (i.e. to the object that received the message being processed)
* `^^/1` - _super_ call (of an inherited or imported predicate)

Some of the most important entity and predicate directives will be introduced in the next sections.

# Entities and roles

Logtalk provides _objects_, _protocols_, and _categories_ as first-class entities. Relations between entities define _patterns of code reuse_ and the _roles_ played by the entities. For example, when an object _instantiates_ another object, the first object plays the role of an instance and the second object plays the role of a class. An _extends_ relation between two objects implies that both objects play the role of prototypes, with one of them extending the other, its parent prototype.

# Defining an object

An object encapsulates predicate declarations and definitions. Objects can be created dynamically but are usually static and defined in source files. A single source file can contain any number of entity definitions. A simple object, defining a list member public predicate:

```logtalk
:- object(list).

	:- public(member/2).
	member(Head, [Head| _]).
	member(Head, [_| Tail]) :-
		member(Head, Tail).

:- end_object.
```

# Compiling and loading source files

Assuming that the code above for the `list` object is saved in a `list.lgt` file, it can be compiled and loaded using the `logtalk_load/1` built-in predicate or its abbreviation, `{}/1`, with the file path as argument (the extension can be omitted):

```logtalk
?- {list}.
yes
```

In general, entities may have dependencies on entities defined in other source files (e.g. library entities). To load a file and all its dependencies, the advised solution is to define a 
_loader_ file that loads all the necessary files for an application. A loader file is simply a source file, typically named `loader.lgt`, that makes calls to the `logtalk_load/1-2`
built-in predicates, usually from an `initialization/1` directive for portability and
standards compliance. Loader files are provided for all libraries, tools, and examples.

# Sending a message to an object

The `::/2` infix operator is used to send a message to an object. As in Prolog, we can backtrack for alternative solutions:

```logtalk
?- list::member(X, [1,2,3]).
X = 1 ;
X = 2 ;
X = 3
yes
```

Encapsulation is enforced. A predicate can be declared _public_, _protected_, or _private_. It can also be _local_ when there is no scope directive for it. For example:

```logtalk
:- object(scopes).

	:- private(bar/0).
	bar.

	local.

:- end_object.
```

Assuming the object is saved in a `scopes.lgt` file:

```logtalk
?- {scopes}.
yes

?- catch(scopes::bar, Error, true).
Error = error(
	permission_error(access, private_predicate, bar/0),
	logtalk(scopes::bar, user)
)
yes

?- catch(scopes::local, Error, true).
Error = error(
	existence_error(predicate_declaration, local/0),
	logtalk(scopes::local, user)
)
yes
```

When the predicate in a message is unknown for the object (the role it plays determines the lookup procedures), we also get an error. For example:

```logtalk
?- catch(scopes::unknown, Error, true).
Error = error(
	existence_error(predicate_declaration, unknown/0),
	logtalk(scopes::unknown, user)
)
yes
```

A subtle point is that predicate scope directives specify predicate _calling_ semantics, not _definition_ semantics. For example, if an object playing the role of a class declares a predicate private, the predicate can be defined in subclasses and instances *but* can only be called in its instances _from_ the class.

# Defining and implementing a protocol

Protocols contain predicate declarations that can be implemented by any number of objects and categories:

```logtalk
:- protocol(listp).

	:- public(member/2).

:- end_protocol.

:- object(list,
	implements(listp)).

	member(Head, [Head| _]).
	member(Head, [_| Tail]) :-
		member(Head, Tail).

:- end_object.
```

The scope of the protocol predicates can be restricted using protected or private implementation. For example:

```logtalk
:- object(stack,
	implements(private::listp)).

:- end_object.
```

In fact, all entity relations (in an entity opening directive) can be qualified as public (the default), protected, or private.

# Prototypes

An object without an _instantiation_ or _specialization_ relation with another object plays the role of a prototype. A prototype can _extend_ another object, its parent prototype.

```logtalk
% clyde, our prototypical elephant
:- object(clyde).

	:- public(color/1).
	color(grey).

	:- public(number_of_legs/1).
	number_of_legs(4).

:- end_object.

% fred, another elephant, is like clyde, except that he's white
:- object(fred,
	extends(clyde)).

	color(white).

:- end_object.
```

When answering a message sent to an object playing the role of a prototype, we validate the message and look for an answer first in the prototype itself and, if not found, we delegate to the prototype parents if any:

```logtalk
?- fred::number_of_legs(N).
N = 4
yes

?- fred::color(C).
C = white
yes
```

A message is valid if the corresponding predicate is declared (and the sender is within scope) but it will fail, rather then throwing an error, if the predicate is not defined. This is called the _closed-world assumption_. For example, consider the following object, saved in a `foo.lgt` file:

```logtalk
:- object(foo).

	:- public(bar/0).

:- end_object.
```

Loading the file and trying to call the `bar/0` predicate fails as expected. Note that this is different from calling an _unknown_ predicate, which results in an error:

```logtalk
?- {foo}.
yes

?- foo::bar.
no

?- catch(foo::baz, Error, true).
Error = error(
	existence_error(predicate_declaration, baz/0),
	logtalk(foo::baz, user)
)
yes
```

# Classes and instances

In order to define objects playing the role of classes and/or instances, an object must have at least an instantiation or a specialization relation with another object. Objects playing the role of meta-classes can be used when we need to see a class also as an instance. We use the following example to also illustrate how to dynamically create new objects at runtime:

```logtalk
% a simple, generic, metaclass defining a new/2 predicate for its instances
:- object(metaclass,
	instantiates(metaclass)).

	:- public(new/2).
	new(Instance, Clauses) :-
		self(Class),
		create_object(Instance, [instantiates(Class)], [], Clauses).

:- end_object.

% a simple class defining age/1 and name/1 predicate for its instances
:- object(person,
	instantiates(metaclass)).

	:- public([
		age/1, name/1
	]).

	% a default value for age/1
	age(42).

:- end_object.

% a static instance of the class person
:- object(john,
	instantiates(person)).

	name(john).
	age(12).

:- end_object.
```

When answering a message sent to an object playing the role of an instance, we validate the message by starting in its class and going up to its class superclasses if necessary. Assuming that the message is valid, then we look for an answer starting in the instance itself:

```logtalk
?- person::new(Instance, [name(paulo)]).
Instance = o1
yes

?- o1::name(Name).
Name = paulo
yes

?- o1::age(Age).
Age = 42
yes

?- john::age(Age).
Age = 12
yes
```

# Categories

A category is a fine grained unit of code reuse, used to encapsulate a _cohesive_ set of predicate declarations and definitions, implementing a _single_ functionality, that can be imported into any object. A category can thus be seen as the dual concept of a protocol. In the following example, we define categories representing car engines and then import them into car objects:

```logtalk
% a protocol describing engine characteristics
:- protocol(carenginep).

	:- public([
		reference/1,
		capacity/1,
		cylinders/1,
		horsepower_rpm/2,
		bore_stroke/2,
		fuel/1
	]).

:- end_protocol.

% a typical engine defined as a category
:- category(classic,
	implements(carenginep)).

	reference('M180.940').
	capacity(2195).
	cylinders(6).
	horsepower_rpm(94, 4800).
	bore_stroke(80, 72.8).
	fuel(gasoline).

:- end_category.

% a souped up version of the previous engine
:- category(sport,
	extends(classic)).

	reference('M180.941').
	horsepower_rpm(HP, RPM) :-
		^^horsepower_rpm(ClassicHP, ClassicRPM),	% ""super"" call
		HP is truncate(ClassicHP*1.23),
		RPM is truncate(ClassicRPM*0.762).

:- end_category.

% with engines (and other components), we may start ""assembling"" some cars
:- object(sedan,
	imports(classic)).

:- end_object.

:- object(coupe,
	imports(sport)).

:- end_object.
```

Categories are independently compiled and thus allow importing objects to be updated by simple updating the imported categories without requiring object recompilation. Categories also provide _runtime transparency_. I.e. the category protocol adds to the protocol of the objects importing the category:

```logtalk
?- sedan::current_predicate(Predicate).
Predicate = reference/1 ;
Predicate = capacity/1 ;
Predicate = cylinders/1 ;
Predicate = horsepower_rpm/2 ;
Predicate = bore_stroke/2 ;
Predicate = fuel/1
yes
```

# Hot patching

Categories can be also be used for hot-patching objects. A category can add new predicates to an object and/or replace object predicate definitions. For example, consider the following object:

```logtalk
:- object(buggy).

	:- public(p/0).
	p :- write(foo).

:- end_object.
```

Assume that the object prints the wrong string when sent the message `p/0`:

```logtalk
?- {buggy}.
yes

?- buggy::p.
foo
yes
```

If the object source code is not available and we need to fix an application running the object code, we can simply define a category that fixes the buggy predicate:

```logtalk
:- category(patch,
	complements(buggy)).

	% fixed p/0 def
	p :- write(bar).

:- end_category.
```

After compiling and loading the category into the running application we will now get:

```logtalk
?- {patch}.
yes

?- buggy::p.
bar
yes
```

As hot-patching forcefully breaks encapsulation, there is a `complements` compiler flag that can be set (globally or on a per-object basis) to allow, restrict, or prevent it.

# Parametric objects and categories

Objects and categories can be parameterized by using as identifier a compound term instead of an atom. Object and category parameters are _logical variables_ shared with all encapsulated predicates. An example with geometric circles:

```logtalk
:- object(circle(_Radius, _Color)).

	:- public([
		area/1, perimeter/1
	]).

	area(Area) :-
		parameter(1, Radius),
		Area is pi*Radius*Radius.

	perimeter(Perimeter) :-
		parameter(1, Radius),
		Perimeter is 2*pi*Radius.

:- end_object.
```

Parametric objects are used just as any other object, usually providing values for the parameters when sending a message:

```logtalk
?- circle(1.23, blue)::area(Area).
Area = 4.75291
yes
```

Parametric objects also provide a simple way of associating a set of predicates with a plain Prolog predicate. Prolog facts can be interpreted as _parametric object proxies_ when they have the same functor and arity as the identifiers of parametric objects. Handy syntax is provided to for working with proxies. For example, assuming the following clauses for a `circle/2` predicate:

```logtalk
circle(1.23, blue).
circle(3.71, yellow).
circle(0.39, green).
circle(5.74, black).
circle(8.32, cyan).
```

With these clauses loaded, we can easily compute for example a list with the areas of all the circles:

```logtalk
?- findall(Area, {circle(_, _)}::area(Area), Areas).
Areas = [4.75291, 43.2412, 0.477836, 103.508, 217.468]
yes
```

The `{Goal}::Message` construct proves `Goal`, possibly instantiating any variables in it, and sends `Message` to the resulting term.

# Events and monitors

Logtalk supports _event-driven programming_ by allowing defining events and monitors for those events. An event is simply the sending of a message to an object. Interpreting message sending as an atomic activity, a _before_ event and an _after_ event are recognized. Event monitors define event handler predicates, `before/3` and `after/3`, and can query, register, and delete a system-wide event registry that associates events with monitors. For example, a simple tracer for any message being sent using the `::/2` control construct can be defined as:

```logtalk
:- object(tracer,
	implements(monitoring)).    % built-in protocol for event handlers

	:- initialization(define_events(_, _, _, _, tracer)).

	before(Object, Message, Sender) :-
		write('call: '), writeq(Object), write(' <-- '), writeq(Message),
		write(' from '), writeq(Sender), nl.

	after(Object, Message, Sender) :-
		write('exit: '), writeq(Object), write(' <-- '), writeq(Message),
		write(' from '), writeq(Sender), nl.

:- end_object.
```

Assuming that the `tracer` object and the `list` object defined earlier are compiled and loaded, we can observe the event handlers in action by sending a message:

```logtalk
?- list::member(X, [1,2,3]).

call: list <-- member(X, [1,2,3]) from user
exit: list <-- member(1, [1,2,3]) from user
X = 1 ;
exit: list <-- member(2, [1,2,3]) from user
X = 2 ;
exit: list <-- member(3, [1,2,3]) from user
X = 3
yes
```

Events can be set and deleted dynamically at runtime by calling the `define_events/5` and `abolish_events/5` built-in predicates.

Event-driven programming can be seen as a form of _computational reflection_. But note that events are only generated when using the `::/2` message-sending control construct.

# Lambda expressions

Logtalk supports lambda expressions. Lambda parameters are represented using a list with the `(>>)/2` infix operator connecting them to the lambda. Some simple examples using library meta-predicates:

```logtalk
?- {library(metapredicates_loader)}.
yes

?- meta::map([X,Y]>>(Y is 2*X), [1,2,3], Ys).
Ys = [2,4,6]
yes
```

Currying is also supported:

```logtalk
?- meta::map([X]>>([Y]>>(Y is 2*X)), [1,2,3], Ys).
Ys = [2,4,6]
yes
```

Lambda free variables can be expressed using the extended syntax `{Free1, ...}/[Parameter1, ...]>>Lambda`.

# Macros

Terms and goals in source files can be _expanded_ at compile time by specifying a _hook object_ that defines term-expansion and goal-expansion rules. For example, consider the following simple object, saved in a `source.lgt` file:

```logtalk
:- object(source).

	:- public(bar/1).
	bar(X) :- foo(X).

	foo(a). foo(b). foo(c).

:- end_object.
```

Assume the following hook object, saved in a `my_macros.lgt` file, that expands clauses and calls to the `foo/1` local predicate:

```logtalk
:- object(my_macros,
	implements(expanding)).    % built-in protocol for expanding predicates

	term_expansion(foo(Char), baz(Code)) :-
		char_code(Char, Code). % standard built-in predicate

	goal_expansion(foo(X), baz(X)).

:- end_object.
```

After loading the macros file, we can then expand our source file with it using the `hook` compiler flag:

```logtalk
?- logtalk_load(my_macros), logtalk_load(source, [hook(my_macros)]).
yes

?- source::bar(X).
X = 97 ;
X = 98 ;
X = 99
true
```

The Logtalk library provides support for combining hook objects using different workflows (for example, defining a pipeline of expansions).

# Further information

Visit the [Logtalk website](http://logtalk.org) for more information."
"Set theory is a branch of mathematics that studies sets, their operations, and their properties.

* A set is a collection of disjoint items.

## Basic symbols

### Operators
* the union operator, `∪`, pronounced ""cup"", means ""or"";
* the intersection operator, `∩`, pronounced ""cap"", means ""and"";
* the exclusion operator, `\`, means ""without"";
* the complement operator, `'`, means ""the inverse of"";
* the cross operator, `×`, means ""the Cartesian product of"".

### Qualifiers 
* the colon, `:`, or the vertical bar `|` qualifiers are interchangeable and mean ""such that"";
* the membership qualifier, `∈`, means ""belongs to"";
* the subset qualifier, `⊆`, means ""is a subset of"";
* the proper subset qualifier, `⊂`, means ""is a subset of but is not equal to"".

### Canonical sets
* `∅`, the empty set, i.e. the set containing no items;
* `ℕ`, the set of all natural numbers;
* `ℤ`, the set of all integers;
* `ℚ`, the set of all rational numbers;
* `ℝ`, the set of all real numbers.

There are a few caveats to mention regarding the canonical sets:
1. Even though the empty set contains no items, the empty set is a subset of itself (and indeed every other set);
2. Mathematicians generally do not universally agree on whether zero is a natural number, and textbooks will typically explicitly state whether or not the author considers zero to be a natural number.


### Cardinality

The cardinality, or size, of a set is determined by the number of items in the set. The cardinality operator is given by a double pipe, `|...|`.

For example, if `S = { 1, 2, 4 }`, then `|S| = 3`.

### The Empty Set
* The empty set can be constructed in set builder notation using impossible conditions, e.g. `∅ = { x : x ≠ x }`, or `∅ = { x : x ∈ N, x < 0 }`;
* the empty set is always unique (i.e. there is one and only one empty set);
* the empty set is a subset of all sets;
* the cardinality of the empty set is 0, i.e. `|∅| = 0`.

## Representing sets

### Literal Sets

A set can be constructed literally by supplying a complete list of objects contained in the set. For example, `S = { a, b, c, d }`.

Long lists may be shortened with ellipses as long as the context is clear. For example, `E = { 2, 4, 6, 8, ... }` is clearly the set of all even numbers, containing an infinite number of objects, even though we've only explicitly written four of them.

### Set Builder

Set builder notation is a more descriptive way of constructing a set. It relies on a _subject_ and a _predicate_ such that `S = { subject : predicate }`. For example,

```
A = { x : x is a vowel } = { a, e, i, o, u }
B = { x : x ∈ N, x < 10 } = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
C = { x : x = 2k, k ∈ N } = { 0, 2, 4, 6, 8, ... }
```

Sometimes the predicate may ""leak"" into the subject, e.g.

```
D = { 2x : x ∈ N } = { 0, 2, 4, 6, 8, ... }
```

## Relations

### Membership

* If the value `a` is contained in the set `A`, then we say `a` belongs to `A` and represent this symbolically as `a ∈ A`.
* If the value `a` is not contained in the set `A`, then we say `a` does not belong to `A` and represent this symbolically as `a ∉ A`.

### Equality

* If two sets contain the same items then we say the sets are equal, e.g. `A = B`.
* Order does not matter when determining set equality, e.g. `{ 1, 2, 3, 4 } = { 2, 3, 1, 4 }`.
* Sets are disjoint, meaning elements cannot be repeated, e.g. `{ 1, 2, 2, 3, 4, 3, 4, 2 } = { 1, 2, 3, 4 }`.
* Two sets `A` and `B` are equal if and only if `A ⊆ B` and `B ⊆ A`.

## Special Sets

### The Power Set
* Let `A` be any set. The set that contains all possible subsets of `A` is called a ""power set"" and is written as `P(A)`. If the set `A` contains `n` elements, then `P(A)` contains `2^n` elements.

```
P(A) = { x : x ⊆ A }
```

## Set operations among two sets
### Union
Given two sets `A` and `B`, the union of the two sets are the items that appear in either `A` or `B`, written as `A ∪ B`.

```
A ∪ B = { x : x ∈ A ∪ x ∈ B }
```

### Intersection
Given two sets `A` and `B`, the intersection of the two sets are the items that appear in both `A` and `B`, written as `A ∩ B`.

```
A ∩ B = { x : x ∈ A, x ∈ B }
```

### Difference
Given two sets `A` and `B`, the set difference of `A` with `B` is every item in `A` that does not belong to `B`.

```
A \ B = { x : x ∈ A, x ∉ B }
```

### Symmetrical difference
Given two sets `A` and `B`, the symmetrical difference is all items among `A` and `B` that doesn't appear in their intersections.

```
A △ B = { x : ((x ∈ A) ∩ (x ∉ B)) ∪ ((x ∈ B) ∩ (x ∉ A)) }

A △ B = (A \ B) ∪ (B \ A)
```

### Cartesian product
Given two sets `A` and `B`, the cartesian product between `A` and `B` consists of a set containing all combinations of items of `A` and `B`.

```
A × B = { (x, y) | x ∈ A, y ∈ B }
```"
"Red was created out of the need to get work done, and the tool the author wanted to use, the language of REBOL, had a couple of drawbacks.
It was not Open Sourced at that time and it is an interpreted language, what means that it is on average slow compared to a compiled language.

Red, together with its C-level dialect Red/System, provides a language that covers the entire programming space you ever need to program something in.
Red is a language heavily based on the language of REBOL. Where Red itself reproduces the flexibility of the REBOL language, the underlying language Red will be built upon,
Red/System, covers the more basic needs of programming like C can, being closer to the metal.

Red will be the world's first Full Stack Programming Language. This means that it will be an effective tool to do (almost) any programming task on every level
from the metal to the meta without the aid of other stack tools.
Furthermore Red will be able to cross-compile Red source code without using any GCC like toolchain
from any platform to any other platform. And it will do this all from a binary executable that is supposed to stay under 1 MB.

Ready to learn your first Red?

```
All text before the header will be treated as comment, as long as you avoid
using the word ""red"" starting with a capital ""R"" in this pre-header text.
This is a temporary shortcoming of the used lexer but most of the time you
start your script or program with the header itself.

The header of a red script is the capitalized word ""red"" followed by a
whitespace character followed by a block of square brackets []. The block of
brackets can be filled with useful information about this script or program:
the author's name, the filename, the version, the license, a summary of what
the program does or any other files it needs. The red/System header is just
like the red header, only saying ""red/System"" and not ""red"".
```
```red
Red []

;this is a commented line

print ""Hello Red World""    ; this is another comment

comment {
    This is a multiline comment.
    You just saw the Red version of the ""Hello World"" program.
}

; Your program's entry point is the first executable code that is found
; no need to restrict this to a 'main' function.

; Valid variable names start with a letter and can contain numbers,
; variables containing only capital A through F and numbers and ending with 'h'
; are forbidden, because that is how hexadecimal numbers are expressed in Red
; and Red/System.

; assign a value to a variable using a colon "":""
my-name: ""Red""
reason-for-using-the-colon: {Assigning values using the colon makes
 the equality sign ""="" exclusively usable for comparisons purposes,
 exactly what ""="" was intended for in the first place!
 Remember this y = x + 1 and x = 1 => y = 2 stuff from school?
}
is-this-name-valid?: true

; print output using print, or prin for printing without a newline or linefeed
; at the end of the printed text.

prin "" My name is "" print my-name
My name is Red

print [""My name is "" my-name lf]
My name is Red

; If you haven't already noticed: statements do NOT end with a semicolon ;-)

;
; Datatypes
;
; If you know Rebol, you probably have noticed it has lots of datatypes. Red
; does not have yet all those types, but as Red want to be close to Rebol it
; will have a lot of datatypes.
; You can recognize types by the exclamation sign at the end. But beware
; names ending with an exclamation sign are allowed.
; Some of the available types are integer! string! block!

; Declaring variables before using them?
; Red knows by itself what variable is best to use for the data you want to
; use it for.
; A variable declaration is not always necessary.
; It is considered good coding practise to declare your variables,
; but it is not forced upon you by Red.
; You can declare a variable and specify its type. a variable's type
; determines its size in bytes.

; Variables of integer! type are usually 4 bytes or 32 bits
my-integer: 0
; Red's integers are signed. No support for unsigned atm but that will come.

; To find out the type of variable use type?
type? my-integer
integer!

; A variable can be initialized using another variable that gets initialized
; at the same time. Initialize here refers to both declaring a variable and
; assigning a value to it.
i2: 1 + i1: 1

; Arithmetic is straightforward
i1 + i2 ; result 3
i2 - i1 ; result 1
i2 * i1 ; result 2
i1 / i2 ; result 0 (0.5, but truncated towards 0)

; Comparison operators are probably familiar, and unlike in other languages
; you only need a single '=' sign for comparison. Inequality is '<>' like in Pascal.
; There is a boolean like type in Red. It has values true and false, but also
; the values on/off or yes/no can be used

3 = 2 ; result false
3 <> 2 ; result true
3 > 2 ; result true
3 < 2 ; result false
2 <= 2 ; result true
2 >= 2 ; result true

;
; Control Structures
;
; if
; Evaluate a block of code if a given condition is true. IF returns
; the resulting value of the block or 'none' if the condition was false.
if a < 0 [print ""a is negative""]

; either
; Evaluate a block of code if a given condition is true, else evaluate an
; alternative block of code. If the last expressions in both blocks have the
; same type, EITHER can be used inside an expression.
either a > 0 [
   msg: ""positive""
][
   either a = 0 [
       msg: ""zero""
   ][
       msg: ""negative""
   ]
]

print [""a is "" msg lf]

; There is an alternative way to write this
; (Which is allowed because all code paths return a value of the same type):

msg: either a > 0 [
   ""positive""
][
   either a = 0 [
       ""zero""
   ][
       ""negative""
   ]
]
print [""a is "" msg lf]

; until
; Loop over a block of code until the condition at end of block, is met.
; UNTIL always returns the 'true' value from the final evaluation of the last expression.
c: 5
until [
   prin ""o""
   c: c - 1
   c = 0    ; the condition to end the until loop
]
;   will output:
ooooo
; Note that the loop will always be evaluated at least once, even if the
; condition is not met from the beginning.

; while
; While a given condition is met, evaluate a block of code.
; WHILE does not return any value, so it cannot be used in an expression.
c: 5
while [c > 0][
   prin ""o""
   c: c - 1
]
; will output:
ooooo

;
; Functions
;
; function example
twice: function [a [integer!] /one return: [integer!]][
        c: 2
        a: a * c
        either one [a + 1][a]
]
b: 3
print twice b   ; will output 6.

; Import external files with #include and filenames start with a % sign
#include %includefile.red
; Now the functions in the included file can be used too.

```

## Further Reading

The main source for information about Red is the [Red language homepage](http://www.red-lang.org).

The source can be found on [github](https://github.com/red/red).

The Red/System language specification can be found [here](http://static.red-lang.org/red-system-specs-light.html).

To learn more about Rebol and Red join the [chat on Gitter](https://gitter.im/red/red). And if that is not working for you drop a mail to us on the [Red mailing list](mailto: red-langNO_SPAM@googlegroups.com) (remove NO_SPAM).

Browse or ask questions on [Stack Overflow](https://stackoverflow.com/questions/tagged/red).

Maybe you want to try Red right away? That is possible on the [try Rebol and Red site](http://tryrebol.esperconsultancy.nl).

You can also learn Red by learning some [Rebol](http://www.rebol.com/docs.html)."
"The FunC language is used to program smart contracts on the [The Open Network](https://ton.org) blockchain. Contract logic is executed in TVM, the stack-based TON Virtual Machine.

FunC is a statically typed, which is similar to C.

# Basic syntax, the first Smart Contract — Data Types, Storage, Functions

```c
;; Single line comment

	{- This is a multi-line comment
		{- this is a comment in the comment -}
	-}
	
	(int) sum(int a, int b) { 
    ;; This is a function that gets two integer parameters 
    ;; and return integer result
	  return a + b;  
    ;; All integers are signed and are 257 bit long. Overflow throws exception
    ;; expressions must end with a semicolon
	}
	
	() f(int i, cell c, slice s, builder b, cont c, tuple t) {
	  ;; FunC has 7 atomic types: 
	  ;; int - 257 bit signed integers,
	  ;; cell - basic for TON opaque data structure,
      ;; which contains up to 1,023 bits and up to 4 references to other cells,
	  ;; slice and builder - special objects to read from and write to cells,
	  ;; continuation - another flavor of cell that contains 
      ;; ready-to-execute TVM byte-code.
	  ;; tuple is an ordered collection of up to 255 components,
      ;; having arbitrary value types, possibly distinct.
	  ;; Finally tensor type (A,B, ...) is an ordered collection ready for
      ;; mass assigning like: (int, int) a = (3, 5);
	  ;; Special case of tensor type is the unit type ().
	  ;; It represents that a function doesn’t return any value,
      ;; or has no arguments.
	}
	
	;; During execution, the contract has read access to local context:
    ;; its storage, balance, time, network config, etc.
	;; Contract may change its storage and code,
    ;; and also may send messages to other contracts

	;; Let’s write a counter smart contract that gets a number
    ;; from an incoming message,
	;; adds to already stored numbers and stores result in “storage”

	;; For handling special events, smart contracts have reserved methods:
	;; recv_internal() handles internal messages from other smart contracts
	;; recv_external() handles external messages from the outside world —
    ;; e.g., from a user.

	() recv_internal(slice in_msg_body) {
	  ;; Cells play the role of memory in the stack-based TVM.
      ;; A cell can be transformed into a slice,
	  ;; and then the data bits and references to
      ;; other cells from the cell can be obtained
	  ;; by loading them from the slice.
      ;; Data bits and references to other cells can be stored
	  ;; into a builder, and then the builder can be finalized into a new cell.
	  ;; recv_internal gets the slice
      ;; with incoming message data as an argument.

	  ;; As everything else on TON, permanent storage data is stored as a cell.
	  ;; It can be retrieved via the get_data() method
	  ;; begin_parse - converts a cell with data into a readable slice

	  slice ds = get_data().begin_parse(); 
      ;; `.` is a syntax sugar: a.b() is equivalent to b(a)

	  ;; load_uint is a function from the FunC standard library;
      ;; it loads an unsigned n-bit integer from a slice
	  int total = ds~load_uint(64); ;; `~` is a ""modifying"" method:
	  ;; essentially, it is a syntax sugar: `r = a~b(x)` 
      ;; is equivalent to (a,r) = b(a,x)
	  
	  ;; Now let’s read the incoming value from the message body slice
	  int n = in_msg_body~load_uint(32);

	  total += n;
      ;; integers support usual +-*/ operations as well as (+-*/)= syntax sugar

	  ;; In order to keep a store integer value, we need to do four things:
	  ;; create a Builder for the future cell - begin_cell()
	  ;; write a value to total - store_uint(value, bit_size)
	  ;; create a Cell from the Builder - end_cell()
	  ;; write the resulting cell into permanent storage - set_data()

	  set_data(begin_cell().store_uint(total, 64).end_cell());
	}



	;; The FunC program is essentially a list of
    function declarations/definitions and global variable declarations.

	;; Any function in FunC matches the following pattern:
	;; [<forall declarator>] <return_type> <function_name>(<comma_separated_function_args>) <specifiers>


	;; Specifiers:
	;; The impure specifier indicates that
    ;; function calls should not be optimized
    ;; (whether its result is used or not)
	;; it is important for methods that change the smart contract data
    ;; or send messages

	;; The method_id specifier allows you to call a GET function by name
	
	;; For instance, we can create a get method for the contract above
    ;; to allow outside viewers to read counter

	int get_total() method_id {
	  slice ds = get_data().begin_parse();
	  int total = ds~load_uint(64);

	  ;; Note that (int) and int is the same,
      ;; thus brackets in the function declaration
      ;; and in the return statement are omitted.
	  return total;
	}
	;; Now any observer can read get_total value via lite-client or explorer
```

# Messages

The actor model is a model of concurrent computation and is at the heart of TON smart contracts. Each smart contract can process one message at a time, change its own state, or send one or several messages. Processing of the message occurs in one transaction, that is, it cannot be interrupted. Messages to one contract are processed consequently one by one. As a result, the execution of each transaction is local and can be parallelized at the blockchain level, which allows for on-demand throughput horizontal scaling and hosting an unlimited number of users and transactions.

```c
;; For normal internal message-triggered transactions,
;; before passing control to recv_internal TVM puts the following
;; elements on stack.
;;;; Smart contract balance (in nanoTons)
;;;; Incoming message balance (in nanoTons)
;;;; Cell with an incoming message
;;;; Incoming message body, slice type
;; In turn, recv_internal may use only
;; the required number of fields (like 1 in the example above or 4 below)

;; Let’s dive into message sending

() recv_internal (
    int balance, int msg_value, cell in_msg_full, slice in_msg_body) {
    ;; 
    ;; Every message has a strict layout, thus by parsing it,
    ;; we can get the sender’s address
    ;; first, we need to read some tech flags and
    ;; then take the address using load_msg_addr
    ;; function from FunC standard library - ()
    var cs = in_msg_full.begin_parse();
    var flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    ;; if we want to send a message, we first need to construct it
    ;; message serialization in most cases may be reduced to
    var msg = begin_cell()
    .store_uint(0x18, 6) ;; tech flags
    .store_slice(addr)   ;; destination address
    .store_coins(amount) ;; attached value
    .store_uint(0, 107) ;; more tech flags :)
    .store_slice(in_msg_body) ;; just put some payload here
    .end_cell();

    ;; to send messages, use send_raw_message from the standard library.
    ;; it accepts two arguments message and mode
    send_raw_message(msg, 64);

    ;; mode parameter specifies how to process the funds passed into
    ;; the smart contract with the message and the smart contract funds
    ;; 64 means send everything from the incoming message — 
    ;; what’s left after the commission is deducted

    ;; Exceptions can be thrown by conditional primitives throw_if and
    ;; throw_unless and by unconditional throw
    ;; by default, it will automatically cause a bounce message with 64 mode

    var some  = 7;
    throw_if(102, some == 10);
    ;; Throw exception with code 102 conditionally
    throw_unless(103, some != 10);
    ;; Throw exception with code 103 conditionally
    throw(101);    ;; Throw exception with code 101 unconditionally
}
```

# Flow control: Conditional Statements and Loops; Dictionaries

```c
;; FunC, of course, supports if statements

;;;; usual if-else
if (flag) {
    ;;do_something();
}
else {
    ;;do_alternative();
}

;; If statements are often used as an operation identifier
;; for a smart contract, for example:

() recv_internal (
    int balance, int msg_value, cell in_msg_full, slice in_msg_body) {
    int op = in_msg_body~load_int(32);
    if (op == 1) {
    ;; smth here
    } else {
    if (op == 2) {
        ;; smth here
    } else {
        ;; smth here
    }
    }
}

;; Loops
;; FunC supports repeat, while and do { ... } until loops.
;; for loop is not supported.

;; repeat
int x = 1;
repeat(10) {
    x *= 2;
}
;; x = 1024

;; while
int x = 2;
while (x < 100) {
    x = x * x;
}
;; x = 256

;; until loops
int x = 0;
do {
    x += 3;
} until (x % 17 == 0);
;; x = 51

;; In practice, loops in TON smart contracts are often used to work with
;;  dictionaries, or as they are also called in TON hashmaps

;; A hashmap is a data structure represented by a tree.
;; Hashmap maps keys to values ​​of arbitrary type so that
;; quick lookup and modification are possible. 

;; udict_get_next? from FunC standard library in combination with
;; the loop will help, go through the dictionary

int key = -1;
do {
    (key, slice cs, int f) = dic.udict_get_next?(256, key);

} until (~ f);

;; udict_get_next? - Calculates the minimum key k in the dictionary dict
;; that is greater than some given value and returns k,
;; the associated value, and a flag indicating success.
;; If the dictionary is empty, returns (null, null, 0).
```

# Functions

```c
;; Most useful functions are slice reader and builder writer primitives,
;; storage handlers and sending messages

;; slice begin_parse(cell c) - Converts a cell into a slice
;; (slice, int) load_int(slice s, int len) - 
;; Loads a signed len-bit integer from a slice.
;; (slice, int) load_uint(slice s, int len) - 
;; Loads a unsigned len-bit integer from a slice.
;; (slice, slice) load_bits(slice s, int len) - 
;; Loads the first 0 ≤ len ≤ 1023 bits from slice into a separate slice.
;; (slice, cell) load_ref(slice s) - Loads the reference cell from the slice.

;; builder begin_cell() - Creates a new empty builder.
;; cell end_cell(builder b) - Converts a builder into an ordinary cell.
;; builder store_int(builder b, int x, int len) -
;; Stores a signed len-bit integer x into b for 0 ≤ len ≤ 257.
;; builder store_uint(builder b, int x, int len) -
;; Stores an unsigned len-bit integer x into b for 0 ≤ len ≤ 256.
;; builder store_slice(builder b, slice s) - Stores slice s into builder b.
;; builder store_ref(builder b, cell c) -
;; Stores a reference to cell c into builder b.

;; cell get_data() - Returns the persistent contract storage cell. 
;; () set_data(cell c) - Sets cell c as persistent contract data.

;; () send_raw_message(cell msg, int mode) -
;; put message msg into sending queue with mode.
;; Note, that message will be sent after a successful execution
;; of the whole transaction

;; Detailed descriptions of all standard functions can be found
;; in docs https://ton.org/docs/#/func/stdlib
;; 
```

## Additional resources
- [FunC Lessons](https://github.com/romanovichim/TonFunClessons_Eng)
- [TON Development Onboarding](https://www.tonspace.co)
- [TON Documentation](https://ton.org/docs/#/)
- [FunC Documentation](https://ton.org/docs/#/func/overview)
- [TON Smart Contracts examples](https://github.com/ton-blockchain/ton/tree/master/crypto/smartcont)
- [Community portal](https://society.ton.org)
- [Blockchain portal](https://ton.org)
- [Stackoverflow](https://stackoverflow.com/questions/tagged/ton)

## Social
- [Developer community](https://t.me/tondev_eng)
- [TON Learn](https://t.me/ton_learn)
- [FunC Lessons Channel](https://github.com/romanovichim/TonFunClessons_Eng)
- [FunC onboarding](https://t.me/func_guide)
- [Tondev News](https://t.me/tondevnews)

## Useful blogposts
- [Setting up a TON Development Environment](https://society.ton.org/setting-up-a-ton-development-environment)
- [Hello World on TON](https://society.ton.org/ton-hello-world-step-by-step-guide-for-writing-your-first-smart-contract-in-func)


## Future To Dos
- Add smart contracts examples
- Add more posts


This file is mostly copied from [TonFunClessons 15 minutes intro](https://github.com/romanovichim/TonFunClessons_Eng/blob/main/13lesson/15min.md).

P.S. If by any chance you're familiar with [Forth](https://learnxinyminutes.com/docs/forth/), you can also take a look at [Fift](https://ton-blockchain.github.io/docs/fiftbase.pdf)."
"HTML stands for Hypertext Markup Language.

It is a language which allows us to write pages for the World Wide Web.
It is a markup language, it enables us to write webpages using code to indicate
how text and data should be displayed.  In fact, HTML files are simple text
files.

What is this markup? It is a method of organising the page's data by
surrounding it with opening tags and closing tags.  This markup serves to give
significance to the text that it encloses.  Like other computer languages, HTML
has many versions. Here we will talk about HTML5.

**NOTE :**  You can test the different tags and elements as you progress through
the tutorial on a site like [codepen](http://codepen.io/pen/) in order to see
their effects, understand how they work and familiarise yourself with the
language.  This article is concerned principally with HTML syntax and some
useful tips.


```html
<!-- Comments are enclosed like this line! -->

<!--
	Comments
	can
	span
	multiple
	lines!
-->

<!-- #################### The Tags #################### -->

<!-- Here is an example HTML file that we are going to analyse. -->


<!doctype html>
	<html>
		<head>
			<title>My Site</title>
		</head>
		<body>
			<h1>Hello, world!</h1>
			<a href=""http://codepen.io/anon/pen/xwjLbZ"">
				Come look at what this shows
			</a>
			<p>This is a paragraph.</p>
			<p>This is another paragraph.</p>
			<ul>
				<li>This is an item in a non-enumerated list (bullet list)</li>
				<li>This is another item</li>
				<li>And this is the last item on the list</li>
			</ul>
		</body>
	</html>

<!--
	An HTML file always starts by indicating to the browser that the page is HTML.
-->
<!doctype html>

<!-- After this, it starts by opening an <html> tag. -->
<html>

<!-- that will be closed at the end of the file with </html>. -->
</html>

<!-- Nothing should appear after this final tag. -->

<!-- Inside (between the opening and closing tags <html></html>), we find: -->

<!-- A header defined by <head> (it must be closed with </head>). -->
<!--
	The header contains some description and additional information which are not
	displayed; this is metadata.
-->

<head>
	<!--
		The tag <title> indicates to the browser the title to show in browser
		window's title bar and tab name.
	-->
	<title>My Site</title>
</head>

<!-- After the <head> section, we find the tag - <body> -->
<!-- Until this point, nothing described will show up in the browser window. -->
<!-- We must fill the body with the content to be displayed. -->

<body>
	<!-- The h1 tag creates a title. -->
	<h1>Hello, world!</h1>
	<!--
		There are also subtitles to <h1> from the most important (h2) to the most
		precise (h6).
	-->

	<!-- a hyperlink to the url given by the attribute href="""" -->
	<a href=""http://codepen.io/anon/pen/xwjLbZ"">
		Come look at what this shows
	</a>

	<!-- The tag <p> lets us include text in the html page. -->
	<p>This is a paragraph.</p>
	<p>This is another paragraph.</p>

	<!-- The tag <ul> creates a bullet list. -->
	<!--
		To have a numbered list instead we would use <ol> giving 1. for the first
		element, 2. for the second, etc.
	-->
	<ul>
		<li>This is an item in a non-enumerated list (bullet list)</li>
		<li>This is another item</li>
		<li>And this is the last item on the list</li>
	</ul>
</body>

<!-- And that's it, creating an HTML file can be simple. -->

<!-- But it is possible to add many additional types of HTML tags. -->

<!-- The <img /> tag is used to insert an image. -->
<!--
	The source of the image is indicated using the attribute src=""""
	The source can be an URL or even path to a file on your computer.
-->
<img src=""http://i.imgur.com/XWG0O.gif""/>

<!-- It is also possible to create a table. -->

<!-- We open a <table> element. -->
<table>

	<!-- <tr> allows us to create a row. -->
	<tr>

		<!-- <th> allows us to give a title to a table column. -->
		<th>First Header</th>
		<th>Second Header</th>
	</tr>

	<tr>

		<!-- <td> allows us to create a table cell. -->
		<td>first row, first column</td>
		<td>first row, second column</td>
	</tr>

	<tr>
		<td>second row, first column</td>
		<td>second row, second column</td>
	</tr>
</table>

```

## Usage

HTML is written in files ending with `.html` or `.htm`. The mime type is
`text/html`.
**HTML is NOT a programming language**
## To Learn More

* [Wikipedia](https://en.wikipedia.org/wiki/HTML)
* [HTML Tutorial](https://developer.mozilla.org/en-US/docs/Web/HTML)
* [W3Schools](http://www.w3schools.com/html/html_intro.asp)"
"Forth was created by Charles H. Moore in the 70s. It is an imperative,
stack-based language and programming environment, being used in projects
such as Open Firmware. It's also used by NASA.

Note: This article focuses predominantly on the Gforth implementation of
Forth, but most of what is written here should work elsewhere.

```forth
\ This is a comment
( This is also a comment but it's only used when defining words )

\ --------------------------------- Precursor ----------------------------------

\ All programming in Forth is done by manipulating the parameter stack (more
\ commonly just referred to as ""the stack"").
5 2 3 56 76 23 65    \ ok

\ Those numbers get added to the stack, from left to right.
.s    \ <7> 5 2 3 56 76 23 65 ok

\ In Forth, everything is either a word or a number.

\ ------------------------------ Basic Arithmetic ------------------------------

\ Arithmetic (in fact most words requiring data) works by manipulating data on
\ the stack.
5 4 +    \ ok

\ `.` pops the top result from the stack:
.    \ 9 ok

\ More examples of arithmetic:
6 7 * .        \ 42 ok
1360 23 - .    \ 1337 ok
12 12 / .      \ 1 ok
13 2 mod .     \ 1 ok

99 negate .    \ -99 ok
-99 abs .      \ 99 ok
52 23 max .    \ 52 ok
52 23 min .    \ 23 ok

\ ----------------------------- Stack Manipulation -----------------------------

\ Naturally, as we work with the stack, we'll want some useful methods:

3 dup -          \ duplicate the top item (1st now equals 2nd): 3 - 3
2 5 swap /       \ swap the top with the second element:        5 / 2
6 4 5 rot .s     \ rotate the top 3 elements:                   4 5 6
4 0 drop 2 /     \ remove the top item (don't print to screen):  4 / 2
1 2 3 nip .s     \ remove the second item (similar to drop):    1 3

\ ---------------------- More Advanced Stack Manipulation ----------------------

1 2 3 4 tuck   \ duplicate the top item below the second slot:      1 2 4 3 4 ok
1 2 3 4 over   \ duplicate the second item to the top:             1 2 3 4 3 ok
1 2 3 4 2 roll \ *move* the item at that position to the top:      1 3 4 2 ok
1 2 3 4 2 pick \ *duplicate* the item at that position to the top: 1 2 3 4 2 ok

\ When referring to stack indexes, they are zero-based.

\ ------------------------------ Creating Words --------------------------------

\ The `:` word sets Forth into compile mode until it sees the `;` word.
: square ( n -- n ) dup * ;    \ ok
5 square .                     \ 25 ok

\ We can view what a word does too:
see square     \ : square dup * ; ok

\ -------------------------------- Conditionals --------------------------------

\ -1 == true, 0 == false. However, any non-zero value is usually treated as
\ being true:
42 42 =    \ -1 ok
12 53 =    \ 0 ok

\ `if` is a compile-only word. `if` <stuff to do> `then` <rest of program>.
: ?>64 ( n -- n ) dup 64 > if ."" Greater than 64!"" then ; \ ok
100 ?>64                                                  \ Greater than 64! ok

\ Else:
: ?>64 ( n -- n ) dup 64 > if ."" Greater than 64!"" else ."" Less than 64!"" then ;
100 ?>64    \ Greater than 64! ok
20 ?>64     \ Less than 64! ok

\ ------------------------------------ Loops -----------------------------------

\ `do` is also a compile-only word.
: myloop ( -- ) 5 0 do cr ."" Hello!"" loop ; \ ok
myloop
\ Hello!
\ Hello!
\ Hello!
\ Hello!
\ Hello! ok

\ `do` expects two numbers on the stack: the end number and the start number.

\ We can get the value of the index as we loop with `i`:
: one-to-12 ( -- ) 12 0 do i . loop ;     \ ok
one-to-12                                 \ 0 1 2 3 4 5 6 7 8 9 10 11 12 ok

\ `?do` works similarly, except it will skip the loop if the end and start
\ numbers are equal.
: squares ( n -- ) 0 ?do i square . loop ;   \ ok
10 squares                                   \ 0 1 4 9 16 25 36 49 64 81 ok

\ Change the ""step"" with `+loop`:
: threes ( n n -- ) ?do i . 3 +loop ;    \ ok
15 0 threes                             \ 0 3 6 9 12 ok

\ Indefinite loops with `begin` <stuff to do> <flag> `until`:
: death ( -- ) begin ."" Are we there yet?"" 0 until ;    \ ok

\ ---------------------------- Variables and Memory ----------------------------

\ Use `variable` to declare `age` to be a variable.
variable age    \ ok

\ Then we write 21 to age with the word `!`.
21 age !    \ ok

\ Finally we can print our variable using the ""read"" word `@`, which adds the
\ value to the stack, or use `?` that reads and prints it in one go.
age @ .    \ 21 ok
age ?      \ 21 ok

\ Constants are quite similar, except we don't bother with memory addresses:
100 constant WATER-BOILING-POINT    \ ok
WATER-BOILING-POINT .               \ 100 ok

\ ----------------------------------- Arrays -----------------------------------

\ Creating arrays is similar to variables, except we need to allocate more
\ memory to them.

\ You can use `2 cells allot` to create an array that's 3 cells long:
variable mynumbers 2 cells allot    \ ok

\ Initialize all the values to 0
mynumbers 3 cells erase    \ ok

\ Alternatively we could use `fill`:
mynumbers 3 cells 0 fill

\ or we can just skip all the above and initialize with specific values:
create mynumbers 64 , 9001 , 1337 , \ ok (the last `,` is important!)

\ ...which is equivalent to:

\ Manually writing values to each index:
64 mynumbers 0 cells + !      \ ok
9001 mynumbers 1 cells + !    \ ok
1337 mynumbers 2 cells + !    \ ok

\ Reading values at certain array indexes:
0 cells mynumbers + ?    \ 64 ok
1 cells mynumbers + ?    \ 9001 ok

\ We can simplify it a little by making a helper word for manipulating arrays:
: of-arr ( n n -- n ) cells + ;    \ ok
mynumbers 2 of-arr ?               \ 1337 ok

\ Which we can use for writing too:
20 mynumbers 1 of-arr !    \ ok
mynumbers 1 of-arr ?       \ 20 ok

\ ------------------------------ The Return Stack ------------------------------

\ The return stack is used to the hold pointers to things when words are
\ executing other words, e.g. loops.

\ We've already seen one use of it: `i`, which duplicates the top of the return
\ stack. `i` is equivalent to `r@`.
: myloop ( -- ) 5 0 do r@ . loop ;    \ ok

\ As well as reading, we can add to the return stack and remove from it:
5 6 4 >r swap r> .s    \ 6 5 4 ok

\ NOTE: Because Forth uses the return stack for word pointers,  `>r` should
\ always be followed by `r>`.

\ ------------------------- Floating Point Operations --------------------------

\ Most Forths tend to eschew the use of floating point operations.
8.3e 0.8e f+ f.    \ 9.1 ok

\ Usually we simply prepend words with 'f' when dealing with floats:
variable myfloatingvar    \ ok
4.4e myfloatingvar f!     \ ok
myfloatingvar f@ f.       \ 4.4 ok

\ --------------------------------- Final Notes --------------------------------

\ Typing a non-existent word will empty the stack. However, there's also a word
\ specifically for that:
clearstack

\ Clear the screen:
page

\ Loading Forth files:
\ s"" forthfile.fs"" included

\ You can list every word that's in Forth's dictionary (but it's a huge list!):
\ words

\ Exiting Gforth:
\ bye

```

##Ready For More?

* [Starting Forth](http://www.forth.com/starting-forth/)
* [Simple Forth](http://www.murphywong.net/hello/simple.htm)
* [Thinking Forth](http://thinking-forth.sourceforge.net/)"
"Uxntal is a stack-machine assembly language targeting the [Uxn virtual machine](https://wiki.xxiivv.com/site/uxn.html).

Stack machine programming might look at bit odd, as it uses a postfix notation, 
which means that operators are always found at the end of an operation. For 
instance, one would write 3 4 + instead of 3 + 4. 

The expression written (5 + 10) * 3 in conventional notation would be 
written 10 5 + 3 * in reverse Polish notation.

```forth
( This is a comment )

( All programming in Unxtal is done by manipulating the stack )

#12 ( push a byte )
#3456 ( push a short )

( Uxn has 32 opcodes, each opcode has 3 possible modes )

POP ( pop a byte )
POP2 ( pop a short )

( The modes are:
	[2] The short mode consumes two bytes from the stack.
	[k] The keep mode does not consume items from the stack.
	[r] The return mode makes the operator operate on the return-stack. )

#12 #34 ADD ( 46 )
#12 #34 ADDk ( 12  34  46 )

( The modes can be combined )

#1234 #5678 ADD2k ( 12  34  56  78  68  ac )

( The arithmetic/bitwise opcodes are:
	ADD SUB MUL DIV
	AND ORA EOR SFT )

( New opcodes can be created using macros )

%MOD2 { DIV2k MUL2 SUB2 }

#1234 #0421 MOD2 ( 01  b0 )

( ---------------------------------------------------------------------------- )

( A short is simply two bytes, each byte can be manipulated )

#1234 SWP ( 34  12 )
#1234 #5678 SWP2 ( 56  78  12  34 )
#1234 #5678 SWP ( 12  34  78  56 )

( Individual bytes of a short can be removed from the stack )

#1234 POP ( 12 )
#1234 NIP ( 34 )

( The stack opcodes are:
	POP DUP NIP SWP OVR ROT )

( ---------------------------------------------------------------------------- )

( To compare values on the stack with each other )

#12 #34 EQU ( 00 )
#12 #12 EQU ( 01 )

( Logic opcodes will put a flag with a value of either 00 or 01 )

#12 #34 LTH 
#78 #56 GTH 
	#0101 EQU2 ( 01 )

( The logic opcodes are:
	EQU NEQ GTH LTH )

( ---------------------------------------------------------------------------- )

( Uxn's accessible memory is as follows: 
	256 bytes of working stack 
	256 bytes of return stack
	65536 bytes of memory
	256 bytes of IO memory )

( The addressable memory is between 0000-ffff )

#12 #0200 STA ( stored 12 at 0200 in memory )
#3456 #0201 STA2 ( stored 3456 at 0201 in memory )
#0200 LDA2 ( 12  34 )

( The zero-page can be addressed with a single byte )

#1234 #80 STZ2 ( stored 12 at 0080, and 34 at 0081 )
#80 LDZ2 ( 12  34 )

( Devices are ways for Uxn to communicate with the outside world
	There is a maximum of 16 devices connected to Uxn at once
	Device bytes are called ports, the Console device uses the 10-1f ports
	The console's port 18 is called /write )

%EMIT { #18 DEO }

#31 EMIT ( print ""1"" to console )

( A label is equal to a position in the program )
@parent ( defines a label ""parent"" )
	&child ( defines a sublabel ""parent/child"" )

( Label positions can be pushed on stack )
;parent ( push the absolute position, 2 bytes )
,parent ( push the relative position, 1 byte )
.parent ( push the zero-page position, 1 byte )

( The memory opcodes are:
	LDZ STZ LDR STR
	LDA STA DEI DEO )

( ---------------------------------------------------------------------------- )

( Logic allows to create conditionals )

#12 #34 NEQ ,skip JCN
	#31 EMIT
	@skip

( Logic also allows to create for-loops )

#3a #30
@loop
	DUP EMIT ( print ""123456789"" to console )
	INC GTHk ,loop JCN
POP2

( Logic also allows to create while-loops )

;word
@while
	LDAk EMIT
	INC2 LDAk ,while JCN
POP2
BRK

@word ""vermillion $1

( Subroutines can be jumped to with JSR, and returned from with JMP2r )

;word ,print-word JSR
BRK

@print-word ( word* -- )
	@while
		LDAk EMIT
		INC2 LDAk ,while JCN
	POP2
JMP2r

@word ""cerulean

( The jump opcodes are: 
	JMP JCN JSR )
```

## Ready For More?

* [Uxntal Lessons](https://compudanzas.net/uxn_tutorial.html)
* [Uxntal Assembly](https://wiki.xxiivv.com/site/uxntal.html)
* [Uxntal Resources](https://github.com/hundredrabbits/awesome-uxn)"
"LOLCODE is an esoteric programming language designed to resemble the speech of [lolcats](https://upload.wikimedia.org/wikipedia/commons/a/ab/Lolcat_in_folder.jpg?1493656347257).

```
BTW This is an inline comment
BTW All code must begin with `HAI <language version>` and end with `KTHXBYE`

HAI 1.3
CAN HAS STDIO? BTW Importing standard headers

OBTW
     ==========================================================================
     ================================= BASICS =================================
     ==========================================================================
TLDR

BTW Displaying text:
VISIBLE ""HELLO WORLD""

BTW Declaring variables:
I HAS A MESSAGE ITZ ""CATZ ARE GOOD""
VISIBLE MESSAGE

OBTW
    (This is a codeblock.) Variables are dynamically typed so you don't need to
    declare their type. A variable's type matches its content. These are the
    types:
TLDR

I HAS A STRING  ITZ ""DOGZ ARE GOOOD"" BTW type is YARN
I HAS A INTEGER ITZ 42               BTW type is NUMBR
I HAS A FLOAT   ITZ 3.1415           BTW type is NUMBAR
I HAS A BOOLEAN ITZ WIN              BTW type is TROOF
I HAS A UNTYPED                      BTW type is NOOB

BTW Accepting user input:
I HAS A AGE
GIMMEH AGE
BTW The variable is stored as a YARN. To convert it into NUMBR:
AGE IS NOW A NUMBR

OBTW
     ==========================================================================
     ================================== MATH ==================================
     ==========================================================================
TLDR

BTW LOLCODE uses polish notation style math.

BTW Basic mathematical notation:

SUM OF 21 AN 33         BTW 21 + 33
DIFF OF 90 AN 10        BTW 90 - 10
PRODUKT OF 12 AN 13     BTW 12 * 13
QUOSHUNT OF 32 AN 43    BTW 32 / 43
MOD OF 43 AN 64         BTW 43 modulo 64
BIGGR OF 23 AN 53       BTW max(23, 53)
SMALLR OF 53 AN 45      BTW min(53, 45)

BTW Binary notation:

BOTH OF WIN AN WIN           BTW and: WIN if x=WIN, y=WIN
EITHER OF FAIL AN WIN        BTW or: FAIL if x=FAIL, y=FAIL
WON OF WIN AN FAIL           BTW xor: FAIL if x=y
NOT FAIL                     BTW unary negation: WIN if x=FAIL
ALL OF WIN AN WIN MKAY   BTW infinite arity AND
ANY OF WIN AN FAIL MKAY  BTW infinite arity OR

BTW Comparison:

BOTH SAEM ""CAT"" AN ""DOG""             BTW WIN if x == y
DIFFRINT 732 AN 184                  BTW WIN if x != y
BOTH SAEM 12 AN BIGGR OF 12 AN 4     BTW x >= y
BOTH SAEM 43 AN SMALLR OF 43 AN 56   BTW x <= y
DIFFRINT 64 AN SMALLR OF 64 AN 2     BTW x > y
DIFFRINT 75 AN BIGGR OF 75 AN 643    BTW x < y

OBTW
     ==========================================================================
     ============================== FLOW CONTROL ==============================
     ==========================================================================
TLDR

BTW If/then statement:
I HAS A ANIMAL
GIMMEH ANIMAL
BOTH SAEM ANIMAL AN ""CAT"", O RLY?
    YA RLY
        VISIBLE ""YOU HAV A CAT""
    MEBBE BOTH SAEM ANIMAL AN ""MAUS""
        VISIBLE ""NOM NOM NOM. I EATED IT.""
    NO WAI
        VISIBLE ""AHHH IS A WOOF WOOF""
OIC

BTW Case statement:
I HAS A COLOR
GIMMEH COLOR
COLOR, WTF?
    OMG ""R""
        VISIBLE ""RED FISH""
        GTFO
    OMG ""Y""
        VISIBLE ""YELLOW FISH""
        BTW Since there is no `GTFO` the next statements will also be tested
    OMG ""G""
    OMG ""B""
        VISIBLE ""FISH HAS A FLAVOR""
        GTFO
    OMGWTF
        VISIBLE ""FISH IS TRANSPARENT OHNO WAT""
OIC

BTW For loop:
I HAS A TEMPERATURE
GIMMEH TEMPERATURE
TEMPERATURE IS NOW A NUMBR
IM IN YR LOOP UPPIN YR ITERATOR TIL BOTH SAEM ITERATOR AN TEMPERATURE
    VISIBLE ITERATOR
IM OUTTA YR LOOP

BTW While loop:
IM IN YR LOOP NERFIN YR ITERATOR WILE DIFFRINT ITERATOR AN -10
    VISIBLE ITERATOR
IM OUTTA YR LOOP

OBTW
     =========================================================================
     ================================ Strings ================================
     =========================================================================
TLDR

BTW Linebreaks:
VISIBLE ""FIRST LINE :) SECOND LINE""

BTW Tabs:
VISIBLE "":>SPACES ARE SUPERIOR""

BTW Bell (goes beep):
VISIBLE ""NXT CUSTOMER PLS :o""

BTW Literal double quote:
VISIBLE ""HE SAID :""I LIKE CAKE:""""

BTW Literal colon:
VISIBLE ""WHERE I LIVE:: CYBERSPACE""

OBTW
     =========================================================================
     =============================== FUNCTIONS ===============================
     =========================================================================
TLDR

BTW Declaring a new function:
HOW IZ I SELECTMOVE YR MOVE BTW `MOVE` is an argument
    BOTH SAEM MOVE AN ""ROCK"", O RLY?
        YA RLY
            VISIBLE ""YOU HAV A ROCK""
        NO WAI
            VISIBLE ""OH NO IS A SNIP-SNIP""
    OIC
    GTFO BTW This returns NOOB
IF U SAY SO

BTW Declaring a function and returning a value:
HOW IZ I IZYELLOW
    FOUND YR ""YELLOW""
IF U SAY SO

BTW Calling a function:
I IZ IZYELLOW MKAY

KTHXBYE
```

## Further reading:

-   [LCI compiler](https://github.com/justinmeza/lci)
-   [Official spec](https://github.com/justinmeza/lolcode-spec/blob/master/v1.2/lolcode-spec-v1.2.md)"
"Tcl was created by [John Ousterhout](https://wiki.tcl-lang.org/page/John+Ousterhout) as a
reusable scripting language for circuit design tools that he authored.  In 1997 he
was awarded the [ACM Software System
Award](https://en.wikipedia.org/wiki/ACM_Software_System_Award) for Tcl.   Tcl
can be used both as an embeddable scripting language and as a general
programming language.  It can also be used as a portable C library, even in
cases where no scripting capability is needed, as it provides data structures
such as dynamic strings, lists, and hash tables.  The C library also provides
portable functionality for loading dynamic libraries, string formatting and
code conversion, filesystem operations, network operations, and more.  Various
features of Tcl stand out:

* Convenient cross-platform networking API

* Fully virtualized filesystem

* Stackable I/O channels

* Asynchronous to the core

* Full coroutines

* A threading model recognized as robust and easy to use


Tcl has much in common with Lisp, but instead of lists, Tcl uses strings as the
currency of the language.  All values are strings.  A list is a string with a
defined format, and the body of a procedure (a script) is also a string rather
than a block.  To achieve performance, Tcl internally caches structured
representations of these values.  list routines, for example, operate on
the internal cached representation, and Tcl takes care of updating the string
representation if it is ever actually needed in the script.  The copy-on-write
design of Tcl allows script authors to pass around large data values without
actually incurring additional memory overhead.  Procedures are automatically
byte-compiled unless they use the more dynamic routines such as ""uplevel"",
""upvar"", and ""trace"".

Tcl is a pleasure to program in.  It will appeal to hacker types who find Lisp,
Forth, or Smalltalk interesting, as well as to engineers and scientists who
just want to get down to business with a tool that bends to their will.  Its
discipline of exposing all programmatic functionality as routines, including
things like looping and mathematical operations that are usually baked into the
syntax of other languages, allows it to fade into the background of whatever
domain-specific functionality a project needs. Its syntax, which is even
lighter than that of Lisp, just gets out of the way.



```tcl
#! /bin/env tclsh

###############################################################################
## 1. Guidelines
###############################################################################

# Tcl is not Sh or C!  This needs to be said because standard shell quoting
# habits almost work in Tcl and it is common for people to pick up Tcl and try
# to get by with syntax they know from another language.  It works at first,
# but soon leads to frustration when scripts become more complex.

# Braces are a quoting mechanism, not syntax for the construction of code
# blocks or lists. Tcl doesn't have either of those things.  Braces are used to
# escape special characters, which makes them well-suited for quoting procedure
# bodies and strings that should be interpreted as lists.


###############################################################################
## 2. Syntax
###############################################################################

# A script is made up of commands delimited by newlines or semicolons.  Each
# command is a call to a routine.  The first word is the name of a routine to
# call, and subsequent words are arguments to the routine.  Words are delimited
# by whitespace.  Since each argument is a word in the command it is already a
# string, and may be unquoted:
set part1 Sal
set part2 ut; set part3 ations


# a dollar sign introduces variable substitution:
set greeting $part1$part2$part3


# When ""set"" is given only the name of a variable, it returns the
# value of that variable:
set part3 ;# Returns the value of the variable.


# Left and right brackets embed a script to be evaluated for a result to
# substitute into the word:
set greeting $part1$part2[set part3]


# An embedded script may be composed of multiple commands, the last of which provides
# the result for the substitution:
set greeting $greeting[
    incr i
    incr i
    incr i
]
puts $greeting ;# The output is ""Salutations3""

# Every word in a command is a string, including the name of the routine, so
# substitutions can be used on it as well. Given this variable
# assignment,
set action pu

# , the following three commands are equivalent:
puts $greeting
${action}ts $greeting 
[set action]ts $greeting


# backslash suppresses the special meaning of characters:
set amount \$16.42


# backslash adds special meaning to certain characters:
puts lots\nof\n\n\n\n\n\nnewlines


# A word enclosed in braces is not subject to any special interpretation or
# substitutions, except that a backslash before a brace is not counted when
# looking for the closing brace:
set somevar {
    This is a literal $ sign, and this \} escaped
    brace remains uninterpreted
}


# In a word enclosed in double quotes, whitespace characters lose their special
# meaning:
set name Neo
set greeting ""Hello, $name""


# A variable name can be any string:
set {first name} New


# The braced form of variable substitution handles more complex variable names:
set greeting ""Hello, ${first name}""


# ""set"" can always be used instead of variable substitution, and can handle all
# variable names:
set greeting ""Hello, [set {first name}]""


# To unpack a list into the command, use the expansion operator, ""{*}"".  These
# two commands are equivalent:
set name Neo
set {*}{name Neo}


# An array is a special variable that is a container for other variables.
set person(name) Neo
set person(destiny) {The One}
set greeting ""Hello, $person(name)""


# ""variable"" can be used to declare or set variables. In contrast with ""set"",
# which uses both the global namespace and the current namespace to resolve a
# variable name, ""variable"" uses only the current namespace:
variable name New


# ""namespace eval"" creates a new namespace if it doesn't exist.  A namespace
# can contain both routines and variables:
namespace eval people {
    namespace eval person1 {
        variable name Neo
    }
}


# Use two or more colons to delimit namespace components in variable names:
namespace eval people {
    set greeting ""Hello $person1::name""
}

# Two or more colons also delimit namespace components in routine names:
proc people::person1::speak {} {
    puts {I am The One.}
}

# Fully-qualified names begin with two colons:
set greeting ""Hello $::people::person1::name""



###############################################################################
## 3. No More Syntax
###############################################################################

# All other functionality is implemented via routines.  From this point on,
# there is no new syntax.  Everything else there is to learn about
# Tcl is about the behaviour of individual routines and what meaning they
# assign to their arguments.



###############################################################################
## 4. Variables and Namespaces
###############################################################################

# Each variable and routine is associated with some namespace.

# To end up with an interpreter that can do nothing, delete the global
# namespace.  It's not very useful to do such a thing, but it illustrates the
# nature of Tcl.  The name of the global namespace is actually the empty
# string, but the only way to represent it is as a fully-qualified name. To
# try it out call this routine:
proc delete_global_namespace {} {
    namespace delete ::
}

# Because ""set"" always keeps its eye on both the global namespace and the
# current namespace, it's safer to use ""variable"" to declare a variable or
# assign a value to a variable.  If a variable called ""name"" already exists in
# the global namespace, using ""set"" here will assign a value to the global
# variable instead of to a variable in the current namespace, whereas
# ""variable"" operates only on the current namespace.
namespace eval people {
    namespace eval person1 {
        variable name Neo
    }
}

# Once a variable is declared in a namespace, [set] sees it instead of seeing
# an identically-named variable in the global namespace:
namespace eval people {
    namespace eval person1 {
        variable name
        set name Neo
    }
}

# But if ""set"" has to create a new variable, it always does it relative to the
# current namespace:
unset name
namespace eval people {
    namespace eval person1 {
        set name neo
    }

}
set people::person1::name


# An absolute name always begins with the name of the global namespace (the
# empty string), followed by two colons:
set ::people::person1::name Neo


# Within a procedure, the ""variable"" links a variable in the current namespace
# into the local scope:
namespace eval people::person1 {
    proc fly {} {
        variable name
        puts ""$name is flying!""
    }
}




###############################################################################
## 5. Built-in Routines
###############################################################################

# Math can be done with the ""expr"":
set a 3
set b 4
set c [expr {$a + $b}]

# Since ""expr"" performs variable substitution on its own, brace the expression
# to prevent Tcl from performing variable substitution first.  See
# ""https://wiki.tcl-lang.org/page/Brace+your+expr-essions"" for details.


# ""expr"" understands variable and script substitution:
set c [expr {$a + [set b]}]


# ""expr"" provides a set of mathematical functions:
set c [expr {pow($a,$b)}]


# Mathematical operators are available as routines in the ::tcl::mathop
# namespace:
::tcl::mathop::+ 5 3

# Routines can be imported from other namespaces:
namespace import ::tcl::mathop::+
set result [+ 5 3]


# Non-numeric values must be quoted, and operators like ""eq"" can be used to
# constrain the operation to string comparison:
set name Neo
expr {{Bob} eq $name}

# The general operators fall back to string comparison if numeric
# operation isn't feasible:
expr {{Bob} == $name}


# ""proc"" creates new routines:
proc greet name {
    return ""Hello, $name!""
}

#multiple parameters can be specified:
proc greet {greeting name} {
    return ""$greeting, $name!""
}


# As noted earlier, braces do not construct a code block.  Every value, even
# the third argument to ""proc"", is a string.  The previous command
# can be rewritten using no braces:
proc greet greeting\ name return\ \""\$greeting,\ \$name!\""
# ""



# When the last parameter is the literal value ""args"", all extra arguments
# passed to the routine are collected into a list and assigned to ""args"":
proc fold {cmd first args} {
    foreach arg $args {
        set first [$cmd $first $arg]
    }
    return $first
}
fold ::tcl::mathop::* 5 3 3 ;# ->  45


# Conditional execution is implemented as a routine:
if {3 > 4} {
    puts {This will never happen}
} elseif {4 > 4} {
    puts {This will also never happen}
} else {
    puts {This will always happen}
}


# Loops are implemented as routines.  The first and third arguments to 
# ""for"" are treated as scripts, while the second argument is treated as
# an expression:
set res 0
for {set i 0} {$i < 10} {incr i} {
    set res [expr {$res + $i}]
}
unset res


# The first argument to ""while"" is also treated as an expression:
set i 0
while {$i < 10} {
    incr i 2
}


# A list is a string, and items in the list are delimited by whitespace:
set amounts 10\ 33\ 18
set amount [lindex $amounts 1]

# Whitespace in a list item must be quoted:
set inventory {""item 1"" item\ 2 {item 3}}


# It's generally a better idea to use list routines when modifying lists:
lappend inventory {item 1} {item 2} {item 3}


# Braces and backslash can be used to format more complex values in a list.  A
# list looks exactly like a script, except that the newline character and the
# semicolon character lose their special meanings, and there is no script or
# variable substitution.  This feature makes Tcl homoiconic.  There are three
# items in the following list:
set values {

    one\ two

    {three four}

    five\{six

}


# Since, like all values, a list is a string, string operations could be
# performed on it, at the risk of corrupting the formatting of the list:
set values {one two three four}
set values [string map {two \{} $values] ;# $values is no-longer a \
    properly-formatted list


# The sure-fire way to get a properly-formatted list is to use ""list"" routines:
set values [list one \{ three four]
lappend values { } ;# add a single space as an item in the list


# Use ""eval"" to evaluate a value as a script:
eval {
    set name Neo
    set greeting ""Hello, $name""
}


# A list can always be passed to ""eval"" as a script composed of a single
# command:
eval {set name Neo}
eval [list set greeting ""Hello, $name""]


# Therefore, when using ""eval"", use ""list"" to build up the desired command:
set command {set name}
lappend command {Archibald Sorbisol}
eval $command


# A common mistake is not to use list functions when building up a command:
set command {set name}
append command { Archibald Sorbisol}
try {
    eval $command ;# The error here is that there are too many arguments \
        to ""set"" in {set name Archibald Sorbisol}
} on error {result eoptions} {
    puts [list {received an error} $result]
}

# This mistake can easily occur with ""subst"":

set replacement {Archibald Sorbisol}
set command {set name $replacement}
set command [subst $command] 
try {
    eval $command ;# The same error as before:  too many arguments to ""set"" in \
        {set name Archibald Sorbisol}
} trap {TCL WRONGARGS} {result options} {
    puts [list {received another error} $result]
}


# ""list"" correctly formats a value for substitution:
set replacement [list {Archibald Sorbisol}]
set command {set name $replacement}
set command [subst $command]
eval $command


# ""list"" is commonly used to format values for substitution into scripts: There
# are several examples of this, below.


# ""apply"" evaluates a two-item list as a routine:
set cmd {{greeting name} {
    return ""$greeting, $name!""
}}
apply $cmd Whaddup Neo

# A third item can be used to specify the namespace to apply the routine in:
set cmd [list {greeting name} {
    return ""$greeting, $name!""
} [namespace current]]
apply $cmd Whaddup Neo


# ""uplevel"" evaluates a script at some higher level in the call stack:
proc greet {} {
    uplevel {puts ""$greeting, $name""}
}

proc set_double {varname value} {
    if {[string is double $value]} {
        uplevel [list variable $varname $value]
    } else {
        error [list {not a double} $value]
    }
}


# ""upvar"" links a variable at the current level in the call stack to a variable
# at some higher level:
proc set_double {varname value} {
    if {[string is double $value]} {
        upvar 1 $varname var
        set var $value
    } else {
        error [list {not a double} $value]
    }
}


# Get rid of the built-in ""while"" routine, and use ""proc"" to define a new one:
rename ::while {}
# handling is left as an exercise:
proc while {condition script} {
    if {[uplevel 1 [list expr $condition]]} {
        uplevel 1 $script
        tailcall [namespace which while] $condition $script
    }
}


# ""coroutine"" creates a new call stack, a new routine to enter that call stack,
# and then calls that routine.  ""yield"" suspends evaluation in that stack and
# returns control to the calling stack:
proc countdown count {
    # send something back to the creator of the coroutine, effectively pausing
    # this call stack for the time being.
    yield [info coroutine]

    while {$count > 1} {
        yield [incr count -1]
    }
    return 0
}
coroutine countdown1 countdown 3
coroutine countdown2 countdown 5
puts [countdown1] ;# -> 2 
puts [countdown2] ;# -> 4 
puts [countdown1] ;# -> 1 
puts [countdown1] ;# -> 0 
catch {
    puts [coundown1] ;# -> invalid command name ""countdown1""
} cres copts 
puts $cres
puts [countdown2] ;# -> 3 


# Coroutine stacks can yield control to each other:

proc pass {whom args} {
    return [yieldto $whom {*}$args]
}

coroutine a apply {{} {
        yield
        set result [pass b {please pass the salt}]
        puts [list got the $result]
        set result [pass b {please pass the pepper}]
        puts [list got the $result]
}}

coroutine b apply {{} {
    set request [yield]
    while 1 {
        set response [pass c $request]
        puts [list [info coroutine] is now yielding]
        set request [pass a $response]
    }
}}

coroutine c apply {{} {
    set request [yield]
    while 1 {
        if {[string match *salt* $request]} {
            set request [pass b salt]
        } else {
            set request [pass b huh?]
        }
    }
}}

# get things moving
a


```

## Reference

[Official Tcl Documentation](https://www.tcl-lang.org)

[Tcl Wiki](https://wiki.tcl-lang.org)

[Tcl Subreddit](http://www.reddit.com/r/Tcl)"
"V is a statically typed compiled programming language 
designed for building maintainable software.

It's similar to Go and its design has also been influenced by 
Oberon, Rust, Swift, Kotlin, and Python.

The language promotes writing 
simple and clear code with minimal abstraction.

Despite being simple, V gives the developer a lot of power. 
Anything you can do in other languages, you can do in V.

```v
// Single Line Comment.
/*
    Multi Line Comment
*/

struct User { // Cannot be defined in main, explained later.
	age  int
	name string
	pos int = -1 // custom default value
}
// struct method
fn (u User) can_register() bool {
	return u.age > 16
}

struct Parser {
	token Token
}

// c like enums
enum Token {
	plus
	minus
	div
	mult
}

// 1. functions
// language does not use semi colons
fn add(x int, y int) int {
	return x + y 
}
// can return multiple values
fn foo() (int, int) {
	return 2, 3
}

// function visibility 
pub fn public_function() { // pub can only be used from a named module.
}

fn private_function() {
}



// Main function
fn main() {
	// Anonymous functions can be declared inside other functions:
	double_fn := fn (n int) int {
		return n + n
	}
	// 2. Variables: they are immutable by default
	// implicitly typed
	x := 1
	// x = 2 // error
	mut y := 2
	y = 4
	name := ""John""
	large_number := i64(9999999999999)
    println(""$x, $y, $name, $large_number"") // 1, 4, John, 9999999999999

	// unpacking values from functions.
	a, b := foo()
	println(""$a, $b"") // 2, 3
	c, _ := foo() // ignore values using `_`
	println(""$c"") // 2

	// Numbers
	u := u16(12)
	v := 13 + u    // v is of type `u16`
	r := f32(45.6)
	q := r + 3.14  // x is of type `f32`
	s := 75        // a is of type `int` 
	l := 14.7      // b is of type `f64` 
	e := u + s     // c is of type `int`
	d := l + r     // d is of type `f64`

	// Strings
	mut bob := 'Bob'
	assert bob[0] == u8(66) // indexing gives a byte, u8(66) == `B`
	assert bob[1..3] == 'ob'  // slicing gives a string 'ob'
	bobby := bob + 'by' // + is used to concatenate strings
	println(bobby) // ""Bobby""
	bob += ""by2"" // += is used to append to strings
	println(bob) // ""Bobby2""

	//String values are immutable. You cannot mutate elements:
	//mut s := 'hello 🌎'
	//s[0] = `H` // not allowed

	//For raw strings, prepend r. Escape handling is not done for raw strings:
	rstring := r'hello\nworld' // the `\n` will be preserved as two characters
	println(rstring) // ""hello\nworld""

	// string interpolation
	println('Hello, $bob!') // Hello, Bob!
	println('Bob length + 10: ${bob.len + 10}!') // Bob length + 10: 13!

	// 3. Arrays
	mut numbers := [1, 2, 3]
	println(numbers) // `[1, 2, 3]`
	numbers << 4 // append elements with <<
	println(numbers[3]) // `4`
	numbers[1] = 5
	println(numbers) // `[1, 5, 3]`
	// numbers << ""John"" // error: `numbers` is an array of numbers
	numbers = [] // array is now empty
	arr := []int{len: 5, init: -1}
	// `arr == [-1, -1, -1, -1, -1]`, arr.cap == 5

	number_slices := [0, 10, 20, 30, 40]
	println(number_slices[1..4]) // [10, 20, 30]
	println(number_slices[..4]) // [0, 10, 20, 30]
	println(number_slices[1..]) // [10, 20, 30, 40]

	// 4. structs and enums
	// struct User {
	// 	age  int
	// 	name string
	//  pos int = -1 // custom default value
	// }
	mut users := User{21, 'Bob', 0}
	println(users.age) // 21
	
	// enum Token {
	// 	plus
	// 	minus
	// 	div
	// 	mult
	// }

	// struct Parser {
	// 	token Token
	// }
	parser := Parser{}
	if parser.token == .plus || parser.token == .minus 
	|| parser.token == .div || parser.token == .mult {
		// ...
	}


	// 5. Maps
	number_map := {
		'one': 1
		'two': 2
	}
	println(number_map) // {'one': 1, 'two': 2}
	println(number_map[""one""]) // 1
	mut m := map[string]int{} // a map with `string` keys and `int` values
	m['one'] = 1
	m['two'] = 2
	println(m['one']) // ""1""
	println(m['bad_key']) // ""0""
	m.delete('two')

	// 6. Conditionals
	a_number := 10
	b_number := 20
	if a_number < b {
		println('$a_number < $b_number')
	} else if a_number > b {
		println('$a_number > $b_number')
	} else {
		println('$a_number == $b_number')
	}
	num := 777
	even_odd := if num % 2 == 0 { 'even' } else { 'odd' }
	println(even_odd)

	match even_odd {
		'even' { println('even') }
		'odd' { println('odd') }
		else { println('unknown') }
	} 

	// 7. Loops
	loops := [1, 2, 3, 4, 5]
	for lp in loops {
		println(lp)
	}
	loop_names := ['Sam', 'Peter']
	for i, lname in loop_names {
		println('$i) $lname')
		// Output: 0) Sam
		//         1) Peter
	}
	// You can also use break and continue followed by a 
	// label name to refer to an outer for loop:
	outer: for i := 4; true; i++ {
		println(i)
		for {
			if i < 7 {
				continue outer
			} else {
				break outer
			}
		}
	}
}

```
## Further reading

There are more complex concepts to be learnt in V which are available at the
official [V documentation](https://github.com/vlang/v/blob/master/doc/docs.md).

You can also find more information about the V language at the [official website](https://vlang.io/)
or check it out at the [v playground](https://v-wasm.vercel.app/)."
"**Qt** is a widely-known framework for developing cross-platform software that can be run on various software and hardware platforms with little or no change in the code, while having the power and speed of native applications. Though **Qt** was originally written in *C++*.


This is an adaption on the C++ intro to QT by [Aleksey Kholovchuk](https://github.com/vortexxx192
), some of the code examples should result in the same functionality
this version just having been done using pyqt! 

```python
import sys
from PyQt4 import QtGui
	
def window():
	# Create an application object 
    app = QtGui.QApplication(sys.argv)
	# Create a widget where our label will be placed in
    w = QtGui.QWidget()
	# Add a label to the widget 
    b = QtGui.QLabel(w)
	# Set some text for the label 
    b.setText(""Hello World!"")
	# Give some size and placement information 
    w.setGeometry(100, 100, 200, 50)
    b.move(50, 20)
	# Give our window a nice title 
    w.setWindowTitle(""PyQt"")
	# Have everything display
    w.show()
	# Execute what we have asked for, once all setup
    sys.exit(app.exec_())

if __name__ == '__main__':
    window()

```

In order to get some of the more advanced features in **pyqt** we need to start looking at building additional elements. 
Here we show how to introduce a dialog popup box, useful for asking the user to confirm a decision or to provide information.

```Python 
import sys
from PyQt4.QtGui import *
from PyQt4.QtCore import *


def window():
    app = QApplication(sys.argv)
    w = QWidget()
    # Create a button and attach to widget w
    b = QPushButton(w)
    b.setText(""Press me"")
    b.move(50, 50)
    # Tell b to call this function when clicked
    # notice the lack of ""()"" on the function call
    b.clicked.connect(showdialog)
    w.setWindowTitle(""PyQt Dialog"")
    w.show()
    sys.exit(app.exec_())
	
# This function should create a dialog window with a button
# that waits to be clicked and then exits the program
def showdialog():
    d = QDialog()
    b1 = QPushButton(""ok"", d)
    b1.move(50, 50)
    d.setWindowTitle(""Dialog"")
    # This modality tells the popup to block the parent whilst it's active
    d.setWindowModality(Qt.ApplicationModal)
    # On click I'd like the entire process to end
    b1.clicked.connect(sys.exit)
    d.exec_()

if __name__ == '__main__':
    window()
```"
"C# is an elegant and type-safe object-oriented language that enables developers to build a variety of secure and robust applications that run on the cross-platform .NET framework.

[Read more here.](https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/)

```c#
// Single-line comments start with //

/*
Multi-line comments look like this
*/

/// <summary>
/// This is an XML documentation comment which can be used to generate external
/// documentation or provide context help within an IDE
/// </summary>
/// <param name=""firstParam"">This is some parameter documentation for firstParam</param>
/// <returns>Information on the returned value of a function</returns>
public void MethodOrClassOrOtherWithParsableHelp(string firstParam) { }

// Specify the namespaces this source code will be using
// The namespaces below are all part of the standard .NET Framework Class Library
using System;
using System.Collections.Generic;
using System.Dynamic;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using System.IO;

// But this one is not:
using System.Data.Entity;
// In order to be able to use it, you need to add a dll reference
// This can be done with the NuGet package manager: `Install-Package EntityFramework`

// Namespaces define scope to organize code into ""packages"" or ""modules""
// Using this code from another source file: using Learning.CSharp;

// You can also do this in C# 10, it is called file-scoped namespaces.
// namespace Learning.CSharp;

namespace Learning.CSharp
{
    // Each .cs file should at least contain a class with the same name as the file.
    // You're allowed to do otherwise, but shouldn't for sanity.
    public class LearnCSharp
    {
        // BASIC SYNTAX - skip to INTERESTING FEATURES if you have used Java or C++ before
        public static void Syntax()
        {
            // Use Console.WriteLine to print lines
            Console.WriteLine(""Hello World"");
            Console.WriteLine(
                ""Integer: "" + 10 +
                "" Double: "" + 3.14 +
                "" Boolean: "" + true);

            // To print without a new line, use Console.Write
            Console.Write(""Hello "");
            Console.Write(""World"");

            ///////////////////////////////////////////////////
            // Types & Variables
            //
            // Declare a variable using <type> <name>
            ///////////////////////////////////////////////////

            // Sbyte - Signed 8-bit integer
            // (-128 <= sbyte <= 127)
            sbyte fooSbyte = 100;

            // Byte - Unsigned 8-bit integer
            // (0 <= byte <= 255)
            byte fooByte = 100;

            // Short - 16-bit integer
            // Signed - (-32,768 <= short <= 32,767)
            // Unsigned - (0 <= ushort <= 65,535)
            short fooShort = 10000;
            ushort fooUshort = 10000;

            // Integer - 32-bit integer
            int fooInt = 1; // (-2,147,483,648 <= int <= 2,147,483,647)
            uint fooUint = 1; // (0 <= uint <= 4,294,967,295)

            // Long - 64-bit integer
            long fooLong = 100000L; // (-9,223,372,036,854,775,808 <= long <= 9,223,372,036,854,775,807)
            ulong fooUlong = 100000L; // (0 <= ulong <= 18,446,744,073,709,551,615)
            // Numbers default to being int or uint depending on size.
            // L is used to denote that this variable value is of type long or ulong

            // Double - Double-precision 64-bit IEEE 754 Floating Point
            double fooDouble = 123.4; // Precision: 15-16 digits

            // Float - Single-precision 32-bit IEEE 754 Floating Point
            float fooFloat = 234.5f; // Precision: 7 digits
            // f is used to denote that this variable value is of type float

            // Decimal - a 128-bits data type, with more precision than other floating-point types,
            // suited for financial and monetary calculations
            decimal fooDecimal = 150.3m;

            // Boolean - true & false
            bool fooBoolean = true; // or false

            // Char - A single 16-bit Unicode character
            char fooChar = 'A';

            // Strings -- unlike the previous base types which are all value types,
            // a string is a reference type. That is, you can set it to null
            string fooString = ""\""escape\"" quotes and add \n (new lines) and \t (tabs)"";
            Console.WriteLine(fooString);

            // You can access each character of the string with an indexer:
            char charFromString = fooString[1]; // => 'e'
            // Strings are immutable: you can't do fooString[1] = 'X';

            // Compare strings with current culture, ignoring case
            string.Compare(fooString, ""x"", StringComparison.CurrentCultureIgnoreCase);

            // Formatting, based on sprintf
            string fooFs = string.Format(""Check Check, {0} {1}, {0} {1:0.0}"", 1, 2);

            // Dates & Formatting
            DateTime fooDate = DateTime.Now;
            Console.WriteLine(fooDate.ToString(""hh:mm, dd MMM yyyy""));

            // Verbatim String
            // You can use the @ symbol before a string literal to escape all characters in the string
            string path = ""C:\\Users\\User\\Desktop"";
            string verbatimPath = @""C:\Users\User\Desktop"";
            Console.WriteLine(path == verbatimPath);  // => true

            // You can split a string over two lines with the @ symbol. To escape "" use """"
            string bazString = @""Here's some stuff
on a new line! """"Wow!"""", the masses cried"";

            // Use const or read-only to make a variable immutable
            // const values are calculated at compile time
            const int HoursWorkPerWeek = 9001;

            ///////////////////////////////////////////////////
            // Data Structures
            ///////////////////////////////////////////////////

            // Arrays - zero indexed
            // The array size must be decided upon declaration
            // The format for declaring an array is
            // <datatype>[] <var name> = new <datatype>[<array size>];
            int[] intArray = new int[10];

            // Another way to declare & initialize an array
            int[] y = { 9000, 1000, 1337 };

            // Indexing an array - Accessing an element
            Console.WriteLine(""intArray @ 0: "" + intArray[0]);
            // Arrays are mutable.
            intArray[1] = 1;

            // Lists
            // Lists are used more frequently than arrays as they are more flexible
            // The format for declaring a list is
            // List<datatype> <var name> = new List<datatype>();
            List<int> intList = new List<int>();
            List<string> stringList = new List<string>();
            List<int> z = new List<int> { 9000, 1000, 1337 }; // initialize
            // The <> are for generics - Check out the cool stuff section

            // Lists don't default to a value;
            // A value must be added before accessing the index
            intList.Add(1);
            Console.WriteLine(""intList at 0: "" + intList[0]);

            // Other data structures to check out:
            // Stack/Queue
            // Dictionary (an implementation of a hash map)
            // HashSet
            // Read-only Collections
            // Tuple (.NET 4+)

            ///////////////////////////////////////
            // Operators
            ///////////////////////////////////////
            Console.WriteLine(""\n->Operators"");

            int i1 = 1, i2 = 2; // Shorthand for multiple declarations

            // Arithmetic is straightforward
            Console.WriteLine(i1 + i2 - i1 * 3 / 7); // => 3

            // Modulo
            Console.WriteLine(""11%3 = "" + (11 % 3)); // => 2

            // Comparison operators
            Console.WriteLine(""3 == 2? "" + (3 == 2)); // => false
            Console.WriteLine(""3 != 2? "" + (3 != 2)); // => true
            Console.WriteLine(""3 > 2? "" + (3 > 2)); // => true
            Console.WriteLine(""3 < 2? "" + (3 < 2)); // => false
            Console.WriteLine(""2 <= 2? "" + (2 <= 2)); // => true
            Console.WriteLine(""2 >= 2? "" + (2 >= 2)); // => true

            // Bitwise operators!
            /*
            ~       Unary bitwise complement
            <<      Signed left shift
            >>      Signed right shift
            &       Bitwise AND
            ^       Bitwise exclusive OR
            |       Bitwise inclusive OR
            */

            // Incrementing
            int i = 0;
            Console.WriteLine(""\n->Inc/Dec-rement"");
            Console.WriteLine(i++); //Prints ""0"", i = 1. Post-Increment
            Console.WriteLine(++i); //Prints ""2"", i = 2. Pre-Increment
            Console.WriteLine(i--); //Prints ""2"", i = 1. Post-Decrement
            Console.WriteLine(--i); //Prints ""0"", i = 0. Pre-Decrement

            ///////////////////////////////////////
            // Control Structures
            ///////////////////////////////////////
            Console.WriteLine(""\n->Control Structures"");

            // If statements are C-like
            int j = 10;
            if (j == 10)
            {
                Console.WriteLine(""I get printed"");
            }
            else if (j > 10)
            {
                Console.WriteLine(""I don't"");
            }
            else
            {
                Console.WriteLine(""I also don't"");
            }

            // Ternary operators
            // A simple if/else can be written as follows
            // <condition> ? <true> : <false>
            int toCompare = 17;
            string isTrue = toCompare == 17 ? ""True"" : ""False"";

            // While loop
            int fooWhile = 0;
            while (fooWhile < 100)
            {
                // Iterated 100 times, fooWhile 0->99
                fooWhile++;
            }

            // Do While Loop
            int fooDoWhile = 0;
            do
            {
                // Start iteration 100 times, fooDoWhile 0->99
                if (false)
                    continue; // skip the current iteration

                fooDoWhile++;

                if (fooDoWhile == 50)
                    break; // breaks from the loop completely

            } while (fooDoWhile < 100);

            // for loop structure => for(<start_statement>; <conditional>; <step>)
            for (int fooFor = 0; fooFor < 10; fooFor++)
            {
                // Iterated 10 times, fooFor 0->9
            }

            // For Each Loop
            // foreach loop structure => foreach(<iteratorType> <iteratorName> in <enumerable>)
            // The foreach loop loops over any object implementing IEnumerable or IEnumerable<T>
            // All the collection types (Array, List, Dictionary...) in the .NET framework
            // implement one or both of these interfaces.
            // (The ToCharArray() could be removed, because a string also implements IEnumerable)
            foreach (char character in ""Hello World"".ToCharArray())
            {
                // Iterated over all the characters in the string
            }

            // Switch Case
            // A switch works with byte, short, char, and int data types.
            // It also works with enumerated types (discussed in Enum Types),
            // the String class, and a few special classes that wrap
            // primitive types: Character, Byte, Short, and Integer.
            int month = 3;
            string monthString;
            switch (month)
            {
                case 1:
                    monthString = ""January"";
                    break;
                case 2:
                    monthString = ""February"";
                    break;
                case 3:
                    monthString = ""March"";
                    break;
                // You can assign more than one case to an action
                // But you can't add an action without a break before another case
                // (if you want to do this, you would have to explicitly add a goto case x)
                case 6:
                case 7:
                case 8:
                    monthString = ""Summer time!!"";
                    break;
                default:
                    monthString = ""Some other month"";
                    break;
            }

            ///////////////////////////////////////
            // Converting Data Types And Typecasting
            ///////////////////////////////////////

            // Converting data

            // Convert String To Integer
            // this will throw a FormatException on failure
            int.Parse(""123""); // returns an integer version of ""123""

            // TryParse will default to the type's default value on failure
            // in this case 0
            int tryInt;
            if (int.TryParse(""123"", out tryInt)) // Function is boolean
                Console.WriteLine(tryInt);       // 123

            // Convert Integer To String
            // The Convert class has a number of methods to facilitate conversions

            // String to int

            // Better
            bool result = int.TryParse(string, out var integer)
            int.Parse(string);

            // Not recommended
            Convert.ToString(123);

            // Int to string
            tryInt.ToString();

            // Casting
            // Cast decimal 15 to an int
            // and then implicitly cast to long
            long x = (int) 15M;
        }

        ///////////////////////////////////////
        // CLASSES - see definitions at end of file
        ///////////////////////////////////////
        public static void Classes()
        {
            // See Declaration of objects at end of file

            // Use new to instantiate a class
            Bicycle trek = new Bicycle();

            // Call object methods
            trek.SpeedUp(3); // You should always use setter and getter methods
            trek.Cadence = 100;

            // ToString is a convention to display the value of this Object.
            Console.WriteLine(""trek info: "" + trek.Info());

            // Instantiate a new Penny Farthing
            PennyFarthing funbike = new PennyFarthing(1, 10);
            Console.WriteLine(""funbike info: "" + funbike.Info());

            Console.Read();
        } // End main method

        // Available in C# 9 and later, this is basically syntactic sugar for a class. Records are immutable*.
        public record ARecord(string Csharp);

        // CONSOLE ENTRY - A console application must have a main method as an entry point
        public static void Main(string[] args)
        {
            OtherInterestingFeatures();
        }

        //
        // INTERESTING FEATURES
        //

        // DEFAULT METHOD SIGNATURES

        public // Visibility
        static // Allows for direct call on class without object
        int // Return Type,
        MethodSignatures(
            int maxCount, // First variable, expects an int
            int count = 0, // will default the value to 0 if not passed in
            int another = 3,
            params string[] otherParams // captures all other parameters passed to method
        )
        {
            return -1;
        }

        // Methods can have the same name, as long as the signature is unique
        // A method that differs only in return type is not unique
        public static void MethodSignatures(
            ref int maxCount, // Pass by reference
            out int count)
        {
            // the argument passed in as 'count' will hold the value of 15 outside of this function
            count = 15; // out param must be assigned before control leaves the method
        }

        // GENERICS
        // The classes for TKey and TValue is specified by the user calling this function.
        // This method emulates Python's dict.setdefault()
        public static TValue SetDefault<TKey, TValue>(
            IDictionary<TKey, TValue> dictionary,
            TKey key,
            TValue defaultItem)
        {
            TValue result;
            if (!dictionary.TryGetValue(key, out result))
                return dictionary[key] = defaultItem;
            return result;
        }

        // You can narrow down the objects that are passed in
        public static void IterateAndPrint<T>(T toPrint) where T: IEnumerable<int>
        {
            // We can iterate, since T is a IEnumerable
            foreach (var item in toPrint)
                // Item is an int
                Console.WriteLine(item.ToString());
        }

        // YIELD
        // Usage of the ""yield"" keyword indicates that the method it appears in is an Iterator
        // (this means you can use it in a foreach loop)
        public static IEnumerable<int> YieldCounter(int limit = 10)
        {
            for (var i = 0; i < limit; i++)
                yield return i;
        }

        // which you would call like this :
        public static void PrintYieldCounterToConsole()
        {
            foreach (var counter in YieldCounter())
                Console.WriteLine(counter);
        }

        // you can use more than one ""yield return"" in a method
        public static IEnumerable<int> ManyYieldCounter()
        {
            yield return 0;
            yield return 1;
            yield return 2;
            yield return 3;
        }

        // you can also use ""yield break"" to stop the Iterator
        // this method would only return half of the values from 0 to limit.
        public static IEnumerable<int> YieldCounterWithBreak(int limit = 10)
        {
            for (var i = 0; i < limit; i++)
            {
                if (i > limit/2) yield break;
                yield return i;
            }
        }

        public static void OtherInterestingFeatures()
        {
            // OPTIONAL PARAMETERS
            MethodSignatures(3, 1, 3, ""Some"", ""Extra"", ""Strings"");
            MethodSignatures(3, another: 3); // explicitly set a parameter, skipping optional ones

            // BY REF AND OUT PARAMETERS
            int maxCount = 0, count; // ref params must have value
            MethodSignatures(ref maxCount, out count);

            // EXTENSION METHODS
            int i = 3;
            i.Print(); // Defined below

            // NULLABLE TYPES - great for database interaction / return values
            // any value type (i.e. not a class) can be made nullable by suffixing a ?
            // <type>? <var name> = <value>
            int? nullable = null; // short hand for Nullable<int>
            Console.WriteLine(""Nullable variable: "" + nullable);
            bool hasValue = nullable.HasValue; // true if not null

            // ?? is syntactic sugar for specifying default value (coalesce)
            // in case variable is null
            int notNullable = nullable ?? 0; // 0

            // ?. is an operator for null-propagation - a shorthand way of checking for null
            nullable?.Print(); // Use the Print() extension method if nullable isn't null

            // IMPLICITLY TYPED VARIABLES - you can let the compiler work out what the type is:
            var magic = ""magic is a string, at compile time, so you still get type safety"";
            // magic = 9; will not work as magic is a string, not an int

            // GENERICS
            //
            var phonebook = new Dictionary<string, string>() {
                {""Sarah"", ""212 555 5555""} // Add some entries to the phone book
            };

            // Calling SETDEFAULT defined as a generic above
            Console.WriteLine(SetDefault<string,string>(phonebook, ""Shaun"", ""No Phone"")); // No Phone
            // nb, you don't need to specify the TKey and TValue since they can be
            // derived implicitly
            Console.WriteLine(SetDefault(phonebook, ""Sarah"", ""No Phone"")); // 212 555 5555

            // LAMBDA EXPRESSIONS - allow you to write code in line
            Func<int, int> square = (x) => x * x; // Last T item is the return value
            Console.WriteLine(square(3)); // 9

            // ERROR HANDLING - coping with an uncertain world
            try
            {
                var funBike = PennyFarthing.CreateWithGears(6);

                // will no longer execute because CreateWithGears throws an exception
                string some = """";
                if (true) some = null;
                some.ToLower(); // throws a NullReferenceException
            }
            catch (NotSupportedException)
            {
                Console.WriteLine(""Not so much fun now!"");
            }
            catch (Exception ex) // catch all other exceptions
            {
                throw new ApplicationException(""It hit the fan"", ex);
                // throw; // A rethrow that preserves the callstack
            }
            // catch { } // catch-all without capturing the Exception
            finally
            {
                // executes after try or catch
            }

            // DISPOSABLE RESOURCES MANAGEMENT - let you handle unmanaged resources easily.
            // Most of objects that access unmanaged resources (file handle, device contexts, etc.)
            // implement the IDisposable interface. The using statement takes care of
            // cleaning those IDisposable objects for you.
            using (StreamWriter writer = new StreamWriter(""log.txt""))
            {
                writer.WriteLine(""Nothing suspicious here"");
                // At the end of scope, resources will be released.
                // Even if an exception is thrown.
            }

            // PARALLEL FRAMEWORK
            // https://devblogs.microsoft.com/csharpfaq/parallel-programming-in-net-framework-4-getting-started/

            var words = new List<string> {""dog"", ""cat"", ""horse"", ""pony""};

            Parallel.ForEach(words,
                new ParallelOptions() { MaxDegreeOfParallelism = 4 },
                word =>
                {
                    Console.WriteLine(word);
                }
            );

            // Running this will produce different outputs
            // since each thread finishes at different times.
            // Some example outputs are:
            // cat dog horse pony
            // dog horse pony cat

            // DYNAMIC OBJECTS (great for working with other languages)
            dynamic student = new ExpandoObject();
            student.FirstName = ""First Name""; // No need to define class first!

            // You can even add methods (returns a string, and takes in a string)
            student.Introduce = new Func<string, string>(
                (introduceTo) => string.Format(""Hey {0}, this is {1}"", student.FirstName, introduceTo));
            Console.WriteLine(student.Introduce(""Beth""));

            // IQUERYABLE<T> - almost all collections implement this, which gives you a lot of
            // very useful Map / Filter / Reduce style methods
            var bikes = new List<Bicycle>();
            bikes.Sort(); // Sorts the array
            bikes.Sort((b1, b2) => b1.Wheels.CompareTo(b2.Wheels)); // Sorts based on wheels
            var result = bikes
                .Where(b => b.Wheels > 3) // Filters - chainable (returns IQueryable of previous type)
                .Where(b => b.IsBroken && b.HasTassles)
                .Select(b => b.ToString()); // Map - we only this selects, so result is a IQueryable<string>

            var sum = bikes.Sum(b => b.Wheels); // Reduce - sums all the wheels in the collection

            // Create a list of IMPLICIT objects based on some parameters of the bike
            var bikeSummaries = bikes.Select(b=>new { Name = b.Name, IsAwesome = !b.IsBroken && b.HasTassles });
            // Hard to show here, but you get type ahead completion since the compiler can implicitly work
            // out the types above!
            foreach (var bikeSummary in bikeSummaries.Where(b => b.IsAwesome))
                Console.WriteLine(bikeSummary.Name);

            // ASPARALLEL
            // And this is where things get wicked - combine linq and parallel operations
            var threeWheelers = bikes.AsParallel().Where(b => b.Wheels == 3).Select(b => b.Name);
            // this will happen in parallel! Threads will automagically be spun up and the
            // results divvied amongst them! Amazing for large datasets when you have lots of
            // cores

            // LINQ - maps a store to IQueryable<T> objects, with delayed execution
            // e.g. LinqToSql - maps to a database, LinqToXml maps to an xml document
            var db = new BikeRepository();

            // execution is delayed, which is great when querying a database
            var filter = db.Bikes.Where(b => b.HasTassles); // no query run
            if (42 > 6) // You can keep adding filters, even conditionally - great for ""advanced search"" functionality
                filter = filter.Where(b => b.IsBroken); // no query run

            var query = filter
                .OrderBy(b => b.Wheels)
                .ThenBy(b => b.Name)
                .Select(b => b.Name); // still no query run

            // Now the query runs, but opens a reader, so only populates as you iterate through
            foreach (string bike in query)
                Console.WriteLine(result);



        }

    } // End LearnCSharp class

    // You can include other classes in a .cs file

    public static class Extensions
    {
        // EXTENSION METHODS
        public static void Print(this object obj)
        {
            Console.WriteLine(obj.ToString());
        }
    }


    // DELEGATES AND EVENTS
    public class DelegateTest
    {
        public static int count = 0;
        public static int Increment()
        {
            // increment count then return it
            return ++count;
        }

        // A delegate is a reference to a method.
        // To reference the Increment method,
        // first declare a delegate with the same signature,
        // i.e. takes no arguments and returns an int
        public delegate int IncrementDelegate();

        // An event can also be used to trigger delegates
        // Create an event with the delegate type
        public static event IncrementDelegate MyEvent;

        static void Main(string[] args)
        {
            // Refer to the Increment method by instantiating the delegate
            // and passing the method itself in as an argument
            IncrementDelegate inc = new IncrementDelegate(Increment);
            Console.WriteLine(inc());  // => 1

            // Delegates can be composed with the + operator
            IncrementDelegate composedInc = inc;
            composedInc += inc;
            composedInc += inc;

            // composedInc will run Increment 3 times
            Console.WriteLine(composedInc());  // => 4


            // Subscribe to the event with the delegate
            MyEvent += new IncrementDelegate(Increment);
            MyEvent += new IncrementDelegate(Increment);

            // Trigger the event
            // ie. run all delegates subscribed to this event
            Console.WriteLine(MyEvent());  // => 6
        }
    }


    // Class Declaration Syntax:
    // <public/private/protected/internal> class <class name>{
    //    //data fields, constructors, functions all inside.
    //    //functions are called as methods in Java.
    // }

    public class Bicycle
    {
        // Bicycle's Fields/Variables
        public int Cadence // Public: Can be accessed from anywhere
        {
            get // get - define a method to retrieve the property
            {
                return _cadence;
            }
            set // set - define a method to set a property
            {
                _cadence = value; // Value is the value passed in to the setter
            }
        }
        private int _cadence;

        protected virtual int Gear // Protected: Accessible from the class and subclasses
        {
            get; // creates an auto property so you don't need a member field
            set;
        }

        internal int Wheels // Internal: Accessible from within the assembly
        {
            get;
            private set; // You can set modifiers on the get/set methods
        }

        int _speed; // Everything is private by default: Only accessible from within this class.
                    // can also use keyword private
        public string Name { get; set; }

        // Properties also have a special syntax for when you want a readonly property
        // that simply returns the result of an expression
        public string LongName => Name + "" "" + _speed + "" speed"";

        // Enum is a value type that consists of a set of named constants
        // It is really just mapping a name to a value (an int, unless specified otherwise).
        // The approved types for an enum are byte, sbyte, short, ushort, int, uint, long, or ulong.
        // An enum can't contain the same value twice.
        public enum BikeBrand
        {
            AIST,
            BMC,
            Electra = 42, //you can explicitly set a value to a name
            Gitane // 43
        }
        // We defined this type inside a Bicycle class, so it is a nested type
        // Code outside of this class should reference this type as Bicycle.BikeBrand

        public BikeBrand Brand; // After declaring an enum type, we can declare the field of this type

        // Decorate an enum with the FlagsAttribute to indicate that multiple values can be switched on
        // Any class derived from Attribute can be used to decorate types, methods, parameters etc
        // Bitwise operators & and | can be used to perform and/or operations

        [Flags]
        public enum BikeAccessories
        {
            None = 0,
            Bell = 1,
            MudGuards = 2, // need to set the values manually!
            Racks = 4,
            Lights = 8,
            FullPackage = Bell | MudGuards | Racks | Lights
        }

        // Usage: aBike.Accessories.HasFlag(Bicycle.BikeAccessories.Bell)
        // Before .NET 4: (aBike.Accessories & Bicycle.BikeAccessories.Bell) == Bicycle.BikeAccessories.Bell
        public BikeAccessories Accessories { get; set; }

        // Static members belong to the type itself rather than specific object.
        // You can access them without a reference to any object:
        // Console.WriteLine(""Bicycles created: "" + Bicycle.bicyclesCreated);
        public static int BicyclesCreated { get; set; }

        // readonly values are set at run time
        // they can only be assigned upon declaration or in a constructor
        readonly bool _hasCardsInSpokes = false; // read-only private

        // Constructors are a way of creating classes
        // This is a default constructor
        public Bicycle()
        {
            this.Gear = 1; // you can access members of the object with the keyword this
            Cadence = 50;  // but you don't always need it
            _speed = 5;
            Name = ""Bontrager"";
            Brand = BikeBrand.AIST;
            BicyclesCreated++;
        }

        // This is a specified constructor (it contains arguments)
        public Bicycle(int startCadence, int startSpeed, int startGear,
                       string name, bool hasCardsInSpokes, BikeBrand brand)
            : base() // calls base first
        {
            Gear = startGear;
            Cadence = startCadence;
            _speed = startSpeed;
            Name = name;
            _hasCardsInSpokes = hasCardsInSpokes;
            Brand = brand;
        }

        // Constructors can be chained
        public Bicycle(int startCadence, int startSpeed, BikeBrand brand) :
            this(startCadence, startSpeed, 0, ""big wheels"", true, brand)
        {
        }

        // Function Syntax:
        // <public/private/protected> <return type> <function name>(<args>)

        // classes can implement getters and setters for their fields
        // or they can implement properties (this is the preferred way in C#)

        // Method parameters can have default values.
        // In this case, methods can be called with these parameters omitted
        public void SpeedUp(int increment = 1)
        {
            _speed += increment;
        }

        public void SlowDown(int decrement = 1)
        {
            _speed -= decrement;
        }

        // properties get/set values
        // when only data needs to be accessed, consider using properties.
        // properties may have either get or set, or both
        private bool _hasTassles; // private variable
        public bool HasTassles // public accessor
        {
            get { return _hasTassles; }
            set { _hasTassles = value; }
        }

        // You can also define an automatic property in one line
        // this syntax will create a backing field automatically.
        // You can set an access modifier on either the getter or the setter (or both)
        // to restrict its access:
        public bool IsBroken { get; private set; }

        // Properties can be auto-implemented
        public int FrameSize
        {
            get;
            // you are able to specify access modifiers for either get or set
            // this means only Bicycle class can call set on Framesize
            private set;
        }

        // It's also possible to define custom Indexers on objects.
        // All though this is not entirely useful in this example, you
        // could do bicycle[0] which returns ""chris"" to get the first passenger or
        // bicycle[1] = ""lisa"" to set the passenger. (of this apparent quattrocycle)
        private string[] passengers = { ""chris"", ""phil"", ""darren"", ""regina"" };

        public string this[int i]
        {
            get {
                return passengers[i];
            }

            set {
                passengers[i] = value;
            }
        }

        // Method to display the attribute values of this Object.
        public virtual string Info()
        {
            return ""Gear: "" + Gear +
                    "" Cadence: "" + Cadence +
                    "" Speed: "" + _speed +
                    "" Name: "" + Name +
                    "" Cards in Spokes: "" + (_hasCardsInSpokes ? ""yes"" : ""no"") +
                    ""\n------------------------------\n""
                    ;
        }

        // Methods can also be static. It can be useful for helper methods
        public static bool DidWeCreateEnoughBicycles()
        {
            // Within a static method, we only can reference static class members
            return BicyclesCreated > 9000;
        } // If your class only needs static members, consider marking the class itself as static.


    } // end class Bicycle

    // PennyFarthing is a subclass of Bicycle
    class PennyFarthing : Bicycle
    {
        // (Penny Farthings are those bicycles with the big front wheel.
        // They have no gears.)

        // calling parent constructor
        public PennyFarthing(int startCadence, int startSpeed) :
            base(startCadence, startSpeed, 0, ""PennyFarthing"", true, BikeBrand.Electra)
        {
        }

        protected override int Gear
        {
            get
            {
                return 0;
            }
            set
            {
                throw new InvalidOperationException(""You can't change gears on a PennyFarthing"");
            }
        }

        public static PennyFarthing CreateWithGears(int gears)
        {
            var penny = new PennyFarthing(1, 1);
            penny.Gear = gears; // Oops, can't do this!
            return penny;
        }

        public override string Info()
        {
            string result = ""PennyFarthing bicycle "";
            result += base.ToString(); // Calling the base version of the method
            return result;
        }
    }

    // Interfaces only contain signatures of the members, without the implementation.
    interface IJumpable
    {
        void Jump(int meters); // all interface members are implicitly public
    }

    interface IBreakable
    {
        bool Broken { get; } // interfaces can contain properties as well as methods & events
    }

    // Classes can inherit only one other class, but can implement any amount of interfaces,
    // however the base class name must be the first in the list and all interfaces follow
    class MountainBike : Bicycle, IJumpable, IBreakable
    {
        int damage = 0;

        public void Jump(int meters)
        {
            damage += meters;
        }

        public bool Broken
        {
            get
            {
                return damage > 100;
            }
        }
    }

    /// <summary>
    /// Used to connect to DB for LinqToSql example.
    /// EntityFramework Code First is awesome (similar to Ruby's ActiveRecord, but bidirectional)
    /// https://docs.microsoft.com/ef/ef6/modeling/code-first/workflows/new-database
    /// </summary>
    public class BikeRepository : DbContext
    {
        public BikeRepository()
            : base()
        {
        }

        public DbSet<Bicycle> Bikes { get; set; }
    }

    // Classes can be split across multiple .cs files
    // A1.cs
    public partial class A
    {
        public static void A1()
        {
            Console.WriteLine(""Method A1 in class A"");
        }
    }

    // A2.cs
    public partial class A
    {
        public static void A2()
        {
            Console.WriteLine(""Method A2 in class A"");
        }
    }

    // Program using the partial class ""A""
    public class Program
    {
        static void Main()
        {
            A.A1();
            A.A2();
        }
    }

    // String interpolation by prefixing the string with $
    // and wrapping the expression you want to interpolate with { braces }
    // You can also combine both interpolated and verbatim strings with $@
    public class Rectangle
    {
        public int Length { get; set; }
        public int Width { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Rectangle rect = new Rectangle { Length = 5, Width = 3 };
            Console.WriteLine($""The length is {rect.Length} and the width is {rect.Width}"");

            string username = ""User"";
            Console.WriteLine($@""C:\Users\{username}\Desktop"");
        }
    }

    // New C# 6 features
    class GlassBall : IJumpable, IBreakable
    {
        // Autoproperty initializers
        public int Damage { get; private set; } = 0;

        // Autoproperty initializers on getter-only properties
        public string Name { get; } = ""Glass ball"";

        // Getter-only autoproperty that is initialized in constructor
        public string GenieName { get; }

        public GlassBall(string genieName = null)
        {
            GenieName = genieName;
        }

        public void Jump(int meters)
        {
            if (meters < 0)
                // New nameof() expression; compiler will check that the identifier exists
                // nameof(x) == ""x""
                // Prevents e.g. parameter names changing but not updated in error messages
                throw new ArgumentException(""Cannot jump negative amount!"", nameof(meters));

            Damage += meters;
        }

        // Expression-bodied properties ...
        public bool Broken
            => Damage > 100;

        // ... and methods
        public override string ToString()
            // Interpolated string
            => $""{Name}. Damage taken: {Damage}"";

        public string SummonGenie()
            // Null-conditional operators
            // x?.y will return null immediately if x is null; y is not evaluated
            => GenieName?.ToUpper();
    }

    static class MagicService
    {
        private static bool LogException(Exception ex)
        {
            // log exception somewhere
            return false;
        }

        public static bool CastSpell(string spell)
        {
            try
            {
                // Pretend we call API here
                throw new MagicServiceException(""Spell failed"", 42);

                // Spell succeeded
                return true;
            }
            // Only catch if Code is 42 i.e. spell failed
            catch(MagicServiceException ex) when (ex.Code == 42)
            {
                // Spell failed
                return false;
            }
            // Other exceptions, or MagicServiceException where Code is not 42
            catch(Exception ex) when (LogException(ex))
            {
                // Execution never reaches this block
                // The stack is not unwound
            }
            return false;
            // Note that catching a MagicServiceException and rethrowing if Code
            // is not 42 or 117 is different, as then the final catch-all block
            // will not catch the rethrown exception
        }
    }

    public class MagicServiceException : Exception
    {
        public int Code { get; }

        public MagicServiceException(string message, int code) : base(message)
        {
            Code = code;
        }
    }

    public static class PragmaWarning {
        // Obsolete attribute
        [Obsolete(""Use NewMethod instead"", false)]
        public static void ObsoleteMethod()
        {
            // obsolete code
        }

        public static void NewMethod()
        {
            // new code
        }

        public static void Main()
        {
            ObsoleteMethod(); // CS0618: 'ObsoleteMethod is obsolete: Use NewMethod instead'
#pragma warning disable CS0618
            ObsoleteMethod(); // no warning
#pragma warning restore CS0618
            ObsoleteMethod(); // CS0618: 'ObsoleteMethod is obsolete: Use NewMethod instead'
        }
    }
} // End Namespace

using System;
// C# 6, static using
using static System.Math;

namespace Learning.More.CSharp
{
    class StaticUsing
    {
        static void Main()
        {
            // Without a static using statement..
            Console.WriteLine(""The square root of 4 is {}."", Math.Sqrt(4));
            // With one
            Console.WriteLine(""The square root of 4 is {}."", Sqrt(4));
        }
    }
}

// New C# 7 Feature
// Install Microsoft.Net.Compilers Latest from Nuget
// Install System.ValueTuple Latest from Nuget
using System;
namespace Csharp7
{
    // TUPLES, DECONSTRUCTION AND DISCARDS
    class TuplesTest
    {
        public (string, string) GetName()
        {
            // Fields in tuples are by default named Item1, Item2...
            var names1 = (""Peter"", ""Parker"");
            Console.WriteLine(names1.Item2);  // => Parker

            // Fields can instead be explicitly named
            // Type 1 Declaration
            (string FirstName, string LastName) names2 = (""Peter"", ""Parker"");

            // Type 2 Declaration
            var names3 = (First:""Peter"", Last:""Parker"");

            Console.WriteLine(names2.FirstName);  // => Peter
            Console.WriteLine(names3.Last);  // => Parker

            return names3;
        }

        public string GetLastName() {
            var fullName = GetName();

            // Tuples can be deconstructed
            (string firstName, string lastName) = fullName;

            // Fields in a deconstructed tuple can be discarded by using _
            var (_, last) = fullName;
            return last;
        }

        // Any type can be deconstructed in the same way by
        // specifying a Deconstruct method
        public int randomNumber = 4;
        public int anotherRandomNumber = 10;

        public void Deconstruct(out int randomNumber, out int anotherRandomNumber)
        {
            randomNumber = this.randomNumber;
            anotherRandomNumber = this.anotherRandomNumber;
        }

        static void Main(string[] args)
        {
            var tt = new TuplesTest();
            (int num1, int num2) = tt;
            Console.WriteLine($""num1: {num1}, num2: {num2}"");  // => num1: 4, num2: 10

            Console.WriteLine(tt.GetLastName());
        }
    }

    // PATTERN MATCHING
    class PatternMatchingTest
    {
        public static (string, int)? CreateLogMessage(object data)
        {
            switch(data)
            {
                // Additional filtering using when
                case System.Net.Http.HttpRequestException h when h.Message.Contains(""404""):
                    return (h.Message, 404);
                case System.Net.Http.HttpRequestException h when h.Message.Contains(""400""):
                    return (h.Message, 400);
                case Exception e:
                    return (e.Message, 500);
                case string s:
                    return (s, s.Contains(""Error"") ? 500 : 200);
                case null:
                    return null;
                default:
                    return (data.ToString(), 500);
            }
        }
    }

    // REFERENCE LOCALS
    // Allow you to return a reference to an object instead of just its value
    class RefLocalsTest
    {
        // note ref in return
        public static ref string FindItem(string[] arr, string el)
        {
            for(int i=0; i<arr.Length; i++)
            {
                if(arr[i] == el) {
                    // return the reference
                    return ref arr[i];
                }
            }
            throw new Exception(""Item not found"");
        }

        public static void SomeMethod()
        {
            string[] arr = {""this"", ""is"", ""an"", ""array""};

            // note refs everywhere
            ref string item = ref FindItem(arr, ""array"");
            item = ""apple"";
            Console.WriteLine(arr[3]);  // => apple
        }
    }

    // LOCAL FUNCTIONS
    class LocalFunctionTest
    {
        private static int _id = 0;
        public int id;
        public LocalFunctionTest()
        {
            id = generateId();

            // This local function can only be accessed in this scope
            int generateId()
            {
                return _id++;
            }
        }

        public static void AnotherMethod()
        {
            var lf1 = new LocalFunctionTest();
            var lf2 = new LocalFunctionTest();
            Console.WriteLine($""{lf1.id}, {lf2.id}"");  // => 0, 1

            int id = generateId();
            // error CS0103: The name 'generateId' does not exist in the current context
        }
    }
}

```

## Topics Not Covered
✨ New, 👍 Old, 🎈 LTS, 🔥 Cross-platform, 🎁 Windows-only

 * Attributes

 * Asynchronous Programming

 * Web Development
    * ASP.NET Core ✨

 * Desktop Development
 	* Windows Presentation Foundation 👍 🎈 🎁
    * Universal Windows Platform ✨ 🎁
    * Uno Platform 🔥 ✨
 	* WinForms 👍 🎈 🎁
    * Avalonia 🔥 ✨
    * WinUI ✨ 🎁

* Cross-platform Development
    * Xamarin.Forms 👍
    * MAUI ✨


## Further Reading

 * [C# language reference](https://docs.microsoft.com/dotnet/csharp/language-reference/)
 * [Learn .NET](https://dotnet.microsoft.com/learn)
 * [C# Coding Conventions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions)
 * [DotNetPerls](http://www.dotnetperls.com)
 * [C# in Depth](http://manning.com/skeet2)
 * [Programming C# 5.0](http://shop.oreilly.com/product/0636920024064.do)
 * [LINQ Pocket Reference](http://shop.oreilly.com/product/9780596519254.do)
 * [Windows Forms Programming in C#](http://www.amazon.com/Windows-Forms-Programming-Chris-Sells/dp/0321116208)
 * [freeCodeCamp - C# Tutorial for Beginners](https://www.youtube.com/watch?v=GhQdlIFylQ8)"
This article is available in [Russian](https://learnxinyminutes.com/docs/ru-ru/linker-ru/).
"Hy is a lisp dialect built on top of python. This is achieved by
converting hy code to python's abstract syntax tree (ast). This allows
hy to call native python code or python to call native hy code as well

This tutorial works for hy ≥ 0.9.12, with some corrections for hy 0.11.

```clojure
;; this gives an gentle introduction to hy
;;
; Semicolon comments, like other LISPS

;; s-expression basics
; lisp programs are made of symbolic expressions or sexps which
; resemble
(some-function args)
; now the quintessential hello world
(print ""hello world"")

;; simple data types
; All simple data types are exactly similar to their python counterparts
; which
42 ; => 42
3.14 ; => 3.14
True ; => True
4+10j ; => (4+10j) a complex number

; lets start with some really simple arithmetic
(+ 4 1) ;=> 5
; the operator is applied to all arguments, like other lisps
(+ 4 1 2 3) ;=> 10
(- 2 1) ;=> 1
(* 4 2) ;=> 8
(/ 4 1) ;=> 4
(% 4 2) ;=> 0 the modulo operator
; power is represented by ** operator like python
(** 3 2) ;=> 9
; nesting forms will do the expected thing
(+ 2 (* 4 2)) ;=> 10
; also logical operators and or not and equal to etc. do as expected
(= 5 4) ;=> False
(not (= 5 4)) ;=> True

;; variables
; variables are set using setv, variable names can use utf-8 except
; for ()[]{}"",'`;#|
(setv a 42)
(setv π 3.14159)
(def *foo* 42)
;; other container data types
; strings, lists, tuples & dicts
; these are exactly same as python's container types
""hello world"" ;=> ""hello world""
; string operations work similar to python
(+ ""hello "" ""world"") ;=> ""hello world""
; lists are created using [], indexing starts at 0
(setv mylist [1 2 3 4])
; tuples are immutable data structures
(setv mytuple (, 1 2))
; dictionaries are key value pairs
(setv dict1 {""key1"" 42 ""key2"" 21})
; :name can be used to define keywords in hy which can be used for keys
(setv dict2 {:key1 41 :key2 20})
; use `get' to get the element at an index/key
(get mylist 1) ;=> 2
(get dict1 ""key1"") ;=> 42
; Alternatively if keywords were used they can directly be called
(:key1 dict2) ;=> 41

;; functions and other program constructs
; functions are defined using defn, the last sexp is returned by default
(defn greet [name]
  ""A simple greeting"" ; an optional docstring
  (print ""hello "" name))

(greet ""bilbo"") ;=> ""hello bilbo""

; functions can take optional arguments as well as keyword arguments
(defn foolists [arg1 &optional [arg2 2]]
  [arg1 arg2])

(foolists 3) ;=> [3 2]
(foolists 10 3) ;=> [10 3]

; you can use rest arguments and kwargs too:
(defn something-fancy [wow &rest descriptions &kwargs props]
  (print ""Look at"" wow)
  (print ""It's"" descriptions)
  (print ""And it also has:"" props))

(something-fancy ""My horse"" ""amazing"" :mane ""spectacular"")
  
; you use apply instead of the splat operators:
(apply something-fancy [""My horse"" ""amazing""] { ""mane"" ""spectacular"" })

; anonymous functions are created using `fn' or `lambda' constructs
; which are similar to `defn'
(map (fn [x] (* x x)) [1 2 3 4]) ;=> [1 4 9 16]

;; Sequence operations
; hy has some builtin utils for sequence operations etc.
; retrieve the first element using `first' or `car'
(setv mylist [1 2 3 4])
(setv mydict {""a"" 1 ""b"" 2})
(first mylist) ;=> 1

; slice lists using slice
(slice mylist 1 3) ;=> [2 3]
; or, in hy 0.11, use cut instead:
(cut mylist 1 3) ;=> [2 3]

; get elements from a list or dict using `get'
(get mylist 1) ;=> 2
(get mydict ""b"") ;=> 2
; list indexing starts from 0 same as python
; assoc can set elements at keys/indexes
(assoc mylist 2 10) ; makes mylist [1 2 10 4]
(assoc mydict ""c"" 3) ; makes mydict {""a"" 1 ""b"" 2 ""c"" 3}
; there are a whole lot of other core functions which makes working with
; sequences fun

;; Python interop
;; import works just like in python
(import datetime)
(import [functools [partial reduce]]) ; imports fun1 and fun2 from module1
(import [matplotlib.pyplot :as plt]) ; doing an import foo as bar
; all builtin python methods etc. are accessible from hy
; a.foo(arg) is called as (.foo a arg)
(.split (.strip ""hello world  "")) ;=> [""hello"" ""world""]

; there is a shortcut for executing multiple functions on a value called the
; ""threading macro"", denoted by an arrow:
(-> ""hello world  "" (.strip) (.split)) ;=> [""hello"" ""world]
; the arrow passes the value along the calls as the first argument, for instance:
(-> 4 (* 3) (+ 2))
; is the same as:
(+ (* 4 3) 2)

; there is also a ""threading tail macro"", which instead passes the value as the
; second argument. compare:
(-> 4 (- 2) (+ 1)) ;=> 3
(+ (- 4 2) 1) ;=> 3
; to:
(->> 4 (- 2) (+ 1)) ;=> -1
(+ 1 (- 2 4)) ;=> -1

;; Conditionals
; (if condition (body-if-true) (body-if-false)
(if (= passcode ""moria"")
  (print ""welcome"")
  (print ""Speak friend, and Enter!""))

; nest multiple if else if clauses with cond
(cond
 [(= someval 42)
  (print ""Life, universe and everything else!"")]
 [(> someval 42)
  (print ""val too large"")]
 [(< someval 42)
  (print ""val too small"")])

; group statements with do, these are executed sequentially
; forms like defn have an implicit do
(do
 (setv someval 10)
 (print ""someval is set to "" someval)) ;=> 10

; create lexical bindings with `let', all variables defined thusly
; have local scope
(let [[nemesis {""superman"" ""lex luther""
                ""sherlock"" ""moriarty""
                ""seinfeld"" ""newman""}]]
  (for [(, h v) (.items nemesis)]
	(print (.format ""{0}'s nemesis was {1}"" h v))))

;; classes
; classes are defined in the following way
(defclass Wizard [object]
  [[--init-- (fn [self spell]
             (setv self.spell spell) ; init the spell attr
             None)]
   [get-spell (fn [self]
              self.spell)]])

; or, in hy 0.11:
(defclass Wizard [object]
  (defn --init-- [self spell]
    (setv self.spell spell))

  (defn get-spell [self]
    self.spell))

;; do checkout hylang.org
```

### Further Reading

This tutorial is just a very basic introduction to hy/lisp/python.

Hy docs are here: [http://hy.readthedocs.org](http://hy.readthedocs.org)

Hy's GitHub repo: [http://github.com/hylang/hy](http://github.com/hylang/hy)

On freenode irc #hy, twitter hashtag #hylang"
"Python was created by Guido van Rossum in the early 90s. It is now one of the
most popular languages in existence. I fell in love with Python for its
syntactic clarity. It's basically executable pseudocode.

Note: This article applies to Python 3 specifically. Check out
[here](http://learnxinyminutes.com/docs/pythonlegacy/) if you want to learn the
old Python 2.7

```python

# Single line comments start with a number symbol.

"""""" Multiline strings can be written
    using three ""s, and are often used
    as documentation.
""""""

####################################################
## 1. Primitive Datatypes and Operators
####################################################

# You have numbers
3  # => 3

# Math is what you would expect
1 + 1   # => 2
8 - 1   # => 7
10 * 2  # => 20
35 / 5  # => 7.0

# Integer division rounds down for both positive and negative numbers.
5 // 3       # => 1
-5 // 3      # => -2
5.0 // 3.0   # => 1.0 # works on floats too
-5.0 // 3.0  # => -2.0

# The result of division is always a float
10.0 / 3  # => 3.3333333333333335

# Modulo operation
7 % 3   # => 1
# i % j have the same sign as j, unlike C
-7 % 3  # => 2

# Exponentiation (x**y, x to the yth power)
2**3  # => 8

# Enforce precedence with parentheses
1 + 3 * 2    # => 7
(1 + 3) * 2  # => 8

# Boolean values are primitives (Note: the capitalization)
True   # => True
False  # => False

# negate with not
not True   # => False
not False  # => True

# Boolean Operators
# Note ""and"" and ""or"" are case-sensitive
True and False  # => False
False or True   # => True

# True and False are actually 1 and 0 but with different keywords
True + True # => 2
True * 8    # => 8
False - 5   # => -5

# Comparison operators look at the numerical value of True and False
0 == False  # => True
2 > True    # => True
2 == True   # => False
-5 != False # => True

# None, 0, and empty strings/lists/dicts/tuples/sets all evaluate to False.
# All other values are True
bool(0)     # => False
bool("""")    # => False
bool([])    # => False
bool({})    # => False
bool(())    # => False
bool(set()) # => False
bool(4)     # => True
bool(-6)    # => True

# Using boolean logical operators on ints casts them to booleans for evaluation,
# but their non-cast value is returned. Don't mix up with bool(ints) and bitwise
# and/or (&,|)
bool(0)     # => False
bool(2)     # => True
0 and 2     # => 0
bool(-5)    # => True
bool(2)     # => True
-5 or 0     # => -5

# Equality is ==
1 == 1  # => True
2 == 1  # => False

# Inequality is !=
1 != 1  # => False
2 != 1  # => True

# More comparisons
1 < 10  # => True
1 > 10  # => False
2 <= 2  # => True
2 >= 2  # => True

# Seeing whether a value is in a range
1 < 2 and 2 < 3  # => True
2 < 3 and 3 < 2  # => False
# Chaining makes this look nicer
1 < 2 < 3  # => True
2 < 3 < 2  # => False

# (is vs. ==) is checks if two variables refer to the same object, but == checks
# if the objects pointed to have the same values.
a = [1, 2, 3, 4]  # Point a at a new list, [1, 2, 3, 4]
b = a             # Point b at what a is pointing to
b is a            # => True, a and b refer to the same object
b == a            # => True, a's and b's objects are equal
b = [1, 2, 3, 4]  # Point b at a new list, [1, 2, 3, 4]
b is a            # => False, a and b do not refer to the same object
b == a            # => True, a's and b's objects are equal

# Strings are created with "" or '
""This is a string.""
'This is also a string.'

# Strings can be added too
""Hello "" + ""world!""  # => ""Hello world!""
# String literals (but not variables) can be concatenated without using '+'
""Hello "" ""world!""    # => ""Hello world!""

# A string can be treated like a list of characters
""Hello world!""[0]  # => 'H'

# You can find the length of a string
len(""This is a string"")  # => 16

# Since Python 3.6, you can use f-strings or formatted string literals.
name = ""Reiko""
f""She said her name is {name}."" # => ""She said her name is Reiko""
# Any valid Python expression inside these braces is returned to the string.
f""{name} is {len(name)} characters long."" # => ""Reiko is 5 characters long.""

# None is an object
None  # => None

# Don't use the equality ""=="" symbol to compare objects to None
# Use ""is"" instead. This checks for equality of object identity.
""etc"" is None  # => False
None is None   # => True

####################################################
## 2. Variables and Collections
####################################################

# Python has a print function
print(""I'm Python. Nice to meet you!"")  # => I'm Python. Nice to meet you!

# By default the print function also prints out a newline at the end.
# Use the optional argument end to change the end string.
print(""Hello, World"", end=""!"")  # => Hello, World!

# Simple way to get input data from console
input_string_var = input(""Enter some data: "") # Returns the data as a string

# There are no declarations, only assignments.
# Convention is to use lower_case_with_underscores
some_var = 5
some_var  # => 5

# Accessing a previously unassigned variable is an exception.
# See Control Flow to learn more about exception handling.
some_unknown_var  # Raises a NameError

# if can be used as an expression
# Equivalent of C's '?:' ternary operator
""yay!"" if 0 > 1 else ""nay!""  # => ""nay!""

# Lists store sequences
li = []
# You can start with a prefilled list
other_li = [4, 5, 6]

# Add stuff to the end of a list with append
li.append(1)    # li is now [1]
li.append(2)    # li is now [1, 2]
li.append(4)    # li is now [1, 2, 4]
li.append(3)    # li is now [1, 2, 4, 3]
# Remove from the end with pop
li.pop()        # => 3 and li is now [1, 2, 4]
# Let's put it back
li.append(3)    # li is now [1, 2, 4, 3] again.

# Access a list like you would any array
li[0]   # => 1
# Look at the last element
li[-1]  # => 3

# Looking out of bounds is an IndexError
li[4]  # Raises an IndexError

# You can look at ranges with slice syntax.
# The start index is included, the end index is not
# (It's a closed/open range for you mathy types.)
li[1:3]   # Return list from index 1 to 3 => [2, 4]
li[2:]    # Return list starting from index 2 => [4, 3]
li[:3]    # Return list from beginning until index 3  => [1, 2, 4]
li[::2]   # Return list selecting elements with a step size of 2 => [1, 4]
li[::-1]  # Return list in reverse order => [3, 4, 2, 1]
# Use any combination of these to make advanced slices
# li[start:end:step]

# Make a one layer deep copy using slices
li2 = li[:]  # => li2 = [1, 2, 4, 3] but (li2 is li) will result in false.

# Remove arbitrary elements from a list with ""del""
del li[2]  # li is now [1, 2, 3]

# Remove first occurrence of a value
li.remove(2)  # li is now [1, 3]
li.remove(2)  # Raises a ValueError as 2 is not in the list

# Insert an element at a specific index
li.insert(1, 2)  # li is now [1, 2, 3] again

# Get the index of the first item found matching the argument
li.index(2)  # => 1
li.index(4)  # Raises a ValueError as 4 is not in the list

# You can add lists
# Note: values for li and for other_li are not modified.
li + other_li  # => [1, 2, 3, 4, 5, 6]

# Concatenate lists with ""extend()""
li.extend(other_li)  # Now li is [1, 2, 3, 4, 5, 6]

# Check for existence in a list with ""in""
1 in li  # => True

# Examine the length with ""len()""
len(li)  # => 6


# Tuples are like lists but are immutable.
tup = (1, 2, 3)
tup[0]      # => 1
tup[0] = 3  # Raises a TypeError

# Note that a tuple of length one has to have a comma after the last element but
# tuples of other lengths, even zero, do not.
type((1))   # => <class 'int'>
type((1,))  # => <class 'tuple'>
type(())    # => <class 'tuple'>

# You can do most of the list operations on tuples too
len(tup)         # => 3
tup + (4, 5, 6)  # => (1, 2, 3, 4, 5, 6)
tup[:2]          # => (1, 2)
2 in tup         # => True

# You can unpack tuples (or lists) into variables
a, b, c = (1, 2, 3)  # a is now 1, b is now 2 and c is now 3
# You can also do extended unpacking
a, *b, c = (1, 2, 3, 4)  # a is now 1, b is now [2, 3] and c is now 4
# Tuples are created by default if you leave out the parentheses
d, e, f = 4, 5, 6  # tuple 4, 5, 6 is unpacked into variables d, e and f
# respectively such that d = 4, e = 5 and f = 6
# Now look how easy it is to swap two values
e, d = d, e  # d is now 5 and e is now 4


# Dictionaries store mappings from keys to values
empty_dict = {}
# Here is a prefilled dictionary
filled_dict = {""one"": 1, ""two"": 2, ""three"": 3}

# Note keys for dictionaries have to be immutable types. This is to ensure that
# the key can be converted to a constant hash value for quick look-ups.
# Immutable types include ints, floats, strings, tuples.
invalid_dict = {[1,2,3]: ""123""}  # => Yield a TypeError: unhashable type: 'list'
valid_dict = {(1,2,3):[1,2,3]}   # Values can be of any type, however.

# Look up values with []
filled_dict[""one""]  # => 1

# Get all keys as an iterable with ""keys()"". We need to wrap the call in list()
# to turn it into a list. We'll talk about those later.  Note - for Python
# versions <3.7, dictionary key ordering is not guaranteed. Your results might
# not match the example below exactly. However, as of Python 3.7, dictionary
# items maintain the order at which they are inserted into the dictionary.
list(filled_dict.keys())  # => [""three"", ""two"", ""one""] in Python <3.7
list(filled_dict.keys())  # => [""one"", ""two"", ""three""] in Python 3.7+


# Get all values as an iterable with ""values()"". Once again we need to wrap it
# in list() to get it out of the iterable. Note - Same as above regarding key
# ordering.
list(filled_dict.values())  # => [3, 2, 1]  in Python <3.7
list(filled_dict.values())  # => [1, 2, 3] in Python 3.7+

# Check for existence of keys in a dictionary with ""in""
""one"" in filled_dict  # => True
1 in filled_dict      # => False

# Looking up a non-existing key is a KeyError
filled_dict[""four""]  # KeyError

# Use ""get()"" method to avoid the KeyError
filled_dict.get(""one"")      # => 1
filled_dict.get(""four"")     # => None
# The get method supports a default argument when the value is missing
filled_dict.get(""one"", 4)   # => 1
filled_dict.get(""four"", 4)  # => 4

# ""setdefault()"" inserts into a dictionary only if the given key isn't present
filled_dict.setdefault(""five"", 5)  # filled_dict[""five""] is set to 5
filled_dict.setdefault(""five"", 6)  # filled_dict[""five""] is still 5

# Adding to a dictionary
filled_dict.update({""four"":4})  # => {""one"": 1, ""two"": 2, ""three"": 3, ""four"": 4}
filled_dict[""four""] = 4         # another way to add to dict

# Remove keys from a dictionary with del
del filled_dict[""one""]  # Removes the key ""one"" from filled dict

# From Python 3.5 you can also use the additional unpacking options
{'a': 1, **{'b': 2}}  # => {'a': 1, 'b': 2}
{'a': 1, **{'a': 2}}  # => {'a': 2}



# Sets store ... well sets
empty_set = set()
# Initialize a set with a bunch of values.
some_set = {1, 1, 2, 2, 3, 4}  # some_set is now {1, 2, 3, 4}

# Similar to keys of a dictionary, elements of a set have to be immutable.
invalid_set = {[1], 1}  # => Raises a TypeError: unhashable type: 'list'
valid_set = {(1,), 1}

# Add one more item to the set
filled_set = some_set
filled_set.add(5)  # filled_set is now {1, 2, 3, 4, 5}
# Sets do not have duplicate elements
filled_set.add(5)  # it remains as before {1, 2, 3, 4, 5}

# Do set intersection with &
other_set = {3, 4, 5, 6}
filled_set & other_set  # => {3, 4, 5}

# Do set union with |
filled_set | other_set  # => {1, 2, 3, 4, 5, 6}

# Do set difference with -
{1, 2, 3, 4} - {2, 3, 5}  # => {1, 4}

# Do set symmetric difference with ^
{1, 2, 3, 4} ^ {2, 3, 5}  # => {1, 4, 5}

# Check if set on the left is a superset of set on the right
{1, 2} >= {1, 2, 3} # => False

# Check if set on the left is a subset of set on the right
{1, 2} <= {1, 2, 3} # => True

# Check for existence in a set with in
2 in filled_set   # => True
10 in filled_set  # => False

# Make a one layer deep copy
filled_set = some_set.copy()  # filled_set is {1, 2, 3, 4, 5}
filled_set is some_set        # => False


####################################################
## 3. Control Flow and Iterables
####################################################

# Let's just make a variable
some_var = 5

# Here is an if statement. Indentation is significant in Python!
# Convention is to use four spaces, not tabs.
# This prints ""some_var is smaller than 10""
if some_var > 10:
    print(""some_var is totally bigger than 10."")
elif some_var < 10:    # This elif clause is optional.
    print(""some_var is smaller than 10."")
else:                  # This is optional too.
    print(""some_var is indeed 10."")


""""""
For loops iterate over lists
prints:
    dog is a mammal
    cat is a mammal
    mouse is a mammal
""""""
for animal in [""dog"", ""cat"", ""mouse""]:
    # You can use format() to interpolate formatted strings
    print(""{} is a mammal"".format(animal))

""""""
""range(number)"" returns an iterable of numbers
from zero up to (but excluding) the given number
prints:
    0
    1
    2
    3
""""""
for i in range(4):
    print(i)

""""""
""range(lower, upper)"" returns an iterable of numbers
from the lower number to the upper number
prints:
    4
    5
    6
    7
""""""
for i in range(4, 8):
    print(i)

""""""
""range(lower, upper, step)"" returns an iterable of numbers
from the lower number to the upper number, while incrementing
by step. If step is not indicated, the default value is 1.
prints:
    4
    6
""""""
for i in range(4, 8, 2):
    print(i)

""""""
Loop over a list to retrieve both the index and the value of each list item:
    0 dog
    1 cat
    2 mouse
""""""
animals = [""dog"", ""cat"", ""mouse""]
for i, value in enumerate(animals):
    print(i, value)

""""""
While loops go until a condition is no longer met.
prints:
    0
    1
    2
    3
""""""
x = 0
while x < 4:
    print(x)
    x += 1  # Shorthand for x = x + 1

# Handle exceptions with a try/except block
try:
    # Use ""raise"" to raise an error
    raise IndexError(""This is an index error"")
except IndexError as e:
    pass                 # Refrain from this, provide a recovery (next example).
except (TypeError, NameError):
    pass                 # Multiple exceptions can be processed jointly.
else:                    # Optional clause to the try/except block. Must follow
                         # all except blocks.
    print(""All good!"")   # Runs only if the code in try raises no exceptions
finally:                 # Execute under all circumstances
    print(""We can clean up resources here"")

# Instead of try/finally to cleanup resources you can use a with statement
with open(""myfile.txt"") as f:
    for line in f:
        print(line)

# Writing to a file
contents = {""aa"": 12, ""bb"": 21}
with open(""myfile1.txt"", ""w+"") as file:
    file.write(str(contents))        # writes a string to a file

import json
with open(""myfile2.txt"", ""w+"") as file:
    file.write(json.dumps(contents)) # writes an object to a file

# Reading from a file
with open('myfile1.txt', ""r+"") as file:
    contents = file.read()           # reads a string from a file
print(contents)
# print: {""aa"": 12, ""bb"": 21}

with open('myfile2.txt', ""r+"") as file:
    contents = json.load(file)       # reads a json object from a file
print(contents)
# print: {""aa"": 12, ""bb"": 21}


# Python offers a fundamental abstraction called the Iterable.
# An iterable is an object that can be treated as a sequence.
# The object returned by the range function, is an iterable.

filled_dict = {""one"": 1, ""two"": 2, ""three"": 3}
our_iterable = filled_dict.keys()
print(our_iterable)  # => dict_keys(['one', 'two', 'three']). This is an object
                     # that implements our Iterable interface.

# We can loop over it.
for i in our_iterable:
    print(i)  # Prints one, two, three

# However we cannot address elements by index.
our_iterable[1]  # Raises a TypeError

# An iterable is an object that knows how to create an iterator.
our_iterator = iter(our_iterable)

# Our iterator is an object that can remember the state as we traverse through
# it. We get the next object with ""next()"".
next(our_iterator)  # => ""one""

# It maintains state as we iterate.
next(our_iterator)  # => ""two""
next(our_iterator)  # => ""three""

# After the iterator has returned all of its data, it raises a
# StopIteration exception
next(our_iterator)  # Raises StopIteration

# We can also loop over it, in fact, ""for"" does this implicitly!
our_iterator = iter(our_iterable)
for i in our_iterator:
    print(i)  # Prints one, two, three

# You can grab all the elements of an iterable or iterator by call of list().
list(our_iterable)  # => Returns [""one"", ""two"", ""three""]
list(our_iterator)  # => Returns [] because state is saved


####################################################
## 4. Functions
####################################################

# Use ""def"" to create new functions
def add(x, y):
    print(""x is {} and y is {}"".format(x, y))
    return x + y  # Return values with a return statement

# Calling functions with parameters
add(5, 6)  # => prints out ""x is 5 and y is 6"" and returns 11

# Another way to call functions is with keyword arguments
add(y=6, x=5)  # Keyword arguments can arrive in any order.

# You can define functions that take a variable number of
# positional arguments
def varargs(*args):
    return args

varargs(1, 2, 3)  # => (1, 2, 3)

# You can define functions that take a variable number of
# keyword arguments, as well
def keyword_args(**kwargs):
    return kwargs

# Let's call it to see what happens
keyword_args(big=""foot"", loch=""ness"")  # => {""big"": ""foot"", ""loch"": ""ness""}


# You can do both at once, if you like
def all_the_args(*args, **kwargs):
    print(args)
    print(kwargs)
""""""
all_the_args(1, 2, a=3, b=4) prints:
    (1, 2)
    {""a"": 3, ""b"": 4}
""""""

# When calling functions, you can do the opposite of args/kwargs!
# Use * to expand args (tuples) and use ** to expand kwargs (dictionaries).
args = (1, 2, 3, 4)
kwargs = {""a"": 3, ""b"": 4}
all_the_args(*args)            # equivalent: all_the_args(1, 2, 3, 4)
all_the_args(**kwargs)         # equivalent: all_the_args(a=3, b=4)
all_the_args(*args, **kwargs)  # equivalent: all_the_args(1, 2, 3, 4, a=3, b=4)

# Returning multiple values (with tuple assignments)
def swap(x, y):
    return y, x  # Return multiple values as a tuple without the parenthesis.
                 # (Note: parenthesis have been excluded but can be included)

x = 1
y = 2
x, y = swap(x, y)     # => x = 2, y = 1
# (x, y) = swap(x,y)  # Again the use of parenthesis is optional.

# global scope
x = 5

def set_x(num):
    # local scope begins here
    # local var x not the same as global var x
    x = num    # => 43
    print(x)   # => 43

def set_global_x(num):
    # global indicates that particular var lives in the global scope
    global x
    print(x)   # => 5
    x = num    # global var x is now set to 6
    print(x)   # => 6

set_x(43)
set_global_x(6)
""""""
prints:
    43
    5
    6
""""""


# Python has first class functions
def create_adder(x):
    def adder(y):
        return x + y
    return adder

add_10 = create_adder(10)
add_10(3)   # => 13

# There are also anonymous functions
(lambda x: x > 2)(3)                  # => True
(lambda x, y: x ** 2 + y ** 2)(2, 1)  # => 5

# There are built-in higher order functions
list(map(add_10, [1, 2, 3]))          # => [11, 12, 13]
list(map(max, [1, 2, 3], [4, 2, 1]))  # => [4, 2, 3]

list(filter(lambda x: x > 5, [3, 4, 5, 6, 7]))  # => [6, 7]

# We can use list comprehensions for nice maps and filters
# List comprehension stores the output as a list (which itself may be nested).
[add_10(i) for i in [1, 2, 3]]         # => [11, 12, 13]
[x for x in [3, 4, 5, 6, 7] if x > 5]  # => [6, 7]

# You can construct set and dict comprehensions as well.
{x for x in 'abcddeef' if x not in 'abc'}  # => {'d', 'e', 'f'}
{x: x**2 for x in range(5)}  # => {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}


####################################################
## 5. Modules
####################################################

# You can import modules
import math
print(math.sqrt(16))  # => 4.0

# You can get specific functions from a module
from math import ceil, floor
print(ceil(3.7))   # => 4
print(floor(3.7))  # => 3

# You can import all functions from a module.
# Warning: this is not recommended
from math import *

# You can shorten module names
import math as m
math.sqrt(16) == m.sqrt(16)  # => True

# Python modules are just ordinary Python files. You
# can write your own, and import them. The name of the
# module is the same as the name of the file.

# You can find out which functions and attributes
# are defined in a module.
import math
dir(math)

# If you have a Python script named math.py in the same
# folder as your current script, the file math.py will
# be loaded instead of the built-in Python module.
# This happens because the local folder has priority
# over Python's built-in libraries.


####################################################
## 6. Classes
####################################################

# We use the ""class"" statement to create a class
class Human:

    # A class attribute. It is shared by all instances of this class
    species = ""H. sapiens""

    # Basic initializer, this is called when this class is instantiated.
    # Note that the double leading and trailing underscores denote objects
    # or attributes that are used by Python but that live in user-controlled
    # namespaces. Methods(or objects or attributes) like: __init__, __str__,
    # __repr__ etc. are called special methods (or sometimes called dunder
    # methods). You should not invent such names on your own.
    def __init__(self, name):
        # Assign the argument to the instance's name attribute
        self.name = name

        # Initialize property
        self._age = 0   # the leading underscore indicates the ""age"" property is 
                        # intended to be used internally
                        # do not rely on this to be enforced: it's a hint to other devs

    # An instance method. All methods take ""self"" as the first argument
    def say(self, msg):
        print(""{name}: {message}"".format(name=self.name, message=msg))

    # Another instance method
    def sing(self):
        return 'yo... yo... microphone check... one two... one two...'

    # A class method is shared among all instances
    # They are called with the calling class as the first argument
    @classmethod
    def get_species(cls):
        return cls.species

    # A static method is called without a class or instance reference
    @staticmethod
    def grunt():
        return ""*grunt*""

    # A property is just like a getter.
    # It turns the method age() into a read-only attribute of the same name.
    # There's no need to write trivial getters and setters in Python, though.
    @property
    def age(self):
        return self._age

    # This allows the property to be set
    @age.setter
    def age(self, age):
        self._age = age

    # This allows the property to be deleted
    @age.deleter
    def age(self):
        del self._age


# When a Python interpreter reads a source file it executes all its code.
# This __name__ check makes sure this code block is only executed when this
# module is the main program.
if __name__ == '__main__':
    # Instantiate a class
    i = Human(name=""Ian"")
    i.say(""hi"")                     # ""Ian: hi""
    j = Human(""Joel"")
    j.say(""hello"")                  # ""Joel: hello""
    # i and j are instances of type Human; i.e., they are Human objects.

    # Call our class method
    i.say(i.get_species())          # ""Ian: H. sapiens""
    # Change the shared attribute
    Human.species = ""H. neanderthalensis""
    i.say(i.get_species())          # => ""Ian: H. neanderthalensis""
    j.say(j.get_species())          # => ""Joel: H. neanderthalensis""

    # Call the static method
    print(Human.grunt())            # => ""*grunt*""

    # Static methods can be called by instances too
    print(i.grunt())                # => ""*grunt*""

    # Update the property for this instance
    i.age = 42
    # Get the property
    i.say(i.age)                    # => ""Ian: 42""
    j.say(j.age)                    # => ""Joel: 0""
    # Delete the property
    del i.age
    # i.age                         # => this would raise an AttributeError


####################################################
## 6.1 Inheritance
####################################################

# Inheritance allows new child classes to be defined that inherit methods and
# variables from their parent class.

# Using the Human class defined above as the base or parent class, we can
# define a child class, Superhero, which inherits the class variables like
# ""species"", ""name"", and ""age"", as well as methods, like ""sing"" and ""grunt""
# from the Human class, but can also have its own unique properties.

# To take advantage of modularization by file you could place the classes above
# in their own files, say, human.py

# To import functions from other files use the following format
# from ""filename-without-extension"" import ""function-or-class""

from human import Human


# Specify the parent class(es) as parameters to the class definition
class Superhero(Human):

    # If the child class should inherit all of the parent's definitions without
    # any modifications, you can just use the ""pass"" keyword (and nothing else)
    # but in this case it is commented out to allow for a unique child class:
    # pass

    # Child classes can override their parents' attributes
    species = 'Superhuman'

    # Children automatically inherit their parent class's constructor including
    # its arguments, but can also define additional arguments or definitions
    # and override its methods such as the class constructor.
    # This constructor inherits the ""name"" argument from the ""Human"" class and
    # adds the ""superpower"" and ""movie"" arguments:
    def __init__(self, name, movie=False,
                 superpowers=[""super strength"", ""bulletproofing""]):

        # add additional class attributes:
        self.fictional = True
        self.movie = movie
        # be aware of mutable default values, since defaults are shared
        self.superpowers = superpowers

        # The ""super"" function lets you access the parent class's methods
        # that are overridden by the child, in this case, the __init__ method.
        # This calls the parent class constructor:
        super().__init__(name)

    # override the sing method
    def sing(self):
        return 'Dun, dun, DUN!'

    # add an additional instance method
    def boast(self):
        for power in self.superpowers:
            print(""I wield the power of {pow}!"".format(pow=power))


if __name__ == '__main__':
    sup = Superhero(name=""Tick"")

    # Instance type checks
    if isinstance(sup, Human):
        print('I am human')
    if type(sup) is Superhero:
        print('I am a superhero')

    # Get the ""Method Resolution Order"" used by both getattr() and super()
    # (the order in which classes are searched for an attribute or method)
    # This attribute is dynamic and can be updated
    print(Superhero.__mro__)    # => (<class '__main__.Superhero'>,
                                # => <class 'human.Human'>, <class 'object'>)

    # Calls parent method but uses its own class attribute
    print(sup.get_species())    # => Superhuman

    # Calls overridden method
    print(sup.sing())           # => Dun, dun, DUN!

    # Calls method from Human
    sup.say('Spoon')            # => Tick: Spoon

    # Call method that exists only in Superhero
    sup.boast()                 # => I wield the power of super strength!
                                # => I wield the power of bulletproofing!

    # Inherited class attribute
    sup.age = 31
    print(sup.age)              # => 31

    # Attribute that only exists within Superhero
    print('Am I Oscar eligible? ' + str(sup.movie))

####################################################
## 6.2 Multiple Inheritance
####################################################

# Another class definition
# bat.py
class Bat:

    species = 'Baty'

    def __init__(self, can_fly=True):
        self.fly = can_fly

    # This class also has a say method
    def say(self, msg):
        msg = '... ... ...'
        return msg

    # And its own method as well
    def sonar(self):
        return '))) ... ((('

if __name__ == '__main__':
    b = Bat()
    print(b.say('hello'))
    print(b.fly)


# And yet another class definition that inherits from Superhero and Bat
# superhero.py
from superhero import Superhero
from bat import Bat

# Define Batman as a child that inherits from both Superhero and Bat
class Batman(Superhero, Bat):

    def __init__(self, *args, **kwargs):
        # Typically to inherit attributes you have to call super:
        # super(Batman, self).__init__(*args, **kwargs)
        # However we are dealing with multiple inheritance here, and super()
        # only works with the next base class in the MRO list.
        # So instead we explicitly call __init__ for all ancestors.
        # The use of *args and **kwargs allows for a clean way to pass
        # arguments, with each parent ""peeling a layer of the onion"".
        Superhero.__init__(self, 'anonymous', movie=True,
                           superpowers=['Wealthy'], *args, **kwargs)
        Bat.__init__(self, *args, can_fly=False, **kwargs)
        # override the value for the name attribute
        self.name = 'Sad Affleck'

    def sing(self):
        return 'nan nan nan nan nan batman!'


if __name__ == '__main__':
    sup = Batman()

    # The Method Resolution Order
    print(Batman.__mro__)       # => (<class '__main__.Batman'>,
                                # => <class 'superhero.Superhero'>,
                                # => <class 'human.Human'>,
                                # => <class 'bat.Bat'>, <class 'object'>)

    # Calls parent method but uses its own class attribute
    print(sup.get_species())    # => Superhuman

    # Calls overridden method
    print(sup.sing())           # => nan nan nan nan nan batman!

    # Calls method from Human, because inheritance order matters
    sup.say('I agree')          # => Sad Affleck: I agree

    # Call method that exists only in 2nd ancestor
    print(sup.sonar())          # => ))) ... (((

    # Inherited class attribute
    sup.age = 100
    print(sup.age)              # => 100

    # Inherited attribute from 2nd ancestor whose default value was overridden.
    print('Can I fly? ' + str(sup.fly)) # => Can I fly? False



####################################################
## 7. Advanced
####################################################

# Generators help you make lazy code.
def double_numbers(iterable):
    for i in iterable:
        yield i + i

# Generators are memory-efficient because they only load the data needed to
# process the next value in the iterable. This allows them to perform
# operations on otherwise prohibitively large value ranges.
# NOTE: `range` replaces `xrange` in Python 3.
for i in double_numbers(range(1, 900000000)):  # `range` is a generator.
    print(i)
    if i >= 30:
        break

# Just as you can create a list comprehension, you can create generator
# comprehensions as well.
values = (-x for x in [1,2,3,4,5])
for x in values:
    print(x)  # prints -1 -2 -3 -4 -5 to console/terminal

# You can also cast a generator comprehension directly to a list.
values = (-x for x in [1,2,3,4,5])
gen_to_list = list(values)
print(gen_to_list)  # => [-1, -2, -3, -4, -5]


# Decorators are a form of syntactic sugar.
# They make code easier to read while accomplishing clunky syntax.

# Wrappers are one type of decorator.
# They're really useful for adding logging to existing functions without needing to modify them.

def log_function(func):
    def wrapper(*args, **kwargs):
        print(""Entering function"", func.__name__)
        result = func(*args, **kwargs)
        print(""Exiting function"", func.__name__)
        return result
    return wrapper

@log_function               # equivalent:
def my_function(x,y):       # def my_function(x,y):
    return x+y              #   return x+y
                            # my_function = log_function(my_function)
# The decorator @log_function tells us as we begin reading the function definition
# for my_function that this function will be wrapped with log_function.
# When function definitions are long, it can be hard to parse the non-decorated
# assignment at the end of the definition.

my_function(1,2) # => ""Entering function my_function""
                 # => ""3""
                 # => ""Exiting function my_function""

# But there's a problem.
# What happens if we try to get some information about my_function?

print(my_function.__name__) # => 'wrapper'
print(my_function.__code__.co_argcount) # => 0. The argcount is 0 because both arguments in wrapper()'s signature are optional.

# Because our decorator is equivalent to my_function = log_function(my_function)
# we've replaced information about my_function with information from wrapper

# Fix this using functools

from functools import wraps

def log_function(func):
    @wraps(func) # this ensures docstring, function name, arguments list, etc. are all copied
                 # to the wrapped function - instead of being replaced with wrapper's info
    def wrapper(*args, **kwargs):
        print(""Entering function"", func.__name__)
        result = func(*args, **kwargs)
        print(""Exiting function"", func.__name__)
        return result
    return wrapper

@log_function               
def my_function(x,y):       
    return x+y              
                            
my_function(1,2) # => ""Entering function my_function""
                 # => ""3""
                 # => ""Exiting function my_function""

print(my_function.__name__) # => 'my_function'
print(my_function.__code__.co_argcount) # => 2

```

### Free Online

* [Automate the Boring Stuff with Python](https://automatetheboringstuff.com)
* [The Official Docs](https://docs.python.org/3/)
* [Hitchhiker's Guide to Python](https://docs.python-guide.org/en/latest/)
* [Python Course](https://www.python-course.eu)
* [Free Interactive Python Course](http://www.Kikodo.io)
* [First Steps With Python](https://realpython.com/learn/python-first-steps/)
* [A curated list of awesome Python frameworks, libraries and software](https://github.com/vinta/awesome-python)
* [30 Python Language Features and Tricks You May Not Know About](https://sahandsaba.com/thirty-python-language-features-and-tricks-you-may-not-know.html)
* [Official Style Guide for Python](https://www.python.org/dev/peps/pep-0008/)
* [Python 3 Computer Science Circles](https://cscircles.cemc.uwaterloo.ca/)
* [Dive Into Python 3](https://www.diveintopython3.net/index.html)
* [A Crash Course in Python for Scientists](https://nbviewer.jupyter.org/gist/anonymous/5924718)
* [Python Tutorial for Intermediates](https://pythonbasics.org/)
* [Build a Desktop App with Python](https://pythonpyqt.com/)"
"YAML is a data serialisation language designed to be directly writable and
readable by humans.

It's a strict superset of JSON, with the addition of syntactically
significant newlines and indentation, like Python. Unlike Python, however,
YAML doesn't allow literal tab characters for indentation.

```yaml
---  # document start

# Comments in YAML look like this.
# YAML supports single-line comments.

################
# SCALAR TYPES #
################

# Our root object (which continues for the entire document) will be a map,
# which is equivalent to a dictionary, hash or object in other languages.
key: value
another_key: Another value goes here.
a_number_value: 100
scientific_notation: 1e+12
hex_notation: 0x123  # evaluates to 291
octal_notation: 0123 # evaluates to 83

# The number 1 will be interpreted as a number, not a boolean. 
# If you want it to be interpreted as a boolean, use true.
boolean: true
null_value: null
another_null_value: ~
key with spaces: value

# Yes and No (doesn't matter the case) will be evaluated to boolean 
# true and false values respectively.
# To use the actual value use single or double quotes.
no: no            # evaluates to ""no"": false
yes: No           # evaluates to ""yes"": false
not_enclosed: yes # evaluates to ""not_enclosed"": true
enclosed: ""yes""   # evaluates to ""enclosed"": yes

# Notice that strings don't need to be quoted. However, they can be.
however: 'A string, enclosed in quotes.'
'Keys can be quoted too.': ""Useful if you want to put a ':' in your key.""
single quotes: 'have ''one'' escape pattern'
double quotes: ""have many: \"", \0, \t, \u263A, \x0d\x0a == \r\n, and more.""
# UTF-8/16/32 characters need to be encoded
Superscript two: \u00B2

# Special characters must be enclosed in single or double quotes
special_characters: ""[ John ] & { Jane } - <Doe>""

# Multiple-line strings can be written either as a 'literal block' (using |), 
# or a 'folded block' (using '>').
# Literal block turn every newline within the string into a literal newline (\n).
# Folded block removes newlines within the string.
literal_block: |
  This entire block of text will be the value of the 'literal_block' key,
  with line breaks being preserved.

  The literal continues until de-dented, and the leading indentation is
  stripped.

      Any lines that are 'more-indented' keep the rest of their indentation -
      these lines will be indented by 4 spaces.
folded_style: >
  This entire block of text will be the value of 'folded_style', but this
  time, all newlines will be replaced with a single space.

  Blank lines, like above, are converted to a newline character.

      'More-indented' lines keep their newlines, too -
      this text will appear over two lines.

# |- and >- removes the trailing blank lines (also called literal/block ""strip"")
literal_strip: |-
  This entire block of text will be the value of the 'literal_block' key,
  with trailing blank line being stripped.
block_strip: >-
  This entire block of text will be the value of 'folded_style', but this
  time, all newlines will be replaced with a single space and 
  trailing blank line being stripped.

# |+ and >+ keeps trailing blank lines (also called literal/block ""keep"")
literal_keep: |+
  This entire block of text will be the value of the 'literal_block' key,
  with trailing blank line being kept.

block_keep: >+
  This entire block of text will be the value of 'folded_style', but this
  time, all newlines will be replaced with a single space and 
  trailing blank line being kept.

####################
# COLLECTION TYPES #
####################

# Nesting uses indentation. 2 space indent is preferred (but not required).
a_nested_map:
  key: value
  another_key: Another Value
  another_nested_map:
    hello: hello

# Maps don't have to have string keys.
0.25: a float key

# Keys can also be complex, like multi-line objects
# We use ? followed by a space to indicate the start of a complex key.
? |
  This is a key
  that has multiple lines
: and this is its value

# YAML also allows mapping between sequences with the complex key syntax
# Some language parsers might complain
# An example
? - Manchester United
  - Real Madrid
: [ 2001-01-01, 2002-02-02 ]

# Sequences (equivalent to lists or arrays) look like this
# (note that the '-' counts as indentation):
a_sequence:
  - Item 1
  - Item 2
  - 0.5  # sequences can contain disparate types.
  - Item 4
  - key: value
    another_key: another_value
  - - This is a sequence
    - inside another sequence
  - - - Nested sequence indicators
      - can be collapsed

# Since YAML is a superset of JSON, you can also write JSON-style maps and
# sequences:
json_map: { ""key"": ""value"" }
json_seq: [ 3, 2, 1, ""takeoff"" ]
and quotes are optional: { key: [ 3, 2, 1, takeoff ] }

#######################
# EXTRA YAML FEATURES #
#######################

# YAML also has a handy feature called 'anchors', which let you easily duplicate
# content across your document.
# Anchors identified by & character which define the value.
# Aliases identified by * character which acts as ""see above"" command.
# Both of these keys will have the same value:
anchored_content: &anchor_name This string will appear as the value of two keys.
other_anchor: *anchor_name

# Anchors can be used to duplicate/inherit properties
base: &base
  name: Everyone has same name

# The regexp << is called 'Merge Key Language-Independent Type'. It is used to
# indicate that all the keys of one or more specified maps should be inserted
# into the current map.
# NOTE: If key already exists alias will not be merged
foo:
  <<: *base # doesn't merge the anchor
  age: 10
  name: John
bar:
  <<: *base # base anchor will be merged
  age: 20

# foo and bar would also have name: Everyone has same name

# YAML also has tags, which you can use to explicitly declare types.
# Syntax: !![typeName] [value]
explicit_boolean: !!bool true
explicit_integer: !!int 42
explicit_float: !!float -42.24
explicit_string: !!str 0.5
explicit_datetime: !!timestamp 2022-11-17 12:34:56.78 +9
explicit_null: !!null null

# Some parsers implement language specific tags, like this one for Python's
# complex number type.
python_complex_number: !!python/complex 1+2j

# We can also use yaml complex keys with language specific tags
? !!python/tuple [ 5, 7 ]
: Fifty Seven
# Would be {(5, 7): 'Fifty Seven'} in Python

####################
# EXTRA YAML TYPES #
####################

# Strings and numbers aren't the only scalars that YAML can understand.
# ISO-formatted date and datetime literals are also parsed.
datetime_canonical: 2001-12-15T02:59:43.1Z
datetime_space_separated_with_time_zone: 2001-12-14 21:59:43.10 -5
date_implicit: 2002-12-14
date_explicit: !!timestamp 2002-12-14

# The !!binary tag indicates that a string is actually a base64-encoded
# representation of a binary blob.
gif_file: !!binary |
  R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5
  OTk6enp56enmlpaWNjY6Ojo4SEhP/++f/++f/++f/++f/++f/++f/++f/++f/+
  +f/++f/++f/++f/++f/++SH+Dk1hZGUgd2l0aCBHSU1QACwAAAAADAAMAAAFLC
  AgjoEwnuNAFOhpEMTRiggcz4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs=

# YAML also has a set type, which looks like this:
set:
  ? item1
  ? item2
  ? item3
or: { item1, item2, item3 }

# Sets are just maps with null values; the above is equivalent to:
set2:
  item1: null
  item2: null
  item3: null

...  # document end
```

### More Resources

+ [YAML official website](https://yaml.org/)
+ [Online YAML Validator](http://www.yamllint.com/)
+ [JSON ⇆ YAML](https://www.json2yaml.com/)"
"[Phel](https://phel-lang.org/) is a functional programming language that compiles to PHP.
It is a dialect of Lisp inspired by Clojure and Janet.

## Features
- Built on PHP's ecosystem
- Good error reporting
- Persistent Datastructures (Lists, Vectors, Maps and Sets)
- Macros
- Recursive functions
- Powerful but simple Syntax
- REPL

```newlisp
# Comments begin with a # character and continue until the end of the line. There are no multi-line comments.

# Phel is written in ""forms"", which are just
# lists of things inside parentheses, separated by whitespace.

# The first call in a file should be ns, to set the namespace
(ns learn-phel)

# More basic examples:

# str will create a string out of all its arguments
(str ""Hello"" "" "" ""World"") #=> ""Hello World""

# Math is straightforward
(+ 1 1) #=> 2
(- 2 1) #=> 1
(* 1 2) #=> 2
(/ 2 1) #=> 2

# Equality is =
(= 1 1) #=> true
(= 2 1) #=> false

# You need not for logic, too
(not true) #=> false

# Nesting forms works as you expect
(+ 1 (- 3 2)) # = 1 + (3 - 2) => 2

# Phel inherits PHP under the hood, so it can use native PHP (functions and classes) without 
# any additional cost by using the `php/` prefix to all PHP native functions.

# Types
#############

# Booleans are similar as the native PHP ones

nil
true
false 

# Symbols are used to name functions and variables in Phel
# For example: symbol, snake_case_symbol, my-module/my-function

# Keywords are like symbols that begin with a colon character. However, they are used as constants rather than a name for something.

:keyword
:0x0x0x
::

# Numbers in Phel are equivalent to numbers in PHP

1337 # integer
+1337 # positive integer
-1337 # negative integer

1.234 # float
+1.234 # positive float
-1.234 # negative float
1.2e3 # float
7E-10 # float

# Strings are surrounded by double quotes. They almost work the same as PHP double quoted strings.
# A string can be written in multiple lines. The line break character is then ignored by the reader.

""hello world""

""this is\na\nstring""

""this
is
a
string.""

""use backslack to escape \"" string""

""the dollar must not be escaped: $ or $abc just works""


# Collections & Sequences
#############

# Lists are linked-list data structures, while vectors are array-backed
(type '(1 2 3)) #=> :list
(type [1 2 3])  #=> :vector

# A list would be written as just (1 2 3), but we have to quote
# it to stop the reader thinking it's a function.
# Also, (list 1 2 3) is the same as '(1 2 3)

# You can produce a (non-lazy) sequence between a range. 
(range 1 10 2) #=> (range from to step)
(take 4 (range 10))

# Use cons to add an item to the beginning of a list
(cons 4 '(1 2 3)) #=> (4 1 2 3)

# Use push to add, and put to replace an item in a vector 
(push [1 2 3] 4)  #=> (1 2 3 4)
(put [1 2 3] 1 4) #=> (1 4 3)

# Use concat to add lists or vectors together
(concat [1 2] '(3 4)) #=> [1 2 3 4]

# Use filter, map to interact with collections
(map inc [1 2 3])      #=> [2 3 4]
(filter even? [1 2 3]) #=> [2]

# Use reduce to reduce them. The initial-value is mandatory
(reduce + 0 [1 2 3 4])
#=> (+ (+ (+ 1 2) 3) 4)
#=> 10

(reduce push [] '(3 2 1))
#=> (push (push (push [] 3) 2) 1)
#=> [3 2 1]

# Functions
#############

# Use fn to create new functions
# A function always returns its last statement
(fn [] ""Hello World"") #=> <function>

# You need extra parens to call it
((fn [] ""Hello World"")) #=> ""Hello World""

# You can bind a value to a symbol using def for definition
(def x 1)
x #=> 1

# Variables provide a way to manage mutable state
(def foo (var 10)) # Define a variable with value 10

# Assign a function to a definition
(def hello-world (fn [] ""Hello World""))
(hello-world) #=> ""Hello World""

# You can shorten this process by using defn
(defn hello-world [] ""Hello World"")

# The [] is the list of arguments for the function
(defn hello [name]
  (str ""Hello "" name))
(hello ""Jens"") #=> ""Hello Jens""

# You can also use this shorthand to create functions
(def hello2 |(str ""Hello "" $1))
(hello2 ""Anna"") #=> ""Hello Anna""

# Functions can pack extra arguments up in a seq for you
(defn count-args [& args]
  (str ""You passed "" (count args) "" args: "" args))
(count-args 1 2 3) #=> ""You passed 3 args: @[1 2 3]""

# You can mix regular and packed arguments
(defn hello-count [name & args]
  (str ""Hello "" name "", you passed "" (count args) "" extra args""))
(hello-count ""Jesus"" 1 2) #=> ""Hello Jesus, you passed 2 extra args""


# Maps
#############

# Hash maps have faster lookups but don't retain key order
(type {:a 1 :b 2 :c 3})          #=> :hash-map
(type (hash-map :a 1 :b 2 :c 3)) #=> :hash-map

# Maps can use any hashable type as a key, but usually keywords are best
# Keywords are like strings with some efficiency bonuses and they start with `:`
(type :a) #=> :keyword

(def stringmap {""a"" 1 ""b"" 2 ""c"" 3})
stringmap  #=> {""a"" 1 ""b"" 2 ""c"" 3}

(def keymap {:a 1 :b 2 :c 3})
keymap  #=> {:a 1 :c 3 :b 2}

# Retrieve a value from a map by calling it as a function
(stringmap ""a"") #=> 1
(keymap :a)     #=> 1

# Keywords can be used to retrieve their value from a map, too!
(:b keymap) #=> 2

# Don't try this with strings
# (""a"" stringmap)
# ...Exception: Call to undefined function a()

# Retrieving a non-present key returns nil
(stringmap ""d"") #=> nil

# Use put to add new keys to hash-maps
(def newkeymap (put keymap :d 4))
newkeymap #=> {:a 1 :b 2 :c 3 :d 4}

# But remember, phel types are immutable!
keymap #=> {:a 1 :b 2 :c 3}

# Use unset to remove keys
(unset keymap :a) #=> {:b 2 :c 3}

# Sets
#############

# A Set contains unique values in random order

(type (set 1 2 3)) #=> :set
(set 1 2 3 1 2 3 3 2 1 3 2 1) #=> (set 1 2 3)

# Add a member with push
(push (set 1 2 3) 4) #=> (set 1 2 3 4)

# Remove one with unset
(unset (set 1 2 3) 1) #=> (set 2 3)

# Test for existence by using the set as a function
((set 1 2 3) 1) #=> 1
((set 1 2 3) 4) #=> nil

# There are more functions like: count, union, intersection, difference, etc


# Useful forms
#############

# `If` conditionals in phel are special forms
(if false ""a"" ""b"") #=> ""b""
(if false ""a"") #=> nil

# Use let to create temporary bindings
(let [a 1 b 2]
  (> a b)) #=> false

# Group statements together with do
(do
  (print ""Hello"")
  ""World"") #=> ""World"" (prints ""Hello"")

# Functions have an implicit do
(defn print-and-say-hello [name]
  (print ""Saying hello to "" name)
  (str ""Hello "" name))
(print-and-say-hello ""Jeff"") #=> ""Hello Jeff"" (prints ""Saying hello to Jeff"")

# So does let
(let [name ""Urkel""]
  (print ""Saying hello to "" name)
  (str ""Hello "" name)) #=> ""Hello Urkel"" (prints ""Saying hello to Urkel"")

# Use the threading macros (-> and ->>) to express transformations of
# data more clearly.

# The ""Thread-first"" macro (->) inserts into each form the result of
# the previous, as the first argument (second item)
(->
   {:a 1 :b 2}
   (put :c 3)  #=> (put {:a 1 :b 2} :c 3)
   (unset :b)) #=> (unset (put {:a 1 :b 2} :c 3) :b)


# The double arrow does the same thing, but inserts the result of
# each line at the *end* of the form. This is useful for collection
# operations in particular:
(->>
   (range 10)
   (map inc)      #=> (map inc (range 10))
   (filter odd?)) #=> (filter odd? (map inc (range 10)))
                  # Result: [1 3 5 7 9]


# When you are in a situation where you want more freedom as where to
# put the result of previous data transformations in an
# expression, you can use the as-> macro. With it, you can assign a
# specific name to transformations' output and use it as a
# placeholder in your chained expressions:

(as-> [1 2 3] input
  (map inc input)     #=> You can use last transform's output at the last position
  (get input 2)       #=> and at the second position, in the same expression
  (push [4 5 6] input 8 9 10)) #=> or in the middle !
                               # Result: [4 5 6 4 8 9 10]

# PHP
#################

# PHP has a huge and useful standard library, and you're able to use
# all native functions with the prefix `php/`.
(php/+ 1 2 3)

# With :use you can use different namespaces. Similar as `use` in PHP
(ns my\module
  (:use \DateTimeImmutable))

# You can import functions from other phel files with :require
(ns my\module
  (:require phel\test :refer [deftest is]))

# Use the class name with a ""php/new"" to make a new instance
(php/new \DateTime) # <a date-time object>

# Use php/-> to call methods of an object
(def d (php/new \DateTime))
(php/-> d (getTimestamp)) # <a timestamp>

# you can do it in one line too
(php/-> (php/new \DateTime) (getTimestamp))

# Use php/:: to call static methods
(php/:: \DateTimeImmutable ATOM) # <a timestamp>
```

### Further Reading

This is far from exhaustive, but hopefully it's enough to get you on your feet.

Read the full documentation in the website: [https://phel-lang.org/](https://phel-lang.org/documentation/getting-started/)"
"- Smalltalk is a fully object-oriented, dynamically typed, reflective programming language with no 'non-object' types.
- Smalltalk was created as the language to underpin the ""new world"" of computing exemplified by ""human–computer symbiosis.""
- It was designed and created in part for educational use, more so for constructionist learning, at the Learning Research Group (LRG) of Xerox PARC by Alan Kay, Dan Ingalls, Adele Goldberg, Ted Kaehler, Scott Wallace, and others during the 1970s.

`Feedback highly appreciated! Reach me at [@jigyasa_grover](https://twitter.com/jigyasa_grover) or send me an e-mail at grover.jigyasa1@gmail.com.`

## The Basics

### Everything is an object
Yes, everything. Integers are instances of one of the numeric classes. Classes are instances of the class Metaclass and are just as manipulable as any other object. All classes are part of a single class tree; no disjoint class trees. Stack frames are objects and can be manipulated, which is how the debugger works. There are no pointers into memory locations that you can dereference and mess with.

### Functions are not called; messages are sent to objects
- Work is done by sending messages to objects, which decide how to respond to that message and run a method as a result, which eventually returns some object to the original message sending code.
- The system knows the class of the object receiving a message and looks up the message in that class's list of methods. If it is not found, the lookup continues in the super class until either it is found or the root of the classes is reached and there is still no relevant method. 
- If a suitable method is found the code is run, and the same process keeps on going with all the methods sent by that method and so on forever.
- If no suitable method is found an exception is raised, which typically results in a user interface notifier to tell the user that the message was not understood. It is entirely possible to catch the exception and do something to fix the problem, which might range from 'ignore it' to 'load some new packages for this class and try again'.
- A method (more strictly an instance of the class CompiledMethod) is a chunk of Smalltalk code that has been compiled into bytecodes. Executing methods start at the beginning and return to the sender when a return is encountered (we use ^ to signify 'return the following object') or the end of the code is reached, in which case the current object running the code is returned.

### Simple syntax
Smalltalk has a simple syntax with very few rules. 
The most basic operation is to send a message to an object
`anObject aMessage`

There are three sorts of messages

- unary - a single symbol that may be several words conjoined in what we call camelcase form, with no arguments. For example 'size', 'reverseBytes', 'convertToLargerFormatPixels'
- binary - a small set of symbols of the sort often used for arithmetic operations in most languages, requiring a single argument. For example '+', '//', '@'. We do not use traditional arithmetic precedence, something to keep an eye on.
- keyword - the general form where multiple arguments can be passed. As with the unary form we use camelcase to join words together but arguments are inserted in the midst of the message with colons used to separate them lexically. For example 'setTemperature:', 'at:put:', 'drawFrom:to:lineWidth:fillColor:'

#### An example
`result := myObject doSomethingWith: thatObject`
We are sending the message 'doSomethingWith:' to myObject. This happens to be a message that has a single argument but that's not important yet.
'myObject' is a 'MyExampleClass' instance so the system looks at the list of messages understood by MyExampleClass

- beClever
- doWeirdThing:
- doSomethingWith

In searching we see what initially looks like a match - but no, it lacks the final colon. So we find the super class of MyExampleClass - BigExampleClass. Which has a list of known messages of its own

- beClever
- doSomethingWith:
- buildCastleInAir
- annoyUserByDoing:

We find a proper exact match and start to execute the code:

```smalltalk
doSomethingWith: argumentObject
    self size > 4 ifTrue: [^argumentObject sizeRelatingTo: self].
```   

Everything here except the `^` involves sending more messages. Event the `ifTrue:` that you might think is a language control structure is just Smalltalk code.

We start by sending `size` to `self`. `self` is the object currently running the code - so in this case it is the myObject we started with. `size` is a very common message that we might anticipate tells us something about how big an object is; you could look it up with the Smalltalk tools very simply. The result we get is then sent the message `>` with the plain old integer 4 (which is an object too; no strange primitive types to pollute the system here) and nobody should be surprised the `>` is a comparison that answers true or false. That boolean (which is actually a Boolean object in Smalltalk) is sent the message `ifTrue:` with the block of code between the `[]` as its argument; obviously a true boolean might be expected to run that block of code and a false to ignore it. 

If the block is run then we do some more message sending to the argument object and noting the `^` we return the answer back to our starting point and it gets assigned to `result`. If the block is ignored we seem to run out of code and so `self` is returned and assigned to `result`.

## Smalltalk quick reference cheat-sheet
Taken from [Smalltalk Cheatsheet](http://www.angelfire.com/tx4/cus/notes/smalltalk.html)

#### Allowable characters:
- a-z
- A-Z
- 0-9
- .+/\*~<>@%|&?
- blank, tab, cr, ff, lf

#### Variables:
- variable names must be declared before use but are untyped
- shared vars (globals, class vars) conventionally begin with uppercase (except the reserved names shown below)
- local vars (instance vars, temporaries, method & block arguments) conventionally begin with lowercase
- reserved names: `nil`, `true`, `false`, `self`, `super`, and `thisContext`

#### Variable scope:
- Global: defined in a Dictionary named 'Smalltalk' and accessible by all objects in system
- Special: (reserved) `Smalltalk`, `super`, `self`, `true`, `false`, & `nil`
- Method Temporary: local to a method
- Block Temporary: local to a block
- Pool: variables in a Dictionary object, possibly shared with classes not directly related by inheritance
- Method Parameters: automatic method temp vars that name the incoming parameters. Cannot be assigned to 
- Block Parameters: automatic block temp vars that name the incoming parameters. Cannot be assigned to
- Class: shared with all instances of a class & its subclasses
- Class Instance: unique to each instance of a class. Too commonly confused with class variables
- Instance Variables: unique to each instance of a class

`""Comments are enclosed in quotes and may be arbitrary length""`

`""Period (.) is the statement separator. Not required on last line of a method""`

#### Transcript:
```smalltalk
Transcript clear.                        ""clear to transcript window""
Transcript show: 'Hello World'.          ""output string in transcript window""
Transcript nextPutAll: 'Hello World'.    ""output string in transcript window""
Transcript nextPut: $A.                  ""output character in transcript window""
Transcript space.                        ""output space character in transcript window""
Transcript tab.                          ""output tab character in transcript window""
Transcript cr.                           ""carriage return / linefeed""
'Hello' printOn: Transcript.             ""append print string into the window""
'Hello' storeOn: Transcript.             ""append store string into the window""
Transcript endEntry.                     ""flush the output buffer""
```

#### Assignment:
```smalltalk
| x y |
x _ 4.                            ""assignment (Squeak) <-""
x := 5.                           ""assignment""
x := y := z := 6.                 ""compound assignment""
x := (y := 6) + 1.
x := Object new.                  ""bind to allocated instance of a class""
```

#### Constants:
```smalltalk
| b |
b := true.                ""true constant""
b := false.               ""false constant""
x := nil.                 ""nil object constant""
x := 1.                   ""integer constants""
x := 3.14.                ""float constants""
x := 2e-2.                ""fractional constants""
x := 16r0F.               ""hex constant"".
x := -1.                  ""negative constants""
x := 'Hello'.             ""string constant""
x := 'I''m here'.         ""single quote escape""
x := $A.                  ""character constant""
x := $ .                  ""character constant (space)""
x := #aSymbol.            ""symbol constants""
x := #(3 2 1).            ""array constants""
x := #('abc' 2 $a).       ""mixing of types allowed""
```

#### Booleans:
```smalltalk
| b x y |
x := 1. y := 2.
b := (x = y).                         ""equals""
b := (x ~= y).                         ""not equals""
b := (x == y).                         ""identical""
b := (x ~~ y).                         ""not identical""
b := (x > y).                          ""greater than""
b := (x < y).                          ""less than""
b := (x >= y).                         ""greater than or equal""
b := (x <= y).                         ""less than or equal""
b := b not.                            ""boolean not""
b := (x < 5) & (y > 1).                ""boolean and""
b := (x < 5) | (y > 1).                ""boolean or""
b := (x < 5) and: [y > 1].             ""boolean and (short-circuit)""
b := (x < 5) or: [y > 1].              ""boolean or (short-circuit)""
b := (x < 5) eqv: (y > 1).             ""test if both true or both false""
b := (x < 5) xor: (y > 1).             ""test if one true and other false""
b := 5 between: 3 and: 12.             ""between (inclusive)""
b := 123 isKindOf: Number.             ""test if object is class or subclass of""
b := 123 isMemberOf: SmallInteger.     ""test if object is type of class""
b := 123 respondsTo: sqrt.             ""test if object responds to message""
b := x isNil.                          ""test if object is nil""
b := x isZero.                         ""test if number is zero""
b := x positive.                       ""test if number is positive""
b := x strictlyPositive.               ""test if number is greater than zero""
b := x negative.                       ""test if number is negative""
b := x even.                           ""test if number is even""
b := x odd.                            ""test if number is odd""
b := x isLiteral.                      ""test if literal constant""
b := x isInteger.                      ""test if object is integer""
b := x isFloat.                        ""test if object is float""
b := x isNumber.                       ""test if object is number""
b := $A isUppercase.                   ""test if upper case character""
b := $A isLowercase.                   ""test if lower case character""
```

#### Arithmetic expressions:
```smalltalk
| x |
x := 6 + 3.                             ""addition""
x := 6 - 3.                             ""subtraction""
x := 6 * 3.                             ""multiplication""
x := 1 + 2 * 3.                         ""evaluation always left to right (1 + 2) * 3""
x := 5 / 3.                             ""division with fractional result""
x := 5.0 / 3.0.                         ""division with float result""
x := 5.0 // 3.0.                        ""integer divide""
x := 5.0 \\ 3.0.                        ""integer remainder""
x := -5.                                ""unary minus""
x := 5 sign.                            ""numeric sign (1, -1 or 0)""
x := 5 negated.                         ""negate receiver""
x := 1.2 integerPart.                   ""integer part of number (1.0)""
x := 1.2 fractionPart.                  ""fractional part of number (0.2)""
x := 5 reciprocal.                      ""reciprocal function""
x := 6 * 3.1.                           ""auto convert to float""
x := 5 squared.                         ""square function""
x := 25 sqrt.                           ""square root""
x := 5 raisedTo: 2.                     ""power function""
x := 5 raisedToInteger: 2.              ""power function with integer""
x := 5 exp.                             ""exponential""
x := -5 abs.                            ""absolute value""
x := 3.99 rounded.                      ""round""
x := 3.99 truncated.                    ""truncate""
x := 3.99 roundTo: 1.                   ""round to specified decimal places""
x := 3.99 truncateTo: 1.                ""truncate to specified decimal places""
x := 3.99 floor.                        ""truncate""
x := 3.99 ceiling.                      ""round up""
x := 5 factorial.                       ""factorial""
x := -5 quo: 3.                         ""integer divide rounded toward zero""
x := -5 rem: 3.                         ""integer remainder rounded toward zero""
x := 28 gcd: 12.                        ""greatest common denominator""
x := 28 lcm: 12.                        ""least common multiple""
x := 100 ln.                            ""natural logarithm""
x := 100 log.                           ""base 10 logarithm""
x := 100 log: 10.                       ""floor of the log""
x := 180 degreesToRadians.              ""convert degrees to radians""
x := 3.14 radiansToDegrees.             ""convert radians to degrees""
x := 0.7 sin.                           ""sine""
x := 0.7 cos.                           ""cosine""
x := 0.7 tan.                           ""tangent""
x := 0.7 arcSin.                        ""arcsine""
x := 0.7 arcCos.                        ""arccosine""
x := 0.7 arcTan.                        ""arctangent""
x := 10 max: 20.                        ""get maximum of two numbers""
x := 10 min: 20.                        ""get minimum of two numbers""
x := Float pi.                          ""pi""
x := Float e.                           ""exp constant""
x := Float infinity.                    ""infinity""
x := Float nan.                         ""not-a-number""
x := Random new next; yourself. x next. ""random number stream (0.0 to 1.0)""
x := 100 atRandom.                      ""quick random number""
```

#### Bitwise Manipulation:
```smalltalk
| b x |
x := 16rFF bitAnd: 16r0F.           ""and bits""
x := 16rF0 bitOr: 16r0F.            ""or bits""
x := 16rFF bitXor: 16r0F.           ""xor bits""
x := 16rFF bitInvert.               ""invert bits""
x := 16r0F bitShift: 4.             ""left shift""
x := 16rF0 bitShift: -4.            ""right shift""
""x := 16r80 bitAt: 7.""              ""bit at position (0|1) [!Squeak]""
x := 16r80 highbit.                 ""position of highest bit set""
b := 16rFF allMask: 16r0F.          ""test if all bits set in mask set in receiver""
b := 16rFF anyMask: 16r0F.          ""test if any bits set in mask set in receiver""
b := 16rFF noMask: 16r0F.           ""test if all bits set in mask clear in receiver""
```

#### Conversion:
```smalltalk
| x |
x := 3.99 asInteger.               ""convert number to integer (truncates in Squeak)""
x := 3.99 asFraction.              ""convert number to fraction""
x := 3 asFloat.                    ""convert number to float""
x := 65 asCharacter.               ""convert integer to character""
x := $A asciiValue.                ""convert character to integer""
x := 3.99 printString.             ""convert object to string via printOn:""
x := 3.99 storeString.             ""convert object to string via storeOn:""
x := 15 radix: 16.                 ""convert to string in given base""
x := 15 printStringBase: 16.
x := 15 storeStringBase: 16.
```

#### Blocks:
- blocks are objects and may be assigned to a variable
- value is last expression evaluated unless explicit return
- blocks may be nested
- specification [ arguments | | localvars | expressions ]
- Squeak does not currently support localvars in blocks
- max of three arguments allowed
- `^`expression terminates block & method (exits all nested blocks)
- blocks intended for long term storage should not contain `^`

```smalltalk
| x y z |
x := [ y := 1. z := 2. ]. x value.                          ""simple block usage""
x := [ :argOne :argTwo |   argOne, ' and ' , argTwo.].      ""set up block with argument passing""
Transcript show: (x value: 'First' value: 'Second'); cr.    ""use block with argument passing""

""x := [ | z | z := 1.]. *** localvars not available in squeak blocks""
```

#### Method calls:
- unary methods are messages with no arguments
- binary methods
- keyword methods are messages with selectors including colons standard categories/protocols:
- initialize-release    (methods called for new instance)
- accessing             (get/set methods)
- testing               (boolean tests - is)
- comparing             (boolean tests with parameter
- displaying            (gui related methods)
- printing              (methods for printing)
- updating              (receive notification of changes)
- private               (methods private to class)
- instance-creation     (class methods for creating instance)

```smalltalk
| x |
x := 2 sqrt.                                  ""unary message""
x := 2 raisedTo: 10.                          ""keyword message""
x := 194 * 9.                                 ""binary message""
Transcript show: (194 * 9) printString; cr.   ""combination (chaining)""
x := 2 perform: #sqrt.                        ""indirect method invocation""
Transcript                                    ""Cascading - send multiple messages to receiver""
   show: 'hello ';
   show: 'world';
   cr.
x := 3 + 2; * 100.                            ""result=300. Sends message to same receiver (3)""
```

#### Conditional Statements:
```smalltalk
| x |
x > 10 ifTrue: [Transcript show: 'ifTrue'; cr].     ""if then""
x > 10 ifFalse: [Transcript show: 'ifFalse'; cr].   ""if else""

""if then else""
x > 10                                                      
   ifTrue: [Transcript show: 'ifTrue'; cr]
   ifFalse: [Transcript show: 'ifFalse'; cr].

""if else then""
x > 10                                                      
   ifFalse: [Transcript show: 'ifFalse'; cr]
   ifTrue: [Transcript show: 'ifTrue'; cr].
Transcript
   show:
      (x > 10
         ifTrue: ['ifTrue']
         ifFalse: ['ifFalse']);
   cr.

""nested if then else""
Transcript                                                  
   show:
      (x > 10
         ifTrue: [x > 5
            ifTrue: ['A']
            ifFalse: ['B']]
         ifFalse: ['C']);
   cr.

""switch functionality""
switch := Dictionary new.     
switch at: $A put: [Transcript show: 'Case A'; cr].
switch at: $B put: [Transcript show: 'Case B'; cr].
switch at: $C put: [Transcript show: 'Case C'; cr].
result := (switch at: $B) value.
```

#### Iteration statements:
```smalltalk
| x y |
x := 4. y := 1.
[x > 0] whileTrue: [x := x - 1. y := y * 2].     ""while true loop""
[x >= 4] whileFalse: [x := x + 1. y := y * 2].   ""while false loop""
x timesRepeat: [y := y * 2].                     ""times repeat loop (i := 1 to x)""
1 to: x do: [:a | y := y * 2].                   ""for loop""
1 to: x by: 2 do: [:a | y := y / 2].             ""for loop with specified increment""
#(5 4 3) do: [:a | x := x + a].                  ""iterate over array elements""
```

#### Character:
```smalltalk
| x y |
x := $A.                         ""character assignment""
y := x isLowercase.              ""test if lower case""
y := x isUppercase.              ""test if upper case""
y := x isLetter.                 ""test if letter""
y := x isDigit.                  ""test if digit""
y := x isAlphaNumeric.           ""test if alphanumeric""
y := x isSeparator.              ""test if separator char""
y := x isVowel.                  ""test if vowel""
y := x digitValue.               ""convert to numeric digit value""
y := x asLowercase.              ""convert to lower case""
y := x asUppercase.              ""convert to upper case""
y := x asciiValue.               ""convert to numeric ascii value""
y := x asString.                 ""convert to string""
b := $A <= $B.                   ""comparison""
y := $A max: $B.
```

#### Symbol:
```smalltalk
| b x y |
x := #Hello.                                      ""symbol assignment""
y := #Symbol, #Concatenation.                     ""symbol concatenation (result is string)""
b := x isEmpty.                                   ""test if symbol is empty""
y := x size.                                      ""string size""
y := x at: 2.                                     ""char at location""
y := x copyFrom: 2 to: 4.                         ""substring""
y := x indexOf: $e ifAbsent: [0].                 ""first position of character within string""
x do: [:a | Transcript show: a printString; cr].  ""iterate over the string""
b := x conform: [:a | (a >= $a) & (a <= $z)].     ""test if all elements meet condition""
y := x select: [:a | a > $a].                     ""return all elements that meet condition""
y := x asString.                                  ""convert symbol to string""
y := x asText.                                    ""convert symbol to text""
y := x asArray.                                   ""convert symbol to array""
y := x asOrderedCollection.                       ""convert symbol to ordered collection""
y := x asSortedCollection.                        ""convert symbol to sorted collection""
y := x asBag.                                     ""convert symbol to bag collection""
y := x asSet.                                     ""convert symbol to set collection""
```

#### String:
```smalltalk
| b x y |
x := 'This is a string'.                           ""string assignment""
x := 'String', 'Concatenation'.                    ""string concatenation""
b := x isEmpty.                                    ""test if string is empty""
y := x size.                                       ""string size""
y := x at: 2.                                      ""char at location""
y := x copyFrom: 2 to: 4.                          ""substring""
y := x indexOf: $a ifAbsent: [0].                  ""first position of character within string""
x := String new: 4.                                ""allocate string object""
x                                                  ""set string elements""
   at: 1 put: $a;
   at: 2 put: $b;
   at: 3 put: $c;
   at: 4 put: $e.
x := String with: $a with: $b with: $c with: $d.  ""set up to 4 elements at a time""
x do: [:a | Transcript show: a printString; cr].  ""iterate over the string""
b := x conform: [:a | (a >= $a) & (a <= $z)].     ""test if all elements meet condition""
y := x select: [:a | a > $a].                     ""return all elements that meet condition""
y := x asSymbol.                                  ""convert string to symbol""
y := x asArray.                                   ""convert string to array""
x := 'ABCD' asByteArray.                          ""convert string to byte array""
y := x asOrderedCollection.                       ""convert string to ordered collection""
y := x asSortedCollection.                        ""convert string to sorted collection""
y := x asBag.                                     ""convert string to bag collection""
y := x asSet.                                     ""convert string to set collection""
y := x shuffled.                                  ""randomly shuffle string""
```

#### Array:
Fixed length collection
- ByteArray:     Array limited to byte elements (0-255)
- WordArray:     Array limited to word elements (0-2^32)

```smalltalk
| b x y sum max |
x := #(4 3 2 1).                                 ""constant array""
x := Array with: 5 with: 4 with: 3 with: 2.      ""create array with up to 4 elements""
x := Array new: 4.                               ""allocate an array with specified size""
x                                                ""set array elements""
   at: 1 put: 5;
   at: 2 put: 4;
   at: 3 put: 3;
   at: 4 put: 2.
b := x isEmpty.                                  ""test if array is empty""
y := x size.                                     ""array size""
y := x at: 4.                                    ""get array element at index""
b := x includes: 3.                              ""test if element is in array""
y := x copyFrom: 2 to: 4.                        ""subarray""
y := x indexOf: 3 ifAbsent: [0].                 ""first position of element within array""
y := x occurrencesOf: 3.                         ""number of times object in collection""
x do: [:a | Transcript show: a printString; cr]. ""iterate over the array""
b := x conform: [:a | (a >= 1) & (a <= 4)].      ""test if all elements meet condition""
y := x select: [:a | a > 2].                     ""return collection of elements that pass test""
y := x reject: [:a | a < 2].                     ""return collection of elements that fail test""
y := x collect: [:a | a + a].                    ""transform each element for new collection""
y := x detect: [:a | a > 3] ifNone: [].          ""find position of first element that passes test""
sum := 0. x do: [:a | sum := sum + a]. sum.      ""sum array elements""
sum := 0. 1 to: (x size) 
            do: [:a | sum := sum + (x at: a)].   ""sum array elements""
sum := x inject: 0 into: [:a :c | a + c].        ""sum array elements""
max := x inject: 0 into: [:a :c | (a > c)        ""find max element in array""
   ifTrue: [a]
   ifFalse: [c]].
y := x shuffled.                                 ""randomly shuffle collection""
y := x asArray.                                  ""convert to array""
""y := x asByteArray.""                            ""note: this instruction not available on Squeak""
y := x asWordArray.                              ""convert to word array""
y := x asOrderedCollection.                      ""convert to ordered collection""
y := x asSortedCollection.                       ""convert to sorted collection""
y := x asBag.                                    ""convert to bag collection""
y := x asSet.                                    ""convert to set collection""
```

#### OrderedCollection:
acts like an expandable array

```smalltalk
| b x y sum max |
x := OrderedCollection 
     with: 4 with: 3 with: 2 with: 1.            ""create collection with up to 4 elements""
x := OrderedCollection new.                      ""allocate collection""
x add: 3; add: 2; add: 1; add: 4; yourself.      ""add element to collection""
y := x addFirst: 5.                              ""add element at beginning of collection""
y := x removeFirst.                              ""remove first element in collection""
y := x addLast: 6.                               ""add element at end of collection""
y := x removeLast.                               ""remove last element in collection""
y := x addAll: #(7 8 9).                         ""add multiple elements to collection""
y := x removeAll: #(7 8 9).                      ""remove multiple elements from collection""
x at: 2 put: 3.                                  ""set element at index""
y := x remove: 5 ifAbsent: [].                   ""remove element from collection""
b := x isEmpty.                                  ""test if empty""
y := x size.                                     ""number of elements""
y := x at: 2.                                    ""retrieve element at index""
y := x first.                                    ""retrieve first element in collection""
y := x last.                                     ""retrieve last element in collection""
b := x includes: 5.                              ""test if element is in collection""
y := x copyFrom: 2 to: 3.                        ""subcollection""
y := x indexOf: 3 ifAbsent: [0].                 ""first position of element within collection""
y := x occurrencesOf: 3.                         ""number of times object in collection""
x do: [:a | Transcript show: a printString; cr]. ""iterate over the collection""
b := x conform: [:a | (a >= 1) & (a <= 4)].      ""test if all elements meet condition""
y := x select: [:a | a > 2].                     ""return collection of elements that pass test""
y := x reject: [:a | a < 2].                     ""return collection of elements that fail test""
y := x collect: [:a | a + a].                    ""transform each element for new collection""
y := x detect: [:a | a > 3] ifNone: [].          ""find position of first element that passes test""
sum := 0. x do: [:a | sum := sum + a]. sum.      ""sum elements""
sum := 0. 1 to: (x size) 
            do: [:a | sum := sum + (x at: a)].   ""sum elements""
sum := x inject: 0 into: [:a :c | a + c].        ""sum elements""
max := x inject: 0 into: [:a :c | (a > c)        ""find max element in collection""
   ifTrue: [a]
   ifFalse: [c]].
y := x shuffled.                                 ""randomly shuffle collection""
y := x asArray.                                  ""convert to array""
y := x asOrderedCollection.                      ""convert to ordered collection""
y := x asSortedCollection.                       ""convert to sorted collection""
y := x asBag.                                    ""convert to bag collection""
y := x asSet.                                    ""convert to set collection""
```

#### SortedCollection:
like OrderedCollection except order of elements determined by sorting criteria

```smalltalk
| b x y sum max |
x := SortedCollection 
     with: 4 with: 3 with: 2 with: 1.              ""create collection with up to 4 elements""
x := SortedCollection new.                         ""allocate collection""
x := SortedCollection sortBlock: [:a :c | a > c].  ""set sort criteria""
x add: 3; add: 2; add: 1; add: 4; yourself.        ""add element to collection""
y := x addFirst: 5.                                ""add element at beginning of collection""
y := x removeFirst.                                ""remove first element in collection""
y := x addLast: 6.                                 ""add element at end of collection""
y := x removeLast.                                 ""remove last element in collection""
y := x addAll: #(7 8 9).                           ""add multiple elements to collection""
y := x removeAll: #(7 8 9).                        ""remove multiple elements from collection""
y := x remove: 5 ifAbsent: [].                     ""remove element from collection""
b := x isEmpty.                                    ""test if empty""
y := x size.                                       ""number of elements""
y := x at: 2.                                      ""retrieve element at index""
y := x first.                                      ""retrieve first element in collection""
y := x last.                                       ""retrieve last element in collection""
b := x includes: 4.                                ""test if element is in collection""
y := x copyFrom: 2 to: 3.                          ""subcollection""
y := x indexOf: 3 ifAbsent: [0].                   ""first position of element within collection""
y := x occurrencesOf: 3.                           ""number of times object in collection""
x do: [:a | Transcript show: a printString; cr].   ""iterate over the collection""
b := x conform: [:a | (a >= 1) & (a <= 4)].        ""test if all elements meet condition""
y := x select: [:a | a > 2].                       ""return collection of elements that pass test""
y := x reject: [:a | a < 2].                       ""return collection of elements that fail test""
y := x collect: [:a | a + a].                      ""transform each element for new collection""
y := x detect: [:a | a > 3] ifNone: [].            ""find position of first element that passes test""
sum := 0. x do: [:a | sum := sum + a]. sum.        ""sum elements""
sum := 0. 1 to: (x size) 
            do: [:a | sum := sum + (x at: a)].     ""sum elements""
sum := x inject: 0 into: [:a :c | a + c].          ""sum elements""
max := x inject: 0 into: [:a :c | (a > c)          ""find max element in collection""
   ifTrue: [a]
   ifFalse: [c]].
y := x asArray.                                     ""convert to array""
y := x asOrderedCollection.                         ""convert to ordered collection""
y := x asSortedCollection.                          ""convert to sorted collection""
y := x asBag.                                       ""convert to bag collection""
y := x asSet.                                       ""convert to set collection""
```

#### Bag:
like OrderedCollection except elements are in no particular order

```smalltalk
| b x y sum max |
x := Bag with: 4 with: 3 with: 2 with: 1.        ""create collection with up to 4 elements""
x := Bag new.                                    ""allocate collection""
x add: 4; add: 3; add: 1; add: 2; yourself.      ""add element to collection""
x add: 3 withOccurrences: 2.                     ""add multiple copies to collection""
y := x addAll: #(7 8 9).                         ""add multiple elements to collection""
y := x removeAll: #(7 8 9).                      ""remove multiple elements from collection""
y := x remove: 4 ifAbsent: [].                   ""remove element from collection""
b := x isEmpty.                                  ""test if empty""
y := x size.                                     ""number of elements""
b := x includes: 3.                              ""test if element is in collection""
y := x occurrencesOf: 3.                         ""number of times object in collection""
x do: [:a | Transcript show: a printString; cr]. ""iterate over the collection""
b := x conform: [:a | (a >= 1) & (a <= 4)].      ""test if all elements meet condition""
y := x select: [:a | a > 2].                     ""return collection of elements that pass test""
y := x reject: [:a | a < 2].                     ""return collection of elements that fail test""
y := x collect: [:a | a + a].                    ""transform each element for new collection""
y := x detect: [:a | a > 3] ifNone: [].          ""find position of first element that passes test""
sum := 0. x do: [:a | sum := sum + a]. sum.      ""sum elements""
sum := x inject: 0 into: [:a :c | a + c].        ""sum elements""
max := x inject: 0 into: [:a :c | (a > c)        ""find max element in collection""
   ifTrue: [a]
   ifFalse: [c]].
y := x asOrderedCollection.                       ""convert to ordered collection""
y := x asSortedCollection.                        ""convert to sorted collection""
y := x asBag.                                     ""convert to bag collection""
y := x asSet.                                     ""convert to set collection""
```

#### Set:
like Bag except duplicates not allowed

#### IdentitySet:
uses identity test (== rather than =)

```smalltalk
| b x y sum max |
x := Set with: 4 with: 3 with: 2 with: 1.        ""create collection with up to 4 elements""
x := Set new.                                    ""allocate collection""
x add: 4; add: 3; add: 1; add: 2; yourself.      ""add element to collection""
y := x addAll: #(7 8 9).                         ""add multiple elements to collection""
y := x removeAll: #(7 8 9).                      ""remove multiple elements from collection""
y := x remove: 4 ifAbsent: [].                   ""remove element from collection""
b := x isEmpty.                                  ""test if empty""
y := x size.                                     ""number of elements""
x includes: 4.                                   ""test if element is in collection""
x do: [:a | Transcript show: a printString; cr]. ""iterate over the collection""
b := x conform: [:a | (a >= 1) & (a <= 4)].      ""test if all elements meet condition""
y := x select: [:a | a > 2].                     ""return collection of elements that pass test""
y := x reject: [:a | a < 2].                     ""return collection of elements that fail test""
y := x collect: [:a | a + a].                    ""transform each element for new collection""
y := x detect: [:a | a > 3] ifNone: [].          ""find position of first element that passes test""
sum := 0. x do: [:a | sum := sum + a]. sum.      ""sum elements""
sum := x inject: 0 into: [:a :c | a + c].        ""sum elements""
max := x inject: 0 into: [:a :c | (a > c)        ""find max element in collection""
   ifTrue: [a]
   ifFalse: [c]].
y := x asArray.                                  ""convert to array""
y := x asOrderedCollection.                      ""convert to ordered collection""
y := x asSortedCollection.                       ""convert to sorted collection""
y := x asBag.                                    ""convert to bag collection""
y := x asSet.                                    ""convert to set collection""
```

#### Interval:
```smalltalk
| b x y sum max |
x := Interval from: 5 to: 10.                     ""create interval object""
x := 5 to: 10.
x := Interval from: 5 to: 10 by: 2.               ""create interval object with specified increment""
x := 5 to: 10 by: 2.
b := x isEmpty.                                   ""test if empty""
y := x size.                                      ""number of elements""
x includes: 9.                                    ""test if element is in collection""
x do: [:k | Transcript show: k printString; cr].  ""iterate over interval""
b := x conform: [:a | (a >= 1) & (a <= 4)].       ""test if all elements meet condition""
y := x select: [:a | a > 7].                      ""return collection of elements that pass test""
y := x reject: [:a | a < 2].                      ""return collection of elements that fail test""
y := x collect: [:a | a + a].                     ""transform each element for new collection""
y := x detect: [:a | a > 3] ifNone: [].           ""find position of first element that passes test""
sum := 0. x do: [:a | sum := sum + a]. sum.       ""sum elements""
sum := 0. 1 to: (x size) 
            do: [:a | sum := sum + (x at: a)].    ""sum elements""
sum := x inject: 0 into: [:a :c | a + c].         ""sum elements""
max := x inject: 0 into: [:a :c | (a > c)         ""find max element in collection""
   ifTrue: [a]
   ifFalse: [c]].
y := x asArray.                                   ""convert to array""
y := x asOrderedCollection.                       ""convert to ordered collection""
y := x asSortedCollection.                        ""convert to sorted collection""
y := x asBag.                                     ""convert to bag collection""
y := x asSet.                                     ""convert to set collection""
```

#### Associations:
```smalltalk
| x y |
x := #myVar->'hello'.
y := x key.
y := x value.
```

#### Dictionary:
#### IdentityDictionary:
uses identity test (== rather than =)

```smalltalk
| b x y |
x := Dictionary new.                   ""allocate collection""
x add: #a->4; 
  add: #b->3; 
  add: #c->1; 
  add: #d->2; yourself.                ""add element to collection""
x at: #e put: 3.                       ""set element at index""
b := x isEmpty.                        ""test if empty""
y := x size.                           ""number of elements""
y := x at: #a ifAbsent: [].            ""retrieve element at index""
y := x keyAtValue: 3 ifAbsent: [].     ""retrieve key for given value with error block""
y := x removeKey: #e ifAbsent: [].     ""remove element from collection""
b := x includes: 3.                    ""test if element is in values collection""
b := x includesKey: #a.                ""test if element is in keys collection""
y := x occurrencesOf: 3.               ""number of times object in collection""
y := x keys.                           ""set of keys""
y := x values.                         ""bag of values""
x do: [:a | Transcript show: a printString; cr].            ""iterate over the values collection""
x keysDo: [:a | Transcript show: a printString; cr].        ""iterate over the keys collection""
x associationsDo: [:a | Transcript show: a printString; cr].""iterate over the associations""
x keysAndValuesDo: [:aKey :aValue | Transcript              ""iterate over keys and values""
   show: aKey printString; space;
   show: aValue printString; cr].
b := x conform: [:a | (a >= 1) & (a <= 4)].      ""test if all elements meet condition""
y := x select: [:a | a > 2].                     ""return collection of elements that pass test""
y := x reject: [:a | a < 2].                     ""return collection of elements that fail test""
y := x collect: [:a | a + a].                    ""transform each element for new collection""
y := x detect: [:a | a > 3] ifNone: [].          ""find position of first element that passes test""
sum := 0. x do: [:a | sum := sum + a]. sum.      ""sum elements""
sum := x inject: 0 into: [:a :c | a + c].        ""sum elements""
max := x inject: 0 into: [:a :c | (a > c)        ""find max element in collection""
   ifTrue: [a]
   ifFalse: [c]].
y := x asArray.                                   ""convert to array""
y := x asOrderedCollection.                       ""convert to ordered collection""
y := x asSortedCollection.                        ""convert to sorted collection""
y := x asBag.                                     ""convert to bag collection""
y := x asSet.                                     ""convert to set collection""

Smalltalk at: #CMRGlobal put: 'CMR entry'.        ""put global in Smalltalk Dictionary""
x := Smalltalk at: #CMRGlobal.                    ""read global from Smalltalk Dictionary""
Transcript show: (CMRGlobal printString).         ""entries are directly accessible by name""
Smalltalk keys do: [ :k |                         ""print out all classes""
   ((Smalltalk at: k) isKindOf: Class)
      ifFalse: [Transcript show: k printString; cr]].
Smalltalk at: #CMRDictionary put: (Dictionary new). ""set up user defined dictionary""
CMRDictionary at: #MyVar1 put: 'hello1'.            ""put entry in dictionary""
CMRDictionary add: #MyVar2->'hello2'.               ""add entry to dictionary use key->value combo""
CMRDictionary size.                                 ""dictionary size""
CMRDictionary keys do: [ :k |                       ""print out keys in dictionary""
   Transcript show: k printString; cr].
CMRDictionary values do: [ :k |                     ""print out values in dictionary""
   Transcript show: k printString; cr].
CMRDictionary keysAndValuesDo: [:aKey :aValue |     ""print out keys and values""
   Transcript
      show: aKey printString;
      space;
      show: aValue printString;
      cr].
CMRDictionary associationsDo: [:aKeyValue |           ""another iterator for printing key values""
   Transcript show: aKeyValue printString; cr].
Smalltalk removeKey: #CMRGlobal ifAbsent: [].         ""remove entry from Smalltalk dictionary""
Smalltalk removeKey: #CMRDictionary ifAbsent: [].     ""remove user dictionary from Smalltalk dictionary""
```

#### Internal Stream:
```smalltalk
| b x ios |
ios := ReadStream on: 'Hello read stream'.
ios := ReadStream on: 'Hello read stream' from: 1 to: 5.
[(x := ios nextLine) notNil] whileTrue: [Transcript show: x; cr].
ios position: 3.
ios position.
x := ios next.
x := ios peek.
x := ios contents.
b := ios atEnd.

ios := ReadWriteStream on: 'Hello read stream'.
ios := ReadWriteStream on: 'Hello read stream' from: 1 to: 5.
ios := ReadWriteStream with: 'Hello read stream'.
ios := ReadWriteStream with: 'Hello read stream' from: 1 to: 10.
ios position: 0.
[(x := ios nextLine) notNil] whileTrue: [Transcript show: x; cr].
ios position: 6.
ios position.
ios nextPutAll: 'Chris'.
x := ios next.
x := ios peek.
x := ios contents.
b := ios atEnd.
```

#### FileStream:
```smalltalk
| b x ios |
ios := FileStream newFileNamed: 'ios.txt'.
ios nextPut: $H; cr.
ios nextPutAll: 'Hello File'; cr.
'Hello File' printOn: ios.
'Hello File' storeOn: ios.
ios close.

ios := FileStream oldFileNamed: 'ios.txt'.
[(x := ios nextLine) notNil] whileTrue: [Transcript show: x; cr].
ios position: 3.
x := ios position.
x := ios next.
x := ios peek.
b := ios atEnd.
ios close.
```

#### Date:
```smalltalk
| x y |
x := Date today.                                ""create date for today""
x := Date dateAndTimeNow.                       ""create date from current time/date""
x := Date readFromString: '01/02/1999'.         ""create date from formatted string""
x := Date newDay: 12 month: #July year: 1999    ""create date from parts""
x := Date fromDays: 36000.                      ""create date from elapsed days since 1/1/1901""
y := Date dayOfWeek: #Monday.                   ""day of week as int (1-7)""
y := Date indexOfMonth: #January.               ""month of year as int (1-12)""
y := Date daysInMonth: 2 forYear: 1996.         ""day of month as int (1-31)""
y := Date daysInYear: 1996.                     ""days in year (365|366)""
y := Date nameOfDay: 1                          ""weekday name (#Monday,...)""
y := Date nameOfMonth: 1.                       ""month name (#January,...)""
y := Date leapYear: 1996.                       ""1 if leap year; 0 if not leap year""
y := x weekday.                                 ""day of week (#Monday,...)""
y := x previous: #Monday.                       ""date for previous day of week""
y := x dayOfMonth.                              ""day of month (1-31)""
y := x day.                                     ""day of year (1-366)""
y := x firstDayOfMonth.                         ""day of year for first day of month""
y := x monthName.                               ""month of year (#January,...)""
y := x monthIndex.                              ""month of year (1-12)""
y := x daysInMonth.                             ""days in month (1-31)""
y := x year.                                    ""year (19xx)""
y := x daysInYear.                              ""days in year (365|366)""
y := x daysLeftInYear.                          ""days left in year (364|365)""
y := x asSeconds.                               ""seconds elapsed since 1/1/1901""
y := x addDays: 10.                             ""add days to date object""
y := x subtractDays: 10.                        ""subtract days to date object""
y := x subtractDate: (Date today).              ""subtract date (result in days)""
y := x printFormat: #(2 1 3 $/ 1 1).            ""print formatted date""
b := (x <= Date today).                         ""comparison""
```

#### Time:
```smalltalk
| x y |
x := Time now.                                      ""create time from current time""
x := Time dateAndTimeNow.                           ""create time from current time/date""
x := Time readFromString: '3:47:26 pm'.             ""create time from formatted string""
x := Time fromSeconds: (60 * 60 * 4).               ""create time from elapsed time from midnight""
y := Time millisecondClockValue.                    ""milliseconds since midnight""
y := Time totalSeconds.                             ""total seconds since 1/1/1901""
y := x seconds.                                     ""seconds past minute (0-59)""
y := x minutes.                                     ""minutes past hour (0-59)""
y := x hours.                                       ""hours past midnight (0-23)""
y := x addTime: (Time now).                         ""add time to time object""
y := x subtractTime: (Time now).                    ""subtract time to time object""
y := x asSeconds.                                   ""convert time to seconds""
x := Time millisecondsToRun: [                      ""timing facility""
   1 to: 1000 do: [:index | y := 3.14 * index]].
b := (x <= Time now).                               ""comparison""
```

#### Point:
```smalltalk
| x y |
x := 200@100.                            ""obtain a new point""
y := x x.                                ""x coordinate""
y := x y.                                ""y coordinate""
x := 200@100 negated.                    ""negates x and y""
x := (-200@-100) abs.                    ""absolute value of x and y""
x := (200.5@100.5) rounded.              ""round x and y""
x := (200.5@100.5) truncated.            ""truncate x and y""
x := 200@100 + 100.                      ""add scale to both x and y""
x := 200@100 - 100.                      ""subtract scale from both x and y""
x := 200@100 * 2.                        ""multiply x and y by scale""
x := 200@100 / 2.                        ""divide x and y by scale""
x := 200@100 // 2.                       ""divide x and y by scale""
x := 200@100 \\ 3.                       ""remainder of x and y by scale""
x := 200@100 + 50@25.                    ""add points""
x := 200@100 - 50@25.                    ""subtract points""
x := 200@100 * 3@4.                      ""multiply points""
x := 200@100 // 3@4.                     ""divide points""
x := 200@100 max: 50@200.                ""max x and y""
x := 200@100 min: 50@200.                ""min x and y""
x := 20@5 dotProduct: 10@2.              ""sum of product (x1*x2 + y1*y2)""
```

#### Rectangle:
```smalltalk
Rectangle fromUser.
```

#### Pen:
```smalltalk
| myPen |
Display restoreAfter: [
   Display fillWhite.

myPen := Pen new.                            ""get graphic pen""
myPen squareNib: 1.
myPen color: (Color blue).                   ""set pen color""
myPen home.                                  ""position pen at center of display""
myPen up.                                    ""makes nib unable to draw""
myPen down.                                  ""enable the nib to draw""
myPen north.                                 ""points direction towards top""
myPen turn: -180.                            ""add specified degrees to direction""
myPen direction.                             ""get current angle of pen""
myPen go: 50.                                ""move pen specified number of pixels""
myPen location.                              ""get the pen position""
myPen goto: 200@200.                         ""move to specified point""
myPen place: 250@250.                        ""move to specified point without drawing""
myPen print: 'Hello World' 
      withFont: (TextStyle default fontAt: 1).
Display extent.                              ""get display width@height""
Display width.                               ""get display width""
Display height.                              ""get display height""

].
```

#### Dynamic Message Calling/Compiling:
```smalltalk
| receiver message result argument keyword1 keyword2 argument1 argument2 |

""unary message""
receiver := 5.
message := 'factorial' asSymbol.
result := receiver perform: message.
result := Compiler evaluate: ((receiver storeString), ' ', message).
result := (Message new setSelector: message arguments: #()) sentTo: receiver.

""binary message""
receiver := 1.
message := '+' asSymbol.
argument := 2.
result := receiver perform: message withArguments: (Array with: argument).
result := Compiler evaluate: ((receiver storeString), ' ', message, ' ', (argument storeString)).
result := (Message new setSelector: message arguments: (Array with: argument)) sentTo: receiver.

""keyword messages""
receiver := 12.
keyword1 := 'between:' asSymbol.
keyword2 := 'and:' asSymbol.
argument1 := 10.
argument2 := 20.

result := receiver
   perform: (keyword1, keyword2) asSymbol
   withArguments: (Array with: argument1 with: argument2).
   
result := Compiler evaluate:
   ((receiver storeString), ' ', keyword1, (argument1 storeString) , ' ', keyword2, (argument2 storeString)).
   
result := (Message
   new
      setSelector: (keyword1, keyword2) asSymbol
      arguments: (Array with: argument1 with: argument2))
   sentTo: receiver.
```

#### Class/Meta-Class:
```smalltalk
| b x |
x := String name.                     ""class name""
x := String category.                 ""organization category""
x := String comment.                  ""class comment""
x := String kindOfSubclass.           ""subclass type - subclass: variableSubclass, etc""
x := String definition.               ""class definition""
x := String instVarNames.             ""immediate instance variable names""
x := String allInstVarNames.          ""accumulated instance variable names""
x := String classVarNames.            ""immediate class variable names""
x := String allClassVarNames.         ""accumulated class variable names""
x := String sharedPools.              ""immediate dictionaries used as shared pools""
x := String allSharedPools.           ""accumulated dictionaries used as shared pools""
x := String selectors.                ""message selectors for class""
x := String sourceCodeAt: #size.      ""source code for specified method""
x := String allInstances.             ""collection of all instances of class""
x := String superclass.               ""immediate superclass""
x := String allSuperclasses.          ""accumulated superclasses""
x := String withAllSuperclasses.      ""receiver class and accumulated superclasses""
x := String subclasses.               ""immediate subclasses""
x := String allSubclasses.            ""accumulated subclasses""
x := String withAllSubclasses.        ""receiver class and accumulated subclasses""
b := String instSize.                 ""number of named instance variables""
b := String isFixed.                  ""true if no indexed instance variables""
b := String isVariable.               ""true if has indexed instance variables""
b := String isPointers.               ""true if index instance vars contain objects""
b := String isBits.                   ""true if index instance vars contain bytes/words""
b := String isBytes.                  ""true if index instance vars contain bytes""
b := String isWords.                  ""true if index instance vars contain words""
Object withAllSubclasses size.        ""get total number of class entries""
```

#### Debugging:
```smalltalk
| a b x |
x yourself.                             ""returns receiver""
String browse.                          ""browse specified class""
x inspect.                              ""open object inspector window""
x confirm: 'Is this correct?'.
x halt.                                 ""breakpoint to open debugger window""
x halt: 'Halt message'.
x notify: 'Notify text'.
x error: 'Error string'.                ""open up error window with title""
x doesNotUnderstand: #cmrMessage.       ""flag message is not handled""
x shouldNotImplement.                   ""flag message should not be implemented""
x subclassResponsibility.               ""flag message as abstract""
x errorImproperStore.                   ""flag an improper store into indexable object""
x errorNonIntegerIndex.                 ""flag only integers should be used as index""
x errorSubscriptBounds.                 ""flag subscript out of bounds""
x primitiveFailed.                      ""system primitive failed""

a := 'A1'. b := 'B2'. a become: b.      ""switch two objects""
Transcript show: a, b; cr.
```

#### Miscellaneous
```smalltalk
| x |
x := 1.2 hash.                                  ""hash value for object""
y := x copy.                                    ""copy object""
y := x shallowCopy.                             ""copy object (not overridden)""
y := x deepCopy.                                ""copy object and instance vars""
y := x veryDeepCopy.                            ""complete tree copy using a dictionary""
""Smalltalk condenseChanges.""                    ""compress the change file""
x := FillInTheBlank request: 'Prompt Me'.       ""prompt user for input""
Utilities openCommandKeyHelp
```

## Ready For More?

### Online Smalltalk systems
Most Smalltalks are either free as in OSS or have a free downloadable version with some payment required for commercial usage.
* [Squeak](https://www.squeak.org)
* [Pharo](http://pharo.org)
* [Smalltalk/X](https://www.exept.de/en/smalltalk-x.html)
* [Gemstone](http://gemtalksystems.com/)
* [VA Smalltalk](http://www.instantiations.com/products/vasmalltalk/)
* [VisualWorks Smalltalk](http://www.cincomsmalltalk.com/)

### Online Smalltalk books and articles
* [Smalltalk Programming Resources](http://www.whoishostingthis.com/resources/smalltalk/)
* [Smalltalk Cheatsheet](http://www.angelfire.com/tx4/cus/notes/smalltalk.html)
* [Smalltalk-72 Manual](http://www.bitsavers.org/pdf/xerox/parc/techReports/Smalltalk-72_Instruction_Manual_Mar76.pdf)
* [GNU Smalltalk User's Guide](https://www.gnu.org/software/smalltalk/manual/html_node/Tutorial.html)

#### Historical Documentation(s)
* [BYTE: A Special issue on Smalltalk](https://archive.org/details/byte-magazine-1981-08)
* [Smalltalk-72 Manual](http://www.bitsavers.org/pdf/xerox/parc/techReports/Smalltalk-72_Instruction_Manual_Mar76.pdf)
* [Smalltalk, Objects, and Design](https://books.google.co.in/books?id=W8_Une9cbbgC&printsec=frontcover&dq=smalltalk&hl=en&sa=X&ved=0CCIQ6AEwAWoVChMIw63Vo6CpyAIV0HGOCh3S2Alf#v=onepage&q=smalltalk&f=false)
* [Smalltalk: An Introduction to Application Development Using VisualWorks](https://books.google.co.in/books?id=zalQAAAAMAAJ&q=smalltalk&dq=smalltalk&hl=en&sa=X&ved=0CCgQ6AEwAmoVChMIw63Vo6CpyAIV0HGOCh3S2Alf/)"
"Objective-C is the main programming language used by Apple for the macOS and iOS operating systems and their respective frameworks, Cocoa and Cocoa Touch.
It is a general-purpose, object-oriented programming language that adds Smalltalk-style messaging to the C programming language.

```objective-c
// Single-line comments start with //

/*
Multi-line comments look like this
*/

// XCode supports pragma mark directive that improve jump bar readability
#pragma mark Navigation Functions // New tag on jump bar named 'Navigation Functions'
#pragma mark - Navigation Functions // Same tag, now with a separator

// Imports the Foundation headers with #import
// Use <> to import global files (in general frameworks)
// Use """" to import local files (from project)
#import <Foundation/Foundation.h>
#import ""MyClass.h""

// If you enable modules for iOS >= 7.0 or OS X >= 10.9 projects in
// Xcode 5 you can import frameworks like that:
@import Foundation;

// Your program's entry point is a function called
// main with an integer return type
int main (int argc, const char * argv[])
{
    // Create an autorelease pool to manage the memory into the program
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    // If using automatic reference counting (ARC), use @autoreleasepool instead:
    @autoreleasepool {

    // Use NSLog to print lines to the console
    NSLog(@""Hello World!""); // Print the string ""Hello World!""

    ///////////////////////////////////////
    // Types & Variables
    ///////////////////////////////////////

    // Primitive declarations
    int myPrimitive1  = 1;
    long myPrimitive2 = 234554664565;

    // Object declarations
    // Put the * in front of the variable names for strongly-typed object declarations
    MyClass *myObject1 = nil;  // Strong typing
    id       myObject2 = nil;  // Weak typing
    // %@ is an object
    // 'description' is a convention to display the value of the Objects
    NSLog(@""%@ and %@"", myObject1, [myObject2 description]); // prints => ""(null) and (null)""

    // String
    NSString *worldString = @""World"";
    NSLog(@""Hello %@!"", worldString); // prints => ""Hello World!""
    // NSMutableString is a mutable version of the NSString object
    NSMutableString *mutableString = [NSMutableString stringWithString:@""Hello""];
    [mutableString appendString:@"" World!""];
    NSLog(@""%@"", mutableString); // prints => ""Hello World!""

    // Character literals
    NSNumber *theLetterZNumber = @'Z';
    char theLetterZ            = [theLetterZNumber charValue]; // or 'Z'
    NSLog(@""%c"", theLetterZ);

    // Integral literals
    NSNumber *fortyTwoNumber = @42;
    int fortyTwo             = [fortyTwoNumber intValue]; // or 42
    NSLog(@""%i"", fortyTwo);

    NSNumber *fortyTwoUnsignedNumber = @42U;
    unsigned int fortyTwoUnsigned    = [fortyTwoUnsignedNumber unsignedIntValue]; // or 42
    NSLog(@""%u"", fortyTwoUnsigned);

    NSNumber *fortyTwoShortNumber = [NSNumber numberWithShort:42];
    short fortyTwoShort           = [fortyTwoShortNumber shortValue]; // or 42
    NSLog(@""%hi"", fortyTwoShort);

    NSNumber *fortyOneShortNumber   = [NSNumber numberWithShort:41];
    unsigned short fortyOneUnsigned = [fortyOneShortNumber unsignedShortValue]; // or 41
    NSLog(@""%u"", fortyOneUnsigned);

    NSNumber *fortyTwoLongNumber = @42L;
    long fortyTwoLong            = [fortyTwoLongNumber longValue]; // or 42
    NSLog(@""%li"", fortyTwoLong);

    NSNumber *fiftyThreeLongNumber   = @53L;
    unsigned long fiftyThreeUnsigned = [fiftyThreeLongNumber unsignedLongValue]; // or 53
    NSLog(@""%lu"", fiftyThreeUnsigned);

    // Floating point literals
    NSNumber *piFloatNumber = @3.141592654F;
    float piFloat           = [piFloatNumber floatValue]; // or 3.141592654f
    NSLog(@""%f"", piFloat); // prints => 3.141592654
    NSLog(@""%5.2f"", piFloat); // prints => "" 3.14""

    NSNumber *piDoubleNumber = @3.1415926535;
    double piDouble          = [piDoubleNumber doubleValue]; // or 3.1415926535
    NSLog(@""%f"", piDouble);
    NSLog(@""%4.2f"", piDouble); // prints => ""3.14""

    // NSDecimalNumber is a fixed-point class that's more precise than float or double
    NSDecimalNumber *oneDecNum = [NSDecimalNumber decimalNumberWithString:@""10.99""];
    NSDecimalNumber *twoDecNum = [NSDecimalNumber decimalNumberWithString:@""5.002""];
    // NSDecimalNumber isn't able to use standard +, -, *, / operators so it provides its own:
    [oneDecNum decimalNumberByAdding:twoDecNum];
    [oneDecNum decimalNumberBySubtracting:twoDecNum];
    [oneDecNum decimalNumberByMultiplyingBy:twoDecNum];
    [oneDecNum decimalNumberByDividingBy:twoDecNum];
    NSLog(@""%@"", oneDecNum); // prints => 10.99 as NSDecimalNumber is immutable

    // BOOL literals
    NSNumber *yesNumber = @YES;
    NSNumber *noNumber  = @NO;
    // or
    BOOL yesBool = YES;
    BOOL noBool  = NO;
    NSLog(@""%i"", yesBool); // prints => 1

    // Array object
    // May contain different data types, but must be an Objective-C object
    NSArray *anArray      = @[@1, @2, @3, @4];
    NSNumber *thirdNumber = anArray[2];
    NSLog(@""Third number = %@"", thirdNumber); // prints => ""Third number = 3""
    // Since Xcode 7, NSArray objects can be typed (Generics)
    NSArray<NSString *> *stringArray = @[@""hello"", @""world""];
    // NSMutableArray is a mutable version of NSArray, allowing you to change
    // the items in the array and to extend or shrink the array object.
    // Convenient, but not as efficient as NSArray.
    NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:2];
    [mutableArray addObject:@""Hello""];
    [mutableArray addObject:@""World""];
    [mutableArray removeObjectAtIndex:0];
    NSLog(@""%@"", [mutableArray objectAtIndex:0]); // prints => ""World""

    // Dictionary object
    NSDictionary *aDictionary = @{ @""key1"" : @""value1"", @""key2"" : @""value2"" };
    NSObject *valueObject     = aDictionary[@""A Key""];
    NSLog(@""Object = %@"", valueObject); // prints => ""Object = (null)""
    // Since Xcode 7, NSDictionary objects can be typed (Generics)
    NSDictionary<NSString *, NSNumber *> *numberDictionary = @{@""a"": @1, @""b"": @2};
    // NSMutableDictionary also available as a mutable dictionary object
    NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithCapacity:2];
    [mutableDictionary setObject:@""value1"" forKey:@""key1""];
    [mutableDictionary setObject:@""value2"" forKey:@""key2""];
    [mutableDictionary removeObjectForKey:@""key1""];

    // Change types from Mutable To Immutable
    //In general [object mutableCopy] will make the object mutable whereas [object copy] will make the object immutable
    NSMutableDictionary *aMutableDictionary = [aDictionary mutableCopy];
    NSDictionary *mutableDictionaryChanged = [mutableDictionary copy];


    // Set object
    NSSet *set = [NSSet setWithObjects:@""Hello"", @""Hello"", @""World"", nil];
    NSLog(@""%@"", set); // prints => {(Hello, World)} (may be in different order)
    // Since Xcode 7, NSSet objects can be typed (Generics)
    NSSet<NSString *> *stringSet = [NSSet setWithObjects:@""hello"", @""world"", nil];
    // NSMutableSet also available as a mutable set object
    NSMutableSet *mutableSet = [NSMutableSet setWithCapacity:2];
    [mutableSet addObject:@""Hello""];
    [mutableSet addObject:@""Hello""];
    NSLog(@""%@"", mutableSet); // prints => {(Hello)}

    ///////////////////////////////////////
    // Operators
    ///////////////////////////////////////

    // The operators works like in the C language
    // For example:
    2 + 5; // => 7
    4.2f + 5.1f; // => 9.3f
    3 == 2; // => 0 (NO)
    3 != 2; // => 1 (YES)
    1 && 1; // => 1 (Logical and)
    0 || 1; // => 1 (Logical or)
    ~0x0F; // => 0xF0 (bitwise negation)
    0x0F & 0xF0; // => 0x00 (bitwise AND)
    0x01 << 1; // => 0x02 (bitwise left shift (by 1))

    ///////////////////////////////////////
    // Control Structures
    ///////////////////////////////////////

    // If-Else statement
    if (NO)
    {
        NSLog(@""I am never run"");
    } else if (0)
    {
        NSLog(@""I am also never run"");
    } else
    {
        NSLog(@""I print"");
    }

    // Switch statement
    switch (2)
    {
        case 0:
        {
            NSLog(@""I am never run"");
        } break;
        case 1:
        {
            NSLog(@""I am also never run"");
        } break;
        default:
        {
            NSLog(@""I print"");
        } break;
    }

    // While loops statements
    int ii = 0;
    while (ii < 4)
    {
        NSLog(@""%d,"", ii++); // ii++ increments ii in-place, after using its value
    } // prints => ""0,""
      //           ""1,""
      //           ""2,""
      //           ""3,""

    // For loops statements
    int jj;
    for (jj=0; jj < 4; jj++)
    {
        NSLog(@""%d,"", jj);
    } // prints => ""0,""
      //           ""1,""
      //           ""2,""
      //           ""3,""

    // Foreach statements
    NSArray *values = @[@0, @1, @2, @3];
    for (NSNumber *value in values)
    {
        NSLog(@""%@,"", value);
    } // prints => ""0,""
      //           ""1,""
      //           ""2,""
      //           ""3,""

    // Object for loop statement. Can be used with any Objective-C object type
    for (id item in values) {
        NSLog(@""%@,"", item);
    } // prints => ""0,""
      //           ""1,""
      //           ""2,""
      //           ""3,""

    // Try-Catch-Finally statements
    @try
    {
        // Your statements here
        @throw [NSException exceptionWithName:@""FileNotFoundException""
                            reason:@""File Not Found on System"" userInfo:nil];
    } @catch (NSException * e) // use: @catch (id exceptionName) to catch all objects.
    {
        NSLog(@""Exception: %@"", e);
    } @finally
    {
        NSLog(@""Finally. Time to clean up."");
    } // prints => ""Exception: File Not Found on System""
      //           ""Finally. Time to clean up.""

    // NSError objects are useful for function arguments to populate on user mistakes.
    NSError *error = [NSError errorWithDomain:@""Invalid email."" code:4 userInfo:nil];

    ///////////////////////////////////////
    // Objects
    ///////////////////////////////////////

    // Create an object instance by allocating memory and initializing it
    // An object is not fully functional until both steps have been completed
    MyClass *myObject = [[MyClass alloc] init];

    // The Objective-C model of object-oriented programming is based on message
    // passing to object instances
    // In Objective-C one does not simply call a method; one sends a message
    [myObject instanceMethodWithParameter:@""Steve Jobs""];

    // Clean up the memory you used into your program
    [pool drain];

    // End of @autoreleasepool
    }

    // End the program
    return 0;
}

///////////////////////////////////////
// Classes And Functions
///////////////////////////////////////

// Declare your class in a header file (MyClass.h):
// Class declaration syntax:
// @interface ClassName : ParentClassName <ImplementedProtocols>
// {
//    type name; <= variable declarations;
// }
// @property type name; <= property declarations
// -/+ (type) Method declarations; <= Method declarations
// @end
@interface MyClass : NSObject <MyProtocol> // NSObject is Objective-C's base object class.
{
    // Instance variable declarations (can exist in either interface or implementation file)
    int count; // Protected access by default.
    @private id data; // Private access (More convenient to declare in implementation file)
    NSString *name;
}
// Convenient notation for public access variables to auto generate a setter method
// By default, setter method name is 'set' followed by @property variable name
@property int propInt; // Setter method name = 'setPropInt'
@property (copy) id copyId; // (copy) => Copy the object during assignment
// (readonly) => Cannot set value outside @interface
@property (readonly) NSString *roString; // Use @synthesize in @implementation to create accessor
// You can customize the getter and setter names instead of using default 'set' name:
@property (getter=lengthGet, setter=lengthSet:) int length;

// Methods
+/- (return type)methodSignature:(Parameter Type *)parameterName;

// + for class methods:
+ (NSString *)classMethod;
+ (MyClass *)myClassFromHeight:(NSNumber *)defaultHeight;

// - for instance methods:
- (NSString *)instanceMethodWithParameter:(NSString *)string;
- (NSNumber *)methodAParameterAsString:(NSString*)string andAParameterAsNumber:(NSNumber *)number;

// Constructor methods with arguments:
- (id)initWithDistance:(int)defaultDistance;
// Objective-C method names are very descriptive. Always name methods according to their arguments

@end // States the end of the interface


// To access public variables from the implementation file, @property generates a setter method
// automatically. Method name is 'set' followed by @property variable name:
MyClass *myClass = [[MyClass alloc] init]; // create MyClass object instance
[myClass setCount:10];
NSLog(@""%d"", [myClass count]); // prints => 10
// Or using the custom getter and setter method defined in @interface:
[myClass lengthSet:32];
NSLog(@""%i"", [myClass lengthGet]); // prints => 32
// For convenience, you may use dot notation to set and access object instance variables:
myClass.count = 45;
NSLog(@""%i"", myClass.count); // prints => 45

// Call class methods:
NSString *classMethodString = [MyClass classMethod];
MyClass *classFromName = [MyClass myClassFromName:@""Hello""];

// Call instance methods:
MyClass *myClass = [[MyClass alloc] init]; // Create MyClass object instance
NSString *stringFromInstanceMethod = [myClass instanceMethodWithParameter:@""Hello""];

// Selectors
// Way to dynamically represent methods. Used to call methods of a class, pass methods
// through functions to tell other classes they should call it, and to save methods
// as a variable
// SEL is the data type. @selector() returns a selector from method name provided
// methodAParameterAsString:andAParameterAsNumber: is method name for method in MyClass
SEL selectorVar = @selector(methodAParameterAsString:andAParameterAsNumber:);
if ([myClass respondsToSelector:selectorVar]) { // Checks if class contains method
    // Must put all method arguments into one object to send to performSelector function
    NSArray *arguments = [NSArray arrayWithObjects:@""Hello"", @4, nil];
    [myClass performSelector:selectorVar withObject:arguments]; // Calls the method
} else {
    // NSStringFromSelector() returns a NSString of the method name of a given selector
    NSLog(@""MyClass does not have method: %@"", NSStringFromSelector(selectedVar));
}

// Implement the methods in an implementation (MyClass.m) file:
@implementation MyClass {
    long distance; // Private access instance variable
    NSNumber height;
}

// To access a public variable from the interface file, use '_' followed by variable name:
_count = 5; // References ""int count"" from MyClass interface
// Access variables defined in implementation file:
distance = 18; // References ""long distance"" from MyClass implementation
// To use @property variable in implementation, use @synthesize to create accessor variable:
@synthesize roString = _roString; // _roString available now in @implementation

// Called before calling any class methods or instantiating any objects
+ (void)initialize
{
    if (self == [MyClass class]) {
        distance = 0;
    }
}

// Counterpart to initialize method. Called when an object's reference count is zero
- (void)dealloc
{
    [height release]; // If not using ARC, make sure to release class variable objects
    [super dealloc];  // and call parent class dealloc
}

// Constructors are a way of creating instances of a class
// This is a default constructor which is called when the object is initialized.
- (id)init
{
    if ((self = [super init])) // 'super' used to access methods from parent class
    {
        self.count = 1; // 'self' used for object to call itself
    }
    return self;
}
// Can create constructors that contain arguments:
- (id)initWithDistance:(int)defaultDistance
{
    distance = defaultDistance;
    return self;
}

+ (NSString *)classMethod
{
    return @""Some string"";
}

+ (MyClass *)myClassFromHeight:(NSNumber *)defaultHeight
{
    height = defaultHeight;
    return [[self alloc] init];
}

- (NSString *)instanceMethodWithParameter:(NSString *)string
{
    return @""New string"";
}

- (NSNumber *)methodAParameterAsString:(NSString*)string andAParameterAsNumber:(NSNumber *)number
{
    return @42;
}

// Objective-C does not have private method declarations, but you can simulate them.
// To simulate a private method, create the method in the @implementation but not in the @interface.
- (NSNumber *)secretPrivateMethod {
    return @72;
}
[self secretPrivateMethod]; // Calls private method

// Methods declared into MyProtocol
- (void)myProtocolMethod
{
    // statements
}

@end // States the end of the implementation

///////////////////////////////////////
// Categories
///////////////////////////////////////
// A category is a group of methods designed to extend a class. They allow you to add new methods
// to an existing class for organizational purposes. This is not to be mistaken with subclasses.
// Subclasses are meant to CHANGE functionality of an object while categories instead ADD
// functionality to an object.
// Categories allow you to:
// -- Add methods to an existing class for organizational purposes.
// -- Allow you to extend Objective-C object classes (ex: NSString) to add your own methods.
// -- Add ability to create protected and private methods to classes.
// NOTE: Do not override methods of the base class in a category even though you have the ability
// to. Overriding methods may cause compiler errors later between different categories and it
// ruins the purpose of categories to only ADD functionality. Subclass instead to override methods.

// Here is a simple Car base class.
@interface Car : NSObject

@property NSString *make;
@property NSString *color;

- (void)turnOn;
- (void)accelerate;

@end

// And the simple Car base class implementation:
#import ""Car.h""

@implementation Car

@synthesize make = _make;
@synthesize color = _color;

- (void)turnOn {
    NSLog(@""Car is on."");
}
- (void)accelerate {
    NSLog(@""Accelerating."");
}

@end

// Now, if we wanted to create a Truck object, we would instead create a subclass of Car as it would
// be changing the functionality of the Car to behave like a truck. But lets say we want to just add
// functionality to this existing Car. A good example would be to clean the car. So we would create
// a category to add these cleaning methods:
// @interface filename: Car+Clean.h (BaseClassName+CategoryName.h)
#import ""Car.h"" // Make sure to import base class to extend.

@interface Car (Clean) // The category name is inside () following the name of the base class.

- (void)washWindows; // Names of the new methods we are adding to our Car object.
- (void)wax;

@end

// @implementation filename: Car+Clean.m (BaseClassName+CategoryName.m)
#import ""Car+Clean.h"" // Import the Clean category's @interface file.

@implementation Car (Clean)

- (void)washWindows {
    NSLog(@""Windows washed."");
}
- (void)wax {
    NSLog(@""Waxed."");
}

@end

// Any Car object instance has the ability to use a category. All they need to do is import it:
#import ""Car+Clean.h"" // Import as many different categories as you want to use.
#import ""Car.h"" // Also need to import base class to use it's original functionality.

int main (int argc, const char * argv[]) {
    @autoreleasepool {
        Car *mustang = [[Car alloc] init];
        mustang.color = @""Red"";
        mustang.make = @""Ford"";

        [mustang turnOn]; // Use methods from base Car class.
        [mustang washWindows]; // Use methods from Car's Clean category.
    }
    return 0;
}

// Objective-C does not have protected method declarations but you can simulate them.
// Create a category containing all of the protected methods, then import it ONLY into the
// @implementation file of a class belonging to the Car class:
@interface Car (Protected) // Naming category 'Protected' to remember methods are protected.

- (void)lockCar; // Methods listed here may only be created by Car objects.

@end
//To use protected methods, import the category, then implement the methods:
#import ""Car+Protected.h"" // Remember, import in the @implementation file only.

@implementation Car

- (void)lockCar {
    NSLog(@""Car locked.""); // Instances of Car can't use lockCar because it's not in the @interface.
}

@end

///////////////////////////////////////
// Extensions
///////////////////////////////////////
// Extensions allow you to override public access property attributes and methods of an @interface.
// @interface filename: Shape.h
@interface Shape : NSObject // Base Shape class extension overrides below.

@property (readonly) NSNumber *numOfSides;

- (int)getNumOfSides;

@end
// You can override numOfSides variable or getNumOfSides method to edit them with an extension:
// @implementation filename: Shape.m
#import ""Shape.h""
// Extensions live in the same file as the class @implementation.
@interface Shape () // () after base class name declares an extension.

@property (copy) NSNumber *numOfSides; // Make numOfSides copy instead of readonly.
-(NSNumber)getNumOfSides; // Make getNumOfSides return a NSNumber instead of an int.
-(void)privateMethod; // You can also create new private methods inside of extensions.

@end
// The main @implementation:
@implementation Shape

@synthesize numOfSides = _numOfSides;

-(NSNumber)getNumOfSides { // All statements inside of extension must be in the @implementation.
    return _numOfSides;
}
-(void)privateMethod {
    NSLog(@""Private method created by extension. Shape instances cannot call me."");
}

@end

// Starting in Xcode 7.0, you can create Generic classes,
// allowing you to provide greater type safety and clarity
// without writing excessive boilerplate.
@interface Result<__covariant A> : NSObject

- (void)handleSuccess:(void(^)(A))success
              failure:(void(^)(NSError *))failure;

@property (nonatomic) A object;

@end

// we can now declare instances of this class like
Result<NSNumber *> *result;
Result<NSArray *> *result;

// Each of these cases would be equivalent to rewriting Result's interface
// and substituting the appropriate type for A
@interface Result : NSObject
- (void)handleSuccess:(void(^)(NSArray *))success
              failure:(void(^)(NSError *))failure;
@property (nonatomic) NSArray * object;
@end

@interface Result : NSObject
- (void)handleSuccess:(void(^)(NSNumber *))success
              failure:(void(^)(NSError *))failure;
@property (nonatomic) NSNumber * object;
@end

// It should be obvious, however, that writing one
//  Class to solve a problem is always preferable to writing two

// Note that Clang will not accept generic types in @implementations,
// so your @implemnation of Result would have to look like this:

@implementation Result

- (void)handleSuccess:(void (^)(id))success
              failure:(void (^)(NSError *))failure {
  // Do something
}

@end


///////////////////////////////////////
// Protocols
///////////////////////////////////////
// A protocol declares methods that can be implemented by any class.
// Protocols are not classes themselves. They simply define an interface
// that other objects are responsible for implementing.
// @protocol filename: ""CarUtilities.h""
@protocol CarUtilities <NSObject> // <NSObject> => Name of another protocol this protocol includes.
    @property BOOL engineOn; // Adopting class must @synthesize all defined @properties and
    - (void)turnOnEngine; // all defined methods.
@end
// Below is an example class implementing the protocol.
#import ""CarUtilities.h"" // Import the @protocol file.

@interface Car : NSObject <CarUtilities> // Name of protocol goes inside <>
    // You don't need the @property or method names here for CarUtilities. Only @implementation does.
- (void)turnOnEngineWithUtilities:(id <CarUtilities>)car; // You can use protocols as data too.
@end
// The @implementation needs to implement the @properties and methods for the protocol.
@implementation Car : NSObject <CarUtilities>

@synthesize engineOn = _engineOn; // Create a @synthesize statement for the engineOn @property.

- (void)turnOnEngine { // Implement turnOnEngine however you would like. Protocols do not define
    _engineOn = YES; // how you implement a method, it just requires that you do implement it.
}
// You may use a protocol as data as you know what methods and variables it has implemented.
- (void)turnOnEngineWithCarUtilities:(id <CarUtilities>)objectOfSomeKind {
    [objectOfSomeKind engineOn]; // You have access to object variables
    [objectOfSomeKind turnOnEngine]; // and the methods inside.
    [objectOfSomeKind engineOn]; // May or may not be YES. Class implements it however it wants.
}

@end
// Instances of Car now have access to the protocol.
Car *carInstance = [[Car alloc] init];
[carInstance setEngineOn:NO];
[carInstance turnOnEngine];
if ([carInstance engineOn]) {
    NSLog(@""Car engine is on.""); // prints => ""Car engine is on.""
}
// Make sure to check if an object of type 'id' implements a protocol before calling protocol methods:
if ([myClass conformsToProtocol:@protocol(CarUtilities)]) {
    NSLog(@""This does not run as the MyClass class does not implement the CarUtilities protocol."");
} else if ([carInstance conformsToProtocol:@protocol(CarUtilities)]) {
    NSLog(@""This does run as the Car class implements the CarUtilities protocol."");
}
// Categories may implement protocols as well: @interface Car (CarCategory) <CarUtilities>
// You may implement many protocols: @interface Car : NSObject <CarUtilities, CarCleaning>
// NOTE: If two or more protocols rely on each other, make sure to forward-declare them:
#import ""Brother.h""

@protocol Brother; // Forward-declare statement. Without it, compiler will throw error.

@protocol Sister <NSObject>

- (void)beNiceToBrother:(id <Brother>)brother;

@end

// See the problem is that Sister relies on Brother, and Brother relies on Sister.
#import ""Sister.h""

@protocol Sister; // These lines stop the recursion, resolving the issue.

@protocol Brother <NSObject>

- (void)beNiceToSister:(id <Sister>)sister;

@end


///////////////////////////////////////
// Blocks
///////////////////////////////////////
// Blocks are statements of code, just like a function, that are able to be used as data.
// Below is a simple block with an integer argument that returns the argument plus 4.
^(int n) {
    return n + 4;
}
int (^addUp)(int n); // Declare a variable to store a block.
void (^noParameterBlockVar)(void); // Example variable declaration of block with no arguments.
// Blocks have access to variables in the same scope. But the variables are readonly and the
// value passed to the block is the value of the variable when the block is created.
int outsideVar = 17; // If we edit outsideVar after declaring addUp, outsideVar is STILL 17.
__block long mutableVar = 3; // __block makes variables writable to blocks, unlike outsideVar.
addUp = ^(int n) { // Remove (int n) to have a block that doesn't take in any parameters.
    NSLog(@""You may have as many lines in a block as you would like."");
    NSSet *blockSet; // Also, you can declare local variables.
    mutableVar = 32; // Assigning new value to __block variable.
    return n + outsideVar; // Return statements are optional.
}
int addUp = addUp(10 + 16); // Calls block code with arguments.
// Blocks are often used as arguments to functions to be called later, or for callbacks.
@implementation BlockExample : NSObject

 - (void)runBlock:(void (^)(NSString))block {
    NSLog(@""Block argument returns nothing and takes in a NSString object."");
    block(@""Argument given to block to execute.""); // Calling block.
 }

 @end


///////////////////////////////////////
// Memory Management
///////////////////////////////////////
/*
For each object used in an application, memory must be allocated for that object. When the application
is done using that object, memory must be deallocated to ensure application efficiency.
Objective-C does not use garbage collection and instead uses reference counting. As long as
there is at least one reference to an object (also called ""owning"" an object), then the object
will be available to use (known as ""ownership"").

When an instance owns an object, its reference counter is increments by one. When the
object is released, the reference counter decrements by one. When reference count is zero,
the object is removed from memory.

With all object interactions, follow the pattern of:
(1) create the object, (2) use the object, (3) then free the object from memory.
*/

MyClass *classVar = [MyClass alloc]; // 'alloc' sets classVar's reference count to one. Returns pointer to object
[classVar release]; // Decrements classVar's reference count
// 'retain' claims ownership of existing object instance and increments reference count. Returns pointer to object
MyClass *newVar = [classVar retain]; // If classVar is released, object is still in memory because newVar is owner
[classVar autorelease]; // Removes ownership of object at end of @autoreleasepool block. Returns pointer to object

// @property can use 'retain' and 'assign' as well for small convenient definitions
@property (retain) MyClass *instance; // Release old value and retain a new one (strong reference)
@property (assign) NSSet *set; // Pointer to new value without retaining/releasing old (weak reference)

// Automatic Reference Counting (ARC)
// Because memory management can be a pain, Xcode 4.2 and iOS 4 introduced Automatic Reference Counting (ARC).
// ARC is a compiler feature that inserts retain, release, and autorelease automatically for you, so when using ARC,
// you must not use retain, release, or autorelease
MyClass *arcMyClass = [[MyClass alloc] init];
// ... code using arcMyClass
// Without ARC, you will need to call: [arcMyClass release] after you're done using arcMyClass. But with ARC,
// there is no need. It will insert this release statement for you

// As for the 'assign' and 'retain' @property attributes, with ARC you use 'weak' and 'strong'
@property (weak) MyClass *weakVar; // 'weak' does not take ownership of object. If original instance's reference count
// is set to zero, weakVar will automatically receive value of nil to avoid application crashing
@property (strong) MyClass *strongVar; // 'strong' takes ownership of object. Ensures object will stay in memory to use

// For regular variables (not @property declared variables), use the following:
__strong NSString *strongString; // Default. Variable is retained in memory until it leaves it's scope
__weak NSSet *weakSet; // Weak reference to existing object. When existing object is released, weakSet is set to nil
__unsafe_unretained NSArray *unsafeArray; // Like __weak, but unsafeArray not set to nil when existing object is released

```
## Further Reading

[Wikipedia Objective-C](http://en.wikipedia.org/wiki/Objective-C)

[Programming with Objective-C. Apple PDF book](https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/ProgrammingWithObjectiveC.pdf)

[Programming with Objective-C for iOS](https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectiveC.html)

[Programming with Objective-C for Mac OSX](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html)

[iOS For High School Students: Getting Started](http://www.raywenderlich.com/5600/ios-for-high-school-students-getting-started)"
"Docker is a tool that helps you build, test, ship and run applications
seamlessly across various machines. It replicates the environment our software
needs on any machine. You can get Docker for your machine from
https://docs.docker.com/get-docker/

It has grown in popularity over the last decade due to being lightweight and
fast as compared to virtual-machines that are bulky and slow. Unlike VMs, docker
does not need a full blown OS of its own to be loaded to start and does not
compete for resources other than what the application it is running will use.
VMs on the other hand are pretty resource intensive on our processors, disks and
memory hence running multiple VMs for various applications becomes a challenge
in a limited capacity architecture.

<pre>
┌────────────────────────┐ ┌───────────────────────┐
│      ┌───────────┐     │ │      ┌───────────┐    │
│      │   App     │     │ │      │   App     │    │
│      └───────────┘     │ │      └───────────┘    │
│  ┌────────┐ ┌────────┐ │ │  ┌────────┐ ┌───────┐ │
│  │  Libs  │ │  Deps  │ │ │  │  Libs  │ │  Deps │ │
│  └────────┘ └────────┘ │ │  └────────┘ └───────┘ │
│  ┌───────────────────┐ │ │  ┌──────────────────┐ │
│  │      Guest OS     │ │ │  │     Guest OS     │ │
│  └───────────────────┘ │ │  └──────────────────┘ │
│           VM1          │ │           VM2         │
└────────────────────────┘ └───────────────────────┘
┌──────────────────────────────────────────────────┐
│                     Hypervisor                   │
└──────────────────────────────────────────────────┘
┌──────────────────────────────────────────────────┐
│                      Host OS                     │
└──────────────────────────────────────────────────┘
┌──────────────────────────────────────────────────┐
│             Hardware Infrastructure              │
└──────────────────────────────────────────────────┘
              (VM based architecture)

┌────────────────────────┐ ┌───────────────────────┐
│      ┌───────────┐     │ │      ┌───────────┐    │
│      │   App     │     │ │      │   App     │    │
│      └───────────┘     │ │      └───────────┘    │
│  ┌────────┐ ┌────────┐ │ │  ┌────────┐ ┌───────┐ │
│  │  Libs  │ │  Deps  │ │ │  │  Libs  │ │  Deps │ │
│  └────────┘ └────────┘ │ │  └────────┘ └───────┘ │
│        Container1      │ │       Container2      │
└────────────────────────┘ └───────────────────────┘
┌──────────────────────────────────────────────────┐
│                       Docker                     │
└──────────────────────────────────────────────────┘
┌──────────────────────────────────────────────────┐
│                        OS                        │
└──────────────────────────────────────────────────┘
┌──────────────────────────────────────────────────┐
│             Hardware Infrastructure              │
└──────────────────────────────────────────────────┘
            (Docker based architecture)

</pre>

Couple of terms we will encounter frequently are Docker Images and Docker
Containers. Images are packages or templates of containers all stored in a
container registry such as [Docker Hub](https://hub.docker.com/). Containers
are standalone, executable instances of these images which include code,
runtime, system tools, system libraries and settings - everything required to
get the software up and running. Coming to Docker, it follows a client-server
architecture wherein the CLI client communicates with the server component,
which here is, the Docker Engine using RESTful API to issue commands.

## The Docker CLI
```bash
# after installing Docker from https://docs.docker.com/get-docker/
# To list available commands, either run `docker` with no parameters or execute
# `docker help`
$ docker

>>> docker [OPTIONS] COMMAND [ARG...]
       docker [ --help | -v | --version ]

    A self-sufficient runtime for containers.

    Options:
        --config string      Location of client config files (default ""/root/.docker"")
    -c, --context string     Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with ""docker context use"")
    -D, --debug              Enable debug mode
        --help               Print usage
    -H, --host value         Daemon socket(s) to connect to (default [])
    -l, --log-level string   Set the logging level (""debug""|""info""|""warn""|""error""|""fatal"") (default ""info"")
        --tls                Use TLS; implied by --tlsverify
        --tlscacert string   Trust certs signed only by this CA (default ""/root/.docker/ca.pem"")
        --tlscert string     Path to TLS certificate file (default ""/root/.docker/cert.pem"")
        --tlskey string      Path to TLS key file (default ""/root/.docker/key.pem"")
        --tlsverify          Use TLS and verify the remote
    -v, --version            Print version information and quit

    Commands:
        attach    Attach to a running container
        # […]

$ docker run hello-world
# `docker run <container-name>` is used to run a container, it will pull the
# images from Docker Hub if they don't already exist in your system. Here the
# docker client connects to the daemon which in turn pulls the ""hello-world""
# image from the Docker Hub. The daemon then builds a new container from the
# image which runs the executable that produces the output streamed back to the
# client that we see on our terminals.

$ docker run -d ubuntu sleep 60s
# The -d (or --detach) flag is when we want to run a container in the background
# and return back to the terminal. Here we detach an ubuntu container from the
# terminal, the output should be the id and the command exits. If we check
# running containers, we should still see ours there:
# CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES
# 133261b4894a   ubuntu    ""sleep 60s""   3 seconds ago   Up 2 seconds             vigorous_gould

$ docker run <container-id> -p 3000:8000
# The -p (or --publish) flag is used to expose port 8000 inside the container to
# port 3000 outside the container. This is because the app inside the container
# runs in isolation, hence the port 8000 where the app runs is private to the
# container.

$ docker run -i
# or
$ docker run -it
# Docker runs our containers in a non-interactive mode i.e. they do not accept
# inputs or work dynamically while running. The -i flag keeps input open to the
# container, and the -t flag creates a pseudo-terminal that the shell can attach
# to (can be combined as -it)

$ docker ps -a
# The `docker ps` command only shows running containers by default. To see all
# containers, use the -a (or --all) flag
# Running the above command should output something similar in the terminal:
# CONTAINER ID   IMAGE         COMMAND    CREATED         STATUS                     PORTS     NAMES
# 82f84bf6912b   hello-world   ""/hello""   9 minutes ago   Exited (0) 9 minutes ago             eloquent_sammet


$ docker stop hello-world
# or
$ docker start hello-world 
# The stop command simply stops one or more containers, and the start command
# starts the container(s) up again! `docker start -a ubuntu` will attach our
# detached container back to the terminal i.e. runs in the foreground

$ docker create alpine
# `docker create` creates a new container for us with the image specified (here,
# alpine), the container does not auto-start unlike `docker run`. This command
# is used to set up a container configuration and then `docker start` to shoot
# it up when required. Note that the status is ""Created"":
# CONTAINER ID   IMAGE         COMMAND       CREATED             STATUS           PORTS     NAMES
# 4c71c727c73d   alpine        ""/bin/sh""     29 seconds ago      Created                   naughty_ritchie

$ docker rm 82f84
# Removes one or more containers using their container ID.
# P.S.: we can use only the first few characters of the entire ID to identify
# containers

$ docker images
# Displays all images and their information, created here means the latest image
# tag updated on Docker Hub:
# REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
# ubuntu        latest    a8780b506fa4   9 days ago      77.8MB
# alpine        latest    9c6f07244728   3 months ago    5.54MB
# hello-world   latest    feb5d9fea6a5   13 months ago   13.3kB

$ docker rmi 
# Removes one or more images from your system which do not have their instances
# (or containers as we know them) running. If the image has an attached
# container, either delete the container first or use the -f (or --force) flag
# to forcefully delete both the container and image.

$ docker pull busybox
# The pull command downloads the specified image on our system from Docker Hub.

$ docker exec -it 7b272 bash
# This command is used to run a command in the running container's default
# directory. Here 7b272 was our ubuntu container and the above command would
# help us interact with the container by opening a bash session.

$docker logs <container-id>
# Displays the information logged by the specified container
# root@7b27222e4bb7:/# whoami
# root
# root@7b27222e4bb7:/# pwd
# /
# root@7b27222e4bb7:/# ls
# bin  boot  dev  etc  home  lib  lib32  lib64 libx3 srv  sys  tmp  usr  var
# root@7b27222e4bb7:/# exit
# exit

# More commands can be found at https://docs.docker.com/engine/reference/commandline/docker/
```
## The Dockerfile
The Dockerfile is a blueprint of a Docker image. We can mention the artifacts
from our application along with their configurations into this file in the 
specific syntax to let anyone create a Docker image of our application.

### A few things to keep in mind:
* It is always strictly named `Dockerfile` without any extensions
* We have to build our custom image on top of some already available Docker base 
image. (there is an empty image called `scratch` which literally lets you build
an image from scratch)
* All capitalised commands are part of the syntax, they are not case-sensitive
but used like a convention
* Below is a sample Dockerfile but you can read in depth from the [official docs](https://docs.docker.com/engine/reference/builder/).

```Dockerfile
FROM <base-image>
# define base image

ENV USERNAME='admin'\
    PWD='****'
# optionally define environmental variables

RUN apt-get update
# run linux commands inside container env, does not affect host env
# This executes during the time of image creation

COPY <src> <target>
# executes on the host, copies files from src (usually on the host) to target
# on the container

ENTRYPOINT [""some-script.sh""]
# executes an entire script as an entrypoint

CMD [<args>,...]
# always part of dockerfile, introduces entry point linux command e.g. 
# `CMD node server.js`
# This executes after image creation only when the container from the image
# is running.
```
### Build your images
Use the `docker build` command after wrapping your application into a Docker
image to run ( or build) it.

```bash

$docker build <path-to-dockerfile>
# used to build an image from the specified Dockerfile
# instead of path we could also specify a URL
# -t tag is optional and used to name and tag your images for e.g.
# `$docker build -t my-image:0.1 ./home/app`
# rebuild images everytime you make changes in the dockerfile
```

## Push your image to DockerHub
If you want your application's Docker image to be made publicly available for
any Docker user, you might wanna push it to the [Docker Hub](https://hub.docker.com/) which is a
registry of Docker images. Make sure you have an account with a username and
password on Docker Hub.

When pushing an image to Docker Hub, we must specify our Docker Hub username
as part of the source image name. We need to create the target image with the
tag name of username/image-name much like GitHub repositories. 

```bash
$docker login
# to login to Docker Hub using your username and password

$docker tag <src-image>[:<src-tag>] <target-image>[:<target-tag>]
# this tags a local src-image to a public target-image
# e.g. `docker tag my-sample-app:1.0.0  akshitadixit/my-sample-app`
# if tags are not specified, they're defaulted to `latest`

$docker push <target-image>[:<target-tag>]
# uploads our image to Docker Hub
# e.g. `docker push akshitadixit/my-sample-app`
# this image will be accessible under your profile's repositories as
# `https://hub.docker.com/r/username/image-name`

```"
"Kotlin is a statically typed programming language for the JVM, Android and the
browser. It is 100% interoperable with Java.
[Read more here.](https://kotlinlang.org/)

```kotlin
// Single-line comments start with //
/*
Multi-line comments look like this.
*/

// The ""package"" keyword works in the same way as in Java.
package com.learnxinyminutes.kotlin

/*
The entry point to a Kotlin program is a function named ""main"".
The function is passed an array containing any command-line arguments.
Since Kotlin 1.3 the ""main"" function can also be defined without
any parameters.
*/
fun main(args: Array<String>) {
    /*
    Declaring values is done using either ""var"" or ""val"".
    ""val"" declarations cannot be reassigned, whereas ""vars"" can.
    */
    val fooVal = 10 // we cannot later reassign fooVal to something else
    var fooVar = 10
    fooVar = 20 // fooVar can be reassigned

    /*
    In most cases, Kotlin can determine what the type of a variable is,
    so we don't have to explicitly specify it every time.
    We can explicitly declare the type of a variable like so:
    */
    val foo: Int = 7

    /*
    Strings can be represented in a similar way as in Java.
    Escaping is done with a backslash.
    */
    val fooString = ""My String Is Here!""
    val barString = ""Printing on a new line?\nNo Problem!""
    val bazString = ""Do you want to add a tab?\tNo Problem!""
    println(fooString)
    println(barString)
    println(bazString)

    /*
    A raw string is delimited by a triple quote ("""""").
    Raw strings can contain newlines and any other characters.
    */
    val fooRawString = """"""
fun helloWorld(val name : String) {
   println(""Hello, world!"")
}
""""""
    println(fooRawString)

    /*
    Strings can contain template expressions.
    A template expression starts with a dollar sign ($).
    */
    val fooTemplateString = ""$fooString has ${fooString.length} characters""
    println(fooTemplateString) // => My String Is Here! has 18 characters

    /*
    For a variable to hold null it must be explicitly specified as nullable.
    A variable can be specified as nullable by appending a ? to its type.
    We can access a nullable variable by using the ?. operator.
    We can use the ?: operator to specify an alternative value to use
    if a variable is null.
    */
    var fooNullable: String? = ""abc""
    println(fooNullable?.length) // => 3
    println(fooNullable?.length ?: -1) // => 3
    fooNullable = null
    println(fooNullable?.length) // => null
    println(fooNullable?.length ?: -1) // => -1

    /*
    Functions can be declared using the ""fun"" keyword.
    Function arguments are specified in brackets after the function name.
    Function arguments can optionally have a default value.
    The function return type, if required, is specified after the arguments.
    */
    fun hello(name: String = ""world""): String {
        return ""Hello, $name!""
    }
    println(hello(""foo"")) // => Hello, foo!
    println(hello(name = ""bar"")) // => Hello, bar!
    println(hello()) // => Hello, world!

    /*
    A function parameter may be marked with the ""vararg"" keyword
    to allow a variable number of arguments to be passed to the function.
    */
    fun varargExample(vararg names: Int) {
        println(""Argument has ${names.size} elements"")
    }
    varargExample() // => Argument has 0 elements
    varargExample(1) // => Argument has 1 elements
    varargExample(1, 2, 3) // => Argument has 3 elements

    /*
    When a function consists of a single expression then the curly brackets can
    be omitted. The body is specified after the = symbol.
    */
    fun odd(x: Int): Boolean = x % 2 == 1
    println(odd(6)) // => false
    println(odd(7)) // => true

    // If the return type can be inferred then we don't need to specify it.
    fun even(x: Int) = x % 2 == 0
    println(even(6)) // => true
    println(even(7)) // => false

    // Functions can take functions as arguments and return functions.
    fun not(f: (Int) -> Boolean): (Int) -> Boolean {
        return {n -> !f.invoke(n)}
    }
    // Named functions can be specified as arguments using the :: operator.
    val notOdd = not(::odd)
    val notEven = not(::even)
    // Lambda expressions can be specified as arguments.
    val notZero = not {n -> n == 0}
    /*
    If a lambda has only one parameter
    then its declaration can be omitted (along with the ->).
    The name of the single parameter will be ""it"".
    */
    val notPositive = not {it > 0}
    for (i in 0..4) {
        println(""${notOdd(i)} ${notEven(i)} ${notZero(i)} ${notPositive(i)}"")
    }

    // The ""class"" keyword is used to declare classes.
    class ExampleClass(val x: Int) {
        fun memberFunction(y: Int): Int {
            return x + y
        }

        infix fun infixMemberFunction(y: Int): Int {
            return x * y
        }
    }
    /*
    To create a new instance we call the constructor.
    Note that Kotlin does not have a ""new"" keyword.
    */
    val fooExampleClass = ExampleClass(7)
    // Member functions can be called using dot notation.
    println(fooExampleClass.memberFunction(4)) // => 11
    /*
    If a function has been marked with the ""infix"" keyword then it can be
    called using infix notation.
    */
    println(fooExampleClass infixMemberFunction 4) // => 28

    /*
    Data classes are a concise way to create classes that just hold data.
    The ""hashCode""/""equals"" and ""toString"" methods are automatically generated.
    */
    data class DataClassExample (val x: Int, val y: Int, val z: Int)
    val fooData = DataClassExample(1, 2, 4)
    println(fooData) // => DataClassExample(x=1, y=2, z=4)

    // Data classes have a ""copy"" function.
    val fooCopy = fooData.copy(y = 100)
    println(fooCopy) // => DataClassExample(x=1, y=100, z=4)

    // Objects can be destructured into multiple variables.
    val (a, b, c) = fooCopy
    println(""$a $b $c"") // => 1 100 4

    // destructuring in ""for"" loop
    for ((a, b, c) in listOf(fooData)) {
        println(""$a $b $c"") // => 1 2 4
    }

    val mapData = mapOf(""a"" to 1, ""b"" to 2)
    // Map.Entry is destructurable as well
    for ((key, value) in mapData) {
        println(""$key -> $value"")
    }

    // The ""with"" function is similar to the JavaScript ""with"" statement.
    data class MutableDataClassExample (var x: Int, var y: Int, var z: Int)
    val fooMutableData = MutableDataClassExample(7, 4, 9)
    with (fooMutableData) {
        x -= 2
        y += 2
        z--
    }
    println(fooMutableData) // => MutableDataClassExample(x=5, y=6, z=8)

    /*
    We can create a list using the ""listOf"" function.
    The list will be immutable - elements cannot be added or removed.
    */
    val fooList = listOf(""a"", ""b"", ""c"")
    println(fooList.size) // => 3
    println(fooList.first()) // => a
    println(fooList.last()) // => c
    // Elements of a list can be accessed by their index.
    println(fooList[1]) // => b

    // A mutable list can be created using the ""mutableListOf"" function.
    val fooMutableList = mutableListOf(""a"", ""b"", ""c"")
    fooMutableList.add(""d"")
    println(fooMutableList.last()) // => d
    println(fooMutableList.size) // => 4

    // We can create a set using the ""setOf"" function.
    val fooSet = setOf(""a"", ""b"", ""c"")
    println(fooSet.contains(""a"")) // => true
    println(fooSet.contains(""z"")) // => false

    // We can create a map using the ""mapOf"" function.
    val fooMap = mapOf(""a"" to 8, ""b"" to 7, ""c"" to 9)
    // Map values can be accessed by their key.
    println(fooMap[""a""]) // => 8

    /*
    Sequences represent lazily-evaluated collections.
    We can create a sequence using the ""generateSequence"" function.
    */
    val fooSequence = generateSequence(1, { it + 1 })
    val x = fooSequence.take(10).toList()
    println(x) // => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    // An example of using a sequence to generate Fibonacci numbers:
    fun fibonacciSequence(): Sequence<Long> {
        var a = 0L
        var b = 1L

        fun next(): Long {
            val result = a + b
            a = b
            b = result
            return a
        }

        return generateSequence(::next)
    }
    val y = fibonacciSequence().take(10).toList()
    println(y) // => [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

    // Kotlin provides higher-order functions for working with collections.
    val z = (1..9).map {it * 3}
                  .filter {it < 20}
                  .groupBy {it % 2 == 0}
                  .mapKeys {if (it.key) ""even"" else ""odd""}
    println(z) // => {odd=[3, 9, 15], even=[6, 12, 18]}

    // A ""for"" loop can be used with anything that provides an iterator.
    for (c in ""hello"") {
        println(c)
    }

    // ""while"" loops work in the same way as other languages.
    var ctr = 0
    while (ctr < 5) {
        println(ctr)
        ctr++
    }
    do {
        println(ctr)
        ctr++
    } while (ctr < 10)

    /*
    ""if"" can be used as an expression that returns a value.
    For this reason the ternary ?: operator is not needed in Kotlin.
    */
    val num = 5
    val message = if (num % 2 == 0) ""even"" else ""odd""
    println(""$num is $message"") // => 5 is odd

    // ""when"" can be used as an alternative to ""if-else if"" chains.
    val i = 10
    when {
        i < 7 -> println(""first block"")
        fooString.startsWith(""hello"") -> println(""second block"")
        else -> println(""else block"")
    }

    // ""when"" can be used with an argument.
    when (i) {
        0, 21 -> println(""0 or 21"")
        in 1..20 -> println(""in the range 1 to 20"")
        else -> println(""none of the above"")
    }

    // ""when"" can be used as an expression that returns a value.
    var result = when (i) {
        0, 21 -> ""0 or 21""
        in 1..20 -> ""in the range 1 to 20""
        else -> ""none of the above""
    }
    println(result)

    /*
    We can check if an object is of a particular type by using the ""is"" operator.
    If an object passes a type check then it can be used as that type without
    explicitly casting it.
    */
    fun smartCastExample(x: Any) : Boolean {
        if (x is Boolean) {
            // x is automatically cast to Boolean
            return x
        } else if (x is Int) {
            // x is automatically cast to Int
            return x > 0
        } else if (x is String) {
            // x is automatically cast to String
            return x.isNotEmpty()
        } else {
            return false
        }
    }
    println(smartCastExample(""Hello, world!"")) // => true
    println(smartCastExample("""")) // => false
    println(smartCastExample(5)) // => true
    println(smartCastExample(0)) // => false
    println(smartCastExample(true)) // => true

    // Smartcast also works with when block
    fun smartCastWhenExample(x: Any) = when (x) {
        is Boolean -> x
        is Int -> x > 0
        is String -> x.isNotEmpty()
        else -> false
    }

    /*
    Extensions are a way to add new functionality to a class.
    This is similar to C# extension methods.
    */
    fun String.remove(c: Char): String {
        return this.filter {it != c}
    }
    println(""Hello, world!"".remove('l')) // => Heo, word!
}

// Enum classes are similar to Java enum types.
enum class EnumExample {
    A, B, C // Enum constants are separated with commas.
}
fun printEnum() = println(EnumExample.A) // => A

// Since each enum is an instance of the enum class, they can be initialized as:
enum class EnumExample(val value: Int) {
    A(value = 1),
    B(value = 2),
    C(value = 3)
}
fun printProperty() = println(EnumExample.A.value) // => 1

// Every enum has properties to obtain its name and ordinal(position) in the enum class declaration:
fun printName() = println(EnumExample.A.name) // => A
fun printPosition() = println(EnumExample.A.ordinal) // => 0

/*
The ""object"" keyword can be used to create singleton objects.
We cannot instantiate it but we can refer to its unique instance by its name.
This is similar to Scala singleton objects.
*/
object ObjectExample {
    fun hello(): String {
        return ""hello""
    }

    override fun toString(): String {
        return ""Hello, it's me, ${ObjectExample::class.simpleName}""
    }
}


fun useSingletonObject() {
    println(ObjectExample.hello()) // => hello
    // In Kotlin, ""Any"" is the root of the class hierarchy, just like ""Object"" is in Java
    val someRef: Any = ObjectExample
    println(someRef) // => Hello, it's me, ObjectExample
}


/* The not-null assertion operator (!!) converts any value to a non-null type and
throws an exception if the value is null.
*/
var b: String? = ""abc""
val l = b!!.length

data class Counter(var value: Int) {
    // overload Counter += Int
    operator fun plusAssign(increment: Int) {
        this.value += increment
    }

    // overload Counter++ and ++Counter
    operator fun inc() = Counter(value + 1)

    // overload Counter + Counter
    operator fun plus(other: Counter) = Counter(this.value + other.value)

    // overload Counter * Counter
    operator fun times(other: Counter) = Counter(this.value * other.value)

    // overload Counter * Int
    operator fun times(value: Int) = Counter(this.value * value)

    // overload Counter in Counter
    operator fun contains(other: Counter) = other.value == this.value

    // overload Counter[Int] = Int
    operator fun set(index: Int, value: Int) {
        this.value = index + value
    }

    // overload Counter instance invocation
    operator fun invoke() = println(""The value of the counter is $value"")

}
/* You can also overload operators through extension methods */
// overload -Counter
operator fun Counter.unaryMinus() = Counter(-this.value)

fun operatorOverloadingDemo() {
    var counter1 = Counter(0)
    var counter2 = Counter(5)
    counter1 += 7
    println(counter1) // => Counter(value=7)
    println(counter1 + counter2) // => Counter(value=12)
    println(counter1 * counter2) // => Counter(value=35)
    println(counter2 * 2) // => Counter(value=10)
    println(counter1 in Counter(5)) // => false
    println(counter1 in Counter(7)) // => true
    counter1[26] = 10
    println(counter1) // => Counter(value=36)
    counter1() // => The value of the counter is 36
    println(-counter2) // => Counter(value=-5)
}
```

### Further Reading

* [Kotlin tutorials](https://kotlinlang.org/docs/tutorials/)
* [Try Kotlin in your browser](https://play.kotlinlang.org/)
* [A list of Kotlin resources](http://kotlin.link/)"
"Tact language is used to program smart contracts on the
[The Open Network](https://ton.org) blockchain. Contract logic is executed in
TVM, the stack-based TON Virtual Machine.

Tact is a statically typed, but language was designed to be friendly for
developers with JS and Python background.

This page is based on [Tact-by-Example](https://tact-by-example.org/).
You can use this resource to play around with contracts and check out
the interactive features.

# Basic syntax, function definition

```c
// Single line comment

 // This is a multi-line comment
  // this is a comment in the comment

    get fun greeting(): String {
    // This is a function that returns ""hello world"" message
    // Return type is specified after a colon :
        return ""hello world"";
    }
```

# A Simple Counter contract

This is a simple counter contract that allows users to increment its value.

This contract has a state variable `val` that persists between contract calls

- the counter value. When persisted, this variable is encoded as `uint32` -
  a 32-bit unsigned integer. Contracts pay rent in proportion to the amount
  of persistent space they consume, so compact representations are encouraged.

State variables should be initialized in `init()` that runs on deployment of
the contract.

## Messages

The actor model is a model of concurrent computation and is at the heart of TON
smart contracts. Each smart contract can process one message at a time, change
its own state, or send one or several messages. Processing of the message
occurs in one transaction, that is, it cannot be interrupted. Messages to one
contract are processed consequently one by one. As a result, the execution of
each transaction is local and can be parallelized at the blockchain level,
which allows for on-demand throughput horizontal scaling and hosting an
unlimited number of users and transactions.

## Receiving messages

This contract can receive messages from users. Unlike getters that are just
read-only, messages can do write operations and change the contract's
persistent state. Incoming messages are processed in receive() methods as
transactions and cost gas for the sender.

After deploying the contract, send the increment message by pressing the Send
increment button in order to increase the counter value by one. Afterwards,
call the getter value() to see that the value indeed changed.

```c
contract Counter {
// Tact allows to create a contract
    // persistent state variable of type Int to hold the counter value
    val: Int as uint32;

    // initialize the state variable when contract is deployed
    init() {
        self.val = 0;
    }

    // handler for incoming increment messages that change the state
    receive(""increment"") {
        self.val = self.val + 1;
    }

    // read-only getter for querying the counter value
    get fun value(): Int {
        return self.val;
    }
}
```

# The Deployable Trait

Tact doesn't support classical class inheritance, but contracts can implement
traits. One of the commonly used traits is `Deployable`. It implements a simple
receiver for the Deploy message which helps deploy contracts in a standard way.

All contracts are deployed by sending them a message. This can be any message,
but best practice is to designate the special `Deploy`
message for this purpose.

This message has a single field, `queryId`, which is provided by the deployer
(normally zero). If the deploy succeeds, the contract will reply with the
message `DeployOk` and echo the same `queryId` in the response.

If you're using Tact's [auto-generated](https://docs.tact-lang.org/tools/typescript#tact-contract-in-typescript) TypeScript
classes to deploy, sending the deploy message should look like:

```c
const msg = { $$type: ""Deploy"", queryId: 0n };
 await contract.send(sender, { value: toNano(1) }, msg);
```

You can see the implementation of the trait [here](https://github.com/tact-lang/tact/blob/main/stdlib/libs/deploy.tact).
Notice that the file deploy.tact needs to be imported from the standard
library using the import keyword.

```c
// this trait has to be imported
import ""@stdlib/deploy"";

// the Deployable trait adds a default receiver for the ""Deploy"" message
contract Counter with Deployable {

    val: Int as uint32;

    init() {
        self.val = 0;
    }

    receive(""increment"") {
        self.val = self.val + 1;
    }

    get fun value(): Int {
        return self.val;
    }
}
```

# Integers

Tact supports a number of primitive data types that are tailored for
smart contract use.

`Int` is the primary number type. Math in smart contracts is always done
with integers and never with floating points since floats are [unpredictable](https://learn.microsoft.com/en-us/cpp/build/why-floating-point-numbers-may-lose-precision).

The runtime type `Int` is always 257-bit signed, so all runtime calculations
are done at 257-bit. This should be large enough for pretty much anything you
need as it's large enough to hold the number of atoms in the universe.

Persistent state variables can be initialized inline or inside `init()`.
If you forget to initialize a state variable, the code will not compile.

## State costs

When encoding `Int` to persistent state, we will usually use smaller
representations than 257-bit to reduce storage cost.
The persistent state size is specified in every declaration of
a state variable after the `as` keyword.

Storing 1000 257-bit integers in state [costs](https://ton.org/docs/develop/smart-contracts/fees#how-to-calculate-fees) about
0.184 TON per year. Storing 1000 32-bit integers only costs
0.023 TON per year by comparison.

```c
import ""@stdlib/deploy"";

contract Integers with Deployable {

    // contract persistent state variables
    // integers can be persisted in state in various sizes
    // range -2^256 to 2^256 - 1 (takes 257 bit = 32 bytes + 1 bit)
    i1: Int as int257 = 3001;
    i2: Int as uint256;         // range 0 to 2^256 - 1 (takes 256 bit = 32 bytes)
    // range -2^255 to 2^255 - 1 (takes 256 bit = 32 bytes)
    i3: Int as int256 = 17;
    i4: Int as uint128;         // range 0 to 2^128 - 1 (takes 128 bit = 16 bytes)
    // range -2^127 to 2^127 - 1 (takes 128 bit = 16 bytes)
    i5: Int as int128;
    i6: Int as coins;           // range 0 to 2^120 - 1 (takes 120 bit = 15 bytes)
    // range 0 to 18,446,744,073,709,551,615 (takes 64 bit = 8 bytes)
    i7: Int as uint64 = 0x1c4a;
    // range -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
    // (takes 64 bit = 8 bytes)
    i8: Int as int64 = -203;
    i9: Int as uint32 = 0;      // range 0 to 4,294,967,295 (takes 32 bit = 4 bytes)
    // range -2,147,483,648 to 2,147,483,647 (takes 32 bit = 4 bytes)
    i10: Int as int32 = 0;
    i11: Int as uint16 = 0;     // range 0 to 65,535 (takes 16 bit = 2 bytes)
    i12: Int as int16 = 0;      // range -32,768 to 32,767 (takes 16 bit = 2 bytes)
    i13: Int as uint8 = 0;      // range 0 to 255 (takes 8 bit = 1 byte)
    i14: Int as int8 = 0;       // range -128 to 127 (takes 8 bit = 1 byte)

    init() {
        // we can define numbers in hex (base 16)
        self.i2 = 0x83dfd552e6372;
        self.i4 = 1507998500293440234999; // we can define numbers in decimal
        self.i5 = pow(10, 9);   // this is 10^9 = 1,000,000,000
        self.i6 = ton(""1.23"");  // easy to read coin balances
        //  (coins type is nano-tons, like cents, just with 9 decimals)
    }

    receive(""show all"") {
        dump(self.i1);
        dump(self.i2);
        dump(self.i3);
        dump(self.i4);
        dump(self.i5);
        dump(self.i6);
        dump(self.i7);
        dump(self.i8);
    }

    get fun result(): Int {
        return self.i1;
    }
}
```

## Bools, Addresses, Strings, Operators and Constants

### Bool

Bool can be used for boolean variables

```js
b1: Bool = true;
b2: Bool = false;
```

### Address

Address is another primitive data type. It represents standard addresses on
the TON blockchain.
TON is divided into multiple chains called workchains. One of the internal
fields of the address is the workchain id:
0 - The standard workchain, for regular users. Your contracts will be here.
-1 - The masterchain, usually for validators.

```js
// bouncable (same foundation wallet)
a1: Address = address(""EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N"");
// non-bounceable (same foundation wallet)
a2: Address = address(""UQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqEBI"");
```

### String

Tact has basic support for strings. Strings support unicode and don't
have any special escape characters like \n.
Strings are immutable. Once a sequence of characters is created, this
sequence cannot be modified.
If you need to concatenate strings in run-time, you can use a StringBuilder.
This object handles gas efficiently and supports append() of various types to
the string.

```js
s1: String = ""hello world"";
sb: StringBuilder = beginString();
sb.append(self.s1);
```

### Integer Operations

Addition, subtraction, multiplication, division, modulo,
shift left and right, minimum and maximum numbers, absolute value

```js
i: Int = -12; // temporary variable, runtime Int type is always int257
i = i1 * 3 + (i2 - i); // basic math expressions
i = i1 % 10; // modulo (remainder after division), 3001 % 10 = 1
i = i1 / 1000; // integer division (truncation toward zero), 3001 / 1000 = 3
i = i1 >> 3; // shift right (multiply by 2^n)
i = i1 << 2; // shift left (divide by 2^n)
i = min(i2, 11); // minimum between two numbers
i = max(i2, 66); // maximum between two numbers
i = abs(-1 * i2); // absolute value
```

### Constants

Unlike variables, constants cannot change. Their values are
calculated in compile-time and cannot change during execution.

```js
const StateUnpaid: Int = 0;
```

## Getters, Receivers and Messages

### Getters

Getters are special contract functions that allow users to query
information from the contract.
Contract methods starting with the prefix get fun are all getters.
Calling getters is free and does not cost gas.
Getters are read-only, they cannot change the contract persistent state.
A contract cannot execute a getter of another contract. Getters are only
executable by end-users off-chain.

```js
count: Int as uint32 = 17;

get fun counter(): Int {
    return self.count;
}
```

### Receivers

Contract methods named receive() are the handlers that process
each incoming message type.
Tact will automatically route every incoming message to the correct receiver
listening for it according to its type. A message is only handled by one receiver.

Handler for ""increment"" textual message - this is a textual string message,
these cannot carry input arguments

```js
receive(""increment"") {
    self.val = self.val + 1;
}
```

### Messages

Messages are defined using the message keyword. They can carry input
arguments. For integers, you must define the encoding size, just like in
state variables.

Handler for the ""Add"" message - this is a binary message that has an input
argument (amount)

```js
receive(msg: Add) {
    self.val = self.val + msg.amount;
}
```

## Structs

Structs allow you to combine multiple primitives together in a more semantic way.
Structs can define complex data types that contain multiple fields of
different types. They can also be nested.

```js
// Normal struct
struct Point {
    x: Int as int64;
    y: Int as int64;
}

// Nested struct
struct Params {
    name: String = ""Satoshi"";   // default value
    age: Int? = null;           // optional field
    point: Point;               // nested structs
}
```

## Message Sender and Throwing Errors

### Message Sender

Every incoming message is sent from some contract that has
an address. You can query the address of the message sender by calling sender()

```js
deployer: Address = sender();
```

### Errors

When an error is thrown, the transaction reverts. By writing a
require() on a condition that isn't met

```js
require(self.val < 5, ""Counter is too high"");
```

## Messages Between Contracts, Sending and Receiving TON Coins

### Messages Between Contracts

Different contracts can only communicate with
each other by sending each other messages.

This example sends a message to the to address with value of 1 TON and body
of a comment with a string ""Hello, World!"".
SendIgnoreErrors means that even when error occurs during message sending
next messages would be sent anyway.

```js
let to: Address = ...;
let value: Int = ton(""1"");
send(SendParameters{
    to: to,                             // address of receiver
    value: value,                       //  amount of TON you want to send
    mode: SendIgnoreErrors,             // 8-bit flag configuring how to send message
    bounce: true,                       // if set to true (default) then message
                                        // will be bounced back to sender
    body: ""Hello, World!"".asComment()   // message body as Cell
});
```

### Receiving TONs

You can query the contract balance with myBalance() - note
that the value is in nano-tons (like cents, just with 9 decimals). The balance
already contains the incoming message value.
You can also get the incoming TON balance with context().value

```js
val: Int as int64 = myBalance()
// or
// print how much TON coin were sent with this message
dump(context().value);
```

### Sending TONs

We can send any amount of TON to any address just like we created
a send call between different contracts

Send mode SendRemainingValue will add to the outgoing value any excess left
from the incoming message after all gas costs are deducted from it.

```js
amount: Int as coins = ton(""1"");
send(SendParameters{
    to: sender(),
    bounce: true,
    value: amount,
    mode: SendRemainingValue + SendIgnoreErrors
});
```

## If/Else statements and Loops

### If

Tact supports if statements in a similar syntax to most programming
languages. Curly braces are required.
We can have the else and else if similar to other programming languages.

```js
if (val > 1000) {
  dump(""larger than 1000"");
} else if (val > 500) {
  dump(""between 500 and 1000"");
} else {
  dump(""smaller than 500"");
}
```

### Loops

Tact does not support traditional 'for' loops, 'break' and 'continue'
statements in loops.
The repeat loop statement input number must fit within an int32.

```js
// repeat exactly 10 times

repeat (10) {
    i = i + 1;
    sum = sum + i;
}

// While loop

let x: Int = 10;
while(x > 0) {
  x = x - 1;
}

// do-until loop

let x: Int = 10;
do {
  x = x - 1;
} until (x <= 0);
```

## Functions

Functions in Tact start with the fun keyword. Functions can receive multiple
input arguments and can optionally return a single output value. You can
return a struct if you want to return multiple values.

```js
fun average(a: Int, b: Int): Int {
    return (a + b) / 2;
}
```

## Maps and Arrays

### Maps

Maps are a dictionary type that can hold an arbitrary number of items,
each under a different key.
The keys in maps can either be an Int type or an Address type.
You can check if a key is found in the map by calling the get() method.
Replace the value under a key by calling the set() method.

```js
mi1: map<Int, TokenInfo>;           // maps with Int as key
ma1: map<Address, TokenInfo>;       // maps with Address as key
```

### Arrays

To create an array, define a map with 'Int' type as key as well as value.

```js
arr: map<Int, Int>; // this is our array implemented with a map
```

## Ownable Standard Library

The Ownable trait allows the contract to set an owner role, which can have
higher priviliges from everybody else.
For this you would need to import the ""@stdlib/ownable"" library and inherit
it in your contract

- Use the self.requireOwner() call to verify that the person making that
  function call is the owner of contract
- 'ChangeOwner{newOwner: Address}' message which allows the owner to
  transfer ownership.
- Define state variables named 'owner: Address' and 'stopped: Bool' and
  call 'self.requireNotStopped()' on actions that should be stopped.
- Define state variables named 'owner: Address' and ""stopped: Bool' and
  call 'self.requireNotStopped()' on actions that should be stopped.

```js
import ""@stdlib/ownable"";
import ""@stdlib/deploy"";

contract Counter with Deployable, Ownable {
    owner: Address;

    init() { // initialize a contract with default values like 'constructor'
        self.owner = sender(); // we can initialize owner to any value we want, the deployer in this case
        self.val = 0;
    }

    // this message in only available to the owner
    receive(""double"") {
        self.requireOwner();
        self.val = self.val * 2;
    }

    // this message will only work until the contract was stopped
    receive(""increment"") {
        self.requireNotStopped();
        self.val = self.val + 1;
    }

    // this message will only work as long as the contract is not stopped
    receive(""increment2"") {
        self.requireNotStopped();
        self.val = self.val + 1;
    }
}

```

## Additional resources

- [TON Documentation](https://ton.org/docs/#/)
- [Tact Docs](https://docs.tact-lang.org/)
- [Tact by Example](https://tact-by-example.org/)
- [Community portal](https://society.ton.org)
- [Blockchain portal](https://ton.org)
- [Stackoverflow](https://stackoverflow.com/questions/tagged/ton)

## Social

- [Tact community](https://t.me/tactlang)
- [Developer community](https://t.me/tondev_eng)
- [TON Learn](https://t.me/ton_learn)
- [Tondev News](https://t.me/tondevnews)
- [TON Technical Updates](https://t.me/thetontech)

## Useful blogposts

- [Setting up a TON Development Environment](https://society.ton.org/setting-up-a-ton-development-environment)
- [Hello World on TON](https://society.ton.org/ton-hello-world-step-by-step-guide-for-writing-your-first-smart-contract-in-func)

## Future To Dos

- Add smart contracts examples
- Add more links to documentations

This file is based on [Tact By Example](https://tact-by-example.org).

P.S. If by any chance you're familiar with [Forth](https://learnxinyminutes.com/docs/forth/),
you can also take a look at [Fift](https://ton-blockchain.github.io/docs/fiftbase.pdf)."
"As with all Lisps, Clojure's inherent [homoiconicity](https://en.wikipedia.org/wiki/Homoiconic)
gives you access to the full extent of the language to write code-generation routines
called ""macros"". Macros provide a powerful way to tailor the language to your needs.

Be careful though. It's considered bad form to write a macro when a function will do.
Use a macro only when you need control over when or if the arguments to a form will
be evaluated.

You'll want to be familiar with Clojure. Make sure you understand everything in
[Clojure in Y Minutes](/docs/clojure/).

```clojure
;; Define a macro using defmacro. Your macro should output a list that can
;; be evaluated as clojure code.
;;
;; This macro is the same as if you wrote (reverse ""Hello World"")
(defmacro my-first-macro []
  (list reverse ""Hello World""))

;; Inspect the result of a macro using macroexpand or macroexpand-1.
;;
;; Note that the call must be quoted.
(macroexpand '(my-first-macro))
;; -> (#<core$reverse clojure.core$reverse@xxxxxxxx> ""Hello World"")

;; You can eval the result of macroexpand directly:
(eval (macroexpand '(my-first-macro)))
; -> (\d \l \o \r \W \space \o \l \l \e \H)

;; But you should use this more succinct, function-like syntax:
(my-first-macro)  ; -> (\d \l \o \r \W \space \o \l \l \e \H)

;; You can make things easier on yourself by using the more succinct quote syntax
;; to create lists in your macros:
(defmacro my-first-quoted-macro []
  '(reverse ""Hello World""))

(macroexpand '(my-first-quoted-macro))
;; -> (reverse ""Hello World"")
;; Notice that reverse is no longer function object, but a symbol.

;; Macros can take arguments.
(defmacro inc2 [arg]
  (list + 2 arg))

(inc2 2) ; -> 4

;; But, if you try to do this with a quoted list, you'll get an error, because
;; the argument will be quoted too. To get around this, clojure provides a
;; way of quoting macros: `. Inside `, you can use ~ to get at the outer scope
(defmacro inc2-quoted [arg]
  `(+ 2 ~arg))

(inc2-quoted 2)

;; You can use the usual destructuring args. Expand list variables using ~@
(defmacro unless [arg & body]
  `(if (not ~arg)
     (do ~@body))) ; Remember the do!

(macroexpand '(unless true (reverse ""Hello World"")))
;; ->
;; (if (clojure.core/not true) (do (reverse ""Hello World"")))

;; (unless) evaluates and returns its body if the first argument is false.
;; Otherwise, it returns nil

(unless true ""Hello"") ; -> nil
(unless false ""Hello"") ; -> ""Hello""

;; Used without care, macros can do great evil by clobbering your vars
(defmacro define-x []
  '(do
     (def x 2)
     (list x)))

(def x 4)
(define-x) ; -> (2)
(list x) ; -> (2)

;; To avoid this, use gensym to get a unique identifier
(gensym 'x) ; -> x1281 (or some such thing)

(defmacro define-x-safely []
  (let [sym (gensym 'x)]
    `(do
       (def ~sym 2)
       (list ~sym))))

(def x 4)
(define-x-safely) ; -> (2)
(list x) ; -> (4)

;; You can use # within ` to produce a gensym for each symbol automatically
(defmacro define-x-hygienically []
  `(do
     (def x# 2)
     (list x#)))

(def x 4)
(define-x-hygienically) ; -> (2)
(list x) ; -> (4)

;; It's typical to use helper functions with macros. Let's create a few to
;; help us support a (dumb) inline arithmetic syntax
(declare inline-2-helper)
(defn clean-arg [arg]
  (if (seq? arg)
    (inline-2-helper arg)
    arg))

(defn apply-arg
  ""Given args [x (+ y)], return (+ x y)""
  [val [op arg]]
  (list op val (clean-arg arg)))

(defn inline-2-helper
  [[arg1 & ops-and-args]]
  (let [ops (partition 2 ops-and-args)]
    (reduce apply-arg (clean-arg arg1) ops)))

;; We can test it immediately, without creating a macro
(inline-2-helper '(a + (b - 2) - (c * 5))) ; -> (- (+ a (- b 2)) (* c 5))

; However, we'll need to make it a macro if we want it to be run at compile time
(defmacro inline-2 [form]
  (inline-2-helper form))

(macroexpand '(inline-2 (1 + (3 / 2) - (1 / 2) + 1)))
; -> (+ (- (+ 1 (/ 3 2)) (/ 1 2)) 1)

(inline-2 (1 + (3 / 2) - (1 / 2) + 1))
; -> 3 (actually, 3N, since the number got cast to a rational fraction with /)
```

### Further Reading

[Writing Macros](http://www.braveclojure.com/writing-macros/)

[Official docs](http://clojure.org/macros)

[When to use macros?](https://lispcast.com/when-to-use-a-macro/)"
"PureScript is a small strongly, statically typed language compiling to JavaScript.

* Learn more at [https://www.purescript.org/](https://www.purescript.org/)
* Documentation: [https://pursuit.purescript.org/](https://pursuit.purescript.org/)
* Book: Purescript by Example, [https://book.purescript.org/](https://book.purescript.org/)

All the noncommented lines of code can be run in the PSCi REPL, though some
will require ""paste"" mode (`:paste` followed by multiple lines, terminated by
^D).

```haskell

--
-- 1. Primitive datatypes that corresponds to their JavaScript
-- equivalents at runtime.

import Prelude
-- Numbers
1.0 + 7.2*5.5 :: Number -- 40.6
-- Ints
1 + 2*5 :: Int -- 11
-- Types are inferred, so the following works fine
9.0/2.5 + 4.4 -- 8.0
-- But Ints and Numbers don't mix, so the following won't
5/2 + 2.5 -- Expression 2.5 does not have type Int
-- Hexadecimal literals
0xff + 1 -- 256
-- Unary negation
6 * -3 -- -18
6 * negate 3 -- -18
-- Modulus, from purescript-math (Math)
3.0 % 2.0 -- 1.0
4.0 % 2.0 -- 0.0
-- Inspect the type of an expression in psci
:t 9.5/2.5 + 4.4 -- Number

-- Booleans
true :: Boolean -- true
false :: Boolean -- false
-- Negation
not true -- false
23 == 23 -- true
1 /= 4 -- true
1 >= 4 -- false
-- Comparisons < <= > >=
-- are defined in terms of compare
compare 1 2 -- LT
compare 2 2 -- EQ
compare 3 2 -- GT
-- Conjunction and Disjunction
true && (9 >= 19 || 1 < 2) -- true

-- Strings
""Hello"" :: String -- ""Hello""
-- Multiline string without newlines, to run in PSCi use ""paste"" mode.
""Hello\
\orld"" -- ""Helloworld""
-- Multiline string with newlines
""""""Hello
world"""""" -- ""Hello\nworld""
-- Concatenate
""such "" <> ""amaze"" -- ""such amaze""

--
-- 2. Arrays are JavaScript arrays, but must be homogeneous

[1,1,2,3,5,8] :: Array Int -- [1,1,2,3,5,8]
[1.2,2.0,3.14] :: Array Number -- [1.2,2.0,3.14]
[true, true, false] :: Array Boolean -- [true,true,false]
-- [1,2, true, ""false""] won't work
-- `Cannot unify Int with Boolean`

-- Requires purescript-arrays (Data.Array)
-- Cons (prepend)
1 : [2,4,3] -- [1,2,4,3]

-- and purescript-maybe (Data.Maybe)
-- Safe access return Maybe a
head [1,2,3] -- (Just 1)
tail [3,2,1] -- (Just [2,1])
init [1,2,3] -- (Just [1,2])
last [3,2,1] -- (Just 1)
-- Array access - indexing
[3,4,5,6,7] !! 2 -- (Just 5)
-- Range
1..5 -- [1,2,3,4,5]
length [2,2,2] -- 3
drop 3 [5,4,3,2,1] -- [2,1]
take 3 [5,4,3,2,1] -- [5,4,3]
append [1,2,3] [4,5,6] -- [1,2,3,4,5,6]

--
-- 3. Records are JavaScript objects, with zero or more fields, which
-- can have different types.
book = {title: ""Foucault's pendulum"", author: ""Umberto Eco""}
-- Access properties
book.title -- ""Foucault's pendulum""

getTitle b = b.title
-- Works on all records with a title (but doesn't require any other field)
getTitle book -- ""Foucault's pendulum""
getTitle {title: ""Weekend in Monaco"", artist: ""The Rippingtons""} -- ""Weekend in Monaco""
-- Can use underscores as shorthand
_.title book -- ""Foucault's pendulum""
-- Update a record
changeTitle b t = b {title = t}
getTitle (changeTitle book ""Ill nome della rosa"") -- ""Ill nome della rosa""

--
-- 4. Functions
-- In PSCi's paste mode
sumOfSquares :: Int -> Int -> Int
sumOfSquares x y = x*x + y*y
sumOfSquares 3 4 -- 25

myMod x y = x % y
myMod 3.0 2.0 -- 1.0
-- Infix application of function
3 `mod` 2 -- 1

-- function application has higher precedence than all other
-- operators
sumOfSquares 3 4 * sumOfSquares 4 5 -- 1025

-- Conditional
abs' n = if n>=0 then n else -n
abs' (-3) -- 3

-- Guarded equations
-- In PSCi's paste mode
abs'' n | n >= 0    = n
        | otherwise = -n

-- Pattern matching

-- Note the type signature, input is a list of numbers. The pattern matching
-- destructures and binds the list into parts.
-- Requires purescript-lists (Data.List) and purescript-maybe (Data.Maybe)
first :: forall a. List a -> Maybe a
first (x : _) = Just x
first Nil = Nothing
first (fromFoldable [3,4,5]) -- (Just 3)

second :: forall a. List a -> Maybe a
second Nil = Nothing
second (_ : Nil) = Nothing
second (_ : (y : _)) = Just y
second (fromFoldable [3,4,5]) -- (Just 4)

-- Complementing patterns to match
-- Good ol' Fibonacci
fib 1 = 1
fib 2 = 2
fib x = fib (x-1) + fib (x-2)
fib 10 -- 89

-- Use underscore to match any, where you don't care about the binding name
isZero 0 = true
isZero _ = false
isZero 9 -- false

-- Pattern matching on records
ecoTitle {author: ""Umberto Eco"", title: t} = Just t
ecoTitle _ = Nothing

ecoTitle {title: ""Foucault's pendulum"", author: ""Umberto Eco""} -- (Just ""Foucault's pendulum"")
ecoTitle {title: ""The Quantum Thief"", author: ""Hannu Rajaniemi""} -- Nothing
-- ecoTitle requires both field to type check:
ecoTitle {title: ""The Quantum Thief""} -- Object lacks required property ""author""

-- Lambda expressions
(\x -> x*x) 3 -- 9
(\x y -> x*x + y*y) 4 5 -- 41
sqr = \x -> x*x

-- Currying
myAdd x y = x + y -- is equivalent with
myAdd' = \x -> \y -> x + y
add3 = myAdd 3
:t add3 -- Int -> Int

-- Forward and backward function composition
-- drop 3 followed by taking 5
(drop 3 >>> take 5) (1..20) -- [4,5,6,7,8]
-- take 5 followed by dropping 3
(drop 3 <<< take 5) (1..20) -- [4,5]

-- Operations using higher order functions
even x = x `mod` 2 == 0
filter even (1..10) -- [2,4,6,8,10]
map (\x -> x + 11) (1..5) -- [12,13,14,15,16]

-- Requires purescript-foldable-traversable (Data.Foldable)

foldr (+) 0 (1..10) -- 55
sum (1..10) -- 55
product (1..10) -- 3628800

-- Testing with predicate
any even [1,2,3] -- true
all even [1,2,3] -- false

```"
"jQuery is a JavaScript library that helps you ""do more, write less"". It makes many common JavaScript tasks and makes them easier to write. jQuery is used by many big companies and developers everywhere. It makes AJAX, event handling, document manipulation, and much more, easier and faster.

Because jQuery is a JavaScript library you should [learn JavaScript first](https://learnxinyminutes.com/docs/javascript/)

**NOTE**: jQuery has fallen out of the limelight in recent years, since you can achieve the same thing with the vanilla DOM (Document Object Model) API. So the only thing it is used for is a couple of handy features, such as the [jQuery date picker](https://api.jqueryui.com/datepicker) (which actually has a standard, unlike the `<input type=""date"">` HTML element), and the obvious decrease in the code length.

```js

///////////////////////////////////
// 1. Selectors

// Selectors in jQuery are used to select an element
var page = $(window); // Selects the whole viewport

// Selectors can also be CSS selector
var paragraph = $('p'); // Selects all paragraph elements
var table1 = $('#table1'); // Selects element with id 'table1'
var squares = $('.square'); // Selects all elements with the class 'square'
var square_p = $('p.square') // Selects paragraphs with the 'square' class


///////////////////////////////////
// 2. Events and Effects
// jQuery is very good at handling what happens when an event is triggered
// A very common event used is the ready event on the document
// You can use the 'ready' method to wait until the element has finished loading
$(document).ready(function(){
  // Code won't execute until the document is loaded
});
// You can also use defined functions
function onAction() {
  // This is executed when the event is triggered
}
$('#btn').click(onAction); // Invokes onAction on click

// Some other common events are:
$('#btn').dblclick(onAction); // Double click
$('#btn').hover(onAction); // Hovering over
$('#btn').focus(onAction); // On focus
$('#btn').blur(onAction); // Losses focus
$('#btn').submit(onAction); // On submit
$('#btn').select(onAction); // When an element is selected
$('#btn').keydown(onAction); // When a key is pushed down
$('#btn').keyup(onAction); // When a key is released
$('#btn').keypress(onAction); // When a key is pressed
$('#btn').mousemove(onAction); // When the mouse is moved
$('#btn').mouseenter(onAction); // Mouse enters the element
$('#btn').mouseleave(onAction); // Mouse leaves the element


// These can all also trigger the event instead of handling it
// by simply not giving any parameters
$('#btn').dblclick(); // Fires double click on the element

// You can handle multiple events while only using the selector once
$('#btn').on(
  {dblclick: myFunction1} // Triggered on double click
  {blur: myFunction1} // Triggered on blur
);

// You can move and hide elements with some effect methods
$('.table').hide(); // Hides the element(s)

// Note: calling a function in these methods will still hide the element
$('.table').hide(function(){
    // Element hidden then function executed
});

// You can store selectors in variables
var tables = $('.table');

// Some basic document manipulation methods are:
tables.hide(); // Hides element(s)
tables.show(); // Shows (un-hides) element(s)
tables.toggle(); // Changes the hide/show state
tables.fadeOut(); // Fades out
tables.fadeIn(); // Fades in
tables.fadeToggle(); // Fades in or out
tables.fadeTo(0.5); // Fades to an opacity (between 0 and 1)
tables.slideUp(); // Slides up
tables.slideDown(); // Slides down
tables.slideToggle(); // Slides up or down

// All of the above take a speed (milliseconds) and callback function
tables.hide(1000, myFunction); // 1 second hide animation then function

// fadeTo has a required opacity as its second parameter
tables.fadeTo(2000, 0.1, myFunction); // 2 sec. fade to 0.1 opacity then function

// You can get slightly more advanced with the animate method
tables.animate({margin-top:""+=50"", height: ""100px""}, 500, myFunction);
// The animate method takes an object of css and values to end with,
// optional options parameter to tune the animation,
// and of course the callback function

///////////////////////////////////
// 3. Manipulation

// These are similar to effects but can do more
$('div').addClass('taming-slim-20'); // Adds class taming-slim-20 to all div

// Common manipulation methods
$('p').append('Hello world'); // Adds to end of element
$('p').attr('class'); // Gets attribute
$('p').attr('class', 'content'); // Sets attribute
$('p').hasClass('taming-slim-20'); // Returns true if it has the class
$('p').height(); // Gets height of element or sets height


// For many manipulation methods, getting info on an element
// will ONLY get the first matching element
$('p').height(); // Gets only the first 'p' tag's height

// You can use each to loop through all the elements
var heights = [];
$('p').each(function() {
  heights.push($(this).height()); // Adds all 'p' tag heights to array
});


```

## Further Reading

* [Codecademy - jQuery](https://www.codecademy.com/learn/learn-jquery) A good introduction to jQuery in a ""learn by doing it"" format."
"JSON is an extremely simple data-interchange format. As [json.org](https://json.org) says, it is easy for humans to read and write and for machines to parse and generate.

A piece of JSON can be any value of the types listed later, but in practice almost always represents either:

* A collection of name/value pairs (`{ }`). In various languages, this is realized as an object, record, struct, dictionary, hash table, keyed list, or associative array.
* An ordered list of values (`[ ]`). In various languages, this is realized as an array, vector, list, or sequence.

JSON in its purest form has no actual comments, but most parsers will accept C-style (`//`, `/* */`) comments. Some parsers also tolerate a trailing comma (i.e. a comma after the last element of an array or the after the last property of an object), but they should be avoided for better compatibility.

For the purposes of this tutorial, everything is going to be 100% valid JSON. Luckily, it kind of speaks for itself.

Supported data types:

* Strings: `""hello""`, `""\""A quote.\""""`, `""\u0abe""`, `""Newline.\n""`
* Numbers: `23`, `0.11`, `12e10`, `3.141e-10`, `1.23e+4`
* Objects: `{ ""key"": ""value"" }`
* Arrays: `[""Values""]`
* Miscellaneous: `true`, `false`, `null`

```json
{
  ""key"": ""value"",

  ""keys"": ""must always be enclosed in double quotes"",
  ""numbers"": 0,
  ""strings"": ""Hellø, wørld. All unicode is allowed, along with \""escaping\""."",
  ""has bools?"": true,
  ""nothingness"": null,

  ""big number"": 1.2e+100,

  ""objects"": {
    ""comment"": ""Most of your structure will come from objects."",

    ""array"": [0, 1, 2, 3, ""Arrays can have anything in them."", 5],

    ""another object"": {
      ""comment"": ""These things can be nested, very useful.""
    }
  },

  ""silliness"": [
    {
      ""sources of potassium"": [""bananas""]
    },
    [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, ""neo""],
      [0, 0, 0, 1]
    ]
  ],

  ""alternative style"": {
    ""comment"": ""check this out!""
  , ""comma position"": ""doesn't matter, if it's before the next key, it's valid""
  , ""another comment"": ""how nice""
  },



  ""whitespace"": ""Does not matter."",



  ""that was short"": ""And done. You now know everything JSON has to offer.""
}
```

## Further Reading

* [JSON.org](https://json.org) All of JSON beautifully explained using flowchart-like graphics.
* [JSON Tutorial](https://www.youtube.com/watch?v=wI1CWzNtE-M) A concise introduction to JSON."
"## Introduction

```yaml
---
""{{ Ansible }}"" is an orchestration tool written in Python.
...
```

Ansible is (one of many) orchestration tools. It allows you to control your
environment (infrastructure and code) and automate the manual tasks.

Ansible has great integration with multiple operating systems (even Windows)
and some hardware (switches, Firewalls, etc). It has multiple tools that
integrate with the cloud providers. Almost every noteworthy cloud provider is
present in the ecosystem (AWS, Azure, Google, DigitalOcean, OVH, etc...).

But ansible is way more! It provides execution plans, an API, library, and callbacks.

### Main pros and cons

#### Pros

* It is an agent-less tool. In most scenarios, it uses ssh as a transport layer.
In some way you can use it as 'bash on steroids'.
* It is very easy to start. If you are familiar with the concept of ssh - you already
know Ansible (ALMOST).
* It executes 'as is' - other tools (salt, puppet, chef - might execute in
different scenario than you would expect)
* Documentation is at the world-class standard!
* Writing your own modules and extensions is fairly easy.
* Ansible AWX is the open source version of Ansible Tower we have been waiting
for, which provides an excellent UI.

#### Cons

* It is an agent-less tool - every agent consumes up to 16MB ram - in some
environments, it may be noticeable amount.
* It is agent-less - you have to verify your environment consistency
'on-demand' - there is no built-in mechanism that would warn you about some
change automatically (this can be achieved with reasonable effort)
* Official GUI - Ansible Tower - is great but expensive.
* There is no 'small enterprise' payment plan, however Ansible AWX is the free
open source version we were all waiting for.

#### Neutral

Migration - Ansible <-> Salt is fairly easy - so if you would need an
event-driven agent environment - it would be a good choice to start quick with
Ansible, and convert to Salt when needed.

#### Some concepts

Ansible uses ssh or paramiko as a transport layer. In a way you can imagine
that you are using a ssh with API to perform your action. The simplest way is
to execute remote command in more controlled way (still using ssh).
On the other hand - in advanced scope - you can wrap Ansible (use python Ansible
code as a library) with your own Python scripts! It would act a
bit like Fabric then.

## Example

An example playbook to install apache and configure log level

```yaml
---
- hosts: apache

  vars:
      apache2_log_level: ""warn""

  handlers:
  - name: restart apache
    service:
      name: apache2
      state: restarted
      enabled: True
    notify:
      - Wait for instances to listen on port 80
    become: True

  - name: reload apache
    service:
      name: apache2
      state: reloaded
    notify:
      - Wait for instances to listen on port 80
    become: True

  - name: Wait for instances to listen on port 80
    wait_for:
      state: started
      host: localhost
      port: 80
      timeout: 15
      delay: 5

  tasks:
  - name: Update cache
    apt:
      update_cache: yes
      cache_valid_time: 7200
    become: True

  - name: Install packages
    apt:
      name={{ item }}
    with_items:
      - apache2
      - logrotate
    notify:
      - restart apache
    become: True

  - name: Configure apache2 log level
    lineinfile:
      dest: /etc/apache2/apache2.conf
      line: ""LogLevel {{ apache2_log_level }}""
      regexp: ""^LogLevel""
    notify:
      - reload apache
    become: True
...
```

## Installation

```bash
# Universal way
$ pip install ansible

# Debian, Ubuntu
$ apt-get install ansible
```

* [Appendix A - How do I install ansible](#infrastructure-as-a-code)
* [Additional Reading.](http://docs.ansible.com/ansible/latest/intro_installation.html)

### Your first ansible command (shell execution)

```bash
# Command pings localhost (defined in default inventory: /etc/ansible/hosts)
$ ansible -m ping localhost
# You should see this output
localhost | SUCCESS => {
    ""changed"": false,
    ""ping"": ""pong""
}
```

### Shell Commands

There are few commands you should know about

* `ansible` (to run modules in CLI)
* `ansible-playbook` (to run playbooks)
* `ansible-vault` (to manage secrets)
* `ansible-galaxy` (to install roles from github/galaxy)

### Module

A program (usually python) that executes, does some work and returns proper
JSON output. This program performs specialized task/action (like manage
instances in the cloud, execute shell command). The simplest module is called
`ping` - it just returns a JSON with `pong` message.

Example of modules:

* Module: `ping` - the simplest module that is useful to verify host connectivity
* Module: `shell` - a module that executes a shell command on a specified host(s).


```bash
$ ansible -m ping all
$ ansible -m shell -a 'date; whoami' localhost #hostname_or_a_group_name
```

* Module: `command` - executes a single command that will not be processed
through the shell, so variables like `$HOME` or operands like ``|` `;`` will not
work. The command module is more secure, because it will not be affected by the
user’s environment. For more complex commands - use shell module.

```bash
$ ansible -m command -a 'date; whoami' # FAILURE
$ ansible -m command -a 'date' all
$ ansible -m command -a 'whoami' all
```

* Module: `file` - performs file operations (stat, link, dir, ...)
* Module: `raw` - executes a low-down and dirty SSH command, not going through
the module subsystem (useful to install python2.7)

### Task

Execution of a single Ansible **module** is called a **task**. The simplest
module is called `ping` as you could see above.

Another example of the module that allows you to execute a command remotely on
multiple resources is called `shell`. See above how you were using them already.

### Playbook

**Execution plan** written in a form of script file(s) is called **playbook**.
Playbooks consist of multiple elements -
* a list (or group) of hosts that 'the play' is executed against
* `task(s)` or `role(s)` that are going to be executed
* multiple optional settings (like default variables, and way more)

Playbook script language is YAML. You can think that playbook is very advanced
CLI script that you are executing.

#### Example of the playbook

This example-playbook would execute (on all hosts defined in inventory) two tasks:
* `ping` that would return message *pong*
* `shell` that execute three commands and return the output to our terminal

```yaml
- hosts: all

  tasks:
    - name: ""ping all""
      ping:

    - name: ""execute a shell command""
      shell: ""date; whoami; df -h;""
```

Run the playbook with the command:

```bash
$ ansible-playbook path/name_of_the_playbook.yml
```

Note: Example playbook is explained in the next chapter: 'Roles'

### More on ansible concept

### Inventory

An inventory is a set of objects or hosts, against which we are executing our
playbooks or single tasks via shell commands. For these few minutes, let's
assume that we are using the default ansible inventory (which in Debian based
system is placed in `/etc/ansible/hosts`).

```
localhost

[some_group]
hostA.mydomain.com
hostB.localdomain
1.2.3.4

[a_group_of_a_groups:children]
some_group
some_other_group
```

* [Additional Reading.](http://docs.ansible.com/ansible/latest/intro_inventory.html)

### ansible-roles (a 'template-playbooks' with right structure)

You already know that the tasks (modules) can be run via CLI. You also know the
playbooks - the execution plans of multiple tasks (with variables and logic).

A concept called `role` was introduced for parts of the code (playbooks) that
should be reusable.

**Role** is a structured way to manage your set of tasks, variables, handlers,
default settings, and way more (meta, files, templates). Roles allow reusing
the same parts of code in multiple playbooks (you can parametrize the role
'further' during its execution). Its a great way to introduce `object oriented`
management for your applications.

Role can be included in your playbook (executed via your playbook).


```yaml
- hosts: all

  tasks:
      - name: ""ping all""
        ping:
      - name: ""execute a shell command""
        shell: ""date; whoami; df -h;""

  roles:
      - some_role
      - { role: another_role, some_variable: 'learnxiny', tags: ['my_tag'] }

  pre_tasks:
      - name: some pre-task
        shell: echo 'this task is the last, but would be executed before roles, and before tasks'
```

#### For remaining examples we would use additional repository
This example installs ansible in `virtualenv` so it is independent from the system.
You need to initialize it into your shell-context with the `source environment.sh`
command.

We are going to use this repository with examples: [https://github.com/sirkubax/ansible-for-learnXinYminutes](https://github.com/sirkubax/ansible-for-learnXinYminutes)

```bash
$ # The following example contains a shell-prompt to indicate the venv and relative path
$ git clone git@github.com:sirkubax/ansible-for-learnXinYminutes.git
user@host:~/$ cd ansible-for-learnXinYminutes
user@host:~/ansible-for-learnXinYminutes$ source environment.sh
$
$ # First lets execute the simple_playbook.yml
(venv) user@host:~/ansible-for-learnXinYminutes$ ansible-playbook playbooks/simple_playbook.yml
```

Run the playbook with roles example

```bash
$ source environment.sh
$ # Now we would run the above playbook with roles
(venv) user@host:~/ansible-for-learnXinYminutes$ ansible-playbook playbooks/simple_role.yml
```

#### Role directory structure

```
roles/
   some_role/
     defaults/      # contains default variables
     files/         # for static files
     templates/     # for jinja templates
     tasks/         # tasks
     handlers/      # handlers
     vars/          # more variables (higher priority)
     meta/          # meta - package (role) info
```

#### Role Handlers
Handlers are tasks that can be triggered (notified) during execution of a
playbook, but they execute at the very end of a playbook. It is the best way to
restart a service, check if the application port is active (successful
deployment criteria), etc.

Get familiar with how you can use roles in the simple_apache_role example

```
playbooks/roles/simple_apache_role/
├── tasks
│   └── main.yml
└── templates
    └── main.yml
```

### ansible - variables

Ansible is flexible - it has 21 levels of variable precedence.
[read more](http://docs.ansible.com/ansible/latest/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable)
For now you should know that CLI variables have the top priority.
You should also know, that a nice way to pool some data is a **lookup**

### Lookups
Awesome tool to query data from various sources!!! Awesome!
query from:
* pipe  (load shell command output into variable!)
* file
* stream
* etcd
* password management tools
* url

```bash
# read playbooks/lookup.yml
# then run
(venv) user@host:~/ansible-for-learnXinYminutes$ ansible-playbook playbooks/lookup.yml
```

You can use them in CLI too

```yaml
ansible -m shell -a 'echo ""{{ my_variable }}""' -e 'my_variable=""{{ lookup(""pipe"", ""date"") }}""' localhost
ansible -m shell -a 'echo ""{{ my_variable }}""' -e 'my_variable=""{{ lookup(""pipe"", ""hostname"") }}""' all

# Or use in playbook

(venv) user@host:~/ansible-for-learnXinYminutes$ ansible-playbook playbooks/lookup.yml
```

### Register and Conditional

#### Register

Another way to dynamically generate the variable content is the `register` command.
`Register` is also useful to store an output of a task and use its value
for executing further tasks.

```
(venv) user@host:~/ansible-for-learnXinYminutes$ ansible-playbook playbooks/register_and_when.yml
```

```yaml
---
- hosts: localhost
  tasks:
   - name: check the system capacity
     shell: df -h /
     register: root_size

   - name: debug root_size
     debug:
        msg: ""{{ root_size }}""

   - name: debug root_size return code
     debug:
       msg:  ""{{ root_size.rc }}""

# when: example

   - name: Print this message when return code of 'check the system capacity' was ok
     debug:
       msg:  ""{{ root_size.rc }}""
     when: root_size.rc == 0
...
```

#### Conditionals - when:

You can define complex logic with Ansible and Jinja functions. Most common is
usage of `when:`, with some variable (often dynamically generated in previous
playbook steps with `register` or `lookup`)

```yaml
---
- hosts: localhost
  tasks:
   - name: check the system capacity
     shell: df -h /
     when: some_variable in 'a string'
  roles:
   - { role: mid_nagios_probe, when: allow_nagios_probes }
...
```

### ansible - tags, limit

You should know about a way to increase efficiency by this simple functionality

#### TAGS

You can tag a task, role (and its tasks), include, etc, and then run only the
tagged resources

```
ansible-playbook playbooks/simple_playbook.yml --tags=tagA,tag_other
ansible-playbook playbooks/simple_playbook.yml -t tagA,tag_other

There are special tags:
    always

--skip-tags can be used to exclude a block of code
--list-tags to list available tags
```

[Read more](http://docs.ansible.com/ansible/latest/playbooks_tags.html)

#### LIMIT

You can limit an execution of your tasks to defined hosts

```
ansible-playbook playbooks/simple_playbook.yml --limit localhost

--limit my_hostname
--limit groupname
--limit some_prefix*
--limit hostname:group #JM
```

### Templates

Templates are a powerful way to deliver some (partially) dynamic content.
Ansible uses **Jinja2** language to describe the template.

```
Some static content

{{ a_variable }}

{% for item in loop_items %}
    this line item is {{ item }}
{% endfor %}
```

Jinja may have some limitations, but it is a powerful tool that you might like.

Please examine this simple example that installs apache2 and generates
index.html from the template
""playbooks/roles/simple_apache_role/templates/index.html""

```bash
$ source environment.sh
$ # Now we would run the above playbook with roles
(venv) user@host:~/ansible-for-learnXinYminutes$ ansible-playbook playbooks/simple_role.yml --tags apache2
```

#### Jinja2 CLI

You can use the jinja in the CLI too

```bash
ansible -m shell -a 'echo {{ my_variable }}' -e 'my_variable=something, playbook_parameter=twentytwo' localhost
```

In fact - jinja is used to template parts of the playbooks too

```yaml
# check part of this playbook: playbooks/roles/sys_debug/tasks/debug_time.yml
- local_action: shell date +'%F %T'
  register: ts
  become: False
  changed_when: False

- name: Timestamp
  debug: msg=""{{ ts.stdout }}""
  when: ts is defined and ts.stdout is defined
  become: False
```

#### Jinja2 filters

Jinja is powerful. It has many built-in useful functions.

```
# get first item of the list
{{ some_list | first() }}
# if variable is undefined - use default value
{{ some_variable | default('default_value') }}
```

[Read More](http://docs.ansible.com/ansible/latest/playbooks_filters.html)

### ansible-vault

To maintain **infrastructure as code** you need to store secrets. Ansible
provides a way to encrypt confidential files so you can store them in the
repository, yet the files are decrypted on-the-fly during ansible execution.

The best way to use it is to store the secret in some secure location, and
configure ansible to use them during runtime.

```bash
# Try (this would fail)
$ ansible-playbook playbooks/vault_example.yml

$ echo some_very_very_long_secret > ~/.ssh/secure_located_file

# in ansible.cfg set the path to your secret file
$ vi ansible.cfg
  ansible_vault_password_file = ~/.ssh/secure_located_file

#or use env
$ export ANSIBLE_VAULT_PASSWORD_FILE=~/.ssh/secure_located_file

$ ansible-playbook playbooks/vault_example.yml

  # encrypt the file
$ ansible-vault encrypt path/somefile

  # view the file
$ ansible-vault view path/somefile

  # check the file content:
$ cat path/somefile

  # decrypt the file
$ ansible-vault decrypt path/somefile
```

### dynamic inventory

You might like to know, that you can build your inventory dynamically.
(For Ansible) inventory is just JSON with proper structure - if you can
deliver that to ansible - anything is possible.

You do not need to reinvent the wheel - there are plenty of ready to use
inventory scripts for the most popular Cloud providers and a lot of in-house
popular usecases.

[AWS example](http://docs.ansible.com/ansible/latest/intro_dynamic_inventory.html#example-aws-ec2-external-inventory-script)

```bash
$ etc/inv/ec2.py --refresh
$ ansible -m ping all -i etc/inv/ec2.py
```

[Read more](http://docs.ansible.com/ansible/latest/intro_dynamic_inventory.html)

### ansible profiling - callback

Playbook execution takes some time. It is OK. First make it run, then you may
like to speed things up. Since ansible 2.x there is built-in callback for task
execution profiling.

```
vi ansible.cfg
# set this to:
callback_whitelist = profile_tasks
```

### facts-cache and ansible-cmdb

You can pull some information about your environment from another host.
If the information does not change - you may consider using a facts_cache
to speed things up.

```
vi ansible.cfg

# if set to a persistent type (not 'memory', for example 'redis') fact values
# from previous runs in Ansible will be stored.  This may be useful when
# wanting to use, for example, IP information from one group of servers
# without having to talk to them in the same playbook run to get their
# current IP information.
fact_caching = jsonfile
fact_caching_connection = ~/facts_cache
fact_caching_timeout = 86400
```

I like to use `jsonfile` as my backend. It allows to use another project
`ansible-cmdb` [(project on github)](https://github.com/fboender/ansible-cmdb) that generates a HTML page of your inventory
resources. A nice 'free' addition!

### Debugging ansible [chapter in progress]

When your job fails - it is good to be effective with debugging.

1. Increase verbosity by using multiple -v **[ -vvvvv]**
2. If variable is undefined -
`grep -R path_of_your_inventory -e missing_variable`
3. If variable (dictionary or a list) is undefined -
`grep -R path_of_your_inventory -e missing_variable`
4. Jinja template debug
5. Strange behaviour - try to run the code 'at the destination'

### Infrastructure as code

You already know, that ansible-vault allows you to store your confidential data
along with your code. You can go further - and define your
ansible installation and configuration as code.
See `environment.sh` to learn how to install the ansible itself inside a
`virtualenv` that is not attached to your operating system (can be changed by
non-privileged user), and as additional benefit - upgrading version of ansible
is as easy as installing new version in new virtualenv. What is more, you can
have multiple versions of Ansible present at the same time.

```bash
# recreate ansible 2.x venv
$ rm -rf venv2
$ source environment2.sh

# execute playbook
(venv2)$ ansible-playbook playbooks/ansible1.9_playbook.yml # would fail - deprecated syntax

# now lets install ansible 1.9.x next to ansible 2.x
(venv2)$ deactivate
$ source environment.1.9.sh

# execute playbook
(venv1.9)$ ansible-playbook playbooks/ansible1.9_playbook.yml # works!

# please note that you have both venv1.9 and venv2 present - you need to (de)activate one - that is all
```

#### become-user, become

In Ansible - to become `sudo` - use the `become` parameter. Use `become_user`
to specify the username.

```
- name: Ensure the httpd service is running
  service:
    name: httpd
    state: started
  become: true
```

Note: You may like to execute Ansible with `--ask-sudo-pass` or add the user to
sudoers file in order to allow non-supervised execution if you require 'admin'
privileges.

[Read more](http://docs.ansible.com/ansible/latest/become.html)

## Tips and tricks

#### --check -C

Always make sure that your playbook can execute in 'dry run' mode (--check),
and its execution is not declaring 'Changed' objects.

#### --diff -D

Diff is useful to see nice detail of the files changed.
It compare 'in memory' the files like `diff -BbruN fileA fileB`.


#### Execute hosts with 'regex'

```bash
ansible -m ping web*
```

#### Host groups can be joined, negated, etc

```bash
ansible -m ping web*:!backend:monitoring:&allow_change
```

#### Tagging

You should tag some (not all) objects - a task in a playbook, all tasks
included form a role, etc. It allows you to execute the chosen parts of the
playbook.

#### no_logs: True

You may see, that some roles print a lot of output in verbose mode. There is
also a debug module. This is the place where credentials may leak. Use `no_log`
to hide the output.

#### Debug module

allows to print a value to the screen - use it!

#### Register the output of a task

You can register the output (stdout), rc (return code), stderr of a task with
the `register` command.

#### Conditionals: when:

#### Loop: with, with\_items, with\_dict, with\_together

[Read more](http://docs.ansible.com/ansible/latest/playbooks_conditionals.html)

## Additional Resources

* [Servers For Hackers: An Ansible Tutorial](https://serversforhackers.com/c/an-ansible-tutorial)
* [A system administrator's guide to getting started with Ansible - FAST!](https://www.redhat.com/en/blog/system-administrators-guide-getting-started-ansible-fast)
* [Ansible Tower](https://www.ansible.com/products/tower) - Ansible Tower provides a web UI, dashboard and rest interface to ansible.
* [Ansible AWX](https://github.com/ansible/awx) - The Open Source version of Ansible Tower.
* [Ansible Tutorial for Beginners: Ultimate Playbook & Examples](https://spacelift.io/blog/ansible-tutorial)"
"Groovy - A dynamic language for the Java platform [Read more here.](http://www.groovy-lang.org/)

```groovy

/*
  Set yourself up:

  1) Install SDKMAN - http://sdkman.io/
  2) Install Groovy: sdk install groovy
  3) Start the groovy console by typing: groovyConsole

*/

//  Single line comments start with two forward slashes
/*
Multi line comments look like this.
*/

// Hello World
println ""Hello world!""

/*
  Variables:

  You can assign values to variables for later use
*/

def x = 1
println x

x = new java.util.Date()
println x

x = -3.1499392
println x

x = false
println x

x = ""Groovy!""
println x

/*
  Collections and maps
*/

//Creating an empty list
def technologies = []

// or create a list with data
technologies = [""Kotlin"", ""Swift""]

/*** Adding a elements to the list ***/

// As with Java
technologies.add(""Grails"")

// Left shift adds, and returns the list
technologies << ""Groovy""

// Add multiple elements
technologies.addAll([""Gradle"",""Griffon""])

/*** Removing elements from the list ***/

// As with Java
technologies.remove(""Griffon"")

// Subtraction works also
technologies = technologies - 'Grails'

/*** Iterating Lists ***/

// Iterate over elements of a list
technologies.each { println ""Technology: $it""}
technologies.eachWithIndex { it, i -> println ""$i: $it""}

/*** Checking List contents ***/

//Evaluate if a list contains element(s) (boolean)
contained = technologies.contains( 'Groovy' )

// Or
contained = 'Groovy' in technologies

// Check for multiple contents
technologies.containsAll(['Groovy','Grails'])

/*** Sorting Lists ***/

// Sort a list (mutates original list)
technologies.sort()

// To sort without mutating original, you can do:
sortedTechnologies = technologies.sort( false )

/*** Manipulating Lists ***/

//Replace all elements in the list
Collections.replaceAll(technologies, 'Gradle', 'gradle')

//Shuffle a list
Collections.shuffle(technologies, new Random())

//Clear a list
technologies.clear()

//Creating an empty map
def devMap = [:]

//Add values
devMap = ['name':'Roberto', 'framework':'Grails', 'language':'Groovy']
devMap.put('lastName','Perez')

//Iterate over elements of a map
devMap.each { println ""$it.key: $it.value"" }
devMap.eachWithIndex { it, i -> println ""$i: $it""}

//Evaluate if a map contains a key
assert devMap.containsKey('name')

//Evaluate if a map contains a value
assert devMap.containsValue('Roberto')

//Get the keys of a map
println devMap.keySet()

//Get the values of a map
println devMap.values()

/*
  Groovy Beans

  GroovyBeans are JavaBeans but using a much simpler syntax

  When Groovy is compiled to bytecode, the following rules are used.

    * If the name is declared with an access modifier (public, private or
      protected) then a field is generated.

    * A name declared with no access modifier generates a private field with
      public getter and setter (i.e. a property).

    * If a property is declared final the private field is created final and no
      setter is generated.

    * You can declare a property and also declare your own getter or setter.

    * You can declare a property and a field of the same name, the property will
      use that field then.

    * If you want a private or protected property you have to provide your own
      getter and setter which must be declared private or protected.

    * If you access a property from within the class the property is defined in
      at compile time with implicit or explicit this (for example this.foo, or
      simply foo), Groovy will access the field directly instead of going though
      the getter and setter.

    * If you access a property that does not exist using the explicit or
      implicit foo, then Groovy will access the property through the meta class,
      which may fail at runtime.

*/

class Foo {
    // read only property
    final String name = ""Roberto""

    // read only property with public getter and protected setter
    String language
    protected void setLanguage(String language) { this.language = language }

    // dynamically typed property
    def lastName
}

/*
  Methods with optional parameters
*/

// A method can have default values for parameters
def say(msg = 'Hello', name = 'world') {
    ""$msg $name!""
}

// It can be called in 3 different ways
assert 'Hello world!' == say()
// Right most parameter with default value is eliminated first.
assert 'Hi world!' == say('Hi')
assert 'learn groovy!' == say('learn', 'groovy')

/*
  Logical Branching and Looping
*/

//Groovy supports the usual if - else syntax
def x = 3

if(x==1) {
    println ""One""
} else if(x==2) {
    println ""Two""
} else {
    println ""X greater than Two""
}

//Groovy also supports the ternary operator:
def y = 10
def x = (y > 1) ? ""worked"" : ""failed""
assert x == ""worked""

//Groovy supports 'The Elvis Operator' too!
//Instead of using the ternary operator:

displayName = user.name ? user.name : 'Anonymous'

//We can write it:
displayName = user.name ?: 'Anonymous'

//For loop
//Iterate over a range
def x = 0
for (i in 0 .. 30) {
    x += i
}

//Iterate over a list
x = 0
for( i in [5,3,2,1] ) {
    x += i
}

//Iterate over an array
array = (0..20).toArray()
x = 0
for (i in array) {
    x += i
}

//Iterate over a map
def map = ['name':'Roberto', 'framework':'Grails', 'language':'Groovy']
x = """"
for ( e in map ) {
    x += e.value
    x += "" ""
}
assert x.equals(""Roberto Grails Groovy "")

/*
  Operators

  Operator Overloading for a list of the common operators that Groovy supports:
  http://www.groovy-lang.org/operators.html#Operator-Overloading

  Helpful groovy operators
*/
//Spread operator:  invoke an action on all items of an aggregate object.
def technologies = ['Groovy','Grails','Gradle']
technologies*.toUpperCase() // = to technologies.collect { it?.toUpperCase() }

//Safe navigation operator: used to avoid a NullPointerException.
def user = User.get(1)
def username = user?.username


/*
  Closures
  A Groovy Closure is like a ""code block"" or a method pointer. It is a piece of
  code that is defined and then executed at a later point.

  More info at: http://www.groovy-lang.org/closures.html
*/
//Example:
def clos = { println ""Hello World!"" }

println ""Executing the Closure:""
clos()

//Passing parameters to a closure
def sum = { a, b -> println a+b }
sum(2,4)

//Closures may refer to variables not listed in their parameter list.
def x = 5
def multiplyBy = { num -> num * x }
println multiplyBy(10)

// If you have a Closure that takes a single argument, you may omit the
// parameter definition of the Closure
def clos = { print it }
clos( ""hi"" )

/*
  Groovy can memoize closure results [1][2][3]
*/
def cl = {a, b ->
    sleep(3000) // simulate some time consuming processing
    a + b
}

mem = cl.memoize()

def callClosure(a, b) {
    def start = System.currentTimeMillis()
    mem(a, b)
    println ""Inputs(a = $a, b = $b) - took ${System.currentTimeMillis() - start} msecs.""
}

callClosure(1, 2)
callClosure(1, 2)
callClosure(2, 3)
callClosure(2, 3)
callClosure(3, 4)
callClosure(3, 4)
callClosure(1, 2)
callClosure(2, 3)
callClosure(3, 4)

/*
  Expando

  The Expando class is a dynamic bean so we can add properties and we can add
  closures as methods to an instance of this class

  http://mrhaki.blogspot.mx/2009/10/groovy-goodness-expando-as-dynamic-bean.html
*/
  def user = new Expando(name:""Roberto"")
  assert 'Roberto' == user.name

  user.lastName = 'Pérez'
  assert 'Pérez' == user.lastName

  user.showInfo = { out ->
      out << ""Name: $name""
      out << "", Last name: $lastName""
  }

  def sw = new StringWriter()
  println user.showInfo(sw)


/*
  Metaprogramming (MOP)
*/

//Using ExpandoMetaClass to add behaviour
String.metaClass.testAdd = {
    println ""we added this""
}

String x = ""test""
x?.testAdd()

//Intercepting method calls
class Test implements GroovyInterceptable {
    def sum(Integer x, Integer y) { x + y }

    def invokeMethod(String name, args) {
        System.out.println ""Invoke method $name with args: $args""
    }
}

def test = new Test()
test?.sum(2,3)
test?.multiply(2,3)

//Groovy supports propertyMissing for dealing with property resolution attempts.
class Foo {
   def propertyMissing(String name) { name }
}
def f = new Foo()

assertEquals ""boo"", f.boo

/*
  TypeChecked and CompileStatic
  Groovy, by nature, is and will always be a dynamic language but it supports
  typechecked and compilestatic

  More info: http://www.infoq.com/articles/new-groovy-20
*/
//TypeChecked
import groovy.transform.TypeChecked

void testMethod() {}

@TypeChecked
void test() {
    testMeethod()

    def name = ""Roberto""

    println naameee

}

//Another example:
import groovy.transform.TypeChecked

@TypeChecked
Integer test() {
    Integer num = ""1""

    Integer[] numbers = [1,2,3,4]

    Date date = numbers[1]

    return ""Test""

}

//CompileStatic example:
import groovy.transform.CompileStatic

@CompileStatic
int sum(int x, int y) {
    x + y
}

assert sum(2,5) == 7


```

## Further resources

[Groovy documentation](http://www.groovy-lang.org/documentation.html)

[Groovy web console](http://groovyconsole.appspot.com/)

Join a [Groovy user group](http://www.groovy-lang.org/usergroups.html)

## Books

* [Groovy Goodness] (https://leanpub.com/groovy-goodness-notebook)

* [Groovy in Action] (http://manning.com/koenig2/)

* [Programming Groovy 2: Dynamic Productivity for the Java Developer] (http://shop.oreilly.com/product/9781937785307.do)

[1] http://roshandawrani.wordpress.com/2010/10/18/groovy-new-feature-closures-can-now-memorize-their-results/
[2] http://www.solutionsiq.com/resources/agileiq-blog/bid/72880/Programming-with-Groovy-Trampoline-and-Memoize
[3] http://mrhaki.blogspot.mx/2011/05/groovy-goodness-cache-closure-results.html"
"Rust is a programming language developed by Mozilla Research.
Rust combines low-level control over performance with high-level convenience and
safety guarantees.

It achieves these goals without requiring a garbage collector or runtime, making
it possible to use Rust libraries as a ""drop-in replacement"" for C.

Rust’s first release, 0.1, occurred in January 2012, and for 3 years development
moved so quickly that until recently the use of stable releases was discouraged
and instead the general advice was to use nightly builds.

On May 15th 2015, Rust 1.0 was released with a complete guarantee of backward
compatibility. Improvements to compile times and other aspects of the compiler are
currently available in the nightly builds. Rust has adopted a train-based release
model with regular releases every six weeks. Rust 1.1 beta was made available at
the same time of the release of Rust 1.0.

Although Rust is a relatively low-level language, it has some functional
concepts that are generally found in higher-level languages. This makes
Rust not only fast, but also easy and efficient to code in.

```rust
// This is a comment. Line comments look like this...
// and extend multiple lines like this.

/* Block comments
  /* can be nested. */ */

/// Documentation comments look like this and support markdown notation.
/// # Examples
///
/// ```
/// let five = 5
/// ```

///////////////
// 1. Basics //
///////////////

#[allow(dead_code)]
// Functions
// `i32` is the type for 32-bit signed integers
fn add2(x: i32, y: i32) -> i32 {
    // Implicit return (no semicolon)
    x + y
}

#[allow(unused_variables)]
#[allow(unused_assignments)]
#[allow(dead_code)]
// Main function
fn main() {
    // Numbers //

    // Immutable bindings
    let x: i32 = 1;

    // Integer/float suffixes
    let y: i32 = 13i32;
    let f: f64 = 1.3f64;

    // Type inference
    // Most of the time, the Rust compiler can infer what type a variable is, so
    // you don’t have to write an explicit type annotation.
    // Throughout this tutorial, types are explicitly annotated in many places,
    // but only for demonstrative purposes. Type inference can handle this for
    // you most of the time.
    let implicit_x = 1;
    let implicit_f = 1.3;

    // Arithmetic
    let sum = x + y + 13;

    // Mutable variable
    let mut mutable = 1;
    mutable = 4;
    mutable += 2;

    // Strings //

    // String literals
    let x: &str = ""hello world!"";

    // Printing
    println!(""{} {}"", f, x); // 1.3 hello world

    // A `String` – a heap-allocated string
    // Stored as a `Vec<u8>` and always hold a valid UTF-8 sequence, 
    // which is not null terminated.
    let s: String = ""hello world"".to_string();

    // A string slice – an immutable view into another string
    // This is basically an immutable pair of pointers to a string – it doesn’t
    // actually contain the contents of a string, just a pointer to
    // the begin and a pointer to the end of a string buffer,
    // statically allocated or contained in another object (in this case, `s`).
    // The string slice is like a view `&[u8]` into `Vec<T>`.
    let s_slice: &str = &s;

    println!(""{} {}"", s, s_slice); // hello world hello world

    // Vectors/arrays //

    // A fixed-size array
    let four_ints: [i32; 4] = [1, 2, 3, 4];

    // A dynamic array (vector)
    let mut vector: Vec<i32> = vec![1, 2, 3, 4];
    vector.push(5);

    // A slice – an immutable view into a vector or array
    // This is much like a string slice, but for vectors
    let slice: &[i32] = &vector;

    // Use `{:?}` to print something debug-style
    println!(""{:?} {:?}"", vector, slice); // [1, 2, 3, 4, 5] [1, 2, 3, 4, 5]

    // Tuples //

    // A tuple is a fixed-size set of values of possibly different types
    let x: (i32, &str, f64) = (1, ""hello"", 3.4);

    // Destructuring `let`
    let (a, b, c) = x;
    println!(""{} {} {}"", a, b, c); // 1 hello 3.4

    // Indexing
    println!(""{}"", x.1); // hello

    //////////////
    // 2. Types //
    //////////////

    // Struct
    struct Point {
        x: i32,
        y: i32,
    }

    let origin: Point = Point { x: 0, y: 0 };

    // A struct with unnamed fields, called a ‘tuple struct’
    struct Point2(i32, i32);

    let origin2 = Point2(0, 0);

    // Basic C-like enum
    enum Direction {
        Left,
        Right,
        Up,
        Down,
    }

    let up = Direction::Up;

    // Enum with fields
    enum OptionalI32 {
        AnI32(i32),
        Nothing,
    }

    let two: OptionalI32 = OptionalI32::AnI32(2);
    let nothing = OptionalI32::Nothing;

    // Generics //

    struct Foo<T> { bar: T }

    // This is defined in the standard library as `Option`
    enum Optional<T> {
        SomeVal(T),
        NoVal,
    }

    // Methods //

    impl<T> Foo<T> {
        // Methods take an explicit `self` parameter
        fn bar(&self) -> &T { // self is borrowed
            &self.bar
        }
        fn bar_mut(&mut self) -> &mut T { // self is mutably borrowed
            &mut self.bar
        }
        fn into_bar(self) -> T { // here self is consumed
            self.bar
        }
    }

    let a_foo = Foo { bar: 1 };
    println!(""{}"", a_foo.bar()); // 1

    // Traits (known as interfaces or typeclasses in other languages) //

    trait Frobnicate<T> {
        fn frobnicate(self) -> Option<T>;
    }

    impl<T> Frobnicate<T> for Foo<T> {
        fn frobnicate(self) -> Option<T> {
            Some(self.bar)
        }
    }

    let another_foo = Foo { bar: 1 };
    println!(""{:?}"", another_foo.frobnicate()); // Some(1)

    // Function pointer types // 

    fn fibonacci(n: u32) -> u32 {
        match n {
            0 => 1,
            1 => 1,
            _ => fibonacci(n - 1) + fibonacci(n - 2),
        }
    }

    type FunctionPointer = fn(u32) -> u32;

    let fib : FunctionPointer = fibonacci;
    println!(""Fib: {}"", fib(4)); // 5

    /////////////////////////
    // 3. Pattern matching //
    /////////////////////////

    let foo = OptionalI32::AnI32(1);
    match foo {
        OptionalI32::AnI32(n) => println!(""it’s an i32: {}"", n),
        OptionalI32::Nothing  => println!(""it’s nothing!""),
    }

    // Advanced pattern matching
    struct FooBar { x: i32, y: OptionalI32 }
    let bar = FooBar { x: 15, y: OptionalI32::AnI32(32) };

    match bar {
        FooBar { x: 0, y: OptionalI32::AnI32(0) } =>
            println!(""The numbers are zero!""),
        FooBar { x: n, y: OptionalI32::AnI32(m) } if n == m =>
            println!(""The numbers are the same""),
        FooBar { x: n, y: OptionalI32::AnI32(m) } =>
            println!(""Different numbers: {} {}"", n, m),
        FooBar { x: _, y: OptionalI32::Nothing } =>
            println!(""The second number is Nothing!""),
    }

    /////////////////////
    // 4. Control flow //
    /////////////////////

    // `for` loops/iteration
    let array = [1, 2, 3];
    for i in array {
        println!(""{}"", i);
    }

    // Ranges
    for i in 0u32..10 {
        print!(""{} "", i);
    }
    println!("""");
    // prints `0 1 2 3 4 5 6 7 8 9 `

    // `if`
    if 1 == 1 {
        println!(""Maths is working!"");
    } else {
        println!(""Oh no..."");
    }

    // `if` as expression
    let value = if true {
        ""good""
    } else {
        ""bad""
    };

    // `while` loop
    while 1 == 1 {
        println!(""The universe is operating normally."");
        // break statement gets out of the while loop.
        //  It avoids useless iterations.
        break
    }

    // Infinite loop
    loop {
        println!(""Hello!"");
        // break statement gets out of the loop
        break
    }

    /////////////////////////////////
    // 5. Memory safety & pointers //
    /////////////////////////////////

    // Owned pointer – only one thing can ‘own’ this pointer at a time
    // This means that when the `Box` leaves its scope, it can be automatically deallocated safely.
    let mut mine: Box<i32> = Box::new(3);
    *mine = 5; // dereference
    // Here, `now_its_mine` takes ownership of `mine`. In other words, `mine` is moved.
    let mut now_its_mine = mine;
    *now_its_mine += 2;

    println!(""{}"", now_its_mine); // 7
    // println!(""{}"", mine); // this would not compile because `now_its_mine` now owns the pointer

    // Reference – an immutable pointer that refers to other data
    // When a reference is taken to a value, we say that the value has been ‘borrowed’.
    // While a value is borrowed immutably, it cannot be mutated or moved.
    // A borrow is active until the last use of the borrowing variable.
    let mut var = 4;
    var = 3;
    let ref_var: &i32 = &var;

    println!(""{}"", var); // Unlike `mine`, `var` can still be used
    println!(""{}"", *ref_var);
    // var = 5; // this would not compile because `var` is borrowed
    // *ref_var = 6; // this would not either, because `ref_var` is an immutable reference
    ref_var; // no-op, but counts as a use and keeps the borrow active
    var = 2; // ref_var is no longer used after the line above, so the borrow has ended

    // Mutable reference
    // While a value is mutably borrowed, it cannot be accessed at all.
    let mut var2 = 4;
    let ref_var2: &mut i32 = &mut var2;
    *ref_var2 += 2;         // '*' is used to point to the mutably borrowed var2

    println!(""{}"", *ref_var2); // 6 , // var2 would not compile.
    // ref_var2 is of type &mut i32, so stores a reference to an i32, not the value.
    // var2 = 2; // this would not compile because `var2` is borrowed.
    ref_var2; // no-op, but counts as a use and keeps the borrow active until here
}
```

## Further reading

There’s a lot more to Rust—this is just the basics of Rust so you can understand
the most important things. To learn more about Rust, read [The Rust Programming
Language](http://doc.rust-lang.org/book/index.html) and check out the
[/r/rust](http://reddit.com/r/rust) subreddit. The folks on the #rust channel on
irc.mozilla.org are also always keen to help newcomers.

You can also try out features of Rust with an online compiler at the official
[Rust playpen](http://play.rust-lang.org) or on the main
[Rust website](http://rust-lang.org)."
"[ZFS](http://open-zfs.org/wiki/Main_Page)
is a rethinking of the storage stack, combining traditional file systems as well as volume
managers into one cohesive tool.  ZFS has some specific terminology that sets it apart from
more traditional storage systems, however it has a great set of features with a focus on
usability for systems administrators.


## ZFS Concepts

### Virtual Devices

A VDEV is similar to a raid device presented by a RAID card, there are several different
types of VDEV's that offer various advantages, including redundancy and speed.  In general
VDEV's offer better reliability and safety than a RAID card.  It is discouraged to use a
RAID setup with ZFS, as ZFS expects to directly manage the underlying disks.

Types of VDEV's

* stripe (a single disk, no redundancy)
* mirror (n-way mirrors supported)
* raidz
	* raidz1 (1-disk parity, similar to RAID 5)
	* raidz2 (2-disk parity, similar to RAID 6)
	* raidz3 (3-disk parity, no RAID analog)
* disk
* file (not recommended for production due to another filesystem adding unnecessary layering)

Your data is striped across all the VDEV's present in your Storage Pool, so more VDEV's will
increase your IOPS.

### Storage Pools

ZFS uses Storage Pools as an abstraction over the lower level storage provider (VDEV), allow
you to separate the user visible file system from the physical layout.

### ZFS Dataset

ZFS datasets are analogous to traditional filesystems but with many more features.  They
provide many of ZFS's advantages.  Datasets support [Copy on Write](https://en.wikipedia.org/wiki/Copy-on-write)
snapshots, quota's, compression and de-duplication.


### Limits

One directory may contain up to 2^48 files, up to 16 exabytes each.  A single storage pool
can contain up to 256 zettabytes (2^78) of space, and can be striped across 2^64 devices.  A
single host can have 2^64 storage pools.  The limits are huge.


## Commands

### Storage Pools

Actions:

* List
* Status
* Destroy
* Get/Set properties

List zpools

```bash
# Create a raidz zpool
$ zpool create bucket raidz1 gpt/zfs0 gpt/zfs1 gpt/zfs2

# List ZPools
$ zpool list
NAME    SIZE  ALLOC   FREE  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
zroot   141G   106G  35.2G         -    43%    75%  1.00x  ONLINE  -

# List detailed information about a specific zpool
$ zpool list -v zroot
NAME                                     SIZE  ALLOC   FREE  EXPANDSZ   FRAG    CAP  DEDUP HEALTH  ALTROOT
zroot                                    141G   106G  35.2G         -    43%    75%  1.00x ONLINE  -
  gptid/c92a5ccf-a5bb-11e4-a77d-001b2172c655   141G   106G  35.2G         -    43%    75%
```

Status of zpools

```bash
# Get status information about zpools
$ zpool status
  pool: zroot
 state: ONLINE
  scan: scrub repaired 0 in 2h51m with 0 errors on Thu Oct  1 07:08:31 2015
config:

        NAME                                          STATE     READ WRITE CKSUM
        zroot                                         ONLINE       0     0     0
          gptid/c92a5ccf-a5bb-11e4-a77d-001b2172c655  ONLINE       0     0     0

errors: No known data errors

# Scrubbing a zpool to correct any errors
$ zpool scrub zroot
$ zpool status -v zroot
  pool: zroot
 state: ONLINE
  scan: scrub in progress since Thu Oct 15 16:59:14 2015
        39.1M scanned out of 106G at 1.45M/s, 20h47m to go
        0 repaired, 0.04% done
config:

        NAME                                          STATE     READ WRITE CKSUM
        zroot                                         ONLINE       0     0     0
          gptid/c92a5ccf-a5bb-11e4-a77d-001b2172c655  ONLINE       0     0     0

errors: No known data errors
```

Properties of zpools

```bash

# Getting properties from the pool properties can be user set or system provided.
$ zpool get all zroot
NAME   PROPERTY                       VALUE                          SOURCE
zroot  size                           141G                           -
zroot  capacity                       75%                            -
zroot  altroot                        -                              default
zroot  health                         ONLINE                         -
...

# Setting a zpool property
$ zpool set comment=""Storage of mah stuff"" zroot
$ zpool get comment
NAME   PROPERTY  VALUE                 SOURCE
tank   comment   -                     default
zroot  comment   Storage of mah stuff  local
```

Remove zpool

```bash
$ zpool destroy test
```


### Datasets

Actions:

* Create
* List
* Rename
* Delete
* Get/Set properties

Create datasets

```bash
# Create dataset
$ zfs create tank/root/data
$ mount | grep data
tank/root/data on /data (zfs, local, nfsv4acls)

# Create child dataset
$ zfs create tank/root/data/stuff
$ mount | grep data
tank/root/data on /data (zfs, local, nfsv4acls)
tank/root/data/stuff on /data/stuff (zfs, local, nfsv4acls)


# Create Volume
$ zfs create -V zroot/win_vm
$ zfs list zroot/win_vm
NAME                 USED  AVAIL  REFER  MOUNTPOINT
tank/win_vm         4.13G  17.9G    64K  -
```

List datasets

```bash
# List all datasets
$ zfs list
NAME                                                                       USED  AVAIL  REFER  MOUNTPOINT
zroot                                                                      106G  30.8G   144K  none
zroot/ROOT                                                                18.5G  30.8G   144K  none
zroot/ROOT/10.1                                                              8K  30.8G  9.63G  /
zroot/ROOT/default                                                        18.5G  30.8G  11.2G  /
zroot/backup                                                              5.23G  30.8G   144K  none
zroot/home                                                                 288K  30.8G   144K  none
...

# List a specific dataset
$ zfs list zroot/home
NAME         USED  AVAIL  REFER  MOUNTPOINT
zroot/home   288K  30.8G   144K  none

# List snapshots
$ zfs list -t snapshot
zroot@daily-2015-10-15                                                                  0      -   144K  -
zroot/ROOT@daily-2015-10-15                                                             0      -   144K  -
zroot/ROOT/default@daily-2015-10-15                                                     0      -  24.2G  -
zroot/tmp@daily-2015-10-15                                                           124K      -   708M  -
zroot/usr@daily-2015-10-15                                                              0      -   144K  -
zroot/home@daily-2015-10-15                                                             0      -  11.9G  -
zroot/var@daily-2015-10-15                                                           704K      -  1.42G  -
zroot/var/log@daily-2015-10-15                                                       192K      -   828K  -
zroot/var/tmp@daily-2015-10-15                                                          0      -   152K  -
```

Rename datasets

```bash
$ zfs rename tank/root/home tank/root/old_home
$ zfs rename tank/root/new_home tank/root/home
```

Delete dataset

```bash
# Datasets cannot be deleted if they have any snapshots
$ zfs destroy tank/root/home
```

Get / set properties of a dataset

```bash
# Get all properties
$ zfs get all  zroot/usr/home                                                                                              │157 # Create Volume
NAME            PROPERTY              VALUE                  SOURCE                                                                          │158 $ zfs create -V zroot/win_vm
zroot/home      type                  filesystem             -                                                                               │159 $ zfs list zroot/win_vm
zroot/home      creation              Mon Oct 20 14:44 2014  -                                                                               │160 NAME                 USED  AVAIL  REFER  MOUNTPOINT
zroot/home      used                  11.9G                  -                                                                               │161 tank/win_vm         4.13G  17.9G    64K  -
zroot/home      available             94.1G                  -                                                                               │162 ```
zroot/home      referenced            11.9G                  -                                                                               │163
zroot/home      mounted               yes                    -
...

# Get property from dataset
$ zfs get compression zroot/usr/home
NAME            PROPERTY     VALUE     SOURCE
zroot/home      compression  off       default

# Set property on dataset
$ zfs set compression=gzip-9 mypool/lamb

# Get a set of properties from all datasets
$ zfs list -o name,quota,reservation
NAME                                                               QUOTA  RESERV
zroot                                                               none    none
zroot/ROOT                                                          none    none
zroot/ROOT/default                                                  none    none
zroot/tmp                                                           none    none
zroot/usr                                                           none    none
zroot/home                                                          none    none
zroot/var                                                           none    none
...
```


### Snapshots

ZFS snapshots are one of the things about zfs that are a really big deal

* The space they take up is equal to the difference in data between the filesystem and its snapshot
* Creation time is only seconds
* Recovery is as fast as you can write data.
* They are easy to automate.

Actions:

* Create
* Delete
* Rename
* Access snapshots
* Send / Receive
* Clone


Create snapshots

```bash
# Create a snapshot of a single dataset
zfs snapshot tank/home/sarlalian@now

# Create a snapshot of a dataset and its children
$ zfs snapshot -r tank/home@now
$ zfs list -t snapshot
NAME                       USED  AVAIL  REFER  MOUNTPOINT
tank/home@now                 0      -    26K  -
tank/home/sarlalian@now       0      -   259M  -
tank/home/alice@now           0      -   156M  -
tank/home/bob@now             0      -   156M  -
...
```

Destroy snapshots

```bash
# How to destroy a snapshot
$ zfs destroy tank/home/sarlalian@now

# Delete a snapshot on a parent dataset and its children
$ zfs destroy -r tank/home/sarlalian@now

```

Renaming Snapshots

```bash
# Rename a snapshot
$ zfs rename tank/home/sarlalian@now tank/home/sarlalian@today
$ zfs rename tank/home/sarlalian@now today

$ zfs rename -r tank/home@now @yesterday
```

Accessing snapshots

```bash
# CD into a snapshot directory
$ cd /home/.zfs/snapshot/
```

Sending and Receiving

```bash
# Backup a snapshot to a file
$ zfs send tank/home/sarlalian@now | gzip > backup_file.gz

# Send a snapshot to another dataset
$ zfs send tank/home/sarlalian@now | zfs recv backups/home/sarlalian

# Send a snapshot to a remote host
$ zfs send tank/home/sarlalian@now | ssh root@backup_server 'zfs recv tank/home/sarlalian'

# Send full dataset with snapshots to new host
$ zfs send -v -R tank/home@now | ssh root@backup_server 'zfs recv tank/home'
```

Cloning Snapshots

```bash
# Clone a snapshot
$ zfs clone tank/home/sarlalian@now tank/home/sarlalian_new

# Promoting the clone so it is no longer dependent on the snapshot
$ zfs promote tank/home/sarlalian_new
```

### Putting it all together

This following a script utilizing FreeBSD, jails and ZFS to automate
provisioning a clean copy of a mysql staging database from a live replication
slave.

```bash
#!/bin/sh

echo ""==== Stopping the staging database server ====""
jail -r staging

echo ""==== Cleaning up existing staging server and snapshot ====""
zfs destroy -r zroot/jails/staging
zfs destroy zroot/jails/slave@staging

echo ""==== Quiescing the slave database ====""
echo ""FLUSH TABLES WITH READ LOCK;"" | /usr/local/bin/mysql -u root -pmyrootpassword -h slave

echo ""==== Snapshotting the slave db filesystem as zroot/jails/slave@staging ====""
zfs snapshot zroot/jails/slave@staging

echo ""==== Starting the slave database server ====""
jail -c slave

echo ""==== Cloning the slave snapshot to the staging server ====""
zfs clone zroot/jails/slave@staging zroot/jails/staging

echo ""==== Installing the staging mysql config ====""
mv /jails/staging/usr/local/etc/my.cnf /jails/staging/usr/local/etc/my.cnf.slave
cp /jails/staging/usr/local/etc/my.cnf.staging /jails/staging/usr/local/etc/my.cnf

echo ""==== Setting up the staging rc.conf file ====""
mv /jails/staging/etc/rc.conf.local /jails/staging/etc/rc.conf.slave
mv /jails/staging/etc/rc.conf.staging /jails/staging/etc/rc.conf.local

echo ""==== Starting the staging db server ====""
jail -c staging

echo ""==== Makes the staging database not pull from the master ====""
echo ""STOP SLAVE;"" | /usr/local/bin/mysql -u root -pmyrootpassword -h staging
echo ""RESET SLAVE;"" | /usr/local/bin/mysql -u root -pmyrootpassword -h staging
```


### Additional Reading

* [BSDNow's Crash Course on ZFS](http://www.bsdnow.tv/tutorials/zfs)
* [FreeBSD Handbook on ZFS](https://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/zfs.html)
* [BSDNow's Crash Course on ZFS](http://www.bsdnow.tv/tutorials/zfs)
* [Oracle's Tuning Guide](http://www.oracle.com/technetwork/articles/servers-storage-admin/sto-recommended-zfs-settings-1951715.html)
* [OpenZFS Tuning Guide](http://open-zfs.org/wiki/Performance_tuning)
* [FreeBSD ZFS Tuning Guide](https://wiki.freebsd.org/ZFSTuningGuide)"
"AsciiDoc is a markup language similar to Markdown and it can be used for anything from books to blogs. Created in 2002 by Stuart Rackham the language is simple but it allows for a great amount of customization.

Document Header

Headers are optional and can't contain blank lines. It must be offset from content by at least one blank line.

Title Only

```
= Document Title

First sentence of document.
```

Title and Author

```
= Document Title
First Last <first.last@learnxinyminutes.com>

Start of this document.
```

Multiple Authors

```
= Document Title
John Doe <john@go.com>; Jane Doe<jane@yo.com>; Black Beard <beardy@pirate.com>

Start of a doc with multiple authors.
```

Revision Line (requires an author line)

```
= Doc Title V1
Potato Man <chip@crunchy.com>
v1.0, 2016-01-13

This article about chips is going to be fun.
```

Paragraphs

```
You don't need anything special for paragraphs.

Add a blank line between paragraphs to separate them.

To create a line blank add a +
and you will receive a line break!
```

Formatting Text

```
_underscore creates italics_
*asterisks for bold*
*_combine for extra fun_*
`use ticks to signify monospace`
`*bolded monospace*`
```

Section Titles

```
= Level 0 (may only be used in document's header)

== Level 1 <h2>

=== Level 2 <h3>

==== Level 3 <h4>

===== Level 4 <h5>

```

Lists

To create a bulleted list use asterisks.

```
* foo
* bar
* baz
```

To create a numbered list use periods.

```
. item 1
. item 2
. item 3
```

You can nest lists by adding extra asterisks or periods up to five times.

```
* foo 1
** foo 2
*** foo 3
**** foo 4
***** foo 5

. foo 1
.. foo 2
... foo 3
.... foo 4
..... foo 5
```

## Further Reading

There are two tools to process AsciiDoc documents:

1. [AsciiDoc](http://asciidoc.org/): original Python implementation available in the main Linux distributions. Stable and currently in maintenance mode.
2. [Asciidoctor](http://asciidoctor.org/): alternative Ruby implementation, usable also from Java and JavaScript. Under active development, it aims to extend the AsciiDoc syntax with new features and output formats.

Following links are related to `Asciidoctor` implementation:

* [Markdown - AsciiDoc syntax comparison](http://asciidoctor.org/docs/user-manual/#comparison-by-example): side-by-side comparison of common Markdown and AsciiDoc elements.
* [Getting started](http://asciidoctor.org/docs/#get-started-with-asciidoctor): installation and quick start guides to render simple documents.
* [Asciidoctor User Manual](http://asciidoctor.org/docs/user-manual/): complete single-document manual with syntax reference, examples, rendering tools, amongst others."
"language: racket
filename: learnracket.rkt
contributors:
  - [""th3rac25"", ""https://github.com/voila""]
  - [""Eli Barzilay"", ""https://github.com/elibarzilay""]
  - [""Gustavo Schmidt"", ""https://github.com/gustavoschmidt""]
  - [""Duong H. Nguyen"", ""https://github.com/cmpitg""]
  - [""Keyan Zhang"", ""https://github.com/keyanzhang""]
---

Racket is a general purpose, multi-paradigm programming language in the Lisp/Scheme family.

Feedback is appreciated! You can reach me at [@th3rac25](http://twitter.com/th3rac25) or th3rac25 [at] [google's email service]


```racket
#lang racket ; defines the language we are using

;;; Comments

;; Single line comments start with a semicolon

#| Block comments
   can span multiple lines and...
    #|
       they can be nested!
    |#
|#

;; S-expression comments discard the following expression,
;; useful to comment expressions when debugging
#; (this expression is discarded)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1. Primitive Datatypes and Operators
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Numbers
9999999999999999999999 ; integers
#b111                  ; binary => 7
#o111                  ; octal => 73
#x111                  ; hexadecimal => 273
3.14                   ; reals
6.02e+23
1/2                    ; rationals
1+2i                   ; complex numbers

;; Function application is written (f x y z ...)
;; where f is a function and x, y, z, ... are operands
;; If you want to create a literal list of data, use ' to stop it from
;; being evaluated
'(+ 1 2) ; => (+ 1 2)
;; Now, some arithmetic operations
(+ 1 1)  ; => 2
(- 8 1)  ; => 7
(* 10 2) ; => 20
(expt 2 3) ; => 8
(quotient 5 2) ; => 2
(remainder 5 2) ; => 1
(/ 35 5) ; => 7
(/ 1 3) ; => 1/3
(exact->inexact 1/3) ; => 0.3333333333333333
(+ 1+2i  2-3i) ; => 3-1i

;;; Booleans
#t ; for true
#f ; for false -- any value other than #f is true
(not #t) ; => #f
(and 0 #f (error ""doesn't get here"")) ; => #f
(or #f 0 (error ""doesn't get here""))  ; => 0

;;; Characters
#\A ; => #\A
#\λ ; => #\λ
#\u03BB ; => #\λ

;;; Strings are fixed-length array of characters.
""Hello, world!""
""Benjamin \""Bugsy\"" Siegel""   ; backslash is an escaping character
""Foo\tbar\41\x21\u0021\a\r\n"" ; includes C escapes, Unicode
""λx:(μα.α→α).xx""              ; can include Unicode characters

;; Strings can be added too!
(string-append ""Hello "" ""world!"") ; => ""Hello world!""

;; A string can be treated like a list of characters
(string-ref ""Apple"" 0) ; => #\A

;; format can be used to format strings:
(format ""~a can be ~a"" ""strings"" ""formatted"")

;; Printing is pretty easy
(printf ""I'm Racket. Nice to meet you!\n"")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 2. Variables
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; You can create a variable using define
;; a variable name can use any character except: ()[]{}"",'`;#|\
(define some-var 5)
some-var ; => 5

;; You can also use unicode characters
(define ⊆ subset?)
(⊆ (set 3 2) (set 1 2 3)) ; => #t

;; Accessing a previously unassigned variable is an exception
; x ; => x: undefined ...

;; Local binding: `me' is bound to ""Bob"" only within the (let ...)
(let ([me ""Bob""])
  ""Alice""
  me) ; => ""Bob""

;; let* is like let, but allows you to use previous bindings in creating later bindings
(let* ([x 1]
       [y (+ x 1)])
  (* x y))

;; finally, letrec allows you to define recursive and mutually recursive functions
(letrec ([is-even? (lambda (n)
                     (or (zero? n)
                         (is-odd? (sub1 n))))]
         [is-odd? (lambda (n)
                    (and (not (zero? n))
                         (is-even? (sub1 n))))])
  (is-odd? 11))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 3. Structs and Collections
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Structs
; By default, structs are immutable
(struct dog (name breed age))
(define my-pet
  (dog ""lassie"" ""collie"" 5))
my-pet ; => #<dog>
; returns whether the variable was constructed with the dog constructor
(dog? my-pet) ; => #t
; accesses the name field of the variable constructed with the dog constructor
(dog-name my-pet) ; => ""lassie""

; You can explicitly declare a struct to be mutable with the #:mutable option
(struct rgba-color (red green blue alpha) #:mutable)
(define burgundy
   (rgba-color 144 0 32 1.0))
(set-rgba-color-green! burgundy 10)
(rgba-color-green burgundy) ; => 10

;;; Pairs (immutable)
;; `cons' constructs pairs, `car' and `cdr' extract the first
;; and second elements
(cons 1 2) ; => '(1 . 2)
(car (cons 1 2)) ; => 1
(cdr (cons 1 2)) ; => 2

;;; Lists

;; Lists are linked-list data structures, made of `cons' pairs and end
;; with a `null' (or '()) to mark the end of the list
(cons 1 (cons 2 (cons 3 null))) ; => '(1 2 3)
;; `list' is a convenience variadic constructor for lists
(list 1 2 3) ; => '(1 2 3)
;; a quote can also be used for a literal list value
'(1 2 3) ; => '(1 2 3)
;; a quasiquote (represented by the backtick character) with commas 
;; can be used to evaluate functions
`(1 ,(+ 1 1) 3) ; => '(1 2 3)

;; With lists, car/cdr work slightly differently
(car '(1 2 3)) ; => 1
(cdr '(1 2 3)) ; => '(2 3)

;; Racket also has predefined functions on top of car and cdr, to extract parts of a list
(cadr (list 1 2 3)) ; => 2
(car (cdr (list 1 2 3))) ; => 2

(cddr (list 1 2 3)) ; => '(3)
(cdr (cdr (list 1 2 3))) ; => '(3)

(caddr (list 1 2 3)) ; => 3
(car (cdr (cdr (list 1 2 3)))) ; => 3

;; Can still use `cons' to add an item to the beginning of a list
(cons 4 '(1 2 3)) ; => '(4 1 2 3)

;; Use `append' to add lists together
(append '(1 2) '(3 4)) ; => '(1 2 3 4)

;; Lists are a very basic type, so there is a *lot* of functionality for
;; them, a few examples:
(map add1 '(1 2 3))          ; => '(2 3 4)
(map + '(1 2 3) '(10 20 30)) ; => '(11 22 33)
(filter even? '(1 2 3 4))    ; => '(2 4)
(count even? '(1 2 3 4))     ; => 2
(take '(1 2 3 4) 2)          ; => '(1 2)
(drop '(1 2 3 4) 2)          ; => '(3 4)

;;; Vectors

;; Vectors are fixed-length arrays
#(1 2 3) ; => '#(1 2 3)

;; Use `vector-append' to add vectors together
(vector-append #(1 2 3) #(4 5 6)) ; => #(1 2 3 4 5 6)

;;; Sets

;; Create a set from a list
(list->set '(1 2 3 1 2 3 3 2 1 3 2 1)) ; => (set 1 2 3)

;; Add a member with `set-add'
;; (Functional: returns the extended set rather than mutate the input)
(set-add (set 1 2 3) 4) ; => (set 1 2 3 4)

;; Remove one with `set-remove'
(set-remove (set 1 2 3) 1) ; => (set 2 3)

;; Test for existence with `set-member?'
(set-member? (set 1 2 3) 1) ; => #t
(set-member? (set 1 2 3) 4) ; => #f

;;; Hashes

;; Create an immutable hash table (mutable example below)
(define m (hash 'a 1 'b 2 'c 3))

;; Retrieve a value
(hash-ref m 'a) ; => 1

;; Retrieving a non-present value is an exception
; (hash-ref m 'd) => no value found

;; You can provide a default value for missing keys
(hash-ref m 'd 0) ; => 0

;; Use `hash-set' to extend an immutable hash table
;; (Returns the extended hash instead of mutating it)
(define m2 (hash-set m 'd 4))
m2 ; => '#hash((b . 2) (a . 1) (d . 4) (c . 3))

;; Remember, these hashes are immutable!
m ; => '#hash((b . 2) (a . 1) (c . 3))  <-- no `d'

;; Use `hash-remove' to remove keys (functional too)
(hash-remove m 'a) ; => '#hash((b . 2) (c . 3))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 4. Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Use `lambda' to create functions.
;; A function always returns the value of its last expression
(lambda () ""Hello World"") ; => #<procedure>
;; Can also use a unicode `λ'
(λ () ""Hello World"")     ; => same function

;; Use parens to call all functions, including a lambda expression
((lambda () ""Hello World"")) ; => ""Hello World""
((λ () ""Hello World""))      ; => ""Hello World""

;; Assign a function to a var
(define hello-world (lambda () ""Hello World""))
(hello-world) ; => ""Hello World""

;; You can shorten this using the function definition syntactic sugar:
(define (hello-world2) ""Hello World"")

;; The () in the above is the list of arguments for the function
(define hello
  (lambda (name)
    (string-append ""Hello "" name)))
(hello ""Steve"") ; => ""Hello Steve""
;; ... or equivalently, using a sugared definition:
(define (hello2 name)
  (string-append ""Hello "" name))

;; You can have multi-variadic functions too, using `case-lambda'
(define hello3
  (case-lambda
    [() ""Hello World""]
    [(name) (string-append ""Hello "" name)]))
(hello3 ""Jake"") ; => ""Hello Jake""
(hello3) ; => ""Hello World""
;; ... or specify optional arguments with a default value expression
(define (hello4 [name ""World""])
  (string-append ""Hello "" name))

;; Functions can pack extra arguments up in a list
(define (count-args . args)
  (format ""You passed ~a args: ~a"" (length args) args))
(count-args 1 2 3) ; => ""You passed 3 args: (1 2 3)""
;; ... or with the unsugared `lambda' form:
(define count-args2
  (lambda args
    (format ""You passed ~a args: ~a"" (length args) args)))

;; You can mix regular and packed arguments
(define (hello-count name . args)
  (format ""Hello ~a, you passed ~a extra args"" name (length args)))
(hello-count ""Finn"" 1 2 3)
; => ""Hello Finn, you passed 3 extra args""
;; ... unsugared:
(define hello-count2
  (lambda (name . args)
    (format ""Hello ~a, you passed ~a extra args"" name (length args))))

;; And with keywords
(define (hello-k #:name [name ""World""] #:greeting [g ""Hello""] . args)
  (format ""~a ~a, ~a extra args"" g name (length args)))
(hello-k)                 ; => ""Hello World, 0 extra args""
(hello-k 1 2 3)           ; => ""Hello World, 3 extra args""
(hello-k #:greeting ""Hi"") ; => ""Hi World, 0 extra args""
(hello-k #:name ""Finn"" #:greeting ""Hey"") ; => ""Hey Finn, 0 extra args""
(hello-k 1 2 3 #:greeting ""Hi"" #:name ""Finn"" 4 5 6)
                                         ; => ""Hi Finn, 6 extra args""

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 5. Equality
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; for numbers use `='
(= 3 3.0) ; => #t
(= 2 1)   ; => #f

;; `eq?' returns #t if 2 arguments refer to the same object (in memory),
;; #f otherwise.
;; In other words, it's a simple pointer comparison.
(eq? '() '()) ; => #t, since there exists only one empty list in memory
(let ([x '()] [y '()])
  (eq? x y))  ; => #t, same as above

(eq? (list 3) (list 3)) ; => #f
(let ([x (list 3)] [y (list 3)])
  (eq? x y))            ; => #f — not the same list in memory!

(let* ([x (list 3)] [y x])
  (eq? x y)) ; => #t, since x and y now point to the same stuff

(eq? 'yes 'yes) ; => #t
(eq? 'yes 'no)  ; => #f

(eq? 3 3)   ; => #t — be careful here
            ; It’s better to use `=' for number comparisons.
(eq? 3 3.0) ; => #f

(eq? (expt 2 100) (expt 2 100))               ; => #f
(eq? (integer->char 955) (integer->char 955)) ; => #f

(eq? (string-append ""foo"" ""bar"") (string-append ""foo"" ""bar"")) ; => #f

;; `eqv?' supports the comparison of number and character datatypes.
;; for other datatypes, `eqv?' and `eq?' return the same result.
(eqv? 3 3.0)                                   ; => #f
(eqv? (expt 2 100) (expt 2 100))               ; => #t
(eqv? (integer->char 955) (integer->char 955)) ; => #t

(eqv? (string-append ""foo"" ""bar"") (string-append ""foo"" ""bar""))   ; => #f

;; `equal?' supports the comparison of the following datatypes:
;; strings, byte strings, pairs, mutable pairs, vectors, boxes,
;; hash tables, and inspectable structures.
;; for other datatypes, `equal?' and `eqv?' return the same result.
(equal? 3 3.0)                                                   ; => #f
(equal? (string-append ""foo"" ""bar"") (string-append ""foo"" ""bar"")) ; => #t
(equal? (list 3) (list 3))                                       ; => #t

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 6. Control Flow
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Conditionals

(if #t               ; test expression
    ""this is true""   ; then expression
    ""this is false"") ; else expression
; => ""this is true""

;; In conditionals, all non-#f values are treated as true
(member 'Groucho '(Harpo Groucho Zeppo)) ; => '(Groucho Zeppo)
(if (member 'Groucho '(Harpo Groucho Zeppo))
    'yep
    'nope)
; => 'yep

;; `cond' chains a series of tests to select a result
(cond [(> 2 2) (error ""wrong!"")]
      [(< 2 2) (error ""wrong again!"")]
      [else 'ok]) ; => 'ok

;;; Pattern Matching

(define (fizzbuzz? n)
  (match (list (remainder n 3) (remainder n 5))
    [(list 0 0) 'fizzbuzz]
    [(list 0 _) 'fizz]
    [(list _ 0) 'buzz]
    [_          #f]))

(fizzbuzz? 15) ; => 'fizzbuzz
(fizzbuzz? 37) ; => #f

;;; Loops

;; Looping can be done through (tail-) recursion
(define (loop i)
  (when (< i 10)
    (printf ""i=~a\n"" i)
    (loop (add1 i))))
(loop 5) ; => i=5, i=6, ...

;; Similarly, with a named let
(let loop ([i 0])
  (when (< i 10)
    (printf ""i=~a\n"" i)
    (loop (add1 i)))) ; => i=0, i=1, ...

;; See below how to add a new `loop' form, but Racket already has a very
;; flexible `for' form for loops:
(for ([i 10])
  (printf ""i=~a\n"" i)) ; => i=0, i=1, ...
(for ([i (in-range 5 10)])
  (printf ""i=~a\n"" i)) ; => i=5, i=6, ...

;;; Iteration Over Other Sequences
;; `for' allows iteration over many other kinds of sequences:
;; lists, vectors, strings, sets, hash tables, etc...

(for ([i (in-list '(l i s t))])
  (displayln i))

(for ([i (in-vector #(v e c t o r))])
  (displayln i))

(for ([i (in-string ""string"")])
  (displayln i))

(for ([i (in-set (set 'x 'y 'z))])
  (displayln i))

(for ([(k v) (in-hash (hash 'a 1 'b 2 'c 3))])
  (printf ""key:~a value:~a\n"" k v))

;;; More Complex Iterations

;; Parallel scan of multiple sequences (stops on shortest)
(for ([i 10] [j '(x y z)]) 
  (printf ""~a:~a\n"" i j))
; => 0:x 1:y 2:z

;; Nested loops
(for* ([i 2] [j '(x y z)]) 
  (printf ""~a:~a\n"" i j))
; => 0:x, 0:y, 0:z, 1:x, 1:y, 1:z

;; Conditions
(for ([i 1000]
      #:when (> i 5)
      #:unless (odd? i)
      #:break (> i 10))
  (printf ""i=~a\n"" i))
; => i=6, i=8, i=10

;;; Comprehensions
;; Very similar to `for' loops -- just collect the results

(for/list ([i '(1 2 3)])
  (add1 i)) ; => '(2 3 4)

(for/list ([i '(1 2 3)] #:when (even? i))
  i) ; => '(2)

(for/list ([i 10] [j '(x y z)])
  (list i j)) ; => '((0 x) (1 y) (2 z))

(for/list ([i 1000] #:when (> i 5) #:unless (odd? i) #:break (> i 10))
  i) ; => '(6 8 10)

(for/hash ([i '(1 2 3)])
  (values i (number->string i)))
; => '#hash((1 . ""1"") (2 . ""2"") (3 . ""3""))

;; There are many kinds of other built-in ways to collect loop values:
(for/sum ([i 10]) (* i i)) ; => 285
(for/product ([i (in-range 1 11)]) (* i i)) ; => 13168189440000
(for/and ([i 10] [j (in-range 10 20)]) (< i j)) ; => #t
(for/or ([i 10] [j (in-range 0 20 2)]) (= i j)) ; => #t
;; And to use any arbitrary combination, use `for/fold'
(for/fold ([sum 0]) ([i '(1 2 3 4)]) (+ sum i)) ; => 10
;; (This can often replace common imperative loops)

;;; Exceptions

;; To catch exceptions, use the `with-handlers' form
(with-handlers ([exn:fail? (lambda (exn) 999)])
  (+ 1 ""2"")) ; => 999
(with-handlers ([exn:break? (lambda (exn) ""no time"")])
  (sleep 3)
  ""phew"") ; => ""phew"", but if you break it => ""no time""

;; Use `raise' to throw exceptions or any other value
(with-handlers ([number?    ; catch numeric values raised
                 identity]) ; return them as plain values
  (+ 1 (raise 2))) ; => 2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 7. Mutation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Use `set!' to assign a new value to an existing variable
(define n 5)
(set! n (add1 n))
n ; => 6

;; Use boxes for explicitly mutable values (similar to pointers or
;; references in other languages)
(define n* (box 5))
(set-box! n* (add1 (unbox n*)))
(unbox n*) ; => 6

;; Many Racket datatypes are immutable (pairs, lists, etc), some come in
;; both mutable and immutable flavors (strings, vectors, hash tables,
;; etc...)

;; Use `vector' or `make-vector' to create mutable vectors
(define vec (vector 2 2 3 4))
(define wall (make-vector 100 'bottle-of-beer))
;; Use vector-set! to update a slot
(vector-set! vec 0 1)
(vector-set! wall 99 'down)
vec ; => #(1 2 3 4)

;; Create an empty mutable hash table and manipulate it
(define m3 (make-hash))
(hash-set! m3 'a 1)
(hash-set! m3 'b 2)
(hash-set! m3 'c 3)
(hash-ref m3 'a)   ; => 1
(hash-ref m3 'd 0) ; => 0
(hash-remove! m3 'a)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 8. Modules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Modules let you organize code into multiple files and reusable
;; libraries; here we use sub-modules, nested in the whole module that
;; this text makes (starting from the ""#lang"" line)

(module cake racket/base ; define a `cake' module based on racket/base

  (provide print-cake) ; function exported by the module

  (define (print-cake n)
    (show ""   ~a   "" n #\.)
    (show "" .-~a-. "" n #\|)
    (show "" | ~a | "" n #\space)
    (show ""---~a---"" n #\-))

  (define (show fmt n ch) ; internal function
    (printf fmt (make-string n ch))
    (newline)))

;; Use `require' to get all `provide'd names from a module
(require 'cake) ; the ' is for a local submodule
(print-cake 3)
; (show ""~a"" 1 #\A) ; => error, `show' was not exported

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 9. Classes and Objects
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Create a class fish% (-% is idiomatic for class bindings)
(define fish%
  (class object%
    (init size) ; initialization argument
    (super-new) ; superclass initialization
    ;; Field
    (define current-size size)
    ;; Public methods
    (define/public (get-size)
      current-size)
    (define/public (grow amt)
      (set! current-size (+ amt current-size)))
    (define/public (eat other-fish)
      (grow (send other-fish get-size)))))

;; Create an instance of fish%
(define charlie
  (new fish% [size 10]))

;; Use `send' to call an object's methods
(send charlie get-size) ; => 10
(send charlie grow 6)
(send charlie get-size) ; => 16

;; `fish%' is a plain ""first class"" value, which can get us mixins
(define (add-color c%)
  (class c%
    (init color)
    (super-new)
    (define my-color color)
    (define/public (get-color) my-color)))
(define colored-fish% (add-color fish%))
(define charlie2 (new colored-fish% [size 10] [color 'red]))
(send charlie2 get-color)
;; or, with no names:
(send (new (add-color fish%) [size 10] [color 'red]) get-color)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 10. Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Macros let you extend the syntax of the language

;; Let's add a while loop
(define-syntax-rule (while condition body ...)
  (let loop ()
    (when condition
      body ...
      (loop))))

(let ([i 0])
  (while (< i  10)
    (displayln i)
    (set! i (add1 i))))

;; Macros are hygienic, you cannot clobber existing variables!
(define-syntax-rule (swap! x y) ; -! is idiomatic for mutation
  (let ([tmp x])
    (set! x y)
    (set! y tmp)))

(define tmp 2)
(define other 3)
(swap! tmp other)
(printf ""tmp = ~a; other = ~a\n"" tmp other)
;; The variable `tmp` is renamed to `tmp_1`
;; in order to avoid name conflict
;; (let ([tmp_1 tmp])
;;   (set! tmp other)
;;   (set! other tmp_1))

;; But they are still code transformations, for example:
(define-syntax-rule (bad-while condition body ...)
  (when condition
    body ...
    (bad-while condition body ...)))
;; this macro is broken: it generates infinite code, if you try to use
;; it, the compiler will get in an infinite loop

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 11. Contracts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Contracts impose constraints on values exported from modules

(module bank-account racket
  (provide (contract-out
            [deposit (-> positive? any)] ; amounts are always positive
            [balance (-> positive?)]))

  (define amount 0)
  (define (deposit a) (set! amount (+ amount a)))
  (define (balance) amount))

(require 'bank-account)
(deposit 5)

(balance) ; => 5

;; Clients that attempt to deposit a non-positive amount are blamed
;; (deposit -5) ; => deposit: contract violation
;; expected: positive?
;; given: -5
;; more details....

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 12. Input & output
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Racket has this concept of ""port"", which is very similar to file
;; descriptors in other languages

;; Open ""/tmp/tmp.txt"" and write ""Hello World""
;; This would trigger an error if the file's already existed
(define out-port (open-output-file ""/tmp/tmp.txt""))
(displayln ""Hello World"" out-port)
(close-output-port out-port)

;; Append to ""/tmp/tmp.txt""
(define out-port (open-output-file ""/tmp/tmp.txt""
                                   #:exists 'append))
(displayln ""Hola mundo"" out-port)
(close-output-port out-port)

;; Read from the file again
(define in-port (open-input-file ""/tmp/tmp.txt""))
(displayln (read-line in-port))
; => ""Hello World""
(displayln (read-line in-port))
; => ""Hola mundo""
(close-input-port in-port)

;; Alternatively, with call-with-output-file you don't need to explicitly
;; close the file
(call-with-output-file ""/tmp/tmp.txt""
  #:exists 'update ; Rewrite the content
  (λ (out-port)
    (displayln ""World Hello!"" out-port)))

;; And call-with-input-file does the same thing for input
(call-with-input-file ""/tmp/tmp.txt""
  (λ (in-port)
    (displayln (read-line in-port))))
```

## Further Reading

Still up for more? Try [Getting Started with Racket](http://docs.racket-lang.org/getting-started/)"
"Go was created out of the need to get work done. It's not the latest trend
in programming language theory, but it is a way to solve real-world
problems.

It draws concepts from imperative languages with static typing.
It's fast to compile and fast to execute, it adds easy-to-understand
concurrency because multi-core CPUs are now common, and it's used successfully
in large codebases (~100 million loc at Google, Inc.).

Go comes with a good standard library and a sizeable community.

```go
// Single line comment
/* Multi-
 line comment */

 /* A build tag is a line comment starting with // +build
  and can be executed by go build -tags=""foo bar"" command.
  Build tags are placed before the package clause near or at the top of the file
  followed by a blank line or other line comments. */
// +build prod, dev, test

// A package clause starts every source file.
// main is a special name declaring an executable rather than a library.
package main

// Import declaration declares library packages referenced in this file.
import (
	""fmt""       // A package in the Go standard library.
	""io/ioutil"" // Implements some I/O utility functions.
	m ""math""    // Math library with local alias m.
	""net/http""  // Yes, a web server!
	""os""        // OS functions like working with the file system
	""strconv""   // String conversions.
)

// A function definition. Main is special. It is the entry point for the
// executable program. Love it or hate it, Go uses brace brackets.
func main() {
	// Println outputs a line to stdout.
	// It comes from the package fmt.
	fmt.Println(""Hello world!"")

	// Call another function within this package.
	beyondHello()
}

// Functions have parameters in parentheses.
// If there are no parameters, empty parentheses are still required.
func beyondHello() {
	var x int // Variable declaration. Variables must be declared before use.
	x = 3     // Variable assignment.
	// ""Short"" declarations use := to infer the type, declare, and assign.
	y := 4
	sum, prod := learnMultiple(x, y)        // Function returns two values.
	fmt.Println(""sum:"", sum, ""prod:"", prod) // Simple output.
	learnTypes()                            // < y minutes, learn more!
}

/* <- multiline comment
Functions can have parameters and (multiple!) return values.
Here `x`, `y` are the arguments and `sum`, `prod` is the signature (what's returned).
Note that `x` and `sum` receive the type `int`.
*/
func learnMultiple(x, y int) (sum, prod int) {
	return x + y, x * y // Return two values.
}

// Some built-in types and literals.
func learnTypes() {
	// Short declaration usually gives you what you want.
	str := ""Learn Go!"" // string type.

	s2 := `A ""raw"" string literal
can include line breaks.` // Same string type.

	// Non-ASCII literal. Go source is UTF-8.
	g := 'Σ' // rune type, an alias for int32, holds a unicode code point.

	f := 3.14195 // float64, an IEEE-754 64-bit floating point number.
	c := 3 + 4i  // complex128, represented internally with two float64's.

	// var syntax with initializers.
	var u uint = 7 // Unsigned, but implementation dependent size as with int.
	var pi float32 = 22. / 7

	// Conversion syntax with a short declaration.
	n := byte('\n') // byte is an alias for uint8.

	// Arrays have size fixed at compile time.
	var a4 [4]int           // An array of 4 ints, initialized to all 0.
	a5 := [...]int{3, 1, 5, 10, 100} // An array initialized with a fixed size of five
	// elements, with values 3, 1, 5, 10, and 100.

	// Arrays have value semantics.
	a4_cpy := a4            // a4_cpy is a copy of a4, two separate instances.
	a4_cpy[0] = 25          // Only a4_cpy is changed, a4 stays the same.
	fmt.Println(a4_cpy[0] == a4[0]) // false

	// Slices have dynamic size. Arrays and slices each have advantages
	// but use cases for slices are much more common.
	s3 := []int{4, 5, 9}    // Compare to a5. No ellipsis here.
	s4 := make([]int, 4)    // Allocates slice of 4 ints, initialized to all 0.
	var d2 [][]float64      // Declaration only, nothing allocated here.
	bs := []byte(""a slice"") // Type conversion syntax.

	// Slices (as well as maps and channels) have reference semantics.
	s3_cpy := s3            // Both variables point to the same instance.
	s3_cpy[0] = 0           // Which means both are updated.
	fmt.Println(s3_cpy[0] == s3[0]) // true	

	// Because they are dynamic, slices can be appended to on-demand.
	// To append elements to a slice, the built-in append() function is used.
	// First argument is a slice to which we are appending. Commonly,
	// the array variable is updated in place, as in example below.
	s := []int{1, 2, 3}		// Result is a slice of length 3.
	s = append(s, 4, 5, 6)	// Added 3 elements. Slice now has length of 6.
	fmt.Println(s) // Updated slice is now [1 2 3 4 5 6]

	// To append another slice, instead of list of atomic elements we can
	// pass a reference to a slice or a slice literal like this, with a
	// trailing ellipsis, meaning take a slice and unpack its elements,
	// appending them to slice s.
	s = append(s, []int{7, 8, 9}...) // Second argument is a slice literal.
	fmt.Println(s)	// Updated slice is now [1 2 3 4 5 6 7 8 9]

	p, q := learnMemory() // Declares p, q to be type pointer to int.
	fmt.Println(*p, *q)   // * follows a pointer. This prints two ints.

	// Maps are a dynamically growable associative array type, like the
	// hash or dictionary types of some other languages.
	m := map[string]int{""three"": 3, ""four"": 4}
	m[""one""] = 1

	// Unused variables are an error in Go.
	// The underscore lets you ""use"" a variable but discard its value.
	_, _, _, _, _, _, _, _, _, _ = str, s2, g, f, u, pi, n, a5, s4, bs
	// Usually you use it to ignore one of the return values of a function
	// For example, in a quick and dirty script you might ignore the
	// error value returned from os.Create, and expect that the file
	// will always be created.
	file, _ := os.Create(""output.txt"")
	fmt.Fprint(file, ""This is how you write to a file, by the way"")
	file.Close()
	
	// Output of course counts as using a variable.
	fmt.Println(s, c, a4, s3, d2, m)

	learnFlowControl() // Back in the flow.
}

// It is possible, unlike in many other languages for functions in go
// to have named return values.
// Assigning a name to the type being returned in the function declaration line
// allows us to easily return from multiple points in a function as well as to
// only use the return keyword, without anything further.
func learnNamedReturns(x, y int) (z int) {
	z = x * y
	return // z is implicit here, because we named it earlier.
}

// Go is fully garbage collected. It has pointers but no pointer arithmetic.
// You can make a mistake with a nil pointer, but not by incrementing a pointer.
// Unlike in C/Cpp taking and returning an address of a local variable is also safe. 
func learnMemory() (p, q *int) {
	// Named return values p and q have type pointer to int.
	p = new(int) // Built-in function new allocates memory.
	// The allocated int slice is initialized to 0, p is no longer nil.
	s := make([]int, 20) // Allocate 20 ints as a single block of memory.
	s[3] = 7             // Assign one of them.
	r := -2              // Declare another local variable.
	return &s[3], &r     // & takes the address of an object.
}

// Use the aliased math library (see imports, above) 
func expensiveComputation() float64 {
	return m.Exp(10)
}

func learnFlowControl() {
	// If statements require brace brackets, and do not require parentheses.
	if true {
		fmt.Println(""told ya"")
	}
	// Formatting is standardized by the command line command ""go fmt"".
	if false {
		// Pout.
	} else {
		// Gloat.
	}
	// Use switch in preference to chained if statements.
	x := 42.0
	switch x {
	case 0:
	case 1, 2: // Can have multiple matches on one case
	case 42:
		// Cases don't ""fall through"".
		/*
		There is a `fallthrough` keyword however, see:
		  https://github.com/golang/go/wiki/Switch#fall-through
		*/
	case 43:
		// Unreached.
	default:
		// Default case is optional.
	}

	// Type switch allows switching on the type of something instead of value
	var data interface{}
	data = """"
	switch c := data.(type) {
	case string:
		fmt.Println(c, ""is a string"")
	case int64:
		fmt.Printf(""%d is an int64\n"", c)
	default:
		// all other cases
	}

	// Like if, for doesn't use parens either.
	// Variables declared in for and if are local to their scope.
	for x := 0; x < 3; x++ { // ++ is a statement.
		fmt.Println(""iteration"", x)
	}
	// x == 42 here.

	// For is the only loop statement in Go, but it has alternate forms.
	for { // Infinite loop.
		break    // Just kidding.
		continue // Unreached.
	}

	// You can use range to iterate over an array, a slice, a string, a map, or a channel.
	// range returns one (channel) or two values (array, slice, string and map).
	for key, value := range map[string]int{""one"": 1, ""two"": 2, ""three"": 3} {
		// for each pair in the map, print key and value
		fmt.Printf(""key=%s, value=%d\n"", key, value)
	}
	// If you only need the value, use the underscore as the key
	for _, name := range []string{""Bob"", ""Bill"", ""Joe""} {
		fmt.Printf(""Hello, %s\n"", name)
	}

	// As with for, := in an if statement means to declare and assign
	// y first, then test y > x.
	if y := expensiveComputation(); y > x {
		x = y
	}
	// Function literals are closures.
	xBig := func() bool {
		return x > 10000 // References x declared above switch statement.
	}
	x = 99999
	fmt.Println(""xBig:"", xBig()) // true
	x = 1.3e3                    // This makes x == 1300
	fmt.Println(""xBig:"", xBig()) // false now.

	// What's more is function literals may be defined and called inline,
	// acting as an argument to function, as long as:
	// a) function literal is called immediately (),
	// b) result type matches expected type of argument.
	fmt.Println(""Add + double two numbers: "",
		func(a, b int) int {
			return (a + b) * 2
		}(10, 2)) // Called with args 10 and 2
	// => Add + double two numbers: 24

	// When you need it, you'll love it.
	goto love
love:

	learnFunctionFactory() // func returning func is fun(3)(3)
	learnDefer()      // A quick detour to an important keyword.
	learnInterfaces() // Good stuff coming up!
}

func learnFunctionFactory() {
	// Next two are equivalent, with second being more practical
	fmt.Println(sentenceFactory(""summer"")(""A beautiful"", ""day!""))

	d := sentenceFactory(""summer"")
	fmt.Println(d(""A beautiful"", ""day!""))
	fmt.Println(d(""A lazy"", ""afternoon!""))
}

// Decorators are common in other languages. Same can be done in Go
// with function literals that accept arguments.
func sentenceFactory(mystring string) func(before, after string) string {
	return func(before, after string) string {
		return fmt.Sprintf(""%s %s %s"", before, mystring, after) // new string
	}
}

func learnDefer() (ok bool) {
	// A defer statement pushes a function call onto a list. The list of saved
	// calls is executed AFTER the surrounding function returns.
	defer fmt.Println(""deferred statements execute in reverse (LIFO) order."")
	defer fmt.Println(""\nThis line is being printed first because"")
	// Defer is commonly used to close a file, so the function closing the
	// file stays close to the function opening the file.
	return true
}

// Define Stringer as an interface type with one method, String.
type Stringer interface {
	String() string
}

// Define pair as a struct with two fields, ints named x and y.
type pair struct {
	x, y int
}

// Define a method on type pair. Pair now implements Stringer because Pair has defined all the methods in the interface.
func (p pair) String() string { // p is called the ""receiver""
	// Sprintf is another public function in package fmt.
	// Dot syntax references fields of p.
	return fmt.Sprintf(""(%d, %d)"", p.x, p.y)
}

func learnInterfaces() {
	// Brace syntax is a ""struct literal"". It evaluates to an initialized
	// struct. The := syntax declares and initializes p to this struct.
	p := pair{3, 4}
	fmt.Println(p.String()) // Call String method of p, of type pair.
	var i Stringer          // Declare i of interface type Stringer.
	i = p                   // Valid because pair implements Stringer
	// Call String method of i, of type Stringer. Output same as above.
	fmt.Println(i.String())

	// Functions in the fmt package call the String method to ask an object
	// for a printable representation of itself.
	fmt.Println(p) // Output same as above. Println calls String method.
	fmt.Println(i) // Output same as above.

	learnVariadicParams(""great"", ""learning"", ""here!"")
}

// Functions can have variadic parameters.
func learnVariadicParams(myStrings ...interface{}) {
	// Iterate each value of the variadic.
	// The underbar here is ignoring the index argument of the array.
	for _, param := range myStrings {
		fmt.Println(""param:"", param)
	}

	// Pass variadic value as a variadic parameter.
	fmt.Println(""params:"", fmt.Sprintln(myStrings...))

	learnErrorHandling()
}

func learnErrorHandling() {
	// "", ok"" idiom used to tell if something worked or not.
	m := map[int]string{3: ""three"", 4: ""four""}
	if x, ok := m[1]; !ok { // ok will be false because 1 is not in the map.
		fmt.Println(""no one there"")
	} else {
		fmt.Print(x) // x would be the value, if it were in the map.
	}
	// An error value communicates not just ""ok"" but more about the problem.
	if _, err := strconv.Atoi(""non-int""); err != nil { // _ discards value
		// prints 'strconv.ParseInt: parsing ""non-int"": invalid syntax'
		fmt.Println(err)
	}
	// We'll revisit interfaces a little later. Meanwhile,
	learnConcurrency()
}

// c is a channel, a concurrency-safe communication object.
func inc(i int, c chan int) {
	c <- i + 1 // <- is the ""send"" operator when a channel appears on the left.
}

// We'll use inc to increment some numbers concurrently.
func learnConcurrency() {
	// Same make function used earlier to make a slice. Make allocates and
	// initializes slices, maps, and channels.
	c := make(chan int)
	// Start three concurrent goroutines. Numbers will be incremented
	// concurrently, perhaps in parallel if the machine is capable and
	// properly configured. All three send to the same channel.
	go inc(0, c) // go is a statement that starts a new goroutine.
	go inc(10, c)
	go inc(-805, c)
	// Read three results from the channel and print them out.
	// There is no telling in what order the results will arrive!
	fmt.Println(<-c, <-c, <-c) // channel on right, <- is ""receive"" operator.

	cs := make(chan string)       // Another channel, this one handles strings.
	ccs := make(chan chan string) // A channel of string channels.
	go func() { c <- 84 }()       // Start a new goroutine just to send a value.
	go func() { cs <- ""wordy"" }() // Again, for cs this time.
	// Select has syntax like a switch statement but each case involves
	// a channel operation. It selects a case at random out of the cases
	// that are ready to communicate.
	select {
	case i := <-c: // The value received can be assigned to a variable,
		fmt.Printf(""it's a %T"", i)
	case <-cs: // or the value received can be discarded.
		fmt.Println(""it's a string"")
	case <-ccs: // Empty channel, not ready for communication.
		fmt.Println(""didn't happen."")
	}
	// At this point a value was taken from either c or cs. One of the two
	// goroutines started above has completed, the other will remain blocked.

	learnWebProgramming() // Go does it. You want to do it too.
}

// A single function from package http starts a web server.
func learnWebProgramming() {

	// First parameter of ListenAndServe is TCP address to listen to.
	// Second parameter is an interface, specifically http.Handler.
	go func() {
		err := http.ListenAndServe("":8080"", pair{})
		fmt.Println(err) // don't ignore errors
	}()

	requestServer()
}

// Make pair an http.Handler by implementing its only method, ServeHTTP.
func (p pair) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Serve data with a method of http.ResponseWriter.
	w.Write([]byte(""You learned Go in Y minutes!""))
}

func requestServer() {
	resp, err := http.Get(""http://localhost:8080"")
	fmt.Println(err)
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	fmt.Printf(""\nWebserver said: `%s`"", string(body))
}
```

## Further Reading

The root of all things Go is the [official Go web site](http://golang.org/).
There you can follow the tutorial, play interactively, and read lots.
Aside from a tour, [the docs](https://golang.org/doc/) contain information on
how to write clean and effective Go code, package and command docs, and release history.

The [Go language specification](https://golang.org/ref/spec) itself is highly recommended. It's easy to read
and amazingly short (as language definitions go these days.)

You can play around with the code on [Go playground](https://play.golang.org/p/tnWMjr16Mm). Try to change it and run it from your browser! Note that you can use [https://play.golang.org](https://play.golang.org) as a [REPL](https://en.wikipedia.org/wiki/Read-eval-print_loop) to test things and code in your browser, without even installing Go.

On the reading list for students of Go is the [source code to the standard
library](http://golang.org/src/pkg/). Comprehensively documented, it
demonstrates the best of readable and understandable Go, Go style, and Go
idioms. Or you can click on a function name in [the
documentation](http://golang.org/pkg/) and the source code comes up!

Another great resource to learn Go is [Go by example](https://gobyexample.com/).

There are many excellent conference talks and video tutorials on Go available on YouTube, and here are three playlists of the very best, tailored for beginners, intermediate, and advanced Gophers respectively:

- [Golang University 101](https://www.youtube.com/playlist?list=PLEcwzBXTPUE9V1o8mZdC9tNnRZaTgI-1P) introduces fundamental Go concepts and shows you how to use the Go tools to create and manage Go code
- [Golang University 201](https://www.youtube.com/playlist?list=PLEcwzBXTPUE_5m_JaMXmGEFgduH8EsuTs) steps it up a notch, explaining important techniques like testing, web services, and APIs
- [Golang University 301](https://www.youtube.com/playlist?list=PLEcwzBXTPUE8KvXRFmmfPEUmKoy9LfmAf) dives into more advanced topics like the Go scheduler, implementation of maps and channels, and optimisation techniques

Go Mobile adds support for mobile platforms (Android and iOS). You can write all-Go native mobile apps or write a library that contains bindings from a Go package, which can be invoked via Java (Android) and Objective-C (iOS). Check out the [Go Mobile page](https://github.com/golang/go/wiki/Mobile) for more information."
"## Getting Started with AMD

The **Asynchronous Module Definition** API specifies a mechanism for defining
JavaScript modules such that the module and its dependencies can be asynchronously
loaded. This is particularly well suited for the browser environment where
synchronous loading of modules incurs performance, usability, debugging, and
cross-domain access problems.

### Basic concept
```javascript
// The basic AMD API consists of nothing but two methods: `define` and `require`
// and is all about module definition and consumption:
// `define(id?, dependencies?, factory)` defines a module
// `require(dependencies, callback)` imports a set of dependencies and
// consumes them in the passed callback

// Let's start by using define to define a new named module
// that has no dependencies. We'll do so by passing a name
// and a factory function to define:
define('awesomeAMD', function(){
  var isAMDAwesome = function(){
    return true;
  };
  // The return value of a module's factory function is
  // what other modules or require calls will receive when
  // requiring our `awesomeAMD` module.
  // The exported value can be anything, (constructor) functions,
  // objects, primitives, even undefined (although that won't help too much).
  return isAMDAwesome;
});

// Now, let's define another module that depends upon our `awesomeAMD` module.
// Notice that there's an additional argument defining our
// module's dependencies now:
define('loudmouth', ['awesomeAMD'], function(awesomeAMD){
  // dependencies will be passed to the factory's arguments
  // in the order they are specified
  var tellEveryone = function(){
    if (awesomeAMD()){
      alert('This is sOoOo rad!');
    } else {
      alert('Pretty dull, isn\'t it?');
    }
  };
  return tellEveryone;
});

// As we do know how to use define now, let's use `require` to
// kick off our program. `require`'s signature is `(arrayOfDependencies, callback)`.
require(['loudmouth'], function(loudmouth){
  loudmouth();
});

// To make this tutorial run code, let's implement a very basic
// (non-asynchronous) version of AMD right here on the spot:
function define(name, deps, factory){
  // notice how modules without dependencies are handled
  define[name] = require(factory ? deps : [], factory || deps);
}

function require(deps, callback){
  var args = [];
  // first let's retrieve all the dependencies needed
  // by the require call
  for (var i = 0; i < deps.length; i++){
    args[i] = define[deps[i]];
  }
  // satisfy all the callback's dependencies
  return callback.apply(null, args);
}
// you can see this code in action here: http://jsfiddle.net/qap949pd/
```

### Real-world usage with require.js

In contrast to the introductory example, `require.js` (the most popular AMD library) actually implements the **A** in **AMD**, enabling you to load modules and their dependencies asynchronously via XHR:

```javascript
/* file: app/main.js */
require(['modules/someClass'], function(SomeClass){
  // the callback is deferred until the dependency is loaded
  var thing = new SomeClass();
});
console.log('So here we are, waiting!'); // this will run first
```

By convention, you usually store one module in one file. `require.js` can resolve module names based on file paths, so you don't have to name your modules, but can simply reference them using their location. In the example `someClass` is assumed to be in the `modules` folder, relative to your configuration's `baseUrl`:

* app/
  * main.js
  * modules/
    * someClass.js
    * someHelpers.js
    * ...
  * daos/
    * things.js
    * ...

This means we can define `someClass` without specifying a module id:

```javascript
/* file: app/modules/someClass.js */
define(['daos/things', 'modules/someHelpers'], function(thingsDao, helpers){
  // module definition, of course, will also happen asynchronously
  function SomeClass(){
    this.method = function(){/**/};
    // ...
  }
  return SomeClass;
});
```
To alter the default path mapping behavior use `requirejs.config(configObj)` in your `main.js`:

```javascript
/* file: main.js */
requirejs.config({
  baseUrl : 'app',
  paths : {
    // you can also load modules from other locations
    jquery : '//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min',
    coolLibFromBower : '../bower_components/cool-lib/coollib'
  }
});
require(['jquery', 'coolLibFromBower', 'modules/someHelpers'], function($, coolLib, helpers){
  // a `main` file needs to call require at least once,
  // otherwise no code will ever run
  coolLib.doFancyStuffWith(helpers.transform($('#foo')));
});
```
`require.js`-based apps will usually have a single entry point (`main.js`) that is passed to the `require.js` script tag as a data-attribute. It will be automatically loaded and executed on pageload:

```html
<!DOCTYPE html>
<html>
<head>
  <title>A hundred script tags? Never again!</title>
</head>
<body>
  <script src=""require.js"" data-main=""app/main""></script>
</body>
</html>
```

### Optimizing a whole project using r.js

Many people prefer using AMD for sane code organization during development, but still want to ship a single script file in production instead of performing hundreds of XHRs on page load.

`require.js` comes with a script called `r.js` (that you will probably run in node.js, although Rhino is supported too) that can analyse your project's dependency graph, and build a single file containing all your modules (properly named), minified and ready for consumption.

Install it using `npm`:
```shell
$ npm install requirejs -g
```

Now you can feed it with a configuration file:
```shell
$ r.js -o app.build.js
```

For our above example the configuration might look like:
```javascript
/* file : app.build.js */
({
  name : 'main', // name of the entry point
  out : 'main-built.js', // name of the file to write the output to
  baseUrl : 'app',
  paths : {
    // `empty:` tells r.js that this should still be loaded from the CDN, using
    // the location specified in `main.js`
    jquery : 'empty:',
    coolLibFromBower : '../bower_components/cool-lib/coollib'
  }
})
```

To use the built file in production, simply swap `data-main`:
```html
<script src=""require.js"" data-main=""app/main-built""></script>
```

An incredibly detailed [overview of build options](https://github.com/jrburke/r.js/blob/master/build/example.build.js) is available in the GitHub repo.

### Topics not covered in this tutorial
* [Loader plugins / transforms](http://requirejs.org/docs/plugins.html)
* [CommonJS style loading and exporting](http://requirejs.org/docs/commonjs.html)
* [Advanced configuration](http://requirejs.org/docs/api.html#config)
* [Shim configuration (loading non-AMD modules)](http://requirejs.org/docs/api.html#config-shim)
* [CSS loading and optimizing with require.js](http://requirejs.org/docs/optimization.html#onecss)
* [Using almond.js for builds](https://github.com/jrburke/almond)

### Further reading:

* [Official Spec](https://github.com/amdjs/amdjs-api/wiki/AMD)
* [Why AMD?](http://requirejs.org/docs/whyamd.html)
* [Universal Module Definition](https://github.com/umdjs/umd)

### Implementations:

* [require.js](http://requirejs.org)
* [dojo toolkit](http://dojotoolkit.org/documentation/tutorials/1.9/modules/)
* [cujo.js](http://cujojs.com/)
* [curl.js](https://github.com/cujojs/curl)
* [lsjs](https://github.com/zazl/lsjs)
* [mmd](https://github.com/alexlawrence/mmd)"
"Stylus is a dynamic stylesheet preprocessor language that is compiled into CSS. It aims to add functionality to CSS without breaking compatibility across web browsers.
It does this using variables, nesting, mixins, functions and more.

Stylus syntax is very flexible. You can use standard CSS syntax and leave the semicolon (;), colon (:) and even the ({) and (}) optional, making your code even more readable.

Stylus does not provide new style options, but gives functionality that lets you make your CSS much more dynamic.

```scss

/* Code style
==============================*/

/* Keys, semicolon, and colon are optional in Stylus. */

body {
  background: #000;
}

body {
  background: #000
}

body {
  background #000
}

body
  background #000

body
  background: #000;

body
  background: #000

// Single-line comments are removed when Stylus is compiled into CSS.

/* Multi-line comments are preserved. */


/* Selectors
==============================*/

/* Selecting elements within another element */
body {
  background: #000000;
  h1 {
    color: #FF0000;
  }
}

/* Or if you prefer... */
body
  background #000000
  h1
    color #FF0000


/* Getting parent element reference
==============================*/
a {
  color: #0088dd;
  &:hover {
    color: #DD8800;
  }
}


/* Variables
==============================*/


/*
  You can store a CSS value (such as the color) of a variable.
  Although it is optional, it is recommended to add $ before a variable name
  so you can distinguish a variable from another CSS value.
*/

$primary-color = #A3A4FF
$secondary-color = #51527F
$body-font = 'Roboto', sans-serif

/* You can use variables throughout your style sheet.
Now, if you want to change the color, you only have to make the change once. */

body
	background-color $primary-color
	color $secondary-color
	font-family $body-font

/* After compilation: */
body {
	background-color: #A3A4FF;
	color: #51527F;
	font-family: 'Roboto', sans-serif;
}

/ *
This is much easier to maintain than having to change color
each time it appears throughout your style sheet.
* /


/* Mixins
==============================*/

/* If you find that you are writing the same code for more than one
element, you may want to store that code in a mixin.

center()
  display block
	margin-left auto
	margin-right auto
	left 0
	right 0

/* Using the mixin */
body {
  center()
  background-color: $primary-color
}

/* After compilation: */
div {
	display: block;
	margin-left: auto;
	margin-right: auto;
	left: 0;
	right: 0;
	background-color: #A3A4FF;
}

/* You can use mixins to create a shorthand property. */

size($width, $height)
  width $width
  height $height

.rectangle
  size(100px, 60px)

.square
	size(40px, 40px)

/* You can use a mixin as a CSS property. */
circle($ratio)
  width $ratio * 2
  height $ratio * 2
  border-radius $ratio

.ball
  circle 25px


/* Interpolation
==============================*/

vendor(prop, args)
  -webkit-{prop} args
  -moz-{prop} args
  {prop} args

border-radius()
  vendor('border-radius', arguments)

box-shadow()
  vendor('box-shadow', arguments)

button
  border-radius 1px 2px / 3px 4px


/* Functions
==============================*/

/* Functions in Stylus allow you to perform a variety of tasks, such as recalling some data. */

body {
  background darken(#0088DD, 50%) // Dim color #0088DD by 50%
}

/* Creating your own function */
add(a, b)
  a + b

body
  padding add(10px, 5)


/* Conditions
==============================*/
compare(a, b)
  if a > b
    bigger
  else if a < b
    smaller
  else
    equal

compare(5, 2)   // => bigger
compare(1, 5)   // => smaller
compare(10, 10) // => equal


/* Iterations
==============================*/

/*
Repeat loop syntax for:
for <val-name> [, <key-name>] in <expression>
*/

for $item in (1..2) /* Repeat block 12 times */
  .col-{$item}
    width ($item / 12) * 100% /* Calculate row by column number */
```

Now that you know a little about this powerful CSS preprocessor, you're ready to create more dynamic style sheets. To learn more, visit the official stylus documentation at http://stylus-lang.com."
"People using Ruby generally have a way to install different Ruby versions,
manage their packages (or gems), and manage their gem dependencies.

## Ruby Versions

Ruby was created by Yukihiro ""Matz"" Matsumoto, who remains somewhat of a
[BDFL](https://en.wikipedia.org/wiki/Benevolent_Dictator_for_Life), although
that is changing recently. As a result, the reference implementation of Ruby is
called MRI (Matz' Reference Implementation), and when you hear a Ruby version,
it is referring to the release version of MRI.

New major versions of Ruby are traditionally released on Christmas Day. The current major version (25 December 2017) is 2.5. The most popular stable versions are 2.4.4 and 2.3.7 (both released 28 March 2018).

## Ruby Managers

Some platforms have Ruby pre-installed or available as a package. Most rubyists
do not use these, or if they do, they only use them to bootstrap another Ruby
installer or implementation. Instead rubyists tend to install a Ruby manager to
install and switch between many versions of Ruby and their projects' Ruby
environments.

The following are the popular Ruby environment managers:

* [RVM](https://rvm.io/) - Installs and switches between rubies. RVM also has
  the concept of gemsets to isolate projects' environments completely.
* [ruby-build](https://github.com/sstephenson/ruby-build) - Only installs
  rubies. Use this for finer control over your rubies' installations.
* [rbenv](https://github.com/sstephenson/rbenv) - Only switches between rubies.
  Used with ruby-build.  Use this for finer control over how rubies load.
* [chruby](https://github.com/postmodern/chruby) - Only switches between rubies.
  Similar in spirit to rbenv. Unopinionated about how rubies are installed.

## Ruby Implementations

The Ruby ecosystem enjoys many different implementations of Ruby, each with
unique strengths and states of compatibility. To be clear, the different
implementations are written in different languages, but *they are all Ruby*.
Each implementation has special hooks and extra features, but they all run
normal Ruby files well. For instance, JRuby is written in Java, but you do
not need to know Java to use it.

Very mature/compatible:

* [MRI](https://github.com/ruby/ruby) - Written in C, this is the reference implementation of Ruby. By
  definition it is 100% compatible (with itself). All other rubies
maintain compatibility with MRI (see [RubySpec](#rubyspec) below).
* [JRuby](http://jruby.org/) - Written in Java and Ruby, this robust implementation is quite fast.
  Most importantly, JRuby's strength is JVM/Java interop, leveraging existing
JVM tools, projects, and languages.
* [Rubinius](http://rubini.us/) - Written primarily in Ruby itself with a C++ bytecode VM. Also
  mature and fast. Because it is implemented in Ruby itself, it exposes many VM
features into rubyland.

Medium mature/compatible:

* [Maglev](http://maglev.github.io/) - Built on top of Gemstone, a Smalltalk VM. Smalltalk has some
  impressive tooling, and this project tries to bring that into Ruby
development.
* [RubyMotion](http://www.rubymotion.com/) - Brings Ruby to iOS development.

Less mature/compatible:

* [Topaz](http://topazruby.com/) - Written in RPython (using the PyPy toolchain), Topaz is fairly young
  and not yet compatible. It shows promise to be a high-performance Ruby
implementation.
* [IronRuby](http://ironruby.net/) - Written in C# targeting the .NET platform, work on IronRuby seems
  to have stopped since Microsoft pulled their support.

Ruby implementations may have their own release version numbers, but they always
target a specific version of MRI for compatibility. Many implementations have
the ability to enter different modes (for example, 1.8 or 1.9 mode) to specify
which MRI version to target.

## RubySpec

Most Ruby implementations rely heavily on [RubySpec](http://rubyspec.org/). Ruby
has no official specification, so the community has written executable specs in
Ruby to test their implementations' compatibility with MRI.

## RubyGems

[RubyGems](http://rubygems.org/) is a community-run package manager for Ruby.
RubyGems ships with Ruby, so there is no need to download it separately.

Ruby packages are called ""gems,"" and they can be hosted by the community at
RubyGems.org. Each gem contains its source code and some metadata, including
things like version, dependencies, author(s), and license(s).

## Bundler

[Bundler](http://bundler.io/) is a gem dependency resolver. It uses a project's
Gemfile to find dependencies, and then fetches those dependencies' dependencies
recursively. It does this until all dependencies are resolved and downloaded, or
it will stop if a conflict has been found.

Bundler will raise an error if it finds conflicting dependencies. For example,
if gem A requires version 3 or greater of gem Z, but gem B requires version 2,
Bundler will notify you of the conflict. This becomes extremely helpful as many
gems refer to other gems (which refer to other gems), which can form a large
dependency graph to resolve.

# Testing

Testing is a large part of Ruby culture. Ruby comes with its own Unit-style
testing framework called minitest (Or TestUnit for Ruby version 1.8.x). There
are many testing libraries with different goals.

* [TestUnit](http://ruby-doc.org/stdlib-1.8.7/libdoc/test/unit/rdoc/Test/Unit.html) - Ruby 1.8's built-in ""Unit-style"" testing framework
* [minitest](http://ruby-doc.org/stdlib-2.0.0/libdoc/minitest/rdoc/MiniTest.html) - Ruby 1.9/2.0's built-in testing framework
* [RSpec](http://rspec.info/) - A testing framework that focuses on expressivity
* [Cucumber](http://cukes.info/) - A BDD testing framework that parses Gherkin formatted tests

## Be Nice

The Ruby community takes pride in being an open, diverse, welcoming community.
Matz himself is extremely friendly, and the generosity of rubyists on the whole
is amazing."
"```
;; learn-wasm.wast

(module
  ;; In WebAssembly, everything is included in a module. Moreover, everything
  ;; can be expressed as an s-expression. Alternatively, there is the
  ;; ""stack machine"" syntax, but that is not compatible with Binaryen
  ;; intermediate representation (IR) syntax.

  ;; The Binaryen IR format is *mostly* compatible with WebAssembly text format.
  ;; There are some small differences:
  ;; local_set -> local.set
  ;; local_get -> local.get

  ;; We have to enclose code in functions

  ;; Data Types
  (func $data_types
    ;; WebAssembly has only four types:
    ;; i32 - 32 bit integer
    ;; i64 - 64 bit integer (not supported in JavaScript)
    ;; f32 - 32 bit floating point
    ;; f64 - 64 bit floating point

    ;; We can declare local variables with the ""local"" keyword
    ;; We have to declare all variables before we start doing anything
    ;; inside the function

    (local $int_32 i32)
    (local $int_64 i64)
    (local $float_32 f32)
    (local $float_64 f64)

    ;; These values remain uninitialized.
    ;; To set them to a value, we can use <type>.const:

    (local.set $int_32 (i32.const 16))
    (local.set $int_64 (i64.const 128))
    (local.set $float_32 (f32.const 3.14))
    (local.set $float_64 (f64.const 1.28))
  )

  ;; Basic operations
  (func $basic_operations

    ;; In WebAssembly, everything is an s-expression, including
    ;; doing math, or getting the value of some variable

    (local $add_result i32)
    (local $mult_result f64)

    (local.set $add_result (i32.add (i32.const 2) (i32.const 4)))
    ;; the value of add_result is now 6!

    ;; We have to use the right data type for each operation:
    ;; (local.set $mult_result (f32.mul (f32.const 2.0) (f32.const 4.0))) ;; WRONG! mult_result is f64!
    (local.set $mult_result (f64.mul (f64.const 2.0) (f64.const 4.0)))

    ;; WebAssembly has some builtin operations, like basic math and bitshifting.
    ;; Notably, it does not have built in trigonometric functions.
    ;; In order to get access to these functions, we have to either
    ;; - implement them ourselves (not recommended)
    ;; - import them from elsewhere (later on)
  )

  ;; Functions
  ;; We specify arguments with the `param` keyword, and specify return values
  ;; with the `result` keyword
  ;; The current value on the stack is the return value of a function

  ;; We can call other functions we've defined with the `call` keyword

  (func $get_16 (result i32)
    (i32.const 16)
  )

  (func $add (param $param0 i32) (param $param1 i32) (result i32)
    (i32.add
      (local.get $param0)
      (local.get $param1)
    )
  )

  (func $double_16 (result i32)
    (i32.mul
      (i32.const 2)
      (call $get_16))
  )

  ;; Up until now, we haven't be able to print anything out, nor do we have
  ;; access to higher level math functions (pow, exp, or trig functions).
  ;; Moreover, we haven't been able to use any of the WASM functions in Javascript!
  ;; The way we get those functions into WebAssembly
  ;; looks different whether we're in a Node.js or browser environment.

  ;; If we're in Node.js we have to do two steps. First we have to convert the
  ;; WASM text representation into actual webassembly. If we're using Binyaren,
  ;; we can do that with a command like the following:

  ;; wasm-as learn-wasm.wast -o learn-wasm.wasm

  ;; We can apply Binaryen optimizations to that file with a command like the
  ;; following:

  ;; wasm-opt learn-wasm.wasm -o learn-wasm.opt.wasm -O3 --rse

  ;; With our compiled WebAssembly, we can now load it into Node.js:
  ;; const fs = require('fs')
  ;; const instantiate = async function (inFilePath, _importObject) {
  ;;  var importObject = {
  ;;     console: {
  ;;       log: (x) => console.log(x),
  ;;     },
  ;;     math: {
  ;;       cos: (x) => Math.cos(x),
  ;;     }
  ;;   }
  ;;  importObject = Object.assign(importObject, _importObject)
  ;;
  ;;  var buffer = fs.readFileSync(inFilePath)
  ;;  var module = await WebAssembly.compile(buffer)
  ;;  var instance = await WebAssembly.instantiate(module, importObject)
  ;;  return instance.exports
  ;; }
  ;;
  ;; const main = function () {
  ;;   var wasmExports = await instantiate('learn-wasm.wasm')
  ;;   wasmExports.print_args(1, 0)
  ;; }

  ;; The following snippet gets the functions from the importObject we defined
  ;; in the JavaScript instantiate async function, and then exports a function
  ;; ""print_args"" that we can call from Node.js

  (import ""console"" ""log"" (func $print_i32 (param i32)))
  (import ""math"" ""cos"" (func $cos (param f64) (result f64)))

  (func $print_args (param $arg0 i32) (param $arg1 i32)
    (call $print_i32 (local.get $arg0))
    (call $print_i32 (local.get $arg1))
  )
  (export ""print_args"" (func $print_args))

  ;; Loading in data from WebAssembly memory.
  ;; Say that we want to apply the cosine function to a Javascript array.
  ;; We need to be able to access the allocated array, and iterate through it.
  ;; This example will modify the input array inplace.
  ;; f64.load and f64.store expect the location of a number in memory *in bytes*.
  ;; If we want to access the 3rd element of an array, we have to pass something
  ;; like (i32.mul (i32.const 8) (i32.const 2)) to the f64.store function.

  ;; In JavaScript, we would call `apply_cos64` as follows
  ;; (using the instantiate function from earlier):
  ;;
  ;; const main = function () {
  ;;   var wasm = await instantiate('learn-wasm.wasm')
  ;;   var n = 100
  ;;   const memory = new Float64Array(wasm.memory.buffer, 0, n)
  ;;   for (var i=0; i<n; i++) {
  ;;     memory[i] = i;
  ;;   }
  ;;   wasm.apply_cos64(n)
  ;; }
  ;;
  ;; This function will not work if we allocate a Float32Array on the JavaScript
  ;; side.

  (memory (export ""memory"") 100)

  (func $apply_cos64 (param $array_length i32)
    ;; declare the loop counter
    (local $idx i32)
    ;; declare the counter that will allow us to access memory
    (local $idx_bytes i32)
    ;; constant expressing the number of bytes in a f64 number.
    (local $bytes_per_double i32)

    ;; declare a variable for storing the value loaded from memory
    (local $temp_f64 f64)

    (local.set $idx (i32.const 0))
    (local.set $idx_bytes (i32.const 0)) ;; not entirely necessary
    (local.set $bytes_per_double (i32.const 8))

    (block
      (loop
        ;; this sets idx_bytes to bytes offset of the value we're interested in.
        (local.set $idx_bytes (i32.mul (local.get $idx) (local.get $bytes_per_double)))

        ;; get the value of the array from memory:
        (local.set $temp_f64 (f64.load (local.get $idx_bytes)))

        ;; now apply the cosine function:
        (local.set $temp_64 (call $cos (local.get $temp_64)))

        ;; now store the result at the same location in memory:
        (f64.store
          (local.get $idx_bytes)
          (local.get $temp_64))

        ;; do it all in one step instead
        (f64.store
          (local.get $idx_bytes)
          (call $cos
            (f64.load
              (local.get $idx_bytes))))

        ;; increment the loop counter
        (local.set $idx (i32.add (local.get $idx) (i32.const 1)))

        ;; stop the loop if the loop counter is equal the array length
        (br_if 1 (i32.eq (local.get $idx) (local.get $array_length)))
        (br 0)
      )
    )
  )
  (export ""apply_cos64"" (func $apply_cos64))

  ;; Wasm is a stack-based language, but for returning values more complicated
  ;; than an int/float, a separate memory stack has to be manually managed. One
  ;; approach is to use a mutable global to store the stack_ptr. We give
  ;; ourselves 1MiB of memstack and grow it downwards.
  ;;
  ;; Below is a demonstration of how this C code **might** be written by hand
  ;;
  ;;   typedef struct {
  ;;       int a;
  ;;       int b;
  ;;   } sum_struct_t;
  ;;
  ;;   sum_struct_t sum_struct_create(int a, int b) {
  ;;     return (sum_struct_t){a, b};
  ;;   }
  ;;
  ;;   int sum_local() {
  ;;     sum_struct_t s = sum_struct_create(40, 2);
  ;;     return s.a + s.b;
  ;;   }

  ;; Unlike C, we must manage our own memory stack. We reserve 1MiB
  (global $memstack_ptr (mut i32) (i32.const 65536))

  ;; Structs can only be returned by reference
  (func $sum_struct_create 
        (param $sum_struct_ptr i32) 
        (param $var$a i32) 
        (param $var$b i32)
    ;; c// sum_struct_ptr->a = a;
    (i32.store
      (get_local $sum_struct_ptr)
      (get_local $var$a)
    )

    ;; c// sum_struct_ptr->b = b;
    (i32.store offset=4
      (get_local $sum_struct_ptr)
      (get_local $var$b)
    )
  )

  (func $sum_local (result i32)
    (local $var$sum_struct$a i32)
    (local $var$sum_struct$b i32)
    (local $local_memstack_ptr i32)

    ;; reserve memstack space
    (i32.sub
      (get_global $memstack_ptr)
      (i32.const 8)
    )
    tee_local $local_memstack_ptr ;; tee both stores and returns given value
    set_global $memstack_ptr

    ;; call the function, storing the result in the memstack
    (call $sum_struct_create
      ((;$sum_struct_ptr=;) get_local $local_memstack_ptr)
      ((;$var$a=;) i32.const 40)
      ((;$var$b=;) i32.const 2)
    )

    ;; retrieve values from struct
    (set_local $var$sum_struct$a
      (i32.load offset=0 (get_local $local_memstack_ptr))
    )
    (set_local $var$sum_struct$b
      (i32.load offset=4 (get_local $local_memstack_ptr))
    )

    ;; unreserve memstack space
    (set_global $memstack_ptr
        (i32.add
          (get_local $local_memstack_ptr)
          (i32.const 8)
        )
    )

    (i32.add
      (get_local $var$sum_struct$a)
      (get_local $var$sum_struct$b)
    )
  )
  (export ""sum_local"" (func $sum_local))
)

```"
"Factor is a modern stack-based language, based on Forth, created by Slava Pestov.

Code in this file can be typed into Factor, but not directly imported because the vocabulary and import header would make the beginning thoroughly confusing.

```factor
! This is a comment

! Like Forth, all programming is done by manipulating the stack.
! Stating a literal value pushes it onto the stack.
5 2 3 56 76 23 65    ! No output, but stack is printed out in interactive mode

! Those numbers get added to the stack, from left to right.
! .s prints out the stack non-destructively.
.s     ! 5 2 3 56 76 23 65

! Arithmetic works by manipulating data on the stack.
5 4 +    ! No output

! `.` pops the top result from the stack and prints it.
.    ! 9

! More examples of arithmetic:
6 7 * .        ! 42
1360 23 - .    ! 1337
12 12 / .      ! 1
13 2 mod .     ! 1

99 neg .       ! -99
-99 abs .      ! 99
52 23 max .    ! 52
52 23 min .    ! 23

! A number of words are provided to manipulate the stack, collectively known as shuffle words.

3 dup -          ! duplicate the top item (1st now equals 2nd): 3 - 3
2 5 swap /       ! swap the top with the second element:        5 / 2
4 0 drop 2 /     ! remove the top item (don't print to screen):  4 / 2
1 2 3 nip .s     ! remove the second item (similar to drop):    1 3
1 2 clear .s     ! wipe out the entire stack
1 2 3 4 over .s  ! duplicate the second item to the top: 1 2 3 4 3
1 2 3 4 2 pick .s ! duplicate the third item to the top: 1 2 3 4 2 3

! Creating Words
! The `:` word sets Factor into compile mode until it sees the `;` word.
: square ( n -- n ) dup * ;    ! No output
5 square .                     ! 25

! We can view what a word does too.
! \ suppresses evaluation of a word and pushes its identifier on the stack instead.
\ square see    ! : square ( n -- n ) dup * ;

! After the name of the word to create, the declaration between brackets gives the stack effect.
! We can use whatever names we like inside the declaration:
: weirdsquare ( camel -- llama ) dup * ;

! Provided their count matches the word's stack effect:
: doubledup ( a -- b ) dup dup ; ! Error: Stack effect declaration is wrong
: doubledup ( a -- a a a ) dup dup ; ! Ok
: weirddoubledup ( i -- am a fish ) dup dup ; ! Also Ok

! Where Factor differs from Forth is in the use of quotations.
! A quotation is a block of code that is pushed on the stack as a value.
! [ starts quotation mode; ] ends it.
[ 2 + ]       ! Quotation that adds 2 is left on the stack
4 swap call . ! 6

! And thus, higher order words. TONS of higher order words.
2 3 [ 2 + ] dip .s      ! Pop top stack value, run quotation, push it back: 4 3
3 4 [ + ] keep .s       ! Copy top stack value, run quotation, push the copy: 7 4
1 [ 2 + ] [ 3 + ] bi .s ! Run each quotation on the top value, push both results: 3 4
4 3 1 [ + ] [ + ] bi .s ! Quotations in a bi can pull values from deeper on the stack: 4 5 ( 1+3 1+4 )
1 2 [ 2 + ] bi@ .s      ! Run the quotation on first and second values
2 [ + ] curry           ! Inject the given value at the start of the quotation: [ 2 + ] is left on the stack

! Conditionals
! Any value is true except the built-in value f.
! A built-in value t does exist, but its use isn't essential.
! Conditionals are higher order words as with the combinators above.

5 [ ""Five is true"" . ] when                     ! Five is true
0 [ ""Zero is true"" . ] when                     ! Zero is true
f [ ""F is true"" . ] when                        ! No output
f [ ""F is false"" . ] unless                     ! F is false
2 [ ""Two is true"" . ] [ ""Two is false"" . ] if   ! Two is true

! By default the conditionals consume the value under test, but starred variants
! leave it alone if it's true:

5 [ . ] when*      ! 5
f [ . ] when*      ! No output, empty stack, f is consumed because it's false


! Loops
! You've guessed it.. these are higher order words too.

5 [ . ] each-integer               ! 0 1 2 3 4
4 3 2 1 0 5 [ + . ] each-integer   ! 0 2 4 6 8
5 [ ""Hello"" . ] times              ! Hello Hello Hello Hello Hello

! Here's a list:
{ 2 4 6 8 }                        ! Goes on the stack as one item

! Loop through the list:
{ 2 4 6 8 } [ 1 + . ] each          ! Prints 3 5 7 9
{ 2 4 6 8 } [ 1 + ] map             ! Leaves { 3 5 7 9 } on stack

! Loop reducing or building lists:
{ 1 2 3 4 5 } [ 2 mod 0 = ] filter  ! Keeps only list members for which quotation yields true: { 2 4 }  
{ 2 4 6 8 } 0 [ + ] reduce .        ! Like ""fold"" in functional languages: prints 20 (0+2+4+6+8)
{ 2 4 6 8 } 0 [ + ] accumulate . .  ! Like reduce but keeps the intermediate values in a list: prints { 0 2 6 12 } then 20
1 5 [ 2 * dup ] replicate .         ! Loops the quotation 5 times and collects the results in a list: { 2 4 8 16 32 }
1 [ dup 100 < ] [ 2 * dup ] produce ! Loops the second quotation until the first returns false and collects the results: { 2 4 8 16 32 64 128 }

! If all else fails, a general purpose while loop:
1 [ dup 10 < ] [ ""Hello"" . 1 + ] while  ! Prints ""Hello"" 10 times
                                        ! Yes, it's hard to read
                                        ! That's what all those variant loops are for

! Variables
! Usually Factor programs are expected to keep all data on the stack.
! Using named variables makes refactoring harder (and it's called Factor for a reason)
! Global variables, if you must:

SYMBOL: name            ! Creates name as an identifying word
""Bob"" name set-global   ! No output
name get-global .       ! ""Bob""                     

! Named local variables are considered an extension but are available
! In a quotation..
[| m n                  ! Quotation captures top two stack values into m and n
 | m n + ]              ! Read them

! Or in a word..
:: lword ( -- )           ! Note double colon to invoke lexical variable extension
   2 :> c                 ! Declares immutable variable c to hold 2
   c . ;                  ! Print it out

! In a word declared this way,  the input side of the stack declaration
! becomes meaningful and gives the variable names stack values are captured into
:: double ( a -- result ) a 2 * ;

! Variables are declared mutable by ending their name with a shriek
:: mword2 ( a! -- x y )   ! Capture top of stack in mutable variable a
   a                      ! Push a
   a 2 * a!               ! Multiply a by 2 and store result back in a
   a ;                    ! Push new value of a
5 mword2                  ! Stack: 5 10

! Lists and Sequences
! We saw above how to push a list onto the stack

0 { 1 2 3 4 } nth         ! Access a particular member of a list: 1
10 { 1 2 3 4 } nth        ! Error: sequence index out of bounds
1 { 1 2 3 4 } ?nth        ! Same as nth if index is in bounds: 2
10 { 1 2 3 4 } ?nth       ! No error if out of bounds: f

{ ""at"" ""the"" ""beginning"" } ""Append"" prefix    ! { ""Append"" ""at"" ""the"" ""beginning"" }
{ ""Append"" ""at"" ""the"" } ""end"" suffix          ! { ""Append"" ""at"" ""the"" ""end"" }
""in"" 1 { ""Insert"" ""the"" ""middle"" } insert-nth ! { ""Insert"" ""in"" ""the"" ""middle"" }
""Concat"" ""enate"" append                       ! ""Concatenate"" - strings are sequences too
""Concatenate"" ""Reverse "" prepend              ! ""Reverse Concatenate""
{ ""Concatenate "" ""seq "" ""of "" ""seqs"" } concat ! ""Concatenate seq of seqs""
{ ""Connect"" ""subseqs"" ""with"" ""separators"" } "" "" join  ! ""Connect subseqs with separators""

! And if you want to get meta, quotations are sequences and can be dismantled..
0 [ 2 + ] nth                              ! 2
1 [ 2 + ] nth                              ! +
[ 2 + ] \ - suffix                         ! Quotation [ 2 + - ]


```

##Ready For More?

* [Factor Documentation](http://docs.factorcode.org/content/article-help.home.html)"
"F# is a general purpose functional/OO programming language.  It's free and open source, and runs on Linux, Mac, Windows and more.

It has a powerful type system that traps many errors at compile time, but it uses type inference so that it reads more like a dynamic language.

The syntax of F# is different from C-style languages:

* Curly braces are not used to delimit blocks of code. Instead, indentation is used (like Python).
* Whitespace is used to separate parameters rather than commas.

If you want to try out the code below, you can go to [https://try.fsharp.org](https://try.fsharp.org) and paste it into an interactive REPL.

```csharp

// single line comments use a double slash
(* multi line comments use (* . . . *) pair

-end of multi line comment- *)

// ================================================
// Basic Syntax
// ================================================

// ------ ""Variables"" (but not really) ------
// The ""let"" keyword defines an (immutable) value
let myInt = 5
let myFloat = 3.14
let myString = ""hello""           // note that no types needed

// ------ Lists ------
let twoToFive = [2; 3; 4; 5]     // Square brackets create a list with
                                 // semicolon delimiters.
let oneToFive = 1 :: twoToFive   // :: creates list with new 1st element
// The result is [1; 2; 3; 4; 5]
let zeroToFive = [0; 1] @ twoToFive   // @ concats two lists

// IMPORTANT: commas are never used as delimiters, only semicolons!

// ------ Functions ------
// The ""let"" keyword also defines a named function.
let square x = x * x          // Note that no parens are used.
square 3                      // Now run the function. Again, no parens.

let add x y = x + y           // don't use add (x,y)! It means something
                              // completely different.
add 2 3                       // Now run the function.

// to define a multiline function, just use indents. No semicolons needed.
let evens list =
   let isEven x = x % 2 = 0   // Define ""isEven"" as a sub function. Note
                              // that equality operator is single char ""="".
   List.filter isEven list    // List.filter is a library function
                              // with two parameters: a boolean function
                              // and a list to work on

evens oneToFive               // Now run the function

// You can use parens to clarify precedence. In this example,
// do ""map"" first, with two args, then do ""sum"" on the result.
// Without the parens, ""List.map"" would be passed as an arg to List.sum
let sumOfSquaresTo100 =
   List.sum ( List.map square [1..100] )

// You can pipe the output of one operation to the next using ""|>""
// Piping data around is very common in F#, similar to UNIX pipes.

// Here is the same sumOfSquares function written using pipes
let sumOfSquaresTo100piped =
   [1..100] |> List.map square |> List.sum  // ""square"" was defined earlier

// you can define lambdas (anonymous functions) using the ""fun"" keyword
let sumOfSquaresTo100withFun =
   [1..100] |> List.map (fun x -> x * x) |> List.sum

// In F# there is no ""return"" keyword. A function always
// returns the value of the last expression used.

// ------ Pattern Matching ------
// Match..with.. is a supercharged case/switch statement.
let simplePatternMatch =
   let x = ""a""
   match x with
    | ""a"" -> printfn ""x is a""
    | ""b"" -> printfn ""x is b""
    | _ -> printfn ""x is something else""   // underscore matches anything

// F# doesn't allow nulls by default -- you must use an Option type
// and then pattern match.
// Some(..) and None are roughly analogous to Nullable wrappers
let validValue = Some(99)
let invalidValue = None

// In this example, match..with matches the ""Some"" and the ""None"",
// and also unpacks the value in the ""Some"" at the same time.
let optionPatternMatch input =
   match input with
    | Some i -> printfn ""input is an int=%d"" i
    | None -> printfn ""input is missing""

optionPatternMatch validValue
optionPatternMatch invalidValue

// ------ Printing ------
// The printf/printfn functions are similar to the
// Console.Write/WriteLine functions in C#.
printfn ""Printing an int %i, a float %f, a bool %b"" 1 2.0 true
printfn ""A string %s, and something generic %A"" ""hello"" [1; 2; 3; 4]

// There are also sprintf/sprintfn functions for formatting data
// into a string, similar to String.Format in C#.

// ================================================
// More on functions
// ================================================

// F# is a true functional language -- functions are first
// class entities and can be combined easily to make powerful
// constructs

// Modules are used to group functions together
// Indentation is needed for each nested module.
module FunctionExamples =

    // define a simple adding function
    let add x y = x + y

    // basic usage of a function
    let a = add 1 2
    printfn ""1 + 2 = %i"" a

    // partial application to ""bake in"" parameters
    let add42 = add 42
    let b = add42 1
    printfn ""42 + 1 = %i"" b

    // composition to combine functions
    let add1 = add 1
    let add2 = add 2
    let add3 = add1 >> add2
    let c = add3 7
    printfn ""3 + 7 = %i"" c

    // higher order functions
    [1..10] |> List.map add3 |> printfn ""new list is %A""

    // lists of functions, and more
    let add6 = [add1; add2; add3] |> List.reduce (>>)
    let d = add6 7
    printfn ""1 + 2 + 3 + 7 = %i"" d

// ================================================
// Lists and collection
// ================================================

// There are three types of ordered collection:
// * Lists are most basic immutable collection.
// * Arrays are mutable and more efficient when needed.
// * Sequences are lazy and infinite (e.g. an enumerator).
//
// Other collections include immutable maps and sets
// plus all the standard .NET collections

module ListExamples =

    // lists use square brackets
    let list1 = [""a""; ""b""]
    let list2 = ""c"" :: list1    // :: is prepending
    let list3 = list1 @ list2   // @ is concat

    // list comprehensions (aka generators)
    let squares = [for i in 1..10 do yield i * i]

    // A prime number generator
    // - this is using a short notation for the pattern matching syntax
    // - (p::xs) is 'first :: tail' of the list, could also be written as p :: xs
    //   this means this matches 'p' (the first item in the list), and xs is the rest of the list
    //   this is called the 'cons pattern'
    // - uses 'rec' keyword, which is necessary when using recursion
    let rec sieve = function
        | (p::xs) -> p :: sieve [ for x in xs do if x % p > 0 then yield x ]
        | []      -> []
    let primes = sieve [2..50]
    printfn ""%A"" primes

    // pattern matching for lists
    let listMatcher aList =
        match aList with
        | [] -> printfn ""the list is empty""
        | [first] -> printfn ""the list has one element %A "" first
        | [first; second] -> printfn ""list is %A and %A"" first second
        | first :: _ -> printfn ""the list has more than two elements, first element %A"" first

    listMatcher [1; 2; 3; 4]
    listMatcher [1; 2]
    listMatcher [1]
    listMatcher []

    // recursion using lists
    let rec sum aList =
        match aList with
        | [] -> 0
        | x::xs -> x + sum xs
    sum [1..10]

    // -----------------------------------------
    // Standard library functions
    // -----------------------------------------

    // map
    let add3 x = x + 3
    [1..10] |> List.map add3

    // filter
    let even x = x % 2 = 0
    [1..10] |> List.filter even

    // many more -- see documentation

module ArrayExamples =

    // arrays use square brackets with bar
    let array1 = [| ""a""; ""b"" |]
    let first = array1.[0]        // indexed access using dot

    // pattern matching for arrays is same as for lists
    let arrayMatcher aList =
        match aList with
        | [| |] -> printfn ""the array is empty""
        | [| first |] -> printfn ""the array has one element %A "" first
        | [| first; second |] -> printfn ""array is %A and %A"" first second
        | _ -> printfn ""the array has more than two elements""

    arrayMatcher [| 1; 2; 3; 4 |]

    // Standard library functions just as for List

    [| 1..10 |]
    |> Array.map (fun i -> i + 3)
    |> Array.filter (fun i -> i % 2 = 0)
    |> Array.iter (printfn ""value is %i. "")


module SequenceExamples =

    // sequences use curly braces
    let seq1 = seq { yield ""a""; yield ""b"" }

    // sequences can use yield and
    // can contain subsequences
    let strange = seq {
        // ""yield"" adds one element
        yield 1; yield 2;

        // ""yield!"" adds a whole subsequence
        yield! [5..10]
        yield! seq {
            for i in 1..10 do
              if i % 2 = 0 then yield i }}
    // test
    strange |> Seq.toList


    // Sequences can be created using ""unfold""
    // Here's the fibonacci series
    let fib = Seq.unfold (fun (fst,snd) ->
        Some(fst + snd, (snd, fst + snd))) (0,1)

    // test
    let fib10 = fib |> Seq.take 10 |> Seq.toList
    printf ""first 10 fibs are %A"" fib10


// ================================================
// Data Types
// ================================================

module DataTypeExamples =

    // All data is immutable by default

    // Tuples are quick 'n easy anonymous types
    // -- Use a comma to create a tuple
    let twoTuple = 1, 2
    let threeTuple = ""a"", 2, true

    // Pattern match to unpack
    let x, y = twoTuple  // sets x = 1, y = 2

    // ------------------------------------
    // Record types have named fields
    // ------------------------------------

    // Use ""type"" with curly braces to define a record type
    type Person = {First:string; Last:string}

    // Use ""let"" with curly braces to create a record
    let person1 = {First=""John""; Last=""Doe""}

    // Pattern match to unpack
    let {First = first} = person1    // sets first=""John""

    // ------------------------------------
    // Union types (aka variants) have a set of choices
    // Only one case can be valid at a time.
    // ------------------------------------

    // Use ""type"" with bar/pipe to define a union type
    type Temp =
        | DegreesC of float
        | DegreesF of float

    // Use one of the cases to create one
    let temp1 = DegreesF 98.6
    let temp2 = DegreesC 37.0

    // Pattern match on all cases to unpack
    let printTemp = function
       | DegreesC t -> printfn ""%f degC"" t
       | DegreesF t -> printfn ""%f degF"" t

    printTemp temp1
    printTemp temp2

    // ------------------------------------
    // Recursive types
    // ------------------------------------

    // Types can be combined recursively in complex ways
    // without having to create subclasses
    type Employee =
      | Worker of Person
      | Manager of Employee list

    let jdoe = {First=""John""; Last=""Doe""}
    let worker = Worker jdoe

    // ------------------------------------
    // Modeling with types
    // ------------------------------------

    // Union types are great for modeling state without using flags
    type EmailAddress =
        | ValidEmailAddress of string
        | InvalidEmailAddress of string

    let trySendEmail email =
        match email with // use pattern matching
        | ValidEmailAddress address -> ()   // send
        | InvalidEmailAddress address -> () // don't send

    // The combination of union types and record types together
    // provide a great foundation for domain driven design.
    // You can create hundreds of little types that accurately
    // reflect the domain.

    type CartItem = { ProductCode: string; Qty: int }
    type Payment = Payment of float
    type ActiveCartData = { UnpaidItems: CartItem list }
    type PaidCartData = { PaidItems: CartItem list; Payment: Payment}

    type ShoppingCart =
        | EmptyCart  // no data
        | ActiveCart of ActiveCartData
        | PaidCart of PaidCartData

    // ------------------------------------
    // Built in behavior for types
    // ------------------------------------

    // Core types have useful ""out-of-the-box"" behavior, no coding needed.
    // * Immutability
    // * Pretty printing when debugging
    // * Equality and comparison
    // * Serialization

    // Pretty printing using %A
    printfn ""twoTuple=%A,\nPerson=%A,\nTemp=%A,\nEmployee=%A""
             twoTuple person1 temp1 worker

    // Equality and comparison built in.
    // Here's an example with cards.
    type Suit = Club | Diamond | Spade | Heart
    type Rank = Two | Three | Four | Five | Six | Seven | Eight
                | Nine | Ten | Jack | Queen | King | Ace

    let hand = [ Club, Ace; Heart, Three; Heart, Ace;
                 Spade, Jack; Diamond, Two; Diamond, Ace ]

    // sorting
    List.sort hand |> printfn ""sorted hand is (low to high) %A""
    List.max hand |> printfn ""high card is %A""
    List.min hand |> printfn ""low card is %A""


// ================================================
// Active patterns
// ================================================

module ActivePatternExamples =

    // F# has a special type of pattern matching called ""active patterns""
    // where the pattern can be parsed or detected dynamically.

    // ""banana clips"" are the syntax for active patterns

    // You can use ""elif"" instead of ""else if"" in conditional expressions.
    // They are equivalent in F#

    // for example, define an ""active"" pattern to match character types...
    let (|Digit|Letter|Whitespace|Other|) ch =
       if System.Char.IsDigit(ch) then Digit
       elif System.Char.IsLetter(ch) then Letter
       elif System.Char.IsWhiteSpace(ch) then Whitespace
       else Other

    // ... and then use it to make parsing logic much clearer
    let printChar ch =
      match ch with
      | Digit -> printfn ""%c is a Digit"" ch
      | Letter -> printfn ""%c is a Letter"" ch
      | Whitespace -> printfn ""%c is a Whitespace"" ch
      | _ -> printfn ""%c is something else"" ch

    // print a list
    ['a'; 'b'; '1'; ' '; '-'; 'c'] |> List.iter printChar

    // -----------------------------------
    // FizzBuzz using active patterns
    // -----------------------------------

    // You can create partial matching patterns as well
    // Just use underscore in the definition, and return Some if matched.
    let (|MultOf3|_|) i = if i % 3 = 0 then Some MultOf3 else None
    let (|MultOf5|_|) i = if i % 5 = 0 then Some MultOf5 else None

    // the main function
    let fizzBuzz i =
      match i with
      | MultOf3 & MultOf5 -> printf ""FizzBuzz, ""
      | MultOf3 -> printf ""Fizz, ""
      | MultOf5 -> printf ""Buzz, ""
      | _ -> printf ""%i, "" i

    // test
    [1..20] |> List.iter fizzBuzz

// ================================================
// Conciseness
// ================================================

module AlgorithmExamples =

    // F# has a high signal/noise ratio, so code reads
    // almost like the actual algorithm

    // ------ Example: define sumOfSquares function ------
    let sumOfSquares n =
       [1..n]              // 1) take all the numbers from 1 to n
       |> List.map square  // 2) square each one
       |> List.sum         // 3) sum the results

    // test
    sumOfSquares 100 |> printfn ""Sum of squares = %A""

    // ------ Example: define a sort function ------
    let rec sort list =
       match list with
       // If the list is empty
       | [] ->
            []                            // return an empty list
       // If the list is not empty
       | firstElem::otherElements ->      // take the first element
            let smallerElements =         // extract the smaller elements
                otherElements             // from the remaining ones
                |> List.filter (fun e -> e < firstElem)
                |> sort                   // and sort them
            let largerElements =          // extract the larger ones
                otherElements             // from the remaining ones
                |> List.filter (fun e -> e >= firstElem)
                |> sort                   // and sort them
            // Combine the 3 parts into a new list and return it
            List.concat [smallerElements; [firstElem]; largerElements]

    // test
    sort [1; 5; 23; 18; 9; 1; 3] |> printfn ""Sorted = %A""

// ================================================
// Asynchronous Code
// ================================================

module AsyncExample =

    // F# has built-in features to help with async code
    // without encountering the ""pyramid of doom""
    //
    // The following example downloads a set of web pages in parallel.

    open System.Net
    open System
    open System.IO
    open Microsoft.FSharp.Control.CommonExtensions

    // Fetch the contents of a URL asynchronously
    let fetchUrlAsync url =
        async {   // ""async"" keyword and curly braces
                  // creates an ""async"" object
            let req = WebRequest.Create(Uri(url))
            use! resp = req.AsyncGetResponse()
                // use! is async assignment
            use stream = resp.GetResponseStream()
                // ""use"" triggers automatic close()
                // on resource at end of scope
            use reader = new IO.StreamReader(stream)
            let html = reader.ReadToEnd()
            printfn ""finished downloading %s"" url
            }

    // a list of sites to fetch
    let sites = [""http://www.bing.com"";
                 ""http://www.google.com"";
                 ""http://www.microsoft.com"";
                 ""http://www.amazon.com"";
                 ""http://www.yahoo.com""]

    // do it
    sites
    |> List.map fetchUrlAsync  // make a list of async tasks
    |> Async.Parallel          // set up the tasks to run in parallel
    |> Async.RunSynchronously  // start them off

// ================================================
// .NET compatibility
// ================================================

module NetCompatibilityExamples =

    // F# can do almost everything C# can do, and it integrates
    // seamlessly with .NET or Mono libraries.

    // ------- work with existing library functions  -------

    let (i1success, i1) = System.Int32.TryParse(""123"");
    if i1success then printfn ""parsed as %i"" i1 else printfn ""parse failed""

    // ------- Implement interfaces on the fly! -------

    // create a new object that implements IDisposable
    let makeResource name =
       { new System.IDisposable
         with member this.Dispose() = printfn ""%s disposed"" name }

    let useAndDisposeResources =
        use r1 = makeResource ""first resource""
        printfn ""using first resource""
        for i in [1..3] do
            let resourceName = sprintf ""\tinner resource %d"" i
            use temp = makeResource resourceName
            printfn ""\tdo something with %s"" resourceName
        use r2 = makeResource ""second resource""
        printfn ""using second resource""
        printfn ""done.""

    // ------- Object oriented code -------

    // F# is also a fully fledged OO language.
    // It supports classes, inheritance, virtual methods, etc.

    // interface with generic type
    type IEnumerator<'a> =
        abstract member Current : 'a
        abstract MoveNext : unit -> bool

    // abstract base class with virtual methods
    [<AbstractClass>]
    type Shape() =
        // readonly properties
        abstract member Width : int with get
        abstract member Height : int with get
        // non-virtual method
        member this.BoundingArea = this.Height * this.Width
        // virtual method with base implementation
        abstract member Print : unit -> unit
        default this.Print () = printfn ""I'm a shape""

    // concrete class that inherits from base class and overrides
    type Rectangle(x:int, y:int) =
        inherit Shape()
        override this.Width = x
        override this.Height = y
        override this.Print ()  = printfn ""I'm a Rectangle""

    // test
    let r = Rectangle(2, 3)
    printfn ""The width is %i"" r.Width
    printfn ""The area is %i"" r.BoundingArea
    r.Print()

    // ------- extension methods  -------

    // Just as in C#, F# can extend existing classes with extension methods.
    type System.String with
       member this.StartsWithA = this.StartsWith ""A""

    // test
    let s = ""Alice""
    printfn ""'%s' starts with an 'A' = %A"" s s.StartsWithA

    // ------- events  -------

    type MyButton() =
        let clickEvent = new Event<_>()

        [<CLIEvent>]
        member this.OnClick = clickEvent.Publish

        member this.TestEvent(arg) =
            clickEvent.Trigger(this, arg)

    // test
    let myButton = new MyButton()
    myButton.OnClick.Add(fun (sender, arg) ->
            printfn ""Click event with arg=%O"" arg)

    myButton.TestEvent(""Hello World!"")

```

## More Information

For more demonstrations of F#, go to my [why use F#](http://fsharpforfunandprofit.com/why-use-fsharp/) series.

Read more about F# at [fsharp.org](http://fsharp.org/) and [dotnet's F# page](https://dotnet.microsoft.com/languages/fsharp)."
"The q language and its database component kdb+ were developed by Arthur Whitney
and released by Kx systems in 2003. q is a descendant of APL and as such is
very terse and a little strange looking for anyone from a ""C heritage"" language
background. Its expressiveness and vector oriented nature make it well suited
to performing complex calculations on large amounts of data (while also
encouraging some amount of [code
golf](https://en.wikipedia.org/wiki/Code_golf)). The fundamental structure in
the language is not the object but instead the list, and tables are built as
collections of lists. This means - unlike most traditional RDBMS systems -
tables are column oriented.  The language has both an in-memory and on-disk
database built in, giving a large amount of flexibility. kdb+ is most widely
used in the world of finance to store, analyze, process and retrieve large
time-series data sets.

The terms *q* and *kdb+* are usually used interchangeably, as the two are not
separable so this distinction is not really useful.

All Feedback welcome!  You can reach me at matt.doherty@aquaq.co.uk, or Jonny
at jonny.press@aquaq.co.uk

To learn more about kdb+ you can join the [Personal kdb+](https://groups.google.com/forum/#!forum/personal-kdbplus) or [TorQ kdb+](https://groups.google.com/forum/#!forum/kdbtorq) group.

```
/ Single line comments start with a forward-slash
/ These can also be used in-line, so long as at least one whitespace character
/ separates it from text to the left
/
  A forward-slash on a line by itself starts a multiline comment
  and a backward-slash on a line by itself terminates it
\

/ Run this file in an empty directory


////////////////////////////////////
// Basic Operators and Datatypes  //
////////////////////////////////////

/ We have integers, which are 8 byte by default
3 / => 3

/ And floats, also 8 byte as standard.  Trailing f distinguishes from int
3.0 / => 3f

/ 4 byte numerical types can also be specified with trailing chars
3i / => 3i
3.0e / => 3e

/ Math is mostly what you would expect
1+1 / => 2
8-1 / => 7
10*2 / => 20
/ Except division, which uses percent (%) instead of forward-slash (/)
35%5 / => 7f  (the result of division is always a float)

/ For integer division we have the keyword div
4 div 3 / => 1

/ Modulo also uses a keyword, since percent (%) is taken
4 mod 3 / => 1

/ And exponentiation...
2 xexp 4 / => 16

/ ...and truncating...
floor 3.14159 / => 3

/ ...getting the absolute value...
abs -3.14159 / => 3.14159
/ ...and many other things
/ see http://code.kx.com/q/ref/card/ for more

/ q has no operator precedence, everything is evaluated right to left
/ so results like this might take some getting used to
2*1+1 / => 4 / (no operator precedence tables to remember!)

/ Precedence can be modified with parentheses (restoring the 'normal' result)
(2*1)+1 / => 3

/ Assignment uses colon (:) instead of equals (=)
/ No need to declare variables before assignment
a:3
a / => 3

/ Variables can also be assigned in-line
/ this does not affect the value passed on
c:3+b:2+a:1 / (data ""flows"" from right to left)
a / => 1
b / => 3
c / => 6

/ In-place operations are also as you might expect
a+:2
a / => 3

/ There are no ""true"" or ""false"" keywords in q
/ boolean values are indicated by the bit value followed by b
1b / => true value
0b / => false value

/ Equality comparisons use equals (=) (since we don't need it for assignment)
1=1 / => 1b
2=1 / => 0b

/ Inequality uses <>
1<>1 / => 0b
2<>1 / => 1b

/ The other comparisons are as you might expect
1<2 / => 1b
1>2 / => 0b
2<=2 / => 1b
2>=2 / => 1b

/ Comparison is not strict with regard to types...
42=42.0 / => 1b

/ ...unless we use the match operator (~)
/ which only returns true if entities are identical
42~42.0 / => 0b

/ The not operator returns true if the underlying value is zero
not 0b / => 1b
not 1b / => 0b
not 42 / => 0b
not 0.0 / => 1b

/ The max operator (|) reduces to logical ""or"" for bools
42|2.0 / => 42f
1b|0b / => 1b

/ The min operator (&) reduces to logical ""and"" for bools
42&2.0 / => 2f
1b&0b / => 0b

/ q provides two ways to store character data
/ Chars in q are stored in a single byte and use double-quotes ("")
ch:""a""
/ Strings are simply lists of char (more on lists later)
str:""This is a string""
/ Escape characters work as normal
str:""This is a string with \""quotes\""""

/ Char data can also be stored as symbols using backtick (`)
symbol:`sym
/ Symbols are NOT LISTS, they are an enumeration
/ the q process stores internally a vector of strings
/ symbols are enumerated against this vector
/ this can be more space and speed efficient as these are constant width

/ The string function converts to strings
string `symbol / => ""symbol""
string 1.2345 / => ""1.2345""

/ q has a time type...
t:01:00:00.000
/ date type...
d:2015.12.25
/ and a datetime type (among other time types)
dt:2015.12.25D12:00:00.000000000

/ These support some arithmetic for easy manipulation
dt + t / => 2015.12.25D13:00:00.000000000
t - 00:10:00.000 / => 00:50:00.000
/ and can be decomposed using dot notation
d.year / => 2015i
d.mm / => 12i
d.dd / => 25i
/ see http://code.kx.com/q4m3/2_Basic_Data_Types_Atoms/#25-temporal-data for more

/ q also has an infinity value so div by zero will not throw an error
1%0 / => 0w
-1%0 / => -0w

/ And null types for representing missing values
0N / => null int
0n / => null float
/ see http://code.kx.com/q4m3/2_Basic_Data_Types_Atoms/#27-nulls for more

/ q has standard control structures
/ if is as you might expect (; separates the condition and instructions)
if[1=1;a:""hi""]
a / => ""hi""
/ if-else uses $ (and unlike if, returns a value)
$[1=0;a:""hi"";a:""bye""] / => ""bye""
a / => ""bye""
/ if-else can be extended to multiple clauses by adding args separated by ;
$[1=0;a:""hi"";0=1;a:""bye"";a:""hello again""]
a / => ""hello again""


////////////////////////////////////
////      Data Structures       ////
////////////////////////////////////

/ q is not an object oriented language
/ instead complexity is built through ordered lists
/ and mapping them into higher order structures: dictionaries and tables

/ Lists (or arrays if you prefer) are simple ordered collections
/ they are defined using parentheses () and semi-colons (;)
(1;2;3) / => 1 2 3
(-10.0;3.14159e;1b;`abc;""c"")
/ => -10f
/ => 3.14159e
/ => 1b
/ => `abc
/ => ""c""  (mixed type lists are displayed on multiple lines)
((1;2;3);(4;5;6);(7;8;9))
/ => 1 2 3
/ => 4 5 6
/ => 7 8 9

/ Lists of uniform type can also be defined more concisely
1 2 3 / => 1 2 3
`list`of`syms / => `list`of`syms
`list`of`syms ~ (`list;`of;`syms) / => 1b

/ List length
count (1;2;3) / => 3
count ""I am a string"" / => 13 (string are lists of char)

/ Empty lists are defined with parentheses
l:()
count l / => 0

/ Simple variables and single item lists are not equivalent
/ parentheses syntax cannot create a single item list (they indicate precedence)
(1)~1 / => 1b
/ single item lists can be created using enlist
singleton:enlist 1
/ or appending to an empty list
singleton:(),1
1~(),1 / => 0b

/ Speaking of appending, comma (,) is used for this, not plus (+)
1 2 3,4 5 6 / => 1 2 3 4 5 6
""hello "",""there"" / => ""hello there""

/ Indexing uses square brackets []
l:1 2 3 4
l[0] / => 1
l[1] / => 2
/ indexing out of bounds returns a null value rather than an error
l[5] / => 0N
/ and indexed assignment
l[0]:5
l / => 5 2 3 4

/ Lists can also be used for indexing and indexed assignment
l[1 3] / => 2 4
l[1 3]: 1 3
l / => 5 1 3 3

/ Lists can be untyped/mixed type
l:(1;2;`hi)
/ but once they are uniformly typed, q will enforce this
l[2]:3
l / => 1 2 3
l[2]:`hi / throws a type error
/ this makes sense in the context of lists as table columns (more later)

/ For a nested list we can index at depth
l:((1;2;3);(4;5;6);(7;8;9))
l[1;1] / => 5

/ We can elide the indexes to return entire rows or columns
l[;1] / => 2 5 8
l[1;] / => 4 5 6

/ All the functions mentioned in the previous section work on lists natively
1+(1;2;3) / => 2 3 4 (single variable and list)
(1;2;3) - (3;2;1) / => -2 0 2 (list and list)

/ And there are many more that are designed specifically for lists
avg 1 2 3 / => 2f
sum 1 2 3 / => 6
sums 1 2 3 / => 1 3 6 (running sum)
last 1 2 3 / => 3
1 rotate 1 2 3 / => 2 3 1
/ etc.
/ Using and combining these functions to manipulate lists is where much of the
/ power and expressiveness of the language comes from

/ Take (#), drop (_) and find (?) are also useful working with lists
l:1 2 3 4 5 6 7 8 9
l:1+til 9 / til is a useful shortcut for generating ranges
/ take the first 5 elements
5#l / => 1 2 3 4 5
/ drop the first 5
5_l / => 6 7 8 9
/ take the last 5
-5#l / => 5 6 7 8 9
/ drop the last 5
-5_l / => 1 2 3 4
/ find the first occurrence of 4
l?4 / => 3
l[3] / => 4

/ Dictionaries in q are a generalization of lists
/ they map a list to another list (of equal length)
/ the bang (!) symbol is used for defining a dictionary
d:(`a;`b;`c)!(1;2;3)
/ or more simply with concise list syntax
d:`a`b`c!1 2 3
/ the keyword key returns the first list
key d / => `a`b`c
/ and value the second
value d / => 1 2 3

/ Indexing is identical to lists
/ with the first list as a key instead of the position
d[`a] / => 1
d[`b] / => 2

/ As is assignment
d[`c]:4
d
/ => a| 1
/ => b| 2
/ => c| 4

/ Arithmetic and comparison work natively, just like lists
e:(`a;`b;`c)!(2;3;4)
d+e
/ => a| 3
/ => b| 5
/ => c| 8
d-2
/ => a| -1
/ => b| 0
/ => c| 2
d > (1;1;1)
/ => a| 0
/ => b| 1
/ => c| 1

/ And the take, drop and find operators are remarkably similar too
`a`b#d
/ => a| 1
/ => b| 2
`a`b _ d
/ => c| 4
d?2
/ => `b

/ Tables in q are basically a subset of dictionaries
/ a table is a dictionary where all values must be lists of the same length
/ as such tables in q are column oriented (unlike most RDBMS)
/ the flip keyword is used to convert a dictionary to a table
/ i.e. flip the indices
flip `c1`c2`c3!(1 2 3;4 5 6;7 8 9)
/ => c1 c2 c3
/ => --------
/ => 1  4  7
/ => 2  5  8
/ => 3  6  9
/ we can also define tables using this syntax
t:([]c1:1 2 3;c2:4 5 6;c3:7 8 9)
t
/ => c1 c2 c3
/ => --------
/ => 1  4  7
/ => 2  5  8
/ => 3  6  9

/ Tables can be indexed and manipulated in a similar way to dicts and lists
t[`c1]
/ => 1 2 3
/ table rows are returned as dictionaries
t[1]
/ => c1| 2
/ => c2| 5
/ => c3| 8

/ meta returns table type information
meta t
/ => c | t f a
/ => --| -----
/ => c1| j
/ => c2| j
/ => c3| j
/ now we see why type is enforced in lists (to protect column types)
t[1;`c1]:3
t[1;`c1]:3.0 / throws a type error

/ Most traditional databases have primary key columns
/ in q we have keyed tables, where one table containing key columns
/ is mapped to another table using bang (!)
k:([]id:1 2 3)
k!t
/ => id| c1 c2 c3
/ => --| --------
/ => 1 | 1  4  7
/ => 2 | 3  5  8
/ => 3 | 3  6  9

/ We can also use this shortcut for defining keyed tables
kt:([id:1 2 3]c1:1 2 3;c2:4 5 6;c3:7 8 9)

/ Records can then be retrieved based on this key
kt[1]
/ => c1| 1
/ => c2| 4
/ => c3| 7
kt[`id!1]
/ => c1| 1
/ => c2| 4
/ => c3| 7


////////////////////////////////////
////////     Functions      ////////
////////////////////////////////////

/ In q the function is similar to a mathematical map, mapping inputs to outputs
/ curly braces {} are used for function definition
/ and square brackets [] for calling functions (just like list indexing)
/ a very minimal function
f:{x+x}
f[2] / => 4

/ Functions can be anonymous and called at point of definition
{x+x}[2] / => 4

/ By default the last expression is returned
/ colon (:) can be used to specify return
{x+x}[2] / => 4
{:x+x}[2] / => 4
/ semi-colon (;) separates expressions
{r:x+x;:r}[2] / => 4

/ Function arguments can be specified explicitly (separated by ;)
{[arg1;arg2] arg1+arg2}[1;2] / => 3
/ or if omitted will default to x, y and z
{x+y+z}[1;2;3] / => 6

/ Built in functions are no different, and can be called the same way (with [])
+[1;2] / => 3
<[1;2] / => 1b

/ Functions are first class in q, so can be returned, stored in lists etc.
{:{x+y}}[] / => {x+y}
(1;""hi"";{x+y})
/ => 1
/ => ""hi""
/ => {x+y}

/ There is no overloading and no keyword arguments for custom q functions
/ however using a dictionary as a single argument can overcome this
/ allows for optional arguments or differing functionality
d:`arg1`arg2`arg3!(1.0;2;""my function argument"")
{x[`arg1]+x[`arg2]}[d] / => 3f

/ Functions in q see the global scope
a:1
{:a}[] / => 1

/ However local scope obscures this
a:1
{a:2;:a}[] / => 2
a / => 1

/ Functions cannot see nested scopes (only local and global)
{local:1;{:local}[]}[] / throws error as local is not defined in inner function

/ A function can have one or more of its arguments fixed (projection)
f:+[4]
f[4] / => 8
f[5] / => 9
f[6] / => 10


////////////////////////////////////
//////////     q-sql      //////////
////////////////////////////////////

/ q has its own syntax for manipulating tables, similar to standard SQL
/ This contains the usual suspects of select, insert, update etc.
/ and some new functionality not typically available
/ q-sql has two significant differences (other than syntax) to normal SQL:
/ - q tables have well defined record orders
/ - tables are stored as a collection of columns
/   (so vectorized column operations are fast)
/ a full description of q-sql is a little beyond the scope of this intro
/ so we will just cover enough of the basics to get you going

/ First define ourselves a table
t:([]name:`Arthur`Thomas`Polly;age:35 32 52;height:180 175 160;sex:`m`m`f)

/ equivalent of SELECT * FROM t
select from t / (must be lower case, and the wildcard is not necessary)
/ => name   age height sex
/ => ---------------------
/ => Arthur 35  180    m
/ => Thomas 32  175    m
/ => Polly  52  160    f

/ Select specific columns
select name,age from t
/ => name   age
/ => ----------
/ => Arthur 35
/ => Thomas 32
/ => Polly  52

/ And name them (equivalent of using AS in standard SQL)
select charactername:name, currentage:age from t
/ => charactername currentage
/ => ------------------------
/ => Arthur        35
/ => Thomas        32
/ => Polly         52

/ This SQL syntax is integrated with the q language
/ so q can be used seamlessly in SQL statements
select name, feet:floor height*0.032, inches:12*(height*0.032) mod 1 from t
/ => name   feet inches
/ => ------------------
/ => Arthur 5    9.12
/ => Thomas 5    7.2
/ => Polly  5    1.44

/ Including custom functions
select name, growth:{[h;a]h%a}[height;age] from t
/ => name   growth
/ => ---------------
/ => Arthur 5.142857
/ => Thomas 5.46875
/ => Polly  3.076923

/ The where clause can contain multiple statements separated by commas
select from t where age>33,height>175
/ => name   age height sex
/ => ---------------------
/ => Arthur 35  180    m

/ The where statements are executed sequentially (not the same as logical AND)
select from t where age<40,height=min height
/ => name   age height sex
/ => ---------------------
/ => Thomas 32  175    m
select from t where (age<40)&(height=min height)
/ => name age height sex
/ => -------------------

/ The by clause falls between select and from
/ and is equivalent to SQL's GROUP BY
select avg height by sex from t
/ => sex| height
/ => ---| ------
/ => f  | 160
/ => m  | 177.5

/ If no aggregation function is specified, last is assumed
select by sex from t
/ => sex| name   age height
/ => ---| -----------------
/ => f  | Polly  52  160
/ => m  | Thomas 32  175

/ Update has the same basic form as select
update sex:`male from t where sex=`m
/ => name   age height sex
/ => ----------------------
/ => Arthur 35  180    male
/ => Thomas 32  175    male
/ => Polly  52  160    f

/ As does delete
delete from t where sex=`m
/ => name  age height sex
/ => --------------------
/ => Polly 52  160    f

/ None of these sql operations are carried out in place
t
/ => name   age height sex
/ => ---------------------
/ => Arthur 35  180    m
/ => Thomas 32  175    m
/ => Polly  52  160    f

/ Insert however is in place, it takes a table name, and new data
`t insert (`John;25;178;`m) / => ,3
t
/ => name   age height sex
/ => ---------------------
/ => Arthur 35  180    m
/ => Thomas 32  175    m
/ => Polly  52  160    f
/ => John   25  178    m

/ Upsert is similar (but doesn't have to be in-place)
t upsert (`Chester;58;179;`m)
/ => name    age height sex
/ => ----------------------
/ => Arthur  35  180    m
/ => Thomas  32  175    m
/ => Polly   52  160    f
/ => John    25  178    m
/ => Chester 58  179    m

/ it will also upsert dicts or tables
t upsert `name`age`height`sex!(`Chester;58;179;`m)
t upsert (`Chester;58;179;`m)
/ => name    age height sex
/ => ----------------------
/ => Arthur  35  180    m
/ => Thomas  32  175    m
/ => Polly   52  160    f
/ => John    25  178    m
/ => Chester 58  179    m

/ And if our table is keyed
kt:`name xkey t
/ upsert will replace records where required
kt upsert ([]name:`Thomas`Chester;age:33 58;height:175 179;sex:`f`m)
/ => name   | age height sex
/ => -------| --------------
/ => Arthur | 35  180    m
/ => Thomas | 33  175    f
/ => Polly  | 52  160    f
/ => John   | 25  178    m
/ => Chester| 58  179    m

/ There is no ORDER BY clause in q-sql, instead use xasc/xdesc
`name xasc t
/ => name   age height sex
/ => ---------------------
/ => Arthur 35  180    m
/ => John   25  178    m
/ => Polly  52  160    f
/ => Thomas 32  175    m

/ Most of the standard SQL joins are present in q-sql, plus a few new friends
/ see http://code.kx.com/q4m3/9_Queries_q-sql/#99-joins
/ the two most important (commonly used) are lj and aj

/ lj is basically the same as SQL LEFT JOIN
/ where the join is carried out on the key columns of the left table
le:([sex:`m`f]lifeexpectancy:78 85)
t lj le
/ => name   age height sex lifeexpectancy
/ => ------------------------------------
/ => Arthur 35  180    m   78
/ => Thomas 32  175    m   78
/ => Polly  52  160    f   85
/ => John   25  178    m   78

/ aj is an asof join.  This is not a standard SQL join, and can be very powerful
/ The canonical example of this is joining financial trades and quotes tables
trades:([]time:10:01:01 10:01:03 10:01:04;sym:`msft`ibm`ge;qty:100 200 150)
quotes:([]time:10:01:00 10:01:01 10:01:01 10:01:03;
          sym:`ibm`msft`msft`ibm; px:100 99 101 98)
aj[`time`sym;trades;quotes]
/ => time     sym  qty px
/ => ---------------------
/ => 10:01:01 msft 100 101
/ => 10:01:03 ibm  200 98
/ => 10:01:04 ge   150
/ for each row in the trade table, the last (prevailing) quote (px) for that sym
/ is joined on.
/ see http://code.kx.com/q4m3/9_Queries_q-sql/#998-as-of-joins

////////////////////////////////////
/////     Extra/Advanced      //////
////////////////////////////////////

////// Adverbs //////
/ You may have noticed the total lack of loops to this point
/ This is not a mistake!
/ q is a vector language so explicit loops (for, while etc.) are not encouraged
/ where possible functionality should be vectorized (i.e. operations on lists)
/ adverbs supplement this, modifying the behaviour of functions
/ and providing loop type functionality when required
/ (in q functions are sometimes referred to as verbs, hence adverbs)
/ the ""each"" adverb modifies a function to treat a list as individual variables
first each (1 2 3;4 5 6;7 8 9)
/ => 1 4 7

/ each-left (\:) and each-right (/:) modify a two-argument function
/ to treat one of the arguments and individual variables instead of a list
1 2 3 +\: 11 22 33
/ => 12 23 34
/ => 13 24 35
/ => 14 25 36
1 2 3 +/: 11 22 33
/ => 12 13 14
/ => 23 24 25
/ => 34 35 36

/ The true alternatives to loops in q are the adverbs scan (\) and over (/)
/ their behaviour differs based on the number of arguments the function they
/ are modifying receives.  Here I'll summarise some of the most useful cases
/ a single argument function modified by scan given 2 args behaves like ""do""
{x * 2}\[5;1] / => 1 2 4 8 16 32 (i.e. multiply by 2, 5 times)
{x * 2}/[5;1] / => 32 (using over only the final result is shown)

/ If the first argument is a function, we have the equivalent of ""while""
{x * 2}\[{x<100};1] / => 1 2 4 8 16 32 64 128 (iterates until returns 0b)
{x * 2}/[{x<100};1] / => 128 (again returns only the final result)

/ If the function takes two arguments, and we pass a list, we have ""for""
/ where the result of the previous execution is passed back into the next loop
/ along with the next member of the list
{x + y}\[1 2 3 4 5] / => 1 3 6 10 15 (i.e. the running sum)
{x + y}/[1 2 3 4 5] / => 15 (only the final result)

/ There are other adverbs and uses, this is only intended as quick overview
/ http://code.kx.com/q4m3/6_Functions/#67-adverbs

////// Scripts //////
/ q scripts can be loaded from a q session using the ""\l"" command
/ for example ""\l learnkdb.q"" will load this script
/ or from the command prompt passing the script as an argument
/ for example ""q learnkdb.q""

////// On-disk data //////
/ Tables can be persisted to disk in several formats
/ the two most fundamental are serialized and splayed
t:([]a:1 2 3;b:1 2 3f)
`:serialized set t / saves the table as a single serialized file
`:splayed/ set t / saves the table splayed into a directory

/ the dir structure will now look something like:
/ db/
/ ├── serialized
/ └── splayed
/     ├── a
/     └── b

/ Loading this directory (as if it was as script, see above)
/ loads these tables into the q session
\l .
/ the serialized table will be loaded into memory
/ however the splayed table will only be mapped, not loaded
/ both tables can be queried using q-sql
select from serialized
/ => a b
/ => ---
/ => 1 1
/ => 2 2
/ => 3 3
select from splayed / (the columns are read from disk on request)
/ => a b
/ => ---
/ => 1 1
/ => 2 2
/ => 3 3
/ see http://code.kx.com/q4m3/14_Introduction_to_Kdb+/ for more

////// Frameworks //////
/ kdb+ is typically used for data capture and analysis.
/ This involves using an architecture with multiple processes
/ working together.  kdb+ frameworks are available to streamline the setup
/ and configuration of this architecture and add additional functionality
/ such as disaster recovery, logging, access, load balancing etc.
/ https://github.com/AquaQAnalytics/TorQ
```

## Want to know more?

* [*q for mortals* q language tutorial](http://code.kx.com/q4m3/)
* [*Introduction to Kdb+* on disk data tutorial](http://code.kx.com/q4m3/14_Introduction_to_Kdb+/)
* [q language reference](https://code.kx.com/q/ref/)
* [Online training courses](http://training.aquaq.co.uk/)
* [TorQ production framework](https://github.com/AquaQAnalytics/TorQ)"
"PowerShell is the Windows scripting language and configuration management
framework from Microsoft built on the .NET Framework. Windows 7 and up ship
with PowerShell.  
Nearly all examples below can be a part of a shell script or executed directly
in the shell.

A key difference with Bash is that it is mostly objects that you manipulate
rather than plain text. After years of evolving, it resembles Python a bit.

[Read more here.](https://docs.microsoft.com/powershell/scripting/overview)

Powershell as a Language:

```powershell

# Single line comments start with a number symbol.

<#
  Multi-line comments
  like so
#>


####################################################
## 1. Primitive Datatypes and Operators
####################################################

# Numbers
3 # => 3

# Math
1 + 1   # => 2
8 - 1   # => 7
10 * 2  # => 20
35 / 5  # => 7.0

# Powershell uses banker's rounding,
# meaning [int]1.5 would round to 2 but so would [int]2.5
# Division always returns a float. 
# You must cast result to [int] to round.
[int]5 / [int]3       # => 1.66666666666667
[int]-5 / [int]3      # => -1.66666666666667
5.0 / 3.0   # => 1.66666666666667
-5.0 / 3.0  # => -1.66666666666667
[int]$result = 5 / 3 
$result # => 2

# Modulo operation
7 % 3  # => 1

# Exponentiation requires longform or the built-in [Math] class.
[Math]::Pow(2,3)  # => 8

# Enforce order of operations with parentheses.
1 + 3 * 2  # => 7
(1 + 3) * 2  # => 8

# Boolean values are primitives (Note: the $)
$True  # => True
$False  # => False

# negate with !
!$True   # => False
!$False  # => True

# Boolean Operators
# Note ""-and"" and ""-or"" usage
$True -and $False  # => False
$False -or $True   # => True

# True and False are actually 1 and 0 but only support limited arithmetic.
# However, casting the bool to int resolves this.
$True + $True # => 2
$True * 8    # => '[System.Boolean] * [System.Int32]' is undefined
[int]$True * 8 # => 8
$False - 5   # => -5

# Comparison operators look at the numerical value of True and False.
0 -eq $False  # => True
1 -eq $True   # => True
2 -eq $True   # => False
-5 -ne $False # => True

# Using boolean logical operators on ints casts to booleans for evaluation.
# but their non-cast value is returned
# Don't mix up with bool(ints) and bitwise -band/-bor
[bool](0)     # => False
[bool](4)     # => True
[bool](-6)    # => True
0 -band 2     # => 0
-5 -bor 0     # => -5

# Equality is -eq (equals)
1 -eq 1  # => True
2 -eq 1  # => False

# Inequality is -ne (notequals)
1 -ne 1  # => False
2 -ne 1  # => True

# More comparisons
1 -lt 10  # => True
1 -gt 10  # => False
2 -le 2  # => True
2 -ge 2  # => True

# Seeing whether a value is in a range
1 -lt 2 -and 2 -lt 3  # => True
2 -lt 3 -and 3 -lt 2  # => False

# (-is vs. -eq) -is checks if two objects are the same type.
# -eq checks if the objects have the same values.
# Note: we called '[Math]' from .NET previously without the preceeding
# namespaces. We can do the same with [Collections.ArrayList] if preferred.
[System.Collections.ArrayList]$a = @()  # Point a at a new list
$a = (1,2,3,4)
$b = $a                                 # => Point b at what a is pointing to
$b -is $a.GetType()                     # => True, a and b equal same type
$b -eq $a                               # => True, a and b values are equal
[System.Collections.Hashtable]$b = @{}  # => Point a at a new hash table
$b = @{'one' = 1 
       'two' = 2}
$b -is $a.GetType()                     # => False, a and b types not equal

# Strings are created with "" or ' but "" is required for string interpolation
""This is a string.""
'This is also a string.'

# Strings can be added too! But try not to do this.
""Hello "" + ""world!""  # => ""Hello world!""

# A string can be treated like a list of characters
""Hello world!""[0]  # => 'H'

# You can find the length of a string
(""This is a string"").Length  # => 16

# You can also format using f-strings or formatted string literals.
$name = ""Steve""
$age = 22
""He said his name is $name."" 
# => ""He said his name is Steve""
""{0} said he is {1} years old."" -f $name, $age 
# => ""Steve said he is 22 years old""
""$name's name is $($name.Length) characters long."" 
# => ""Steve's name is 5 characters long.""

# Escape Characters in Powershell
# Many languages use the '\', but Windows uses this character for 
# file paths. Powershell thus uses '`' to escape characters
# Take caution when working with files, as '`' is a
# valid character in NTFS filenames.
""Showing`nEscape Chars"" # => new line between Showing and Escape
""Making`tTables`tWith`tTabs"" # => Format things with tabs

# Negate pound sign to prevent comment
# Note that the function of '#' is removed, but '#' is still present
`#Get-Process # => Fail: not a recognized cmdlet

# $null is not an object
$null  # => None

# $null, 0, and empty strings and arrays all evaluate to False.
# All other values are True
function Test-Value ($value) {
  if ($value) {
    Write-Output 'True'
  }
  else {
    Write-Output 'False'
  }
}

Test-Value ($null) # => False
Test-Value (0)     # => False
Test-Value ("""")    # => False
Test-Value []      # => True 
# *[] calls .NET class; creates '[]' string when passed to function
Test-Value ({})    # => True
Test-Value @()     # => False


####################################################
## 2. Variables and Collections
####################################################

# Powershell uses the ""Write-Output"" function to print
Write-Output ""I'm Posh. Nice to meet you!""  # => I'm Posh. Nice to meet you!

# Simple way to get input data from console
$userInput = Read-Host ""Enter some data: "" # Returns the data as a string

# There are no declarations, only assignments.
# Convention is to use camelCase or PascalCase, whatever your team uses.
$someVariable = 5
$someVariable  # => 5

# Accessing a previously unassigned variable does not throw exception.
# The value is $null by default

# Ternary Operators exist in Powershell 7 and up
0 ? 'yes' : 'no'  # => no


# The default array object in Powershell is an fixed length array.
$defaultArray = ""thing"",""thing2"",""thing3""
# you can add objects with '+=', but cannot remove objects.
$defaultArray.Add(""thing4"") # => Exception ""Collection was of a fixed size.""
# To have a more workable array, you'll want the .NET [ArrayList] class
# It is also worth noting that ArrayLists are significantly faster

# ArrayLists store sequences
[System.Collections.ArrayList]$array = @()
# You can start with a prefilled ArrayList
[System.Collections.ArrayList]$otherArray = @(4, 5, 6)

# Add to the end of a list with 'Add' (Note: produces output, append to $null)
$array.Add(1) > $null    # $array is now [1]
$array.Add(2) > $null    # $array is now [1, 2]
$array.Add(4) > $null    # $array is now [1, 2, 4]
$array.Add(3) > $null    # $array is now [1, 2, 4, 3]
# Remove from end with index of count of objects-1; array index starts at 0
$array.RemoveAt($array.Count-1) # => 3 and array is now [1, 2, 4]
# Let's put it back
$array.Add(3) > $null   # array is now [1, 2, 4, 3] again.

# Access a list like you would any array
$array[0]   # => 1
# Look at the last element
$array[-1]  # => 3

# Looking out of bounds returns nothing
$array[4]  # blank line returned

# You can look at ranges with slice syntax.
# The start index is included, the end index is not
# (It's a closed/open range for you mathy types.)
$array[1..3]   # Return array from index 1 to 3 => [2, 4]
$array[2..-1]    # Return array starting from index 2 => [4, 3]
$array[0..3]    # Return array from beginning until index 3  => [1, 2, 4]
$array[0..2]   # Return array selecting every second entry => [1, 4]
$array.Reverse()  # mutates array to reverse order => [3, 4, 2, 1]
# Use any combination of these to make advanced slices

# Remove arbitrary elements from a array with ""del""
$array.Remove($array[2])  # $array is now [1, 2, 3]

# Insert an element at a specific index
$array.Insert(1, 2)  # $array is now [1, 2, 3] again

# Get the index of the first item found matching the argument
$array.IndexOf(2)  # => 1
$array.IndexOf(6)  # Returns -1 as ""outside array"" 

# You can add arrays
# Note: values for $array and for $otherArray are not modified.
$array + $otherArray  # => [1, 2, 3, 4, 5, 6]

# Concatenate arrays with ""AddRange()""
$array.AddRange($otherArray)  # Now $array is [1, 2, 3, 4, 5, 6]

# Check for existence in a array with ""in""
1 -in $array  # => True

# Examine length with ""Count"" (Note: ""Length"" on arrayList = each items length)
$array.Count  # => 6


# Tuples are like arrays but are immutable.
# To use Tuples in powershell, you must use the .NET tuple class.
$tuple = [System.Tuple]::Create(1, 2, 3)
$tuple.Item(0)      # => 1
$tuple.Item(0) = 3  # Raises a TypeError

# You can do some of the array methods on tuples, but they are limited.
$tuple.Length       # => 3
$tuple + (4, 5, 6)  # => Exception
$tuple[0..2]        # => $null
2 -in $tuple        # => False


# Hashtables store mappings from keys to values, similar to Dictionaries.
$emptyHash = @{}
# Here is a prefilled dictionary
$filledHash = @{""one""= 1 
                ""two""= 2 
                ""three""= 3}

# Look up values with []
$filledHash[""one""]  # => 1

# Get all keys as an iterable with "".Keys"".
# items maintain the order at which they are inserted into the dictionary.
$filledHash.Keys  # => [""one"", ""two"", ""three""]

# Get all values as an iterable with "".Values"".
$filledHash.Values  # => [1, 2, 3]

# Check for existence of keys or values in a hash with ""-in""
""one"" -in $filledHash.Keys  # => True
1 -in $filledHash.Values    # => False

# Looking up a non-existing key returns $null
$filledHash[""four""]  # $null

# Adding to a dictionary
$filledHash.Add(""five"",5)  # $filledHash[""five""] is set to 5
$filledHash.Add(""five"",6)  # exception ""Item with key ""five"" has already been added""
$filledHash[""four""] = 4 # $filledHash[""four""] is set to 4, running again does nothing

# Remove keys from a dictionary with del
$filledHash.Remove(""one"") # Removes the key ""one"" from filled dict


####################################################
## 3. Control Flow and Iterables
####################################################

# Let's just make a variable
$someVar = 5

# Here is an if statement.
# This prints ""$someVar is smaller than 10""
if ($someVar -gt 10) {
    Write-Output ""$someVar is bigger than 10.""
}
elseif ($someVar -lt 10) {    # This elseif clause is optional.
    Write-Output ""$someVar is smaller than 10.""
}
else {                        # This is optional too.
    Write-Output ""$someVar is indeed 10.""
}


<#
Foreach loops iterate over arrays
prints:
    dog is a mammal
    cat is a mammal
    mouse is a mammal
#>
foreach ($animal in (""dog"", ""cat"", ""mouse"")) {
    # You can use -f to interpolate formatted strings
    ""{0} is a mammal"" -f $animal
}

<#
For loops iterate over arrays and you can specify indices
prints:
   0 a
   1 b
   2 c
   3 d
   4 e
   5 f
   6 g
   7 h
#>
$letters = ('a','b','c','d','e','f','g','h')
for($i=0; $i -le $letters.Count-1; $i++){
    Write-Host $i, $letters[$i]
}

<#
While loops go until a condition is no longer met.
prints:
    0
    1
    2
    3
#>
$x = 0
while ($x -lt 4) {
    Write-Output $x
    $x += 1  # Shorthand for x = x + 1
}

# Switch statements are more powerful compared to most languages
$val = ""20""
switch($val) {
  { $_ -eq 42 }           { ""The answer equals 42""; break }
  '20'                    { ""Exactly 20""; break }
  { $_ -like 's*' }       { ""Case insensitive""; break }
  { $_ -clike 's*'}       { ""clike, ceq, cne for case sensitive""; break }
  { $_ -notmatch '^.*$'}  { ""Regex matching. cnotmatch, cnotlike, ...""; break }
  default                 { ""Others"" }
}

# Handle exceptions with a try/catch block
try {
    # Use ""throw"" to raise an error
    throw ""This is an error""
}
catch {
    Write-Output $Error.ExceptionMessage
}
finally {
    Write-Output ""We can clean up resources here""
}


# Writing to a file
$contents = @{""aa""= 12 
             ""bb""= 21}
$contents | Export-CSV ""$env:HOMEDRIVE\file.csv"" # writes to a file

$contents = ""test string here""
$contents | Out-File ""$env:HOMEDRIVE\file.txt"" # writes to another file

# Read file contents and convert to json
Get-Content ""$env:HOMEDRIVE\file.csv"" | ConvertTo-Json


####################################################
## 4. Functions
####################################################

# Use ""function"" to create new functions
# Keep the Verb-Noun naming convention for functions
function Add-Numbers {
 $args[0] + $args[1]
}

Add-Numbers 1 2 # => 3

# Calling functions with parameters
function Add-ParamNumbers {
 param( [int]$firstNumber, [int]$secondNumber )
 $firstNumber + $secondNumber
}

Add-ParamNumbers -FirstNumber 1 -SecondNumber 2 # => 3 

# Functions with named parameters, parameter attributes, parsable documentation
<#
.SYNOPSIS
Setup a new website
.DESCRIPTION
Creates everything your new website needs for much win
.PARAMETER siteName
The name for the new website
.EXAMPLE
New-Website -Name FancySite -Po 5000
New-Website SiteWithDefaultPort
New-Website siteName 2000 # ERROR! Port argument could not be validated
('name1','name2') | New-Website -Verbose
#>
function New-Website() {
    [CmdletBinding()]
    param (
        [Parameter(ValueFromPipeline=$true, Mandatory=$true)]
        [Alias('name')]
        [string]$siteName,
        [ValidateSet(3000,5000,8000)]
        [int]$port = 3000
    )
    BEGIN { Write-Output 'Creating new website(s)' }
    PROCESS { Write-Output ""name: $siteName, port: $port"" }
    END { Write-Output 'Website(s) created' }
}


####################################################
## 5. Modules
####################################################

# You can import modules and install modules
# The Install-Module is similar to pip or npm, pulls from Powershell Gallery
Install-Module dbaTools
Import-Module dbaTools

$query = ""SELECT * FROM dbo.sometable""
$queryParams = @{
    SqlInstance = 'testInstance'
    Database    = 'testDatabase'
    Query       = $query
}
Invoke-DbaQuery @queryParams

# You can get specific functions from a module
Import-Module -Function Invoke-DbaQuery


# Powershell modules are just ordinary Posh files. You
# can write your own, and import them. The name of the
# module is the same as the name of the file.

# You can find out which functions and attributes
# are defined in a module.
Get-Command -module dbaTools
Get-Help dbaTools -Full


####################################################
## 6. Classes
####################################################

# We use the ""class"" statement to create a class
class Instrument {
    [string]$Type
    [string]$Family
}

$instrument = [Instrument]::new()
$instrument.Type = ""String Instrument""
$instrument.Family = ""Plucked String""

$instrument

<# Output:
Type              Family        
----              ------        
String Instrument Plucked String
#>


####################################################
## 6.1 Inheritance
####################################################

# Inheritance allows new child classes to be defined that inherit 
# methods and variables from their parent class.

class Guitar : Instrument
{
    [string]$Brand
    [string]$SubType
    [string]$ModelType
    [string]$ModelNumber
}

$myGuitar = [Guitar]::new()
$myGuitar.Brand       = ""Taylor""
$myGuitar.SubType     = ""Acoustic""
$myGuitar.ModelType   = ""Presentation""
$myGuitar.ModelNumber = ""PS14ce Blackwood""

$myGuitar.GetType()

<#
IsPublic IsSerial Name                                     BaseType                                               
-------- -------- ----                                     --------                                               
True     False    Guitar                                   Instrument  
#>


####################################################
## 7. Advanced
####################################################

# The powershell pipeline allows things like High-Order Functions.

# Group-Object is a handy cmdlet that does incredible things.
# It works much like a GROUP BY in SQL.

<#
 The following will get all the running processes,
 group them by Name,
 and tell us how many instances of each process we have running.
 Tip: Chrome and svcHost are usually big numbers in this regard.
#>
Get-Process | Foreach-Object ProcessName | Group-Object

# Useful pipeline examples are iteration and filtering.
1..10 | ForEach-Object { ""Loop number $PSITEM"" }
1..10 | Where-Object { $PSITEM -gt 5 } | ConvertTo-Json

# A notable pitfall of the pipeline is it's performance when
# compared with other options.
# Additionally, raw bytes are not passed through the pipeline,
# so passing an image causes some issues.
# See more on that in the link at the bottom.

<#
 Asynchronous functions exist in the form of jobs.
 Typically a procedural language,
 Powershell can operate non-blocking functions when invoked as Jobs.
#>

# This function is known to be non-optimized, and therefore slow.
$installedApps = Get-CimInstance -ClassName Win32_Product

# If we had a script, it would hang at this func for a period of time.
$scriptBlock = {Get-CimInstance -ClassName Win32_Product}
Start-Job -ScriptBlock $scriptBlock

# This will start a background job that runs the command.
# You can then obtain the status of jobs and their returned results.
$allJobs = Get-Job
$jobResponse = Get-Job | Receive-Job


# Math is built in to powershell and has many functions.
$r=2
$pi=[math]::pi
$r2=[math]::pow( $r, 2 )
$area = $pi*$r2
$area

# To see all possibilities, check the members.
[System.Math] | Get-Member -Static -MemberType All


<#
 This is a silly one:
 You may one day be asked to create a func that could take $start and $end
 and reverse anything in an array within the given range
 based on an arbitrary array without mutating the original array.
 Let's see one way to do that and introduce another data structure.
#>

$targetArray = 'a','b','c','d','e','f','g','h','i','j','k','l','m'

function Format-Range ($start, $end, $array) {
    [System.Collections.ArrayList]$firstSectionArray = @()
    [System.Collections.ArrayList]$secondSectionArray = @()
    [System.Collections.Stack]$stack = @()
    for ($index = 0; $index -lt $array.Count; $index++) {
        if ($index -lt $start) {
            $firstSectionArray.Add($array[$index]) > $null
        }
        elseif ($index -ge $start -and $index -le $end) {
            $stack.Push($array[$index])
        }
        else {
            $secondSectionArray.Add($array[$index]) > $null
        }
    }
    $finalArray = $firstSectionArray + $stack.ToArray() + $secondSectionArray
    return $finalArray
}

Format-Range 2 6 $targetArray 
# => 'a','b','g','f','e','d','c','h','i','j','k','l','m'

# The previous method works, but uses extra memory by allocating new arrays.
# It's also kind of lengthy.
# Let's see how we can do this without allocating a new array.
# This is slightly faster as well.

function Format-Range ($start, $end) {
  while ($start -lt $end)
  {
      $temp = $targetArray[$start]
      $targetArray[$start] = $targetArray[$end]
      $targetArray[$end] = $temp
      $start++
      $end--
  }
  return $targetArray
}

Format-Range 2 6 # => 'a','b','g','f','e','d','c','h','i','j','k','l','m'
```
Powershell as a Tool:

Getting Help:

```Powershell
# Find commands
Get-Command about_* # alias: gcm
Get-Command -Verb Add
Get-Alias ps
Get-Alias -Definition Get-Process

Get-Help ps | less # alias: help
ps | Get-Member # alias: gm

Show-Command Get-WinEvent # Display GUI to fill in the parameters

Update-Help # Run as admin
```

If you are uncertain about your environment:

```Powershell
Get-ExecutionPolicy -List
Set-ExecutionPolicy AllSigned
# Execution policies include:
# - Restricted: Scripts won't run.
# - RemoteSigned: Downloaded scripts run only if signed by a trusted publisher. 
# - AllSigned: Scripts need to be signed by a trusted publisher.
# - Unrestricted: Run all scripts.
help about_Execution_Policies # for more info

# Current PowerShell version:
$PSVersionTable
```

```Powershell
# Calling external commands, executables, 
# and functions with the call operator.
# Exe paths with arguments passed or containing spaces can create issues.
C:\Program Files\dotnet\dotnet.exe
# The term 'C:\Program' is not recognized as a name of a cmdlet,
# function, script file, or executable program.
# Check the spelling of the name, or if a path was included, 
# verify that the path is correct and try again

""C:\Program Files\dotnet\dotnet.exe""
C:\Program Files\dotnet\dotnet.exe    # returns string rather than execute

&""C:\Program Files\dotnet\dotnet.exe --help""   # fail
&""C:\Program Files\dotnet\dotnet.exe"" --help   # success
# Alternatively, you can use dot-sourcing here
.""C:\Program Files\dotnet\dotnet.exe"" --help   # success

# the call operator (&) is similar to Invoke-Expression, 
# but IEX runs in current scope.
# One usage of '&' would be to invoke a scriptblock inside of your script.
# Notice the variables are scoped
$i = 2
$scriptBlock = { $i=5; Write-Output $i }
& $scriptBlock # => 5
$i # => 2

invoke-expression ' $i=5; Write-Output $i ' # => 5
$i # => 5

# Alternatively, to preserve changes to public variables
# you can use ""Dot-Sourcing"". This will run in the current scope.
$x=1
&{$x=2};$x # => 1

.{$x=2};$x # => 2


# Remoting into computers is easy.
Enter-PSSession -ComputerName RemoteComputer

# Once remoted in, you can run commands as if you're local.
RemoteComputer\PS> Get-Process powershell

<#
Handles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName                                             
-------  ------    -----      -----     ------     --  -- -----------                                             
   1096      44   156324     179068      29.92  11772   1 powershell                                              
    545      25    49512      49852             25348   0 powershell 
#>
RemoteComputer\PS> Exit-PSSession

<#
 Powershell is an incredible tool for Windows management and Automation.
 Let's take the following scenario:
 You have 10 servers.
 You need to check whether a service is running on all of them.
 You can RDP and log in, or PSSession to all of them, but why?
 Check out the following
#>

$serverList = @(
    'server1',
    'server2',
    'server3',
    'server4',
    'server5',
    'server6',
    'server7',
    'server8',
    'server9',
    'server10'
)

[scriptblock]$script = {
    Get-Service -DisplayName 'Task Scheduler'
}

foreach ($server in $serverList) {
    $cmdSplat = @{
        ComputerName  = $server
        JobName       = 'checkService'
        ScriptBlock   = $script
        AsJob         = $true
        ErrorAction   = 'SilentlyContinue'
    }
    Invoke-Command @cmdSplat | Out-Null
}

<#
 Here we've invoked jobs across many servers.
 We can now Receive-Job and see if they're all running.
 Now scale this up 100x as many servers :)
#>
```

Interesting Projects  

* [Channel9](https://channel9.msdn.com/Search?term=powershell%20pipeline#ch9Search&lang-en=en) PowerShell tutorials
* [KevinMarquette's Powershell Blog](https://powershellexplained.com/) Excellent blog that goes into great detail on Powershell
* [PSGet](https://github.com/psget/psget) NuGet for PowerShell
* [PSReadLine](https://github.com/lzybkr/PSReadLine/) A bash inspired readline implementation for PowerShell (So good that it now ships with Windows10 by default!)
* [Posh-Git](https://github.com/dahlbyk/posh-git/) Fancy Git Prompt (Recommended!)
* [Oh-My-Posh](https://github.com/JanDeDobbeleer/oh-my-posh) Shell customization similar to the popular Oh-My-Zsh on Mac
* [PSake](https://github.com/psake/psake) Build automation tool
* [Pester](https://github.com/pester/Pester) BDD Testing Framework
* [ZLocation](https://github.com/vors/ZLocation) Powershell `cd` that reads your mind
* [PowerShell Community Extensions](https://github.com/Pscx/Pscx)
* [More on the Powershell Pipeline Issue](https://github.com/PowerShell/PowerShell/issues/1908)"
"# Dynamic Programming

## Introduction

Dynamic Programming is a powerful technique used for solving a particular class of problems as we will see. The idea is very simple, If you have solved a problem with the given input, then save the result for future reference, so as to avoid solving the same problem again.

Always remember!
""Those who can't remember the past are condemned to repeat it""

## Ways of solving such Problems

1. *Top-Down* : Start solving the given problem by breaking it down. If you see that the problem has been solved already, then just return the saved answer. If it has not been solved, solve it and save the answer. This is usually easy to think of and very intuitive. This is referred to as Memoization.

2. *Bottom-Up* : Analyze the problem and see the order in which the sub-problems are solved and start solving from the trivial subproblem, up towards the given problem. In this process, it is guaranteed that the subproblems are solved before solving the problem. This is referred to as Dynamic Programming.

## Example of Dynamic Programming

The Longest Increasing Subsequence problem is to find the longest increasing subsequence of a given sequence. Given a sequence `S={ a1, a2, a3, a4, ............., an-1, an }` we have to find a longest subset such that for all `j` and `i`,  `j<i` in the subset `aj<ai`.
First of all we have to find the value of the longest subsequences(LSi) at every index i with last element of sequence being ai. Then largest LSi would be the longest subsequence in the given sequence. To begin LSi is assigned to be one since ai is element of the sequence(Last element). Then for all `j` such that `j<i` and `aj<ai`, we find Largest LSj and add it to LSi. Then algorithm take *O(n2)* time.

Pseudo-code for finding the length of the longest increasing subsequence:
This algorithms complexity could be reduced by using better data structure rather than array. Storing predecessor array and variable like `largest_sequences_so_far` and its index would save a lot time.

Similar concept could be applied in finding longest path in Directed acyclic graph.

```python
for i=0 to n-1
    LS[i]=1
    for j=0 to i-1
        if (a[i] >  a[j] and LS[i]<LS[j])
            LS[i] = LS[j]+1
for i=0 to n-1
    if (largest < LS[i])
```

### Some Famous DP Problems

- [Floyd Warshall Algorithm - Tutorial and C Program source code](http://www.thelearningpoint.net/computer-science/algorithms-all-to-all-shortest-paths-in-graphs---floyd-warshall-algorithm-with-c-program-source-code)
- [Integer Knapsack Problem - Tutorial and C Program source code](http://www.thelearningpoint.net/computer-science/algorithms-dynamic-programming---the-integer-knapsack-problem)
- [Longest Common Subsequence - Tutorial and C Program source code](http://www.thelearningpoint.net/computer-science/algorithms-dynamic-programming---longest-common-subsequence)

## Online Resources

* MIT 6.006: [Lessons 19,20,21,22](https://www.youtube.com/playlist?list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb)
* TopCoder: [Dynamic Programming from Novice to Advanced](https://www.topcoder.com/community/data-science/data-science-tutorials/dynamic-programming-from-novice-to-advanced/)
* [CodeChef](https://www.codechef.com/wiki/tutorial-dynamic-programming)
* [InterviewBit](https://www.interviewbit.com/courses/programming/topics/dynamic-programming/)
* GeeksForGeeks:
  * [Overlapping Subproblems](https://www.geeksforgeeks.org/dynamic-programming-set-1/)
  * [Tabulation vs Memoization](https://www.geeksforgeeks.org/tabulation-vs-memoizatation/)
  * [Optimal Substructure Property](https://www.geeksforgeeks.org/dynamic-programming-set-2-optimal-substructure-property/)
  * [How to solve a DP problem](https://www.geeksforgeeks.org/solve-dynamic-programming-problem/)
* [How to write DP solutions](https://www.quora.com/Are-there-any-good-resources-or-tutorials-for-dynamic-programming-DP-besides-the-TopCoder-tutorial/answer/Michal-Danilák)"
"Pogoscript is a little language that emphasises readability, DSLs and provides excellent asynchronous primitives for writing connected JavaScript applications for the browser or server.

``` javascript
// defining a variable
water temperature = 24

// re-assigning a variable after its definition
water temperature := 26

// functions allow their parameters to be placed anywhere
temperature at (a) altitude = 32 - a / 100

// longer functions are just indented
temperature at (a) altitude :=
    if (a < 0)
        water temperature
    else
        32 - a / 100

// calling a function
current temperature = temperature at 3200 altitude

// this function constructs a new object with methods
position (x, y) = {
    x = x
    y = y

    distance from position (p) =
        dx = self.x - p.x
        dy = self.y - p.y
        Math.sqrt (dx * dx + dy * dy)
}

// `self` is similar to `this` in JavaScript with the
// exception that `self` isn't redefined in each new
// function definition
// `self` just does what you expect

// calling methods
position (7, 2).distance from position (position (5, 1))

// as in JavaScript, objects are hashes too
position.'x' == position.x == position.('x')

// arrays
positions = [
    position (1, 1)
    position (1, 2)
    position (1, 3)
]

// indexing an array
positions.0.y

n = 2
positions.(n).y

// strings
poem = 'Tail turned to red sunset on a juniper crown a lone magpie cawks.
        Mad at Oryoki in the shrine-room -- Thistles blossomed late afternoon.
        Put on my shirt and took it off in the sun walking the path to lunch.
        A dandelion seed floats above the marsh grass with the mosquitos.
        At 4 A.M. the two middleaged men sleeping together holding hands.
        In the half-light of dawn a few birds warble under the Pleiades.
        Sky reddens behind fir trees, larks twitter, sparrows cheep cheep cheep
        cheep cheep.'

// that's Allen Ginsburg

// interpolation
outlook = 'amazing!'
console.log ""the weather tomorrow is going to be #(outlook)""

// regular expressions
r/(\d+)m/i
r/(\d+) degrees/mg

// operators
true @and true
false @or true
@not false
2 < 4
2 >= 2
2 > 1

// plus all the javascript ones

// to define your own
(p1) plus (p2) =
    position (p1.x + p2.x, p1.y + p2.y)

// `plus` can be called as an operator
position (1, 1) @plus position (0, 2)
// or as a function
(position (1, 1)) plus (position (0, 2))

// explicit return
(x) times (y) = return (x * y)

// new
now = @new Date ()

// functions can take named optional arguments
spark (position, color: 'black', velocity: {x = 0, y = 0}) = {
    color = color
    position = position
    velocity = velocity
}

red = spark (position 1 1, color: 'red')
fast black = spark (position 1 1, velocity: {x = 10, y = 0})

// functions can unsplat arguments too
log (messages, ...) =
    console.log (messages, ...)

// blocks are functions passed to other functions.
// This block takes two parameters, `spark` and `c`,
// the body of the block is the indented code after the
// function call

render each @(spark) into canvas context @(c)
    ctx.begin path ()
    ctx.stroke style = spark.color
    ctx.arc (
        spark.position.x + canvas.width / 2
        spark.position.y
        3
        0
        Math.PI * 2
    )
    ctx.stroke ()

// asynchronous calls

// JavaScript both in the browser and on the server (with Node.js)
// makes heavy use of asynchronous IO with callbacks. Async IO is
// amazing for performance and making concurrency simple but it
// quickly gets complicated.
// Pogoscript has a few things to make async IO much much easier

// Node.js includes the `fs` module for accessing the file system.
// Let's list the contents of a directory

fs = require 'fs'
directory listing = fs.readdir! '.'

// `fs.readdir()` is an asynchronous function, so we can call it
// using the `!` operator. The `!` operator allows you to call
// async functions with the same syntax and largely the same
// semantics as normal synchronous functions. Pogoscript rewrites
// it so that all subsequent code is placed in the callback function
// to `fs.readdir()`.

// to catch asynchronous errors while calling asynchronous functions

try
    another directory listing = fs.readdir! 'a-missing-dir'
catch (ex)
    console.log (ex)

// in fact, if you don't use `try catch`, it will raise the error up the
// stack to the outer-most `try catch` or to the event loop, as you'd expect
// with non-async exceptions

// all the other control structures work with asynchronous calls too
// here's `if else`
config =
    if (fs.stat! 'config.json'.is file ())
        JSON.parse (fs.read file! 'config.json' 'utf-8')
    else
        {
            color: 'red'
        }

// to run two asynchronous calls concurrently, use the `?` operator.
// The `?` operator returns a *future* which can be executed to
// wait for and obtain the result, again using the `!` operator

// we don't wait for either of these calls to finish
a = fs.stat? 'a.txt'
b = fs.stat? 'b.txt'

// now we wait for the calls to finish and print the results
console.log ""size of a.txt is #(a!.size)""
console.log ""size of b.txt is #(b!.size)""

// futures in Pogoscript are analogous to Promises
```

That's it.

Download [Node.js](http://nodejs.org/) and `npm install pogo`.

There is plenty of documentation on [http://pogoscript.org/](http://pogoscript.org/), including a [cheat sheet](http://pogoscript.org/cheatsheet.html), a [guide](http://pogoscript.org/guide/), and how [Pogoscript translates to Javascript](http://featurist.github.io/pogo-examples/). Get in touch on the [google group](http://groups.google.com/group/pogoscript) if you have questions!"
"[Haxe](https://haxe.org/) is a general-purpose language that provides platform support for C++, C#,
Swf/ActionScript, JavaScript, Java, PHP, Python, Lua, HashLink, and Neko bytecode
(the latter two being also written by the Haxe author). Note that this guide is for
Haxe version 3.  Some of the guide may be applicable to older versions, but it is
recommended to use other references.

```csharp
/*
   Welcome to Learn Haxe 3 in 15 minutes.  http://www.haxe.org
   This is an executable tutorial.  You can compile and run it using the haxe
   compiler, while in the same directory as LearnHaxe.hx:
   
       $ haxe -main LearnHaxe3 --interp

   Look for the slash-star marks surrounding these paragraphs.  We are inside
   a ""Multiline comment"".  We can leave some notes here that will get ignored
   by the compiler.

   Multiline comments are also used to generate javadoc-style documentation for
   haxedoc.  They will be used for haxedoc if they immediately precede a class,
   class function, or class variable.
 */

// Double slashes like this will give a single-line comment.

/*
   This is your first actual haxe code coming up, it's declaring an empty
   package.  A package isn't necessary, but it's useful if you want to create
   a namespace for your code (e.g. org.yourapp.ClassName).

   Omitting package declaration is the same as declaring an empty package.
 */
package; // empty package, no namespace.

/*
   Packages are directories that contain modules. Each module is a .hx file
   that contains types defined in a package. Package names (e.g. org.yourapp)
   must be lower case while module names are capitalized. A module contain one
   or more types whose names are also capitalized.

   E.g, the class ""org.yourapp.Foo"" should have the folder structure
   org/module/Foo.hx, as accessible from the compiler's working directory or
   class path.

   If you import code from other files, it must be declared before the rest of
   the code.  Haxe provides a lot of common default classes to get you started:
 */
import haxe.ds.ArraySort;

// you can import many classes/modules at once with ""*""
import haxe.ds.*;

// you can import static fields
import Lambda.array;

// you can also use ""*"" to import all static fields
import Math.*;

// You can also import classes in a special way, enabling them to extend the
// functionality of other classes like a ""mixin"".  More on 'using' later.
using StringTools;

// Typedefs are like variables... for types.  They must be declared before any
// code.  More on this later.
typedef FooString = String;

// Typedefs can also reference ""structural"" types, more on that later as well.
typedef FooObject = { foo: String };

// Here's the class definition.  It's the main class for the file, since it has
// the same name (LearnHaxe3).
class LearnHaxe3 {
    /*
       If you want certain code to run automatically, you need to put it in
       a static main function, and specify the class in the compiler arguments.
       In this case, we've specified the ""LearnHaxe3"" class in the compiler
       arguments above.
     */
    static function main() {
        /*
           Trace is the default method of printing haxe expressions to the
           screen.  Different targets will have different methods of
           accomplishing this.  E.g., java, c++, c#, etc. will print to std
           out.  Javascript will print to console.log, and flash will print to
           an embedded TextField.  All traces come with a default newline.
           Finally, It's possible to prevent traces from showing by using the
           ""--no-traces"" argument on the compiler.
         */
        trace(""Hello World, with trace()!"");

        // Trace can handle any type of value or object.  It will try to print
        // a representation of the expression as best it can.  You can also
        // concatenate strings with the ""+"" operator:
        trace(""Integer: "" + 10 + "" Float: "" + 3.14 + "" Boolean: "" + true);

        // In Haxe, it's required to separate expressions in the same block with
        // semicolons.  But, you can put two expressions on one line:
        trace('two expressions..'); trace('one line');


        //////////////////////////////////////////////////////////////////
        // Types & Variables
        //////////////////////////////////////////////////////////////////
        trace(""***Types & Variables***"");

        // You can save values and references to data structures using the
        // ""var"" keyword:
        var an_integer:Int = 1;
        trace(an_integer + "" is the value for an_integer"");

        /*
           Haxe is statically typed, so ""an_integer"" is declared to have an
           ""Int"" type, and the rest of the expression assigns the value ""1"" to
           it.  It's not necessary to declare the type in many cases.  Here,
           the haxe compiler is inferring that the type of another_integer
           should be ""Int"".
         */
        var another_integer = 2;
        trace(another_integer + "" is the value for another_integer"");

        // The $type() method prints the type that the compiler assigns:
        $type(another_integer);

        // You can also represent integers with hexadecimal:
        var hex_integer = 0xffffff;

        /*
           Haxe uses platform precision for Int and Float sizes.  It also
           uses the platform behavior for overflow.
           (Other numeric types and behavior are possible using special
           libraries.)
           
           In addition to simple values like Integers, Floats, and Booleans,
           Haxe provides standard library implementations for common data
           structures like strings, arrays, lists, and maps:
         */

        // Strings can have double or single quotes.
        var a_string = ""some"" + 'string';
        trace(a_string + "" is the value for a_string"");

        // Strings can be ""interpolated"" by inserting variables into specific
        // positions.  The string must be single quoted, and the variable must
        // be preceded with ""$"".  Expressions can be enclosed in ${...}.
        var x = 1;
        var an_interpolated_string = 'the value of x is $x';
        var another_interpolated_string = 'the value of x + 1 is ${x + 1}';

        // Strings are immutable, instance methods will return a copy of
        // parts or all of the string. (See also the StringBuf class).
        var a_sub_string = a_string.substr(0,4);
        trace(a_sub_string + "" is the value for a_sub_string"");

        // Regexes are also supported, but there's not enough space here to go
        // into much detail.
        var re = ~/foobar/;
        trace(re.match('foo') + "" is the value for (~/foobar/.match('foo')))"");

        // Arrays are zero-indexed, dynamic, and mutable.  Missing values are
        // defined as null.
        var a = new Array<String>(); // an array that contains Strings
        a[0] = 'foo';
        trace(a.length + "" is the value for a.length"");
        a[9] = 'bar';
        trace(a.length + "" is the value for a.length (after modification)"");
        trace(a[3] + "" is the value for a[3]""); //null

        // Arrays are *generic*, so you can indicate which values they contain
        // with a type parameter:
        var a2 = new Array<Int>(); // an array of Ints
        var a3 = new Array<Array<String>>(); // an Array of Arrays (of Strings).

        // Maps are simple key/value data structures.  The key and the value
        // can be of any type.
        // Here, the keys are strings, and the values are Ints:
        var m = new Map<String, Int>();
        m.set('foo', 4);
        // You can also use array notation:
        m['bar'] = 5;
        trace(m.exists('bar') + "" is the value for m.exists('bar')"");
        trace(m.get('bar') + "" is the value for m.get('bar')"");
        trace(m['bar'] + "" is the value for m['bar']"");

        var m2 = ['foo' => 4, 'baz' => 6]; // Alternative map syntax
        trace(m2 + "" is the value for m2"");

        // Remember, you can use type inference.  The Haxe compiler will
        // decide the type of the variable the first time you pass an
        // argument that sets a type parameter.
        var m3 = new Map();
        m3.set(6, 'baz'); // m3 is now a Map<Int,String>
        trace(m3 + "" is the value for m3"");

        // Haxe has some more common datastructures in the haxe.ds module, such
        // as List, Stack, and BalancedTree.


        //////////////////////////////////////////////////////////////////
        // Operators
        //////////////////////////////////////////////////////////////////
        trace(""***OPERATORS***"");

        // basic arithmetic
        trace((4 + 3) + "" is the value for (4 + 3)"");
        trace((5 - 1) + "" is the value for (5 - 1)"");
        trace((2 * 4) + "" is the value for (2 * 4)"");
        // Division always produces Floats.
        trace((8 / 3) + "" is the value for (8 / 3) (a Float)"");
        trace((12 % 4) + "" is the value for (12 % 4)"");

        // basic comparison
        trace((3 == 2) + "" is the value for 3 == 2"");
        trace((3 != 2) + "" is the value for 3 != 2"");
        trace((3 >  2) + "" is the value for 3 > 2"");
        trace((3 <  2) + "" is the value for 3 < 2"");
        trace((3 >= 2) + "" is the value for 3 >= 2"");
        trace((3 <= 2) + "" is the value for 3 <= 2"");

        // standard bitwise operators
        /*
            ~       Unary bitwise complement
            <<      Signed left shift
            >>      Signed right shift
            >>>     Unsigned right shift
            &       Bitwise AND
            ^       Bitwise exclusive OR
            |       Bitwise inclusive OR
        */
        
        var i = 0;
        trace(""Pre-/Post- Increments and Decrements"");
        trace(i++); // i = 1. Post-Increment
        trace(++i); // i = 2. Pre-Increment
        trace(i--); // i = 1. Post-Decrement
        trace(--i); // i = 0. Pre-Decrement


        //////////////////////////////////////////////////////////////////
        // Control Structures
        //////////////////////////////////////////////////////////////////
        trace(""***CONTROL STRUCTURES***"");

        // if statements
        var j = 10;
        if (j == 10) {
            trace(""this is printed"");
        } else if (j > 10) {
            trace(""not greater than 10, so not printed"");
        } else {
            trace(""also not printed."");
        }

        // there is also a ""ternary"" if:
        (j == 10) ? trace(""equals 10"") : trace(""not equals 10"");

        // Finally, there is another form of control structure that operates
        // at compile time:  conditional compilation.
#if neko
        trace('hello from neko');
#elseif js
        trace('hello from js');
#else
        trace('hello from another platform!');
#end

        // The compiled code will change depending on the platform target.
        // Since we're compiling for neko (-x or -neko), we only get the neko
        // greeting.


        trace(""Looping and Iteration"");

        // while loop
        var k = 0;
        while (k < 100) {
            // trace(counter); // will print out numbers 0-99
            k++;
        }

        // do-while loop
        var l = 0;
        do {
            trace(""do statement always runs at least once"");
        } while (l > 0);

        // for loop
        // There is no c-style for loop in Haxe, because they are prone
        // to error, and not necessary.  Instead, Haxe has a much simpler
        // and safer version that uses Iterators (more on those later).
        var m = [1, 2, 3];
        for (val in m) {
            trace(val + "" is the value for val in the m array"");
        }

        // Note that you can iterate on an index using a range
        // (more on ranges later as well)
        var n = ['foo', 'bar', 'baz'];
        for (val in 0...n.length) {
            trace(val + "" is the value for val (an index for n)"");
        }


        trace(""Array Comprehensions"");

        // Array comprehensions give you the ability to iterate over arrays
        // while also creating filters and modifications.
        var filtered_n = [for (val in n) if (val != ""foo"") val];
        trace(filtered_n + "" is the value for filtered_n"");

        var modified_n = [for (val in n) val += '!'];
        trace(modified_n + "" is the value for modified_n"");

        var filtered_and_modified_n
            = [for (val in n) if (val != ""foo"") val += ""!""];
        trace(filtered_and_modified_n
                + "" is the value for filtered_and_modified_n"");


        //////////////////////////////////////////////////////////////////
        // Switch Statements (Value Type)
        //////////////////////////////////////////////////////////////////
        trace(""***SWITCH STATEMENTS (VALUE TYPES)***"");

        /*
           Switch statements in Haxe are very powerful.  In addition to working
           on basic values like strings and ints, they can also work on the
           generalized algebraic data types in enums (more on enums later).
           Here are some basic value examples for now:
         */
        var my_dog_name = ""fido"";
        var favorite_thing  = """";
        switch (my_dog_name) {
            case ""fido"" : favorite_thing = ""bone"";
            case ""rex""  : favorite_thing = ""shoe"";
            case ""spot"" : favorite_thing = ""tennis ball"";
            default     : favorite_thing = ""some unknown treat"";
            // same as default:
            // case _   : favorite_thing = ""some unknown treat"";
        }
        // The ""_"" case above is a ""wildcard"" value that will match anything.

        trace(""My dog's name is "" + my_dog_name
                + "", and his favorite thing is a: ""
                + favorite_thing);


        //////////////////////////////////////////////////////////////////
        // Expression Statements
        //////////////////////////////////////////////////////////////////
        trace(""***EXPRESSION STATEMENTS***"");

        // Haxe control statements are very powerful because every statement
        // is also an expression, consider:

        // if statements
        var k = if (true) 10 else 20;

        trace(""k equals "", k); // outputs 10

        var other_favorite_thing = switch (my_dog_name) {
            case ""fido"" : ""teddy"";
            case ""rex""  : ""stick"";
            case ""spot"" : ""football"";
            default     : ""some unknown treat"";
        }

        trace(""My dog's name is "" + my_dog_name
                + "", and his other favorite thing is a: ""
                + other_favorite_thing);


        //////////////////////////////////////////////////////////////////
        // Converting Value Types
        //////////////////////////////////////////////////////////////////
        trace(""***CONVERTING VALUE TYPES***"");

        // You can convert strings to ints fairly easily.

        // string to integer
        Std.parseInt(""0"");     // returns 0
        Std.parseFloat(""0.4""); // returns 0.4

        // integer to string
        Std.string(0); // returns ""0""
        // concatenation with strings will auto-convert to string.
        0 + """";    // returns ""0""
        true + """"; // returns ""true""
        // See documentation for parsing in Std for more details.


        //////////////////////////////////////////////////////////////////
        // Dealing with Types
        //////////////////////////////////////////////////////////////////

        /*
           As mentioned before, Haxe is a statically typed language.  All in
           all, static typing is a wonderful thing.  It enables
           precise autocompletions, and can be used to thoroughly check the
           correctness of a program.  Plus, the Haxe compiler is super fast.

           *HOWEVER*, there are times when you just wish the compiler would
           let something slide, and not throw a type error in a given case.

           To do this, Haxe has two separate keywords.  The first is the
           ""Dynamic"" type:
         */
        var dyn: Dynamic = ""any type of variable, such as this string"";

        /*
           All that you know for certain with a Dynamic variable is that the
           compiler will no longer worry about what type it is. It is like a
           wildcard variable:  You can pass it instead of any variable type,
           and you can assign any variable type you want.

           The other more extreme option is the ""untyped"" keyword:
         */
        untyped {
            var x:Int = 'foo'; // This can't be right!
            var y:String = 4;  // Madness!
        }

        /*
           The untyped keyword operates on entire *blocks* of code, skipping
           any type checks that might be otherwise required. This keyword should
           be used very sparingly, such as in limited conditionally-compiled
           situations where type checking is a hindrance.

           In general, skipping type checks is *not* recommended.  Use the
           enum, inheritance, or structural type models in order to help ensure
           the correctness of your program.  Only when you're certain that none
           of the type models work should you resort to ""Dynamic"" or ""untyped"".
         */


        //////////////////////////////////////////////////////////////////
        // Basic Object Oriented Programming
        //////////////////////////////////////////////////////////////////
        trace(""***BASIC OBJECT ORIENTED PROGRAMMING***"");

        // Create an instance of FooClass.  The classes for this are at the
        // end of the file.
        var foo_instance = new FooClass(3);

        // read the public variable normally
        trace(foo_instance.public_any
                + "" is the value for foo_instance.public_any"");

        // we can read this variable
        trace(foo_instance.public_read
                + "" is the value for foo_instance.public_read"");
        // but not write it; this will throw an error if uncommented:
        // foo_instance.public_read = 4;
        // trace(foo_instance.public_write); // as will this.

        // Calls the toString method:
        trace(foo_instance + "" is the value for foo_instance"");
        // same thing:
        trace(foo_instance.toString()
                + "" is the value for foo_instance.toString()"");

        // The foo_instance has the ""FooClass"" type, while acceptBarInstance
        // has the BarClass type.  However, since FooClass extends BarClass, it
        // is accepted.
        BarClass.acceptBarInstance(foo_instance);

        // The classes below have some more advanced examples, the ""example()""
        // method will just run them here.
        SimpleEnumTest.example();
        ComplexEnumTest.example();
        TypedefsAndStructuralTypes.example();
        UsingExample.example();
    }
}

// This is the ""child class"" of the main LearnHaxe3 Class.
class FooClass extends BarClass implements BarInterface {
    public var public_any:Int; // public variables are accessible anywhere
    public var public_read (default, null): Int; // enable only public read
    public var public_write (null, default): Int; // or only public write
    // Use this style to enable getters/setters:
    public var property (get, set): Int;

    // private variables are not available outside the class.
    // see @:allow for ways around this.
    var _private:Int; // variables are private if they are not marked public

    // a public constructor
    public function new(arg:Int) {
        // call the constructor of the parent object, since we extended BarClass:
        super();

        this.public_any = 0;
        this._private = arg;
    }

    // getter for _private
    function get_property() : Int {
        return _private;
    }

    // setter for _private
    function set_property(val:Int) : Int {
        _private = val;
        return val;
    }

    // Special function that is called whenever an instance is cast to a string.
    public function toString() {
        return _private + "" with toString() method!"";
    }

    // this class needs to have this function defined, since it implements
    // the BarInterface interface.
    public function baseFunction(x: Int) : String {
        // convert the int to string automatically
        return x + "" was passed into baseFunction!"";
    }
}

// A simple class to extend.
class BarClass {
    var base_variable:Int;
    public function new() {
        base_variable = 4;
    }
    public static function acceptBarInstance(b:BarClass) {}
}

// A simple interface to implement
interface BarInterface {
    public function baseFunction(x:Int):String;
}


//////////////////////////////////////////////////////////////////
// Enums and Switch Statements
//////////////////////////////////////////////////////////////////

// Enums in Haxe are very powerful.  In their simplest form, enums
// are a type with a limited number of states:
enum SimpleEnum {
    Foo;
    Bar;
    Baz;
}

//   Here's a class that uses it:
class SimpleEnumTest {
    public static function example() {
        // You can specify the ""full"" name,
        var e_explicit:SimpleEnum = SimpleEnum.Foo;
        var e = Foo; // but inference will work as well.
        switch (e) {
            case Foo: trace(""e was Foo"");
            case Bar: trace(""e was Bar"");
            case Baz: trace(""e was Baz""); // comment this line to throw an error.
        }

        /*
           This doesn't seem so different from simple value switches on strings.
           However, if we don't include *all* of the states, the compiler will
           complain.  You can try it by commenting out a line above.

           You can also specify a default for enum switches as well:
         */
        switch (e) {
            case Foo: trace(""e was Foo again"");
            default : trace(""default works here too"");
        }
    }
}

// Enums go much further than simple states, we can also enumerate
// *constructors*, but we'll need a more complex enum example.
enum ComplexEnum {
    IntEnum(i:Int);
    MultiEnum(i:Int, j:String, k:Float);
    SimpleEnumEnum(s:SimpleEnum);
    ComplexEnumEnum(c:ComplexEnum);
}
// Note: The enum above can include *other* enums as well, including itself!
// Note: This is what's called *Algebraic data type* in some other languages.

class ComplexEnumTest {
    public static function example() {
        var e1:ComplexEnum = IntEnum(4); // specifying the enum parameter
        // Now we can switch on the enum, as well as extract any parameters
        // it might have had.
        switch (e1) {
            case IntEnum(x) : trace('$x was the parameter passed to e1');
            default: trace(""Shouldn't be printed"");
        }

        // another parameter here that is itself an enum... an enum enum?
        var e2 = SimpleEnumEnum(Foo);
        switch (e2){
            case SimpleEnumEnum(s): trace('$s was the parameter passed to e2');
            default: trace(""Shouldn't be printed"");
        }

        // enums all the way down
        var e3 = ComplexEnumEnum(ComplexEnumEnum(MultiEnum(4, 'hi', 4.3)));
        switch (e3) {
            // You can look for certain nested enums by specifying them
            //  explicitly:
            case ComplexEnumEnum(ComplexEnumEnum(MultiEnum(i,j,k))) : {
                trace('$i, $j, and $k were passed into this nested monster');
            }
            default: trace(""Shouldn't be printed"");
        }
        // Check out ""generalized algebraic data types"" (GADT) for more details
        // on why these are so great.
    }
}

class TypedefsAndStructuralTypes {
    public static function example() {
        // Here we're going to use typedef types, instead of base types.
        // At the top we've declared the type ""FooString"" to mean a ""String"" type.
        var t1:FooString = ""some string"";

        // We can use typedefs for ""structural types"" as well.  These types are
        // defined by their field structure, not by class inheritance.  Here's
        // an anonymous object with a String field named ""foo"":
        var anon_obj = { foo: 'hi' };

        /*
           The anon_obj variable doesn't have a type declared, and is an
           anonymous object according to the compiler.  However, remember back at
           the top where we declared the FooObj typedef?  Since anon_obj matches
           that structure, we can use it anywhere that a ""FooObject"" type is
           expected.
         */
        var f = function(fo:FooObject) {
            trace('$fo was passed in to this function');
        }
        f(anon_obj); // call the FooObject signature function with anon_obj.

        /*
           Note that typedefs can have optional fields as well, marked with ""?""

           typedef OptionalFooObj = {
                ?optionalString: String,
                requiredInt: Int
           }

           Typedefs work well with conditional compilation.  For instance,
           we could have included this at the top of the file:

#if( js )
        typedef Surface = js.html.CanvasRenderingContext2D;
#elseif( nme )
        typedef Surface = nme.display.Graphics;
#elseif( !flash9 )
        typedef Surface = flash8.MovieClip;
#elseif( java )
        typedef Surface = java.awt.geom.GeneralPath;
#end

           That would give us a single ""Surface"" type to work with across
           all of those platforms.
         */
    }
}

class UsingExample {
    public static function example() {
        /*
           The ""using"" import keyword is a special type of class import that
           alters the behavior of any static methods in the class.

           In this file, we've applied ""using"" to ""StringTools"", which contains
           a number of static methods for dealing with String types.
         */
        trace(StringTools.endsWith(""foobar"", ""bar"") + "" should be true!"");

        /*
           With a ""using"" import, the first argument type is extended with the
           method.  What does that mean?  Well, since ""endsWith"" has a first
           argument type of ""String"", that means all String types now have the
           ""endsWith"" method:
         */
        trace(""foobar"".endsWith(""bar"") + "" should be true!"");

        /*
           This technique enables a good deal of expression for certain types,
           while limiting the scope of modifications to a single file.

           Note that the String instance is *not* modified in the run time.
           The newly attached method is not really part of the attached
           instance, and the compiler still generates code equivalent to a
           static method.
         */
    }
}

```

We're still only scratching the surface here of what Haxe can do.  For a formal
overview of all Haxe features, see the [manual](https://haxe.org/manual) and
the [API docs](https://api.haxe.org/). For a comprehensive directory of available
third-party Haxe libraries, see [Haxelib](https://lib.haxe.org/).

For more advanced topics, consider checking out:

* [Abstract types](https://haxe.org/manual/types-abstract.html)
* [Macros](https://haxe.org/manual/macro.html)
* [Compiler Features](https://haxe.org/manual/cr-features.html)


Finally, please join us on [the Haxe forum](https://community.haxe.org/),
on IRC [#haxe on
freenode](http://webchat.freenode.net/), or on the
[Haxe Gitter chat](https://gitter.im/HaxeFoundation/haxe)."
"**Dart** is a single threaded, general purpose programming language.
It borrows a lot from other mainstream languages.
It supports Streams, Futures(known as Promises in JavaScript), Generics, First-class functions(closures) and static type checking.
Dart can run in any platform such as Web, CLI, Desktop, Mobile and IoT devices.

Dart's most controversial feature is its ~~Optional Typing~~ Static Type safety and [Sound Type checks](https://dart.dev/guides/language/sound-dart).

```dart
import ""dart:collection"";
import ""dart:math"" as math;

/// Welcome to Learn Dart in 15 minutes. http://dart.dev/
/// This is an executable tutorial. You can run it with Dart or on
/// the Try Dart! site if you copy/paste it there. http://dartpad.dev/
/// You can also run Flutter in DartPad by click the `< > New Pad ` and choose Flutter


/// In Dart, Everything is an Object.
/// Every declaration of an object is an instance of Null and
/// Null is also an object.


/// 3 Types of comments in dart
// Single line comment
/**
* Multi-line comment
* Can comment more than 2 lines
*/
/// Code doc comment
/// It uses markdown syntax to generate code docs when making an API.
/// Code doc comment is the recommended choice when documenting your APIs, classes and methods.

/// 4 types of variable declaration.
/// Constants are variables that are immutable cannot be change or altered.
/// `const` in dart should practice SCREAMING_SNAKE_CASE name declaration.
const CONSTANT_VALUE = ""I CANNOT CHANGE"";
CONSTANT_VALUE = ""DID I?""; //Error
/// Final is another variable declaration that cannot be change once it has been instantiated. Commonly used in classes and functions
/// `final` can be declared in pascalCase.
final finalValue = ""value cannot be changed once instantiated"";
finalValue = ""Seems not""; //Error

/// `var` is another variable declaration that is mutable and can change its value. Dart will infer types and will not change its data type
var mutableValue = ""Variable string"";
mutableValue = ""this is valid"";
mutableValue = false; // Error.

/// `dynamic` is another variable declaration in which the type is not evaluated by the dart static type checking.
/// It can change its value and data type.
/// Some dartisans uses dynamic cautiously as it cannot keep track of its data type. so use it at your own risk
dynamic dynamicValue = ""I'm a string"";
dynamicValue = false; // false


/// Functions can be declared in a global space
/// Function declaration and method declaration look the same. Function
/// declarations can be nested. The declaration takes the form of
/// name() {} or name() => singleLineExpression;
/// The fat arrow function declaration can be an implicit or
/// explicit return for the result of the expression.
/// Dart will execute a function called `main()` anywhere in the dart project.
///
example1() {
  nested1() {
    nested2() => print(""Example1 nested 1 nested 2"");
    nested2();
  }

  nested1();
}

/// Anonymous functions don't include a name
example2() {
  nested1(fn) {
    fn();
  }
  nested1(() => print(""Example2 nested 1""));
}

/// When a function parameter is declared, the declaration can include the
/// number of parameters the function takes by explicitly specifying the names of the
/// parameters it takes.
example3() {
  planA(fn(String informSomething)) {
    fn(""Example3 plan A"");
  }
  planB(fn) {
    // Or don't declare number of parameters.
    fn(""Example3 plan B"");
  }

  planA((s) => print(s));
  planB((s) => print(s));
}

/// Functions have closure access to outer variables.
/// Dart will infer types when the variable has a value of something.
/// In this example dart knows that this variable is a String.
var example4Something = ""Example4 nested 1"";
example4() {
  nested1(fn(informSomething)) {
    fn(example4Something);
  }

  nested1((s) => print(s));
}

/// Class declaration with a sayIt method, which also has closure access
/// to the outer variable as though it were a function as seen before.
var example5method = ""Example5 sayIt"";

class Example5Class {
  sayIt() {
    print(example5method);
  }
}

example5() {
  /// Create an anonymous instance of the Example5Class and call the sayIt
  /// method on it.
  /// the `new` keyword is optional in Dart.
  new Example5Class().sayIt();
}

/// Class declaration takes the form of class name { [classBody] }.
/// Where classBody can include instance methods and variables, but also
/// class methods and variables.
class Example6Class {
  var instanceVariable = ""Example6 instance variable"";
  sayIt() {
    print(instanceVariable);
  }
}

example6() {
   Example6Class().sayIt();
}

/// Class methods and variables are declared with ""static"" terms.
class Example7Class {
  static var classVariable = ""Example7 class variable"";
  static sayItFromClass() {
    print(classVariable);
  }

  sayItFromInstance() {
    print(classVariable);
  }
}

example7() {
  Example7Class.sayItFromClass();
  new Example7Class().sayItFromInstance();
}

/// Dart supports Generics.
/// Generics refers to the technique of writing the code for a class
/// without specifying the data type(s) that the class works on.
/// Source: https://stackoverflow.com/questions/4560890/what-are-generics-in-c

/// Type `T` refers to any type that has been instantiated
/// you can call whatever you want
/// Programmers uses the convention in the following
/// T - Type(used for class and primitype types)
/// E - Element(used for List, Set, or Iterable)
/// K,V - Key Value(used for Map)
class GenericExample<T>{
  void printType(){
    print(""$T"")
  }
  // methods can also have generics
  genericMethod<M>(){
    print(""class:$T, method: $M"");
  }
}


/// List are similar to arrays but list is a child of Iterable<E>
/// Therefore Maps, List, LinkedList are all child of Iterable<E> to be able to loop using the keyword `for`
/// Important things to remember:
/// () - Iterable<E>
/// [] - List<E>
/// {} - Map<K,V>


/// List are great, but there's a restriction for what List can be
/// outside of function/method bodies. List on the outer scope of class
/// or outside of class have to be constant. Strings and numbers are constant
/// by default. But arrays and maps are not. They can be made constant by
/// declaring them ""const"". Kind of similar to Javascript's Object.freeze()
const example8List = [""Example8 const array""];
const  example8Map = {""someKey"": ""Example8 const map""};
/// Declare List or Maps as Objects.
 List<String> explicitList = new List<String>();
 Map<String,dynamic> explicitMaps = new Map<String,dynamic>();

 explicitList.add(""SomeArray"");
example8() {
  print(example8Map[""someKey""]);
  print(explicitList[0]);
}

/// Assigning a list from one variable to another will not be the same result.
/// Because dart is pass-reference-by-value.
/// So when you assign an existing list to a new variable.
/// Instead of List, it becomes an Iterable
var iterableExplicitList = explicitList;
print(iterableExplicitList) // (""SomeArray""); ""[]"" becomes ""()""
var newExplicitLists = explicitList.toList() // Converts Iterable<E> to List<E>

/// Loops in Dart take the form of standard for () {} or while () {} loops,
/// slightly more modern for (.. in ..) {}, or functional callbacks with many
/// supported features, starting with forEach,map and where.
var example9Array = const [""a"", ""b""];
example9() {
  for (int i = 0; i < example9Array.length; i++) {
    print(""Example9 for loop '${example9Array[i]}'"");
  }
  var i = 0;
  while (i < example9Array.length) {
    print(""Example9 while loop '${example9Array[i]}'"");
    i++;
  }
  for (final e in example9Array) {
    print(""Example9 for-in loop '${e}'"");
  }

  example9Array.forEach((e) => print(""Example9 forEach loop '${e}'""));

}

/// To loop over the characters of a string or to extract a substring.
var example10String = ""ab"";
example10() {
  for (var i = 0; i < example10String.length; i++) {
    print(""Example10 String character loop '${example10String[i]}'"");
  }
  for (var i = 0; i < example10String.length; i++) {
    print(""Example10 substring loop '${example10String.substring(i, i + 1)}'"");
  }
}

/// `int`, `double`  and `num` are the three supported number formats.
/// `num` can be either `int` or `double`.
/// `int` and `double` are children of type `num`
example11() {
  var i = 1 + 320, d = 3.2 + 0.01;
  num myNumDouble = 2.2;
  num myNumInt = 2;
  int myInt = 1;
  double myDouble = 0; // Dart will add decimal prefix, becomes 0.0;
  myNumDouble = myInt; // valid
  myNumDouble = myDouble; //valid
  myNumDouble = myNumInt; //valid

  myNumInt = myInt; // valid
  myNumInt = myDouble; // valid
  myNumInt = myNumDouble; // valid

  myInt = myNumDouble; //Error
  myInt = myDouble; //Error
  myInt = myNumInt; //valid

  myDouble = myInt; //error
  myDouble = myNumInt; //valid
  myDouble = myNumDouble; //valid

  print(""Example11 int ${i}"");
  print(""Example11 double ${d}"");

}

/// DateTime provides date/time arithmetic.
example12() {
  var now = new DateTime.now();
  print(""Example12 now '${now}'"");
  now = now.add(new Duration(days: 1));
  print(""Example12 tomorrow '${now}'"");
}

/// Regular expressions are supported.
example13() {
  var s1 = ""some string"", s2 = ""some"", re = new RegExp(""^s.+?g\$"");
  match(s) {
    if (re.hasMatch(s)) {
      print(""Example13 regexp matches '${s}'"");
    } else {
      print(""Example13 regexp doesn't match '${s}'"");
    }
  }

  match(s1);
  match(s2);
}

/// Boolean expressions support implicit conversions and dynamic type
example14() {
  var a = true;
  if (a) {
    print(""true, a is $a"");
  }
  a = null;
  if (a) {
    print(""true, a is $a"");
  } else {
    print(""false, a is $a""); /// runs here
  }

  /// dynamic typed null can be convert to bool
  var b;/// b is dynamic type
  b = ""abc"";
  try {
    if (b) {
      print(""true, b is $b"");
    } else {
      print(""false, b is $b"");
    }
  } catch (e) {
    print(""error, b is $b""); /// this could be run but got error
  }
  b = null;
  if (b) {
    print(""true, b is $b"");
  } else {
    print(""false, b is $b""); /// runs here
  }

  /// statically typed null can not be convert to bool
  var c = ""abc"";
  c = null;
  /// complie failed
  /// if (c) {
  ///   print(""true, c is $c"");
  /// } else {
  ///   print(""false, c is $c"");
  /// }
}

/// try/catch/finally and throw are used for exception handling.
/// throw takes any object as parameter;
example15() {
  try {
    try {
      throw ""Some unexpected error."";
    } catch (e) {
      print(""Example15 an exception: '${e}'"");
      throw e; /// Re-throw
    }
  } catch (e) {
    print(""Example15 catch exception being re-thrown: '${e}'"");
  } finally {
    print(""Example15 Still run finally"");
  }
}

/// To be efficient when creating a long string dynamically, use
/// StringBuffer. Or you could join a string array.
example16() {
  var sb = new StringBuffer(), a = [""a"", ""b"", ""c"", ""d""], e;
  for (e in a) {
    sb.write(e);
  }
  print(""Example16 dynamic string created with ""
      ""StringBuffer '${sb.toString()}'"");
  print(""Example16 join string array '${a.join()}'"");
}

/// Strings can be concatenated by just having string List next to
/// one another with no further operator needed.

example17() {
  print(""Example17 ""
      ""concatenate ""
      ""strings ""
      ""just like that"");
}

/// Strings have single-quote or double-quote for delimiters with no
/// actual difference between the two. The given flexibility can be good
/// to avoid the need to escape content that matches the delimiter being
/// used. For example, double-quotes of HTML attributes if the string
/// contains HTML content.
example18() {
  print('Example18 <a href=""etc"">'
      ""Don't can't I'm Etc""
      '</a>');
}

/// Strings with triple single-quotes or triple double-quotes span
/// multiple lines and include line delimiters.
example19() {
  print('''Example19 <a href=""etc"">
Example19 Don't can't I'm Etc
Example19 </a>''');
}

/// Strings have the nice interpolation feature with the $ character.
/// With $ { [expression] }, the return of the expression is interpolated.
/// $ followed by a variable name interpolates the content of that variable.
/// $ can be escaped like so \$ to just add it to the string instead.
example20() {
  var s1 = ""'\${s}'"", s2 = ""'\$s'"";
  print(""Example20 \$ interpolation ${s1} or $s2 works."");
}

/// Optional types allow for the annotation of APIs and come to the aid of
/// IDEs so the IDEs can better refactor, auto-complete and check for
/// errors. So far we haven't declared any types and the programs have
/// worked just fine. In fact, types are disregarded during runtime.
/// Types can even be wrong and the program will still be given the
/// benefit of the doubt and be run as though the types didn't matter.
/// There's a runtime parameter that checks for type errors which is
/// the checked mode, which is said to be useful during development time,
/// but which is also slower because of the extra checking and is thus
/// avoided during deployment runtime.
class Example21 {
  List<String> _names;
  Example21() {
    _names = [""a"", ""b""];
  }
  List<String> get names => _names;
  set names(List<String> list) {
    _names = list;
  }

  int get length => _names.length;
  void add(String name) {
    _names.add(name);
  }
}

void example21() {
  Example21 o = new Example21();
  o.add(""c"");
  print(""Example21 names '${o.names}' and length '${o.length}'"");
  o.names = [""d"", ""e""];
  print(""Example21 names '${o.names}' and length '${o.length}'"");
}

/// Class inheritance takes the form of class name extends AnotherClassName {}.
class Example22A {
  var _name = ""Some Name!"";
  get name => _name;
}

class Example22B extends Example22A {}

example22() {
  var o = new Example22B();
  print(""Example22 class inheritance '${o.name}'"");
}

/// Class mixin is also available, and takes the form of
/// class name extends SomeClass with AnotherClassName {}.
/// It's necessary to extend some class to be able to mixin another one.
/// The template class of mixin cannot at the moment have a constructor.
/// Mixin is mostly used to share methods with distant classes, so the
/// single inheritance doesn't get in the way of reusable code.
/// Mixins follow the ""with"" statement during the class declaration.
class Example23A {}

class Example23Utils {
  addTwo(n1, n2) {
    return n1 + n2;
  }
}

class Example23B extends Example23A with Example23Utils {
  addThree(n1, n2, n3) {
    return addTwo(n1, n2) + n3;
  }
}

example23() {
  var o = new Example23B(), r1 = o.addThree(1, 2, 3), r2 = o.addTwo(1, 2);
  print(""Example23 addThree(1, 2, 3) results in '${r1}'"");
  print(""Example23 addTwo(1, 2) results in '${r2}'"");
}

/// The Class constructor method uses the same name of the class and
/// takes the form of SomeClass() : super() {}, where the "": super()""
/// part is optional and it's used to delegate constant parameters to the
/// super-parent's constructor.
class Example24A {
  var _value;
  Example24A({value: ""someValue""}) {
    _value = value;
  }
  get value => _value;
}

class Example24B extends Example24A {
  Example24B({value: ""someOtherValue""}) : super(value: value);
}

example24() {
  var o1 = new Example24B(), o2 = new Example24B(value: ""evenMore"");
  print(""Example24 calling super during constructor '${o1.value}'"");
  print(""Example24 calling super during constructor '${o2.value}'"");
}

/// There's a shortcut to set constructor parameters in case of simpler classes.
/// Just use the this.parameterName prefix and it will set the parameter on
/// an instance variable of same name.
class Example25 {
  var value, anotherValue;
  Example25({this.value, this.anotherValue});
}

example25() {
  var o = new Example25(value: ""a"", anotherValue: ""b"");
  print(""Example25 shortcut for constructor '${o.value}' and ""
      ""'${o.anotherValue}'"");
}

/// Named parameters are available when declared between {}.
/// Parameter order can be optional when declared between {}.
/// Parameters can be made optional when declared between [].
example26() {
  var _name, _surname, _email;
  setConfig1({name, surname}) {
    _name = name;
    _surname = surname;
  }

  setConfig2(name, [surname, email]) {
    _name = name;
    _surname = surname;
    _email = email;
  }

  setConfig1(surname: ""Doe"", name: ""John"");
  print(""Example26 name '${_name}', surname '${_surname}', ""
      ""email '${_email}'"");
  setConfig2(""Mary"", ""Jane"");
  print(""Example26 name '${_name}', surname '${_surname}', ""
      ""email '${_email}'"");
}

/// Variables declared with final can only be set once.
/// In case of classes, final instance variables can be set via constant
/// constructor parameter.
class Example27 {
  final color1, color2;
  /// A little flexibility to set final instance variables with syntax
  /// that follows the :
  Example27({this.color1, color2}) : color2 = color2;
}

example27() {
  final color = ""orange"", o = new Example27(color1: ""lilac"", color2: ""white"");
  print(""Example27 color is '${color}'"");
  print(""Example27 color is '${o.color1}' and '${o.color2}'"");
}

/// To import a library, use import ""libraryPath"" or if it's a core library,
/// import ""dart:libraryName"". There's also the ""pub"" package management with
/// its own convention of import ""package:packageName"".
/// See import ""dart:collection""; at the top. Imports must come before
/// other code declarations. IterableBase comes from dart:collection.
class Example28 extends IterableBase {
  var names;
  Example28() {
    names = [""a"", ""b""];
  }
  get iterator => names.iterator;
}

example28() {
  var o = new Example28();
  o.forEach((name) => print(""Example28 '${name}'""));
}

/// For control flow we have:
/// * standard switch with must break statements
/// * if-else if-else and ternary ..?..:.. operator
/// * closures and anonymous functions
/// * break, continue and return statements
example29() {
  var v = true ? 30 : 60;
  switch (v) {
    case 30:
      print(""Example29 switch statement"");
      break;
  }
  if (v < 30) {
  } else if (v > 30) {
  } else {
    print(""Example29 if-else statement"");
  }
  callItForMe(fn()) {
    return fn();
  }

  rand() {
    v = new DM.Random().nextInt(50);
    return v;
  }

  while (true) {
    print(""Example29 callItForMe(rand) '${callItForMe(rand)}'"");
    if (v != 30) {
      break;
    } else {
      continue;
    }
    /// Never gets here.
  }
}

/// Parse int, convert double to int, or just keep int when dividing numbers
/// by using the ~/ operation. Let's play a guess game too.
example30() {
  var gn,
      tooHigh = false,
      n,
      n2 = (2.0).toInt(),
      top = int.parse(""123"") ~/ n2,
      bottom = 0;
  top = top ~/ 6;
  gn = new DM.Random().nextInt(top + 1); /// +1 because nextInt top is exclusive
  print(""Example30 Guess a number between 0 and ${top}"");
  guessNumber(i) {
    if (n == gn) {
      print(""Example30 Guessed right! The number is ${gn}"");
    } else {
      tooHigh = n > gn;
      print(""Example30 Number ${n} is too ""
          ""${tooHigh ? 'high' : 'low'}. Try again"");
    }
    return n == gn;
  }

  n = (top - bottom) ~/ 2;
  while (!guessNumber(n)) {
    if (tooHigh) {
      top = n - 1;
    } else {
      bottom = n + 1;
    }
    n = bottom + ((top - bottom) ~/ 2);
  }
}

/// Optional Positional Parameter:
/// parameter will be disclosed with square bracket [ ] & square bracketed parameter are optional.
example31() {
    findVolume31(int length, int breath, [int height]) {
      print('length = $length, breath = $breath, height = $height');
    }

    findVolume31(10,20,30); //valid
    findVolume31(10,20); //also valid
}

/// Optional Named Parameter:
/// parameter will be disclosed with curly bracket { }
/// curly bracketed parameter are optional.
/// have to use parameter name to assign a value which separated with colan :
/// in curly bracketed parameter order does not matter
/// these type parameter help us to avoid confusion while passing value for a function which has many parameter.
example32() {
    findVolume32(int length, int breath, {int height}) {
    print('length = $length, breath = $breath, height = $height');
    }

    findVolume32(10,20,height:30);//valid & we can see the parameter name is mentioned here.
    findVolume32(10,20);//also valid
}

/// Optional Default Parameter:
/// same like optional named parameter in addition we can assign default value for this parameter.
/// which means no value is passed this default value will be taken.
example33() {
    findVolume33(int length, int breath, {int height=10}) {
     print('length = $length, breath = $breath, height = $height');
    }

    findVolume33(10,20,height:30);//valid
    findVolume33(10,20);//valid
}

/// Dart has also added feature such as Null aware operators
var isBool = true;
var hasString = isBool ?? ""default String"";

/// Programs have only one entry point in the main function.
/// Nothing is expected to be executed on the outer scope before a program
/// starts running with what's in its main function.
/// This helps with faster loading and even lazily loading of just what
/// the program needs to startup with.
main() {
  print(""Learn Dart in 15 minutes!"");
  [
    example1, example2, example3, example4, example5,
    example6, example7, example8, example9, example10,
    example11, example12, example13, example14, example15,
    example16, example17, example18, example19, example20,
    example21, example22, example23, example24, example25,
    example26, example27, example28, example29,
    example30 // Adding this comment stops the dart formatter from putting all items on a new line
  ].forEach((ef) => ef());
}

```

## Further Reading

Dart has a comprehensive web-site. It covers API reference, tutorials, articles and more, including a
useful DartPad (a cloud-based Dart coding playground).
[https://dart.dev/](https://dart.dev)
[https://dartpad.dev/](https://dartpad.dev)"
"AWK is a standard tool on every POSIX-compliant UNIX system. It's like
flex/lex, from the command-line, perfect for text-processing tasks and
other scripting needs. It has a C-like syntax, but without mandatory
semicolons (although, you should use them anyway, because they are required
when you're writing one-liners, something AWK excels at), manual memory
management, or static typing. It excels at text processing. You can call to
it from a shell script, or you can use it as a stand-alone scripting language.

Why use AWK instead of Perl? Readability. AWK is easier to read
than Perl. For simple text-processing scripts, particularly ones that read
files line by line and split on delimiters, AWK is probably the right tool for
the job.

```awk
#!/usr/bin/awk -f

# Comments are like this


# AWK programs consist of a collection of patterns and actions.
pattern1 { action; } # just like lex
pattern2 { action; }

# There is an implied loop and AWK automatically reads and parses each
# record of each file supplied. Each record is split by the FS delimiter,
# which defaults to white-space (multiple spaces,tabs count as one)
# You can assign FS either on the command line (-F C) or in your BEGIN
# pattern

# One of the special patterns is BEGIN. The BEGIN pattern is true
# BEFORE any of the files are read. The END pattern is true after
# an End-of-file from the last file (or standard-in if no files specified)
# There is also an output field separator (OFS) that you can assign, which
# defaults to a single space

BEGIN {

    # BEGIN will run at the beginning of the program. It's where you put all
    # the preliminary set-up code, before you process any text files. If you
    # have no text files, then think of BEGIN as the main entry point.

    # Variables are global. Just set them or use them, no need to declare.
    count = 0;

    # Operators just like in C and friends
    a = count + 1;
    b = count - 1;
    c = count * 1;
    d = count / 1; # integer division
    e = count % 1; # modulus
    f = count ^ 1; # exponentiation

    a += 1;
    b -= 1;
    c *= 1;
    d /= 1;
    e %= 1;
    f ^= 1;

    # Incrementing and decrementing by one
    a++;
    b--;

    # As a prefix operator, it returns the incremented value
    ++a;
    --b;

    # Notice, also, no punctuation such as semicolons to terminate statements

    # Control statements
    if (count == 0)
        print ""Starting with count of 0"";
    else
        print ""Huh?"";

    # Or you could use the ternary operator
    print (count == 0) ? ""Starting with count of 0"" : ""Huh?"";

    # Blocks consisting of multiple lines use braces
    while (a < 10) {
        print ""String concatenation is done"" "" with a series"" "" of""
            "" space-separated strings"";
        print a;

        a++;
    }

    for (i = 0; i < 10; i++)
        print ""Good ol' for loop"";

    # As for comparisons, they're the standards:
    # a < b   # Less than
    # a <= b  # Less than or equal
    # a != b  # Not equal
    # a == b  # Equal
    # a > b   # Greater than
    # a >= b  # Greater than or equal

    # Logical operators as well
    # a && b  # AND
    # a || b  # OR

    # In addition, there's the super useful regular expression match
    if (""foo"" ~ ""^fo+$"")
        print ""Fooey!"";
    if (""boo"" !~ ""^fo+$"")
        print ""Boo!"";

    # Arrays
    arr[0] = ""foo"";
    arr[1] = ""bar"";

    # You can also initialize an array with the built-in function split()

    n = split(""foo:bar:baz"", arr, "":"");

    # You also have associative arrays (indeed, they're all associative arrays)
    assoc[""foo""] = ""bar"";
    assoc[""bar""] = ""baz"";

    # And multi-dimensional arrays, with some limitations I won't mention here
    multidim[0,0] = ""foo"";
    multidim[0,1] = ""bar"";
    multidim[1,0] = ""baz"";
    multidim[1,1] = ""boo"";

    # You can test for array membership
    if (""foo"" in assoc)
        print ""Fooey!"";

    # You can also use the 'in' operator to traverse the keys of an array
    for (key in assoc)
        print assoc[key];

    # The command line is in a special array called ARGV
    for (argnum in ARGV)
        print ARGV[argnum];

    # You can remove elements of an array
    # This is particularly useful to prevent AWK from assuming the arguments
    # are files for it to process
    delete ARGV[1];

    # The number of command line arguments is in a variable called ARGC
    print ARGC;

    # AWK has several built-in functions. They fall into three categories. I'll
    # demonstrate each of them in their own functions, defined later.

    return_value = arithmetic_functions(a, b, c);
    string_functions();
    io_functions();
}

# Here's how you define a function
function arithmetic_functions(a, b, c,     d) {

    # Probably the most annoying part of AWK is that there are no local
    # variables. Everything is global. For short scripts, this is fine, even
    # useful, but for longer scripts, this can be a problem.

    # There is a work-around (ahem, hack). Function arguments are local to the
    # function, and AWK allows you to define more function arguments than it
    # needs. So just stick local variable in the function declaration, like I
    # did above. As a convention, stick in some extra whitespace to distinguish
    # between actual function parameters and local variables. In this example,
    # a, b, and c are actual parameters, while d is merely a local variable.

    # Now, to demonstrate the arithmetic functions

    # Most AWK implementations have some standard trig functions
    d = sin(a);
    d = cos(a);
    d = atan2(b, a); # arc tangent of b / a

    # And logarithmic stuff
    d = exp(a);
    d = log(a);

    # Square root
    d = sqrt(a);

    # Truncate floating point to integer
    d = int(5.34); # d => 5

    # Random numbers
    srand(); # Supply a seed as an argument. By default, it uses the time of day
    d = rand(); # Random number between 0 and 1.

    # Here's how to return a value
    return d;
}

function string_functions(    localvar, arr) {

    # AWK, being a string-processing language, has several string-related
    # functions, many of which rely heavily on regular expressions.

    # Search and replace, first instance (sub) or all instances (gsub)
    # Both return number of matches replaced
    localvar = ""fooooobar"";
    sub(""fo+"", ""Meet me at the "", localvar); # localvar => ""Meet me at the bar""
    gsub(""e"", ""."", localvar); # localvar => ""M..t m. at th. bar""

    # Search for a string that matches a regular expression
    # index() does the same thing, but doesn't allow a regular expression
    match(localvar, ""t""); # => 4, since the 't' is the fourth character

    # Split on a delimiter
    n = split(""foo-bar-baz"", arr, ""-"");
    # result: a[1] = ""foo""; a[2] = ""bar""; a[3] = ""baz""; n = 3

    # Other useful stuff
    sprintf(""%s %d %d %d"", ""Testing"", 1, 2, 3); # => ""Testing 1 2 3""
    substr(""foobar"", 2, 3); # => ""oob""
    substr(""foobar"", 4); # => ""bar""
    length(""foo""); # => 3
    tolower(""FOO""); # => ""foo""
    toupper(""foo""); # => ""FOO""
}

function io_functions(    localvar) {

    # You've already seen print
    print ""Hello world"";

    # There's also printf
    printf(""%s %d %d %d\n"", ""Testing"", 1, 2, 3);

    # AWK doesn't have file handles, per se. It will automatically open a file
    # handle for you when you use something that needs one. The string you used
    # for this can be treated as a file handle, for purposes of I/O. This makes
    # it feel sort of like shell scripting, but to get the same output, the
    # string must match exactly, so use a variable:

    outfile = ""/tmp/foobar.txt"";

    print ""foobar"" > outfile;

    # Now the string outfile is a file handle. You can close it:
    close(outfile);

    # Here's how you run something in the shell
    system(""echo foobar""); # => prints foobar

    # Reads a line from standard input and stores in localvar
    getline localvar;

    # Reads a line from a pipe (again, use a string so you close it properly)
    cmd = ""echo foobar"";
    cmd | getline localvar; # localvar => ""foobar""
    close(cmd);

    # Reads a line from a file and stores in localvar
    infile = ""/tmp/foobar.txt"";
    getline localvar < infile;
    close(infile);
}

# As I said at the beginning, AWK programs consist of a collection of patterns
# and actions. You've already seen the BEGIN pattern. Other
# patterns are used only if you're processing lines from files or standard
# input.
#
# When you pass arguments to AWK, they are treated as file names to process.
# It will process them all, in order. Think of it like an implicit for loop,
# iterating over the lines in these files. these patterns and actions are like
# switch statements inside the loop.

/^fo+bar$/ {

    # This action will execute for every line that matches the regular
    # expression, /^fo+bar$/, and will be skipped for any line that fails to
    # match it. Let's just print the line:

    print;

    # Whoa, no argument! That's because print has a default argument: $0.
    # $0 is the name of the current line being processed. It is created
    # automatically for you.

    # You can probably guess there are other $ variables. Every line is
    # implicitly split before every action is called, much like the shell
    # does. And, like the shell, each field can be access with a dollar sign

    # This will print the second and fourth fields in the line
    print $2, $4;

    # AWK automatically defines many other variables to help you inspect and
    # process each line. The most important one is NF

    # Prints the number of fields on this line
    print NF;

    # Print the last field on this line
    print $NF;
}

# Every pattern is actually a true/false test. The regular expression in the
# last pattern is also a true/false test, but part of it was hidden. If you
# don't give it a string to test, it will assume $0, the line that it's
# currently processing. Thus, the complete version of it is this:

$0 ~ /^fo+bar$/ {
    print ""Equivalent to the last pattern"";
}

a > 0 {
    # This will execute once for each line, as long as a is positive
}

# You get the idea. Processing text files, reading in a line at a time, and
# doing something with it, particularly splitting on a delimiter, is so common
# in UNIX that AWK is a scripting language that does all of it for you, without
# you needing to ask. All you have to do is write the patterns and actions
# based on what you expect of the input, and what you want to do with it.

# Here's a quick example of a simple script, the sort of thing AWK is perfect
# for. It will read a name from standard input and then will print the average
# age of everyone with that first name. Let's say you supply as an argument the
# name of a this data file:
#
# Bob Jones 32
# Jane Doe 22
# Steve Stevens 83
# Bob Smith 29
# Bob Barker 72
#
# Here's the script:

BEGIN {

    # First, ask the user for the name
    print ""What name would you like the average age for?"";

    # Get a line from standard input, not from files on the command line
    getline name < ""/dev/stdin"";
}

# Now, match every line whose first field is the given name
$1 == name {

    # Inside here, we have access to a number of useful variables, already
    # pre-loaded for us:
    # $0 is the entire line
    # $3 is the third field, the age, which is what we're interested in here
    # NF is the number of fields, which should be 3
    # NR is the number of records (lines) seen so far
    # FILENAME is the name of the file being processed
    # FS is the field separator being used, which is "" "" here
    # ...etc. There are plenty more, documented in the man page.

    # Keep track of a running total and how many lines matched
    sum += $3;
    nlines++;
}

# Another special pattern is called END. It will run after processing all the
# text files. Unlike BEGIN, it will only run if you've given it input to
# process. It will run after all the files have been read and processed
# according to the rules and actions you've provided. The purpose of it is
# usually to output some kind of final report, or do something with the
# aggregate of the data you've accumulated over the course of the script.

END {
    if (nlines)
        print ""The average age for "" name "" is "" sum / nlines;
}

```

Further Reading:

* [Awk tutorial](http://www.grymoire.com/Unix/Awk.html)
* [Awk man page](https://linux.die.net/man/1/awk)
* [The GNU Awk User's Guide](https://www.gnu.org/software/gawk/manual/gawk.html)
  GNU Awk is found on most Linux systems.
* [AWK one-liner collection](http://tuxgraphics.org/~guido/scripts/awk-one-liner.html)
* [Awk alpinelinux wiki](https://wiki.alpinelinux.org/wiki/Awk) a technical
  summary and list of ""gotchas"" (places where different implementations may
  behave in different or unexpected ways).
* [basic libraries for awk](https://github.com/dubiousjim/awkenough)"
"TypeScript is a language that aims at easing development of large scale
applications written in JavaScript.  TypeScript adds common concepts such as
classes, modules, interfaces, generics and (optional) static typing to
JavaScript.  It is a superset of JavaScript: all JavaScript code is valid
TypeScript code so it can be added seamlessly to any project. The TypeScript
compiler emits JavaScript.

This article will focus only on TypeScript extra syntax, as opposed to
[JavaScript](/docs/javascript).

To test TypeScript's compiler, head to the
[Playground](https://www.typescriptlang.org/play) where you will be able
to type code, have auto completion and directly see the emitted JavaScript.

```ts
// There are 3 basic types in TypeScript
let isDone: boolean = false;
let lines: number = 42;
let name: string = ""Anders"";

// But you can omit the type annotation if the variables are derived
// from explicit literals
let isDone = false;
let lines = 42;
let name = ""Anders"";

// When it's impossible to know, there is the ""Any"" type
let notSure: any = 4;
notSure = ""maybe a string instead"";
notSure = false; // okay, definitely a boolean

// Use const keyword for constants
const numLivesForCat = 9;
numLivesForCat = 1; // Error

// For collections, there are typed arrays and generic arrays
let list: number[] = [1, 2, 3];
// Alternatively, using the generic array type
let list: Array<number> = [1, 2, 3];

// For enumerations:
enum Color { Red, Green, Blue };
let c: Color = Color.Green;
console.log(Color[c]); // ""Green""

// Lastly, ""void"" is used in the special case of a function returning nothing
function bigHorribleAlert(): void {
  alert(""I'm a little annoying box!"");
}

// Functions are first class citizens, support the lambda ""fat arrow"" syntax and
// use type inference

// The following are equivalent, the same signature will be inferred by the
// compiler, and same JavaScript will be emitted
let f1 = function (i: number): number { return i * i; }
// Return type inferred
let f2 = function (i: number) { return i * i; }
// ""Fat arrow"" syntax
let f3 = (i: number): number => { return i * i; }
// ""Fat arrow"" syntax with return type inferred
let f4 = (i: number) => { return i * i; }
// ""Fat arrow"" syntax with return type inferred, braceless means no return
// keyword needed
let f5 = (i: number) => i * i;

// Interfaces are structural, anything that has the properties is compliant with
// the interface
interface Person {
  name: string;
  // Optional properties, marked with a ""?""
  age?: number;
  // And of course functions
  move(): void;
}

// Object that implements the ""Person"" interface
// Can be treated as a Person since it has the name and move properties
let p: Person = { name: ""Bobby"", move: () => { } };
// Objects that have the optional property:
let validPerson: Person = { name: ""Bobby"", age: 42, move: () => { } };
// Is not a person because age is not a number
let invalidPerson: Person = { name: ""Bobby"", age: true };

// Interfaces can also describe a function type
interface SearchFunc {
  (source: string, subString: string): boolean;
}
// Only the parameters' types are important, names are not important.
let mySearch: SearchFunc;
mySearch = function (src: string, sub: string) {
  return src.search(sub) != -1;
}

// Classes - members are public by default
class Point {
  // Properties
  x: number;

  // Constructor - the public/private keywords in this context will generate
  // the boiler plate code for the property and the initialization in the
  // constructor.
  // In this example, ""y"" will be defined just like ""x"" is, but with less code
  // Default values are also supported

  constructor(x: number, public y: number = 0) {
    this.x = x;
  }

  // Functions
  dist(): number { return Math.sqrt(this.x * this.x + this.y * this.y); }

  // Static members
  static origin = new Point(0, 0);
}

// Classes can be explicitly marked as implementing an interface.
// Any missing properties will then cause an error at compile-time.
class PointPerson implements Person {
    name: string
    move() {}
}

let p1 = new Point(10, 20);
let p2 = new Point(25); //y will be 0

// Inheritance
class Point3D extends Point {
  constructor(x: number, y: number, public z: number = 0) {
    super(x, y); // Explicit call to the super class constructor is mandatory
  }

  // Overwrite
  dist(): number {
    let d = super.dist();
    return Math.sqrt(d * d + this.z * this.z);
  }
}

// Modules, ""."" can be used as separator for sub modules
module Geometry {
  export class Square {
    constructor(public sideLength: number = 0) {
    }
    area() {
      return Math.pow(this.sideLength, 2);
    }
  }
}

let s1 = new Geometry.Square(5);

// Local alias for referencing a module
import G = Geometry;

let s2 = new G.Square(10);

// Generics
// Classes
class Tuple<T1, T2> {
  constructor(public item1: T1, public item2: T2) {
  }
}

// Interfaces
interface Pair<T> {
  item1: T;
  item2: T;
}

// And functions
let pairToTuple = function <T>(p: Pair<T>) {
  return new Tuple(p.item1, p.item2);
};

let tuple = pairToTuple({ item1: ""hello"", item2: ""world"" });

// Including references to a definition file:
/// <reference path=""jquery.d.ts"" />

// Template Strings (strings that use backticks)
// String Interpolation with Template Strings
let name = 'Tyrone';
let greeting = `Hi ${name}, how are you?`
// Multiline Strings with Template Strings
let multiline = `This is an example
of a multiline string`;

// READONLY: New Feature in TypeScript 3.1
interface Person {
  readonly name: string;
  readonly age: number;
}

var p1: Person = { name: ""Tyrone"", age: 42 };
p1.age = 25; // Error, p1.age is read-only

var p2 = { name: ""John"", age: 60 };
var p3: Person = p2; // Ok, read-only alias for p2
p3.age = 35; // Error, p3.age is read-only
p2.age = 45; // Ok, but also changes p3.age because of aliasing

class Car {
  readonly make: string;
  readonly model: string;
  readonly year = 2018;

  constructor() {
    this.make = ""Unknown Make""; // Assignment permitted in constructor
    this.model = ""Unknown Model""; // Assignment permitted in constructor
  }
}

let numbers: Array<number> = [0, 1, 2, 3, 4];
let moreNumbers: ReadonlyArray<number> = numbers;
moreNumbers[5] = 5; // Error, elements are read-only
moreNumbers.push(5); // Error, no push method (because it mutates array)
moreNumbers.length = 3; // Error, length is read-only
numbers = moreNumbers; // Error, mutating methods are missing

// Tagged Union Types for modelling state that can be in one of many shapes
type State = 
  | { type: ""loading"" }
  | { type: ""success"", value: number }
  | { type: ""error"", message: string };

declare const state: State;
if (state.type === ""success"") {
  console.log(state.value);
} else if (state.type === ""error"") {
  console.error(state.message);
}

// Template Literal Types
// Use to create complex string types
type OrderSize = ""regular"" | ""large"";
type OrderItem = ""Espresso"" | ""Cappuccino"";
type Order = `A ${OrderSize} ${OrderItem}`;

let order1: Order = ""A regular Cappuccino"";
let order2: Order = ""A large Espresso"";
let order3: Order = ""A small Espresso""; // Error

// Iterators and Generators

// for..of statement
// iterate over the list of values on the object being iterated
let arrayOfAnyType = [1, ""string"", false];
for (const val of arrayOfAnyType) {
    console.log(val); // 1, ""string"", false
}

let list = [4, 5, 6];
for (const i of list) {
   console.log(i); // 4, 5, 6
}

// for..in statement
// iterate over the list of keys on the object being iterated
for (const i in list) {
   console.log(i); // 0, 1, 2
}

// Type Assertion

let foo = {} // Creating foo as an empty object
foo.bar = 123 // Error: property 'bar' does not exist on `{}`
foo.baz = 'hello world' // Error: property 'baz' does not exist on `{}`

// Because the inferred type of foo is `{}` (an object with 0 properties), you 
// are not allowed to add bar and baz to it. However with type assertion,
// the following will pass:

interface Foo { 
  bar: number;
  baz: string;
}

let foo = {} as Foo; // Type assertion here
foo.bar = 123;
foo.baz = 'hello world'

```

## Further Reading
 * [TypeScript Official website] (http://www.typescriptlang.org/)
 * [TypeScript language specifications] (https://github.com/microsoft/TypeScript/blob/main/doc/spec-ARCHIVED.md)
 * [Learn TypeScript] (https://learntypescript.dev/)
 * [Source Code on GitHub] (https://github.com/Microsoft/TypeScript)"
"```crystal

# This is a comment

# Everything is an object
nil.class  #=> Nil
100.class  #=> Int32
true.class #=> Bool

# Falsey values are: nil, false and null pointers
!nil   #=> true  : Bool
!false #=> true  : Bool
!0     #=> false : Bool

# Integers

1.class #=> Int32

# Five signed integer types
1_i8.class   #=> Int8
1_i16.class  #=> Int16
1_i32.class  #=> Int32
1_i64.class  #=> Int64
1_i128.class #=> Int128

# Five unsigned integer types
1_u8.class   #=> UInt8
1_u16.class  #=> UInt16
1_u32.class  #=> UInt32
1_u64.class  #=> UInt64
1_u128.class #=> UInt128

2147483648.class          #=> Int64
9223372036854775808.class #=> UInt64

# Binary numbers
0b1101 #=> 13 : Int32

# Octal numbers
0o123 #=> 83 : Int32

# Hexadecimal numbers
0xFE012D #=> 16646445 : Int32
0xfe012d #=> 16646445 : Int32

# Floats

1.0.class #=> Float64

# There are two floating point types
1.0_f32.class #=> Float32
1_f32.class   #=> Float32

1e10.class    #=> Float64
1.5e10.class  #=> Float64
1.5e-7.class  #=> Float64

# Chars use 'a' pair of single quotes

'a'.class #=> Char

# Chars are 32-bit unicode
'あ' #=> 'あ' : Char

# Unicode codepoint
'\u0041' #=> 'A' : Char

# Strings use a ""pair"" of double quotes

""s"".class #=> String

# Strings are immutable
s = ""hello, ""  #=> ""hello, ""        : String
s.object_id    #=> 134667712        : UInt64
s += ""Crystal""
s              #=> ""hello, Crystal"" : String
s.object_id    #=> 142528472        : UInt64

# Supports interpolation
""sum = #{1 + 2}"" #=> ""sum = 3"" : String

# Multiline string
""This is
   multiline string"" #=> ""This is\n   multiline string""


# String with double quotes
%(hello ""world"") #=> ""hello \""world\""""

# Symbols
# Immutable, reusable constants represented internally as Int32 integer value.
# They're often used instead of strings to efficiently convey specific,
# meaningful values

:symbol.class #=> Symbol

sentence = :question?     # :""question?"" : Symbol

sentence == :question?    #=> true  : Bool
sentence == :exclamation! #=> false : Bool
sentence == ""question?""   #=> false : Bool

# Arrays

[1, 2, 3].class         #=> Array(Int32)
[1, ""hello"", 'x'].class #=> Array(Char | Int32 | String)

# Empty arrays should specify a type
[]               # Syntax error: for empty arrays use '[] of ElementType'
[] of Int32      #=> [] : Array(Int32)
Array(Int32).new #=> [] : Array(Int32)

# Arrays can be indexed
array = [1, 2, 3, 4, 5] #=> [1, 2, 3, 4, 5] : Array(Int32)
array[0]                #=> 1               : Int32
array[10]               # raises IndexError
array[-6]               # raises IndexError
array[10]?              #=> nil             : (Int32 | Nil)
array[-6]?              #=> nil             : (Int32 | Nil)

# From the end
array[-1] #=> 5

# With a start index and size
array[2, 3] #=> [3, 4, 5]

# Or with range
array[1..3] #=> [2, 3, 4]

# Add to an array
array << 6  #=> [1, 2, 3, 4, 5, 6]

# Remove from the end of the array
array.pop #=> 6
array     #=> [1, 2, 3, 4, 5]

# Remove from the beginning of the array
array.shift #=> 1
array       #=> [2, 3, 4, 5]

# Check if an item exists in an array
array.includes? 3 #=> true

# Special syntax for an array of string and an array of symbols
%w(one two three) #=> [""one"", ""two"", ""three""] : Array(String)
%i(one two three) #=> [:one, :two, :three]    : Array(Symbol)

# There is a special array syntax with other types too, as long as
# they define a .new and a #<< method
set = Set{1, 2, 3} #=> Set{1, 2, 3}
set.class          #=> Set(Int32)

# The above is equivalent to
set = Set(typeof(1, 2, 3)).new #=> Set{} : Set(Int32)
set << 1                       #=> Set{1} : Set(Int32)
set << 2                       #=> Set{1, 2} : Set(Int32)
set << 3                       #=> Set{1, 2, 3} : Set(Int32)

# Hashes

{1 => 2, 3 => 4}.class   #=> Hash(Int32, Int32)
{1 => 2, 'a' => 3}.class #=> Hash(Char| Int32, Int32)

# Empty hashes must specify a type
{}                     # Syntax Error: for empty hashes use '{} of KeyType => ValueType'
{} of Int32 => Int32   # {} : Hash(Int32, Int32)
Hash(Int32, Int32).new # {} : Hash(Int32, Int32)

# Hashes can be quickly looked up by key
hash = {""color"" => ""green"", ""number"" => 5}
hash[""color""]        #=> ""green""
hash[""no_such_key""]  #=> Missing hash key: ""no_such_key"" (KeyError)
hash[""no_such_key""]? #=> nil

# The type of the returned value is based on all key types
hash[""number""] #=> 5 : (Int32 | String)

# Check existence of keys hash
hash.has_key? ""color"" #=> true

# Special notation for symbol and string keys
{key1: 'a', key2: 'b'}     # {:key1 => 'a', :key2 => 'b'}
{""key1"": 'a', ""key2"": 'b'} # {""key1"" => 'a', ""key2"" => 'b'}

# Special hash literal syntax with other types too, as long as
# they define a .new and a #[]= methods
class MyType
  def []=(key, value)
    puts ""do stuff""
  end
end

MyType{""foo"" => ""bar""}

# The above is equivalent to
tmp = MyType.new
tmp[""foo""] = ""bar""
tmp

# Ranges

1..10                  #=> Range(Int32, Int32)
Range.new(1, 10).class #=> Range(Int32, Int32)

# Can be inclusive or exclusive
(3..5).to_a  #=> [3, 4, 5]
(3...5).to_a #=> [3, 4]

# Check whether range includes the given value or not
(1..8).includes? 2 #=> true

# Tuples are a fixed-size, immutable, stack-allocated sequence of values of
# possibly different types.
{1, ""hello"", 'x'}.class #=> Tuple(Int32, String, Char)

# Access tuple's value by its index
tuple = {:key1, :key2}
tuple[1] #=> :key2
tuple[2] #=> Error: index out of bounds for Tuple(Symbol, Symbol) (2 not in -2..1)

# Can be expanded into multiple variables
a, b, c = {:a, 'b', ""c""}
a #=> :a
b #=> 'b'
c #=> ""c""

# Procs represent a function pointer with an optional context (the closure data)
# It is typically created with a proc literal
proc = ->(x : Int32) { x.to_s }
proc.class # Proc(Int32, String)
# Or using the new method
Proc(Int32, String).new { |x| x.to_s }

# Invoke proc with call method
proc.call 10 #=> ""10""

# Control statements

if true
  ""if statement""
elsif false
  ""else-if, optional""
else
  ""else, also optional""
end 

puts ""if as a suffix"" if true

# If as an expression
a = if 2 > 1
      3
    else
      4
    end

a #=> 3

# Ternary if
a = 1 > 2 ? 3 : 4 #=> 4

# Case statement
cmd = ""move""

action = case cmd
  when ""create""
    ""Creating...""
  when ""copy""
    ""Copying...""
  when ""move""
    ""Moving...""
  when ""delete""
    ""Deleting...""
end

action #=> ""Moving...""

# Loops
index = 0
while index <= 3
  puts ""Index: #{index}""
  index += 1
end
# Index: 0
# Index: 1
# Index: 2
# Index: 3

index = 0
until index > 3
  puts ""Index: #{index}""
  index += 1
end
# Index: 0
# Index: 1
# Index: 2
# Index: 3

# But the preferable way is to use each
(1..3).each do |index|
  puts ""Index: #{index}""
end
# Index: 1
# Index: 2
# Index: 3

# Variable's type depends on the type of the expression
# in control statements
if a < 3
  a = ""hello""
else
  a = true
end
typeof(a) #=> (Bool | String)

if a && b
  # here both a and b are guaranteed not to be Nil
end

if a.is_a? String
  a.class #=> String
end

# Functions

def double(x)
  x * 2
end

# Functions (and all blocks) implicitly return the value of the last statement
double(2) #=> 4

# Parentheses are optional where the call is unambiguous
double 3 #=> 6

double double 3 #=> 12

def sum(x, y)
  x + y
end

# Method arguments are separated by a comma
sum 3, 4 #=> 7

sum sum(3, 4), 5 #=> 12

# yield
# All methods have an implicit, optional block parameter
# it can be called with the 'yield' keyword

def surround
  puts '{'
  yield
  puts '}'
end

surround { puts ""hello world"" }

# {
# hello world
# }


# You can pass a block to a function
# ""&"" marks a reference to a passed block
def guests(&block)
  block.call ""some_argument""
end

# You can pass a list of arguments, which will be converted into an array
# That's what splat operator (""*"") is for
def guests(*array)
  array.each { |guest| puts guest }
end

# If a method returns an array, you can use destructuring assignment
def foods
    [""pancake"", ""sandwich"", ""quesadilla""]
end
breakfast, lunch, dinner = foods
breakfast #=> ""pancake""
dinner    #=> ""quesadilla""

# By convention, all methods that return booleans end with a question mark
5.even? # false
5.odd?  # true

# Also by convention, if a method ends with an exclamation mark, it does 
# something destructive like mutate the receiver.
# Some methods have a ! version to make a change, and
# a non-! version to just return a new changed version
fruits = [""grapes"", ""apples"", ""bananas""]
fruits.sort  #=> [""apples"", ""bananas"", ""grapes""]
fruits       #=> [""grapes"", ""apples"", ""bananas""]
fruits.sort! #=> [""apples"", ""bananas"", ""grapes""]
fruits       #=> [""apples"", ""bananas"", ""grapes""]

# However, some mutating methods do not end in !
fruits.shift #=> ""apples""
fruits       #=> [""bananas"", ""grapes""]

# Define a class with the class keyword
class Human

  # A class variable. It is shared by all instances of this class.
  @@species = ""H. sapiens""

  # An instance variable. Type of name is String
  @name : String

  # Basic initializer
  # Assign the argument to the ""name"" instance variable for the instance
  # If no age given, we will fall back to the default in the arguments list.
  def initialize(@name, @age = 0)
  end

  # Basic setter method
  def name=(name)
    @name = name
  end

  # Basic getter method
  def name
    @name
  end

  # The above functionality can be encapsulated using the propery method as follows
  property :name

  # Getter/setter methods can also be created individually like this
  getter :name
  setter :name

  # A class method uses self to distinguish from instance methods.
  # It can only be called on the class, not an instance.
  def self.say(msg)
    puts msg
  end

  def species
    @@species
  end
end


# Instantiate a class
jim = Human.new(""Jim Halpert"")

dwight = Human.new(""Dwight K. Schrute"")

# Let's call a couple of methods
jim.species #=> ""H. sapiens""
jim.name #=> ""Jim Halpert""
jim.name = ""Jim Halpert II"" #=> ""Jim Halpert II""
jim.name #=> ""Jim Halpert II""
dwight.species #=> ""H. sapiens""
dwight.name #=> ""Dwight K. Schrute""

# Call the class method
Human.say(""Hi"") #=> print Hi and returns nil

# Variables that start with @ have instance scope
class TestClass
  @var = ""I'm an instance var""
end

# Variables that start with @@ have class scope
class TestClass
  @@var = ""I'm a class var""
end
# Variables that start with a capital letter are constants
Var = ""I'm a constant""
Var = ""can't be updated"" # Error: already initialized constant Var

# Class is also an object in Crystal. So a class can have instance variables.
# Class variable is shared among the class and all of its descendants.

# base class
class Human
  @@foo = 0

  def self.foo
    @@foo
  end

  def self.foo=(value)
    @@foo = value
  end
end

# derived class
class Worker < Human
end

Human.foo   #=> 0
Worker.foo  #=> 0

Human.foo = 2 #=> 2
Worker.foo    #=> 0

Worker.foo = 3 #=> 3
Human.foo   #=> 2
Worker.foo  #=> 3

module ModuleExample
  def foo
    ""foo""
  end
end

# Including modules binds their methods to the class instances
# Extending modules binds their methods to the class itself

class Person
  include ModuleExample
end

class Book
  extend ModuleExample
end

Person.foo     # => undefined method 'foo' for Person:Class
Person.new.foo # => 'foo'
Book.foo       # => 'foo'
Book.new.foo   # => undefined method 'foo' for Book


# Exception handling

# Define new exception
class MyException < Exception
end

# Define another exception
class MyAnotherException < Exception; end

ex = begin
   raise MyException.new
rescue ex1 : IndexError
  ""ex1""
rescue ex2 : MyException | MyAnotherException
  ""ex2""
rescue ex3 : Exception
  ""ex3""
rescue ex4 # catch any kind of exception
  ""ex4""
end

ex #=> ""ex2""

```

## Additional resources

- [Official Documentation](https://crystal-lang.org/)"
"Extensible Data Notation (EDN) is a format for serializing data.

EDN is a subset of the syntax used by Clojure. Reading data defined by EDN is
safer than that defined by the full Clojure syntax, especially from untrusted
sources. EDN is restricted to data, no code. It is similar in intent to JSON.
Though it is more commonly used in Clojure, there are implementations of EDN
for many other languages.

The main benefit of EDN over JSON and YAML is that it is extensible. We
will see how it is extended later on.

```clojure
; Comments start with a semicolon.
; Anything after the semicolon is ignored.

;;;;;;;;;;;;;;;;;;;
;;; Basic Types ;;;
;;;;;;;;;;;;;;;;;;;

nil         ; also known in other languages as null

; Booleans
true
false

; Strings are enclosed in double quotes
""hungarian breakfast""
""farmer's cheesy omelette""

; Characters are preceded by backslashes
\g \r \a \c \e

; Keywords start with a colon. They behave like enums. Kind of
; like symbols in Ruby.
:eggs
:cheese
:olives

; Symbols are used to represent identifiers. 
; You can namespace symbols by using /. Whatever precedes / is
; the namespace of the symbol.
spoon
kitchen/spoon ; not the same as spoon
kitchen/fork
github/fork   ; you can't eat with this

; Integers and floats
42
3.14159

; Lists are sequences of values
(:bun :beef-patty 9 ""yum!"")

; Vectors allow random access
[:gelato 1 2 -2]

; Maps are associative data structures that associate the key with its value
{:eggs        2
 :lemon-juice 3.5
 :butter      1}

; You're not restricted to using keywords as keys
{[1 2 3 4] ""tell the people what she wore"",
 [5 6 7 8] ""the more you see the more you hate""}

; You may use commas for readability. They are treated as whitespace.

; Sets are collections that contain unique elements.
#{:a :b 88 ""huat""}

;;;;;;;;;;;;;;;;;;;;;;;
;;; Tagged Elements ;;;
;;;;;;;;;;;;;;;;;;;;;;;

; EDN can be extended by tagging elements with # symbols.

#MyYelpClone/MenuItem {:name ""eggs-benedict"" :rating 10}

; Let me explain this with a Clojure example. Suppose I want to transform that
; piece of EDN into a MenuItem record.

(defrecord MenuItem [name rating])

; defrecord defined, among other things, map->MenuItem which will take a map
; of field names (as keywords) to values and generate a user.MenuItem record

; To transform EDN to Clojure values, I will need to use the built-in EDN
; reader, clojure.edn/read-string

(clojure.edn/read-string ""{:eggs 2 :butter 1 :flour 5}"")
; -> {:eggs 2 :butter 1 :flour 5}

; To transform tagged elements, pass to clojure.edn/read-string an option map
; with a :readers map that maps tag symbols to data-reader functions, like so

(clojure.edn/read-string
    {:readers {'MyYelpClone/MenuItem map->MenuItem}}
    ""#MyYelpClone/MenuItem {:name \""eggs-benedict\"" :rating 10}"")
; -> #user.MenuItem{:name ""eggs-benedict"", :rating 10}

```

# References

- [EDN spec](https://github.com/edn-format/edn)
- [Implementations](https://github.com/edn-format/edn/wiki/Implementations)
- [Tagged Elements](http://www.compoundtheory.com/clojure-edn-walkthrough/)"
"Mercury is a strict, pure functional/logic programming language, with
influences from Prolog, ML, and Haskell.

```prolog
% Percent sign starts a one-line comment.

    % foo(Bar, Baz)
    %
    % Documentation comments are indented before what they describe.
:- pred foo(bar::in, baz::out) is det.

% All toplevel syntax elements end with a '.' -- a full stop.

% Mercury terminology comes from predicate logic. Very roughly:

% | Mercury               | C                            |
% |                       |                              |
% | Goal                  | statement                    |
% | expression            | expression                   |
% | predicate rule        | void function                |
% | function rule         | function                     |
% | head (of a rule)      | function name and parameters |
% | body (of a rule)      | function body                |
% | fact                  | (rule without a body)        |
% | pred/func declaration | function signature           |
% | A, B  (conjunction)   | A && B                       |
% | A ; B (disjunction)   | if (A) {} else if (B) {}     |

% some facts:
man(socrates).  % ""it is a fact that Socrates is a man""
man(plato).
man(aristotle).

% a rule:
mortal(X) :- man(X).  % ""It is a rule that X is a mortal if X is a man.""
%            ^^^^^^-- the body of the rule
%         ^^-- an arrow <--, pointing to the head from the body
%^^^^^^^^-- the head of the rule
% this is also a single clause that defines the rule.

% that X is capitalized is how you know it's a variable.
% that socrates is uncapitalized is how you know it's a term.

% it's an error for 'socrates' to be undefined. It must have a type:

% declarations begin with ':-'
:- type people
    --->    socrates
    ;       plato
    ;       aristotle
    ;       hermes.
    %<--first tab stop (using 4-space tabs)
            %<--third tab stop (first after --->)

:- pred man(people).  % rules and facts also require types

% a rule's modes tell you how it can be used.
:- mode man(in) is semidet.  % man(plato) succeeds. man(hermes) fails.
:- mode man(out) is multi.   % man(X) binds X to one of socrates ; plato ; aristotle

% a semidet predicate is like a test. It doesn't return a value, but
% it can succeed or fail, triggering backtracking or the other side of
% a disjunction or conditional.

% 'is semidet' provides the determinism of a mode. Other determinisms:
% | Can fail? | 0 solutions | 1       | more than 1 |
% |           |             |         |             |
% | no        | erroneous   | det     | multi       |
% | yes       | failure     | semidet | nondet      |

:- pred mortal(people::in) is semidet.  % type/mode in one declaration

% this rule's body consists of two conjunctions: A, B, C
% this rule is true if A, B, and C are all true.
% if age(P) returns 16, it fails.
% if alive(P) fails, it fails.
:- type voter(people::in) is semidet.
voter(P) :-
    alive(P),
    registered(P, locale(P)),
    age(P) >= 18.  % age/1 is a function; int.>= is a function used as an operator

% ""a P is a voter if it is alive, is registered in P's locale, and if
% P's age is 18 or older.""

% the >= used here is provided by the 'int' module, which isn't
% imported by default. Mercury has a very small 'Prelude' (the
% 'builtin' module). You even need to import the 'list' module if
% you're going to use list literals.
```

Complete runnable example. File in 'types.m'; compile with 'mmc --make types'.

```prolog
:- module types.
:- interface.
:- import_module io.  % required for io.io types in...
% main/2 is usually 'det'. threading and exceptions require 'cc_multi'
:- pred main(io::di, io::uo) is cc_multi.  % program entry point
:- implementation.
:- import_module int, float, string, list, bool, map, exception.

% enum.
:- type days
    --->    sunday
    ;       monday
    ;       tuesday
    ;       wednesday
    ;       thursday
    ;       friday
    ;       saturday.

% discriminated union, like datatype in ML.
:- type payment_method
    --->    cash(int)
    ;       credit_card(
                name :: string,         % named fields
                cc_number :: string,
                cvv :: int,
                expiration :: string
            )
    ;       crypto(coin_type, wallet, amount).

:- type coin_type
    --->    etherium
    ;       monero.  % ""other coins are available""

% type aliases.
:- type wallet == string.
:- type amount == int.

% !IO is the pair of io.io arguments
% pass it to anything doing I/O, in order to perform I/O.
% many otherwise-impure functions can 'attach to the I/O state' by taking !IO
main(!IO) :-
    Ints = [
        3,
        1 + 1,
        8 - 1,
        10 * 2,
        35 / 5,
        5 / 2,      % truncating division
        int.div(5, 2),  % floored division
        div(5, 2),  % (module is unambiguous due to types)
        5 `div` 2,  % (any binary function can be an operator with ``)
        7 `mod` 3,  % modulo of floored division
        7 `rem` 3,  % remainder of truncating division
        2 `pow` 4,  % 2 to the 4th power
        (1 + 3) * 2,    % parens have their usual meaning

        2 >> 3,     % bitwise right shift
        128 << 3,   % bitwise left shift
        \ 0,        % bitwise complement
        5 /\ 1,     % bitwise and
        5 \/ 1,     % bitwise or
        5 `xor` 3,  % bitwise xor

        max_int,
        min_int,

        5 `min` 3,  % ( if 5 > 3 then 3 else 5 )
        5 `max` 3
    ],
    Bools = [
        yes,
        no
        % bools are much less important in Mercury because control flow goes by
        % semidet goals instead of boolean expressions.
    ],
    Strings = [
        ""this is a string"",
        ""strings can have """" embedded doublequotes via doubling"",
        ""strings support \u4F60\u597D the usual escapes\n"",
        % no implicit concatenation of strings: ""concat:"" ""together""
        ""but you can "" ++ "" use the string.++ operator"",

        % second param is a list(string.poly_type)
        % s/1 is a function that takes a string and returns a poly_type
        % i/1 takes an int. f/1 takes a float. c/1 takes a char.
        string.format(""Hello, %d'th %s\n"", [i(45), s(""World"")])
    ],

    % start with purely functional types like 'map' and 'list'!
    % arrays and hash tables are available too, but using them
    % requires knowing a lot more about Mercury
    get_map1(Map1),
    get_map2(Map2),

    % list.foldl has *many* variations
    % this one calls io.print_line(X, !IO) for each X of the list
    foldl(io.print_line, Ints, !IO),
    foldl(io.print_line, Bools, !IO),
    foldl(io.print_line, Strings, !IO),
    io.print_line(Map1, !IO),
    % ( if Cond then ThenGoal else ElseGoal )
    % I/O not allowed in Cond: I/O isn't allowed to fail!
    ( if Map2^elem(42) = Elem then
        io.print_line(Elem, !IO)
    else % always required
        true  % do nothing, successfully (vs. 'fail')
    ),

    % exception handling:
    ( try [io(!IO)] ( % io/1 param required or no I/O allowed here
        io.print_line(received(cash(1234)), !IO),
        io.print_line(received(crypto(monero, ""invalid"", 123)), !IO)
    ) then
        io.write_string(""all payments accepted\n"", !IO) % never reached
    catch ""monero not yet supported"" -> % extremely specific catch!
        io.write_string(""monero payment failed\n"", !IO)
    ).

:- pred get_map1(map(string, int)::out) is det.
get_map1(!:Map) :-  % !:Map in the head is the final (free, unbound) Map
    !:Map = init,   % !:Map in the body is the next Map
    det_insert(""hello"", 1, !Map),  % pair of Map vars
    det_insert(""world"", 2, !Map),

    % debug print of current (bound) Map
    % other [Params] can make it optional per runtime or compiletime flags
    trace [io(!IO)] (io.print_line(!.Map, !IO)),

    det_insert_from_corresponding_lists(K, V, !Map),
    % this code is reordered so that K and V and defined prior to their use
    K = [""more"", ""words"", ""here""],
    V = [3, 4, 5].

:- pred get_map2(map(int, bool)::out) is det.
get_map2(Map) :-
    det_insert(42, yes, map.init, Map).

:- func received(payment_method) = string.
received(cash(N)) = string.format(""received %d dollars"", [i(N)]).
received(credit_card(_, _, _, _)) = ""received credit card"".  % _ is throwaway
received(crypto(Type, _Wallet, Amount)) = S :-  % _Wallet is named throwaway
    ( % case/switch structure
        Type = etherium,
        S = string.format(""receiving %d ETH"", [i(Amount)])
    ;
        Type = monero,
        throw(""monero not yet supported"")  % exception with string as payload
    ).
```

## That was quick! Want more?

### More Tutorials

* [Mercury Tutorial](https://mercurylang.org/documentation/papers/book.pdf) (pdf link) - a more traditional tutorial with a more relaxed pace
* [Mercury Crash Course](https://mercury-in.space/crash.html) - a dense example-driven tutorial with Q&A format
* [Github Wiki Tutorial](https://github.com/Mercury-Language/mercury/wiki/Tutorial)
* [Getting Started with Mercury](https://bluishcoder.co.nz/2019/06/23/getting-started-with-mercury.html) - installation and your first steps
  
### Documentation

* Language manual, user's guide, and library reference are all at
  [mercurylang.org](https://mercurylang.org/documentation/documentation.html)"
"Swift is a programming language for iOS and macOS development created by Apple. Designed to coexist with Objective-C and to be more resilient against erroneous code, Swift was introduced in 2014 at Apple's developer conference WWDC. It is built with the LLVM compiler included in Xcode 6+.

The official _[Swift Programming Language](https://itunes.apple.com/us/book/swift-programming-language/id881256329)_ book from Apple is now available via iBooks. It goes into much more detail than this guide, and if you have the time and patience to read it, it's recommended. Some of these examples are from that book.

Another great reference is _About Swift_ on Swift's [website](https://docs.swift.org/swift-book/).

```swift
// import a module
import Foundation

// Single-line comments are prefixed with //
// Multi-line comments start with /* and end with */
/* Nested multiline comments
 /* ARE */
 allowed
 */

// Xcode supports landmarks to annotate your code and lists them in the jump bar
// MARK: Section mark
// MARK: - Section mark with a separator line
// TODO: Do something soon
// FIXME: Fix this code

//MARK: Hello, World
// From Swift 3 on, to print, just use the `print` method.
// It automatically appends a new line.
print(""Hello, world"")

//
// MARK: - Variables
//


//Use `let` to declare a constant and `var` to declare a variable.
let theAnswer = 42
var theQuestion = ""What is the Answer?""
theQuestion = ""How many roads must a man walk down?""
theQuestion = ""What is six by nine?""
// Atttempting to reassign a constant throws a compile-time error
//theAnswer = 54

// Both variables and constants can be declared before they are given a value,
//   but must be given a value before they are used
let someConstant: Int
var someVariable: String
// These lines will throw errors:
//print(someConstant)
//print(someVariable)
someConstant = 0
someVariable = ""0""
// These lines are now valid:
print(someConstant)
print(someVariable)

// As you can see above, variable types are automatically inferred.
//   To explicitly declare the type, write it after the variable name,
//   separated by a colon.
let aString: String = ""A string""
let aDouble: Double = 0

// Values are never implicitly converted to another type.
// Explicitly make instances of the desired type.
let stringWithDouble = aString + String(aDouble)
let intFromDouble = Int(aDouble)

// For strings, use string interpolation
let descriptionString = ""The value of aDouble is \(aDouble)""
// You can put any expression inside string interpolation.
let equation = ""Six by nine is \(6 * 9), not 42!""
// To avoid escaping double quotes and backslashes, change the string delimiter
let explanationString = #""The string I used was ""The value of aDouble is \(aDouble)"" and the result was \#(descriptionString)""#
// You can put as many number signs as you want before the opening quote,
//   just match them at the ending quote. They also change the escape character
//   to a backslash followed by the same number of number signs.

let multiLineString = """"""
    This is a multi-line string.
    It's called that because it takes up multiple lines (wow!)
        Any indentation beyond the closing quotation marks is kept, the rest is discarded.
    You can include "" or """" in multi-line strings because the delimiter is three ""s.
    """"""

// Arrays
let shoppingList = [""catfish"", ""water"", ""tulips"",] //commas are allowed after the last element
let secondElement = shoppingList[1] // Arrays are 0-indexed

// Arrays declared with let are immutable; the following line throws a compile-time error
//shoppingList[2] = ""mango""

// Arrays are structs (more on that later), so this creates a copy instead of referencing the same object
var mutableShoppingList = shoppingList
mutableShoppingList[2] = ""mango""

// == is equality
shoppingList == mutableShoppingList // false

// Dictionaries declared with let are also immutable
var occupations = [
    ""Malcolm"": ""Captain"",
    ""Kaylee"": ""Mechanic""
]
occupations[""Jayne""] = ""Public Relations""
// Dictionaries are also structs, so this also creates a copy
let immutableOccupations = occupations

immutableOccupations == occupations // true

// Arrays and dictionaries both automatically grow as you add elements
mutableShoppingList.append(""blue paint"")
occupations[""Tim""] = ""CEO""

// They can both be set to empty
mutableShoppingList = []
occupations = [:]

let emptyArray = [String]()
let emptyArray2 = Array<String>() // same as above
// [T] is shorthand for Array<T>
let emptyArray3: [String] = [] // Declaring the type explicitly allows you to set it to an empty array
let emptyArray4: Array<String> = [] // same as above

// [Key: Value] is shorthand for Dictionary<Key, Value>
let emptyDictionary = [String: Double]()
let emptyDictionary2 = Dictionary<String, Double>() // same as above
var emptyMutableDictionary: [String: Double] = [:]
var explicitEmptyMutableDictionary: Dictionary<String, Double> = [:] // same as above

// MARK: Other variables
let øπΩ = ""value"" // unicode variable names
let 🤯 = ""wow"" // emoji variable names

// Keywords can be used as variable names
// These are contextual keywords that wouldn't be used now, so are allowed
let convenience = ""keyword""
let weak = ""another keyword""
let override = ""another keyword""

// Using backticks allows keywords to be used as variable names even if they wouldn't be allowed normally
let `class` = ""keyword""

// MARK: - Optionals

/*
 Optionals are a Swift language feature that either contains a value,
 or contains nil (no value) to indicate that a value is missing.
 Nil is roughly equivalent to `null` in other languages.
 A question mark (?) after the type marks the value as optional of that type.

 If a type is not optional, it is guaranteed to have a value.

 Because Swift requires every property to have a type, even nil must be
 explicitly stored as an Optional value.

 Optional<T> is an enum, with the cases .none (nil) and .some(T) (the value)
 */

var someOptionalString: String? = ""optional"" // Can be nil
// T? is shorthand for Optional<T> — ? is a postfix operator (syntax candy)
let someOptionalString2: Optional<String> = nil
let someOptionalString3 = String?.some(""optional"") // same as the first one
let someOptionalString4 = String?.none //nil

/*
 To access the value of an optional that has a value, use the postfix
 operator !, which force-unwraps it. Force-unwrapping is like saying, ""I
 know that this optional definitely has a value, please give it to me.""

 Trying to use ! to access a non-existent optional value triggers a
 runtime error. Always make sure that an optional contains a non-nil
 value before using ! to force-unwrap its value.
 */

if someOptionalString != nil {
    // I am not nil
    if someOptionalString!.hasPrefix(""opt"") {
        print(""has the prefix"")
    }
}

// Swift supports ""optional chaining,"" which means that you can call functions
//   or get properties of optional values and they are optionals of the appropriate type.
// You can even do this multiple times, hence the name ""chaining.""

let empty = someOptionalString?.isEmpty // Bool?

// if-let structure -
// if-let is a special structure in Swift that allows you to check
//   if an Optional rhs holds a value, and if it does unwrap
//   and assign it to the lhs.
if let someNonOptionalStringConstant = someOptionalString {
    // has `Some` value, non-nil
    // someOptionalStringConstant is of type String, not type String?
    if !someNonOptionalStringConstant.hasPrefix(""ok"") {
        // does not have the prefix
    }
}

//if-var is allowed too!
if var someNonOptionalString = someOptionalString {
    someNonOptionalString = ""Non optional AND mutable""
    print(someNonOptionalString)
}

// You can bind multiple optional values in one if-let statement.
//   If any of the bound values are nil, the if statement does not execute.
if let first = someOptionalString, let second = someOptionalString2,
    let third = someOptionalString3, let fourth = someOptionalString4 {
    print(""\(first), \(second), \(third), and \(fourth) are all not nil"")
}

//if-let supports "","" (comma) clauses, which can be used to
//   enforce conditions on newly-bound optional values.
// Both the assignment and the "","" clause must pass.
let someNumber: Int? = 7
if let num = someNumber, num > 3 {
    print(""num is not nil and is greater than 3"")
}

// Implicitly unwrapped optional — An optional value that doesn't need to be unwrapped
let unwrappedString: String! = ""Value is expected.""

// Here's the difference:
let forcedString = someOptionalString! // requires an exclamation mark
let implicitString = unwrappedString // doesn't require an exclamation mark

/*
 You can think of an implicitly unwrapped optional as giving permission
 for the optional to be unwrapped automatically whenever it's used.
 Rather than placing an exclamation mark after the optional's name each time you use it,
 you place an exclamation mark after the optional's type when you declare it.
 */

// Otherwise, you can treat an implicitly unwrapped optional the same way the you treat a normal optional
//   (i.e., if-let, != nil, etc.)

// Pre-Swift 5, T! was shorthand for ImplicitlyUnwrappedOptional<T>
// Swift 5 and later, using ImplicitlyUnwrappedOptional throws a compile-time error.
//var unwrappedString2: ImplicitlyUnwrappedOptional<String> = ""Value is expected."" //error

// The nil-coalescing operator ?? unwraps an optional if it contains a non-nil value, or returns a default value.
someOptionalString = nil
let someString = someOptionalString ?? ""abc""
print(someString) // abc
// a ?? b is shorthand for a != nil ? a! : b

// MARK: - Control Flow

let condition = true
if condition { print(""condition is true"") } // can't omit the braces

if theAnswer > 50 {
    print(""theAnswer > 50"")
} else if condition {
    print(""condition is true"")
} else {
    print(""Neither are true"")
}

// The condition in an `if` statement must be a `Bool`, so the following code is an error, not an implicit comparison to zero
//if 5 {
//    print(""5 is not zero"")
//}

// Switch
// Must be exhaustive
// Does not implicitly fall through, use the fallthrough keyword
// Very powerful, think `if` statements with syntax candy
// They support String, object instances, and primitives (Int, Double, etc)
let vegetable = ""red pepper""
let vegetableComment: String
switch vegetable {
case ""celery"":
    vegetableComment = ""Add some raisins and make ants on a log.""
case ""cucumber"", ""watercress"": // match multiple values
    vegetableComment = ""That would make a good tea sandwich.""
case let localScopeValue where localScopeValue.hasSuffix(""pepper""):
    vegetableComment = ""Is it a spicy \(localScopeValue)?""
default: // required (in order to cover all possible input)
    vegetableComment = ""Everything tastes good in soup.""
}
print(vegetableComment)

// You use the `for-in` loop to iterate over a sequence, such as an array, dictionary, range, etc.
for element in shoppingList {
    print(element) // shoppingList is of type `[String]`, so element is of type `String`
}
//Iterating through a dictionary does not guarantee any specific order
for (person, job) in immutableOccupations {
    print(""\(person)'s job is \(job)"")
}
for i in 1...5 {
    print(i, terminator: "" "") // Prints ""1 2 3 4 5""
}
for i in 0..<5 {
    print(i, terminator: "" "") // Prints ""0 1 2 3 4""
}
//for index in range can replace a C-style for loop:
//    for (int i = 0; i < 10; i++) {
//        //code
//    }
//becomes:
//    for i in 0..<10 {
//        //code
//    }
//To step by more than one, use the stride(from:to:by:) or stride(from:through:by) functions
//`for i in stride(from: 0, to: 10, by: 2)` is the same as `for (int i = 0; i < 10; i += 2)`
//`for i in stride(from: 0, through: 10, by: 2)` is the same as `for (int i = 0; i <= 10; i += 2)

// while loops are just like most languages
var i = 0
while i < 5 {
    i += Bool.random() ? 1 : 0
    print(i)
}

// This is like a do-while loop in other languages — the body of the loop executes a minimum of once
repeat {
    i -= 1
    i += Int.random(in: 0...3)
} while i < 5

// The continue statement continues executing a loop at the next iteration
// The break statement ends a loop immediately

// MARK: - Functions

// Functions are a first-class type, meaning they can be nested in functions and can be passed around.

// Function with Swift header docs (format as Swift-modified Markdown syntax)

/// A greet operation.
///
/// - Parameters:
///   - name: A name.
///   - day: A day.
/// - Returns: A string containing the name and day value.
func greet(name: String, day: String) -> String {
    return ""Hello \(name), today is \(day).""
}
greet(name: ""Bob"", day: ""Tuesday"")

// Ideally, function names and parameter labels combine to make function calls similar to sentences.
func sayHello(to name: String, onDay day: String) -> String {
    return ""Hello \(name), the day is \(day)""
}
sayHello(to: ""John"", onDay: ""Sunday"")

//Functions that don't return anything can omit the return arrow; they don't need to say that they return Void (although they can).
func helloWorld() {
    print(""Hello, World!"")
}

// Argument labels can be blank
func say(_ message: String) {
    print(#""I say ""\#(message)""""#)
}
say(""Hello"")

// Default parameters can be omitted when calling the function.
func printParameters(requiredParameter r: Int, optionalParameter o: Int = 10) {
    print(""The required parameter was \(r) and the optional parameter was \(o)"")
}
printParameters(requiredParameter: 3)
printParameters(requiredParameter: 3, optionalParameter: 6)

// Variadic args — only one set per function.
func setup(numbers: Int...) {
    // it's an array
    let _ = numbers[0]
    let _ = numbers.count
}

// pass by ref
func swapTwoInts(a: inout Int, b: inout Int) {
    let tempA = a
    a = b
    b = tempA
}
var someIntA = 7
var someIntB = 3
swapTwoInts(a: &someIntA, b: &someIntB) //must be called with an & before the variable name.
print(someIntB) // 7

type(of: greet) // (String, String) -> String
type(of: helloWorld) // () -> Void

// Passing and returning functions
func makeIncrementer() -> ((Int) -> Int) {
    func addOne(number: Int) -> Int {
        return 1 + number
    }
    return addOne
}
var increment = makeIncrementer()
increment(7)

func performFunction(_ function: (String, String) -> String, on string1: String, and string2: String) {
    let result = function(string1, string2)
    print(""The result of calling the function on \(string1) and \(string2) was \(result)"")
}

// Function that returns multiple items in a tuple
func getGasPrices() -> (Double, Double, Double) {
    return (3.59, 3.69, 3.79)
}
let pricesTuple = getGasPrices()
let price = pricesTuple.2 // 3.79
// Ignore Tuple (or other) values by using _ (underscore)
let (_, price1, _) = pricesTuple // price1 == 3.69
print(price1 == pricesTuple.1) // true
print(""Gas price: \(price)"")

// Labeled/named tuple params
func getGasPrices2() -> (lowestPrice: Double, highestPrice: Double, midPrice: Double) {
    return (1.77, 37.70, 7.37)
}
let pricesTuple2 = getGasPrices2()
let price2 = pricesTuple2.lowestPrice
let (_, price3, _) = pricesTuple2
print(pricesTuple2.highestPrice == pricesTuple2.1) // true
print(""Highest gas price: \(pricesTuple2.highestPrice)"")

// guard statements
func testGuard() {
    // guards provide early exits or breaks, placing the error handler code near the conditions.
    // it places variables it declares in the same scope as the guard statement.
    // They make it easier to avoid the ""pyramid of doom""
    guard let aNumber = Optional<Int>(7) else {
        return // guard statements MUST exit the scope that they are in.
        // They generally use `return` or `throw`.
    }

    print(""number is \(aNumber)"")
}
testGuard()

// Note that the print function is declared like so:
//     func print(_ input: Any..., separator: String = "" "", terminator: String = ""\n"")
// To print without a newline:
print(""No newline"", terminator: """")
print(""!"")

// MARK: - Closures

var numbers = [1, 2, 6]

// Functions are special case closures ({})

// Closure example.
// `->` separates the arguments and return type
// `in` separates the closure header from the closure body
numbers.map({
    (number: Int) -> Int in
    let result = 3 * number
    return result
})

// When the type is known, like above, we can do this
numbers = numbers.map({ number in 3 * number })
// Or even this
//numbers = numbers.map({ $0 * 3 })

print(numbers) // [3, 6, 18]

// Trailing closure
numbers = numbers.sorted { $0 > $1 }

print(numbers) // [18, 6, 3]

// MARK: - Enums

// Enums can optionally be of a specific type or on their own.
// They can contain methods like classes.

enum Suit {
    case spades, hearts, diamonds, clubs
    var icon: Character {
        switch self {
        case .spades:
            return ""♤""
        case .hearts:
            return ""♡""
        case .diamonds:
            return ""♢""
        case .clubs:
            return ""♧""
        }
    }
}

// Enum values allow short hand syntax, no need to type the enum type
// when the variable is explicitly declared
var suitValue: Suit = .hearts

// Conforming to the CaseIterable protocol automatically synthesizes the allCases property,
//   which contains all the values. It works on enums without associated values or @available attributes.
enum Rank: CaseIterable {
    case ace
    case two, three, four, five, six, seven, eight, nine, ten
    case jack, queen, king
    var icon: String {
        switch self {
        case .ace:
            return ""A""
        case .two:
            return ""2""
        case .three:
            return ""3""
        case .four:
            return ""4""
        case .five:
            return ""5""
        case .six:
            return ""6""
        case .seven:
            return ""7""
        case .eight:
            return ""8""
        case .nine:
            return ""9""
        case .ten:
            return ""10""
        case .jack:
            return ""J""
        case .queen:
            return ""Q""
        case .king:
            return ""K""
        }
    }
}

for suit in [Suit.clubs, .diamonds, .hearts, .spades] {
    for rank in Rank.allCases {
        print(""\(rank.icon)\(suit.icon)"")
    }
}

// String enums can have direct raw value assignments
// or their raw values will be derived from the Enum field
enum BookName: String {
    case john
    case luke = ""Luke""
}
print(""Name: \(BookName.john.rawValue)"")

// Enum with associated Values
enum Furniture {
    // Associate with Int
    case desk(height: Int)
    // Associate with String and Int
    case chair(String, Int)

    func description() -> String {
        //either placement of let is acceptable
        switch self {
        case .desk(let height):
            return ""Desk with \(height) cm""
        case let .chair(brand, height):
            return ""Chair of \(brand) with \(height) cm""
        }
    }
}

var desk: Furniture = .desk(height: 80)
print(desk.description())     // ""Desk with 80 cm""
var chair = Furniture.chair(""Foo"", 40)
print(chair.description())    // ""Chair of Foo with 40 cm""

// MARK: - Structures & Classes

/*
 Structures and classes in Swift have many things in common. Both can:
 - Define properties to store values
 - Define methods to provide functionality
 - Define subscripts to provide access to their values using subscript syntax
 - Define initializers to set up their initial state
 - Be extended to expand their functionality beyond a default implementation
 - Conform to protocols to provide standard functionality of a certain kind

 Classes have additional capabilities that structures don't have:
 - Inheritance enables one class to inherit the characteristics of another.
 - Type casting enables you to check and interpret the type of a class instance at runtime.
 - Deinitializers enable an instance of a class to free up any resources it has assigned.
 - Reference counting allows more than one reference to a class instance.

 Unless you need to use a class for one of these reasons, use a struct.

 Structures are value types, while classes are reference types.
 */

// MARK: Structures

struct NamesTable {
    let names: [String]

    // Custom subscript
    subscript(index: Int) -> String {
        return names[index]
    }
}

// Structures have an auto-generated (implicit) designated ""memberwise"" initializer
let namesTable = NamesTable(names: [""Me"", ""Them""])
let name = namesTable[1]
print(""Name is \(name)"") // Name is Them

// MARK: Classes

class Shape {
    func getArea() -> Int {
        return 0
    }
}

class Rect: Shape {
    var sideLength: Int = 1

    // Custom getter and setter property
    var perimeter: Int {
        get {
            return 4 * sideLength
        }
        set {
            // `newValue` is an implicit variable available to setters
            sideLength = newValue / 4
        }
    }

    // Computed properties must be declared as `var`, you know, cause' they can change
    var smallestSideLength: Int {
        return self.sideLength - 1
    }

    // Lazily load a property
    // subShape remains nil (uninitialized) until getter called
    lazy var subShape = Rect(sideLength: 4)

    // If you don't need a custom getter and setter,
    // but still want to run code before and after getting or setting
    // a property, you can use `willSet` and `didSet`
    var identifier: String = ""defaultID"" {
        // the `someIdentifier` arg will be the variable name for the new value
        willSet(someIdentifier) {
            print(someIdentifier)
        }
    }

    init(sideLength: Int) {
        self.sideLength = sideLength
        // always super.init last when init custom properties
        super.init()
    }

    func shrink() {
        if sideLength > 0 {
            sideLength -= 1
        }
    }

    override func getArea() -> Int {
        return sideLength * sideLength
    }
}

// A simple class `Square` extends `Rect`
class Square: Rect {
    convenience init() {
        self.init(sideLength: 5)
    }
}

var mySquare = Square()
print(mySquare.getArea()) // 25
mySquare.shrink()
print(mySquare.sideLength) // 4

// cast instance
let aShape = mySquare as Shape

// downcast instance: 
// Because downcasting can fail, the result can be an optional (as?) or an implicitly unwrpped optional (as!).  
let anOptionalSquare = aShape as? Square // This will return nil if aShape is not a Square
let aSquare = aShape as! Square // This will throw a runtime error if aShape is not a Square

// compare instances, not the same as == which compares objects (equal to)
if mySquare === mySquare {
    print(""Yep, it's mySquare"")
}

// Optional init
class Circle: Shape {
    var radius: Int
    override func getArea() -> Int {
        return 3 * radius * radius
    }

    // Place a question mark postfix after `init` is an optional init
    // which can return nil
    init?(radius: Int) {
        self.radius = radius
        super.init()

        if radius <= 0 {
            return nil
        }
    }
}

var myCircle = Circle(radius: 1)
print(myCircle?.getArea())    // Optional(3)
print(myCircle!.getArea())    // 3
var myEmptyCircle = Circle(radius: -1)
print(myEmptyCircle?.getArea())    // ""nil""
if let circle = myEmptyCircle {
    // will not execute since myEmptyCircle is nil
    print(""circle is not nil"")
}

// MARK: - Protocols

// protocols are also known as interfaces in some other languages

// `protocol`s can require that conforming types have specific
// instance properties, instance methods, type methods,
// operators, and subscripts.

protocol ShapeGenerator {
    var enabled: Bool { get set }
    func buildShape() -> Shape
}

// MARK: - Other

// MARK: Typealiases

// Typealiases allow one type (or composition of types) to be referred to by another name
typealias Integer = Int
let myInteger: Integer = 0

// MARK: = Operator

// Assignment does not return a value. This means it can't be used in conditional statements,
//   and the following statement is also illegal
//    let multipleAssignment = theQuestion = ""No questions asked""
//But you can do this:
let multipleAssignment = ""No questions asked"", secondConstant = ""No answers given""

// MARK: Ranges

// The ..< and ... operators create ranges.

// ... is inclusive on both ends (a ""closed range"") — mathematically, [0, 10]
let _0to10 = 0...10
// ..< is inclusive on the left, exclusive on the right (a ""range"") — mathematically, [0, 10)
let singleDigitNumbers = 0..<10
// You can omit one end (a ""PartialRangeFrom"") — mathematically, [0, ∞)
let toInfinityAndBeyond = 0...
// Or the other end (a ""PartialRangeTo"") — mathematically, (-∞, 0)
let negativeInfinityToZero = ..<0
// (a ""PartialRangeThrough"") — mathematically, (-∞, 0]
let negativeInfinityThroughZero = ...0

// MARK: Wildcard operator

// In Swift, _ (underscore) is the wildcard operator, which allows values to be ignored

// It allows functions to be declared without argument labels:
func function(_ labelLessParameter: Int, label labeledParameter: Int, labelAndParameterName: Int) {
    print(labelLessParameter, labeledParameter, labelAndParameterName)
}
function(0, label: 0, labelAndParameterName: 0)

// You can ignore the return values of functions
func printAndReturn(_ str: String) -> String {
    print(str)
    return str
}
let _ = printAndReturn(""Some String"")

// You can ignore part of a tuple and keep part of it
func returnsTuple() -> (Int, Int) {
    return (1, 2)
}
let (_, two) = returnsTuple()

// You can ignore closure parameters
let closure: (Int, Int) -> String = { someInt, _ in
    return ""\(someInt)""
}
closure(1, 2) // returns 1

// You can ignore the value in a for loop
for _ in 0..<10 {
    // Code to execute 10 times
}

// MARK: Access Control

/*
 Swift has five levels of access control:
 - Open: Accessible *and subclassible* in any module that imports it.
 - Public: Accessible in any module that imports it, subclassible in the module it is declared in.
 - Internal: Accessible and subclassible in the module it is declared in.
 - Fileprivate: Accessible and subclassible in the file it is declared in.
 - Private: Accessible and subclassible in the enclosing declaration (think inner classes/structs/enums)

 See more here: https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html
 */

// MARK: Preventing Overrides

// You can add keyword `final` before a class or instance method, or a property to prevent it from being overridden
class Shape {
    final var finalInteger = 10
}

// Prevent a class from being subclassed
final class ViewManager {
}

// MARK: Conditional Compilation, Compile-Time Diagnostics, & Availability Conditions

// Conditional Compilation
#if false
print(""This code will not be compiled"")
#else
print(""This code will be compiled"")
#endif
/*
 Options are:
 os()                   macOS, iOS, watchOS, tvOS, Linux
 arch()                 i386, x86_64, arm, arm64
 swift()                >= or < followed by a version number
 compiler()             >= or < followed by a version number
 canImport()            A module name
 targetEnvironment()    simulator
 */
#if swift(<3)
println()
#endif

// Compile-Time Diagnostics
// You can use #warning(message) and #error(message) to have the compiler emit warnings and/or errors
#warning(""This will be a compile-time warning"")
//  #error(""This would be a compile-time error"")

//Availability Conditions
if #available(iOSMac 10.15, *) {
    // macOS 10.15 is available, you can use it here
} else {
    // macOS 10.15 is not available, use alternate APIs
}

// MARK: Any and AnyObject

// Swift has support for storing a value of any type.
// For that purpose there are two keywords: `Any` and `AnyObject`
// `AnyObject` == `id` from Objective-C
// `Any` works with any values (class, Int, struct, etc.)
var anyVar: Any = 7
anyVar = ""Changed value to a string, not good practice, but possible.""
let anyObjectVar: AnyObject = Int(1) as NSNumber

// MARK: Extensions

// Extensions allow you to add extra functionality to an already-declared type, even one that you don't have the source code for.

// Square now ""conforms"" to the `CustomStringConvertible` protocol
extension Square: CustomStringConvertible {
    var description: String {
        return ""Area: \(self.getArea()) - ID: \(self.identifier)""
    }
}

print(""Square: \(mySquare)"")

// You can also extend built-in types
extension Int {
    var doubled: Int {
        return self * 2
    }

    func multipliedBy(num: Int) -> Int {
        return num * self
    }

    mutating func multiplyBy(num: Int) {
        self *= num
    }
}

print(7.doubled) // 14
print(7.doubled.multipliedBy(num: 3)) // 42

// MARK: Generics

// Generics: Similar to Java and C#. Use the `where` keyword to specify the
//   requirements of the generics.

func findIndex<T: Equatable>(array: [T], valueToFind: T) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
findIndex(array: [1, 2, 3, 4], valueToFind: 3) // Optional(2)

// You can extend types with generics as well
extension Array where Array.Element == Int {
    var sum: Int {
        var total = 0
        for el in self {
            total += el
        }
        return total
    }
}

// MARK: Operators

// Custom operators can start with the characters:
//      / = - + * % < > ! & | ^ . ~
// or
// Unicode math, symbol, arrow, dingbat, and line/box drawing characters.
prefix operator !!!

// A prefix operator that triples the side length when used
prefix func !!! (shape: inout Square) -> Square {
    shape.sideLength *= 3
    return shape
}

// current value
print(mySquare.sideLength) // 4

// change side length using custom !!! operator, increases size by 3
!!!mySquare
print(mySquare.sideLength) // 12

// Operators can also be generics
infix operator <->
func <-><T: Equatable> (a: inout T, b: inout T) {
    let c = a
    a = b
    b = c
}

var foo: Float = 10
var bar: Float = 20

foo <-> bar
print(""foo is \(foo), bar is \(bar)"") // ""foo is 20.0, bar is 10.0""

// MARK: - Error Handling

// The `Error` protocol is used when throwing errors to catch
enum MyError: Error {
    case badValue(msg: String)
    case reallyBadValue(msg: String)
}

// functions marked with `throws` must be called using `try`
func fakeFetch(value: Int) throws -> String {
    guard 7 == value else {
        throw MyError.reallyBadValue(msg: ""Some really bad value"")
    }

    return ""test""
}

func testTryStuff() {
    // assumes there will be no error thrown, otherwise a runtime exception is raised
    let _ = try! fakeFetch(value: 7)

    // if an error is thrown, then it proceeds, but if the value is nil
    // it also wraps every return value in an optional, even if its already optional
    let _ = try? fakeFetch(value: 7)

    do {
        // normal try operation that provides error handling via `catch` block
        try fakeFetch(value: 1)
    } catch MyError.badValue(let msg) {
        print(""Error message: \(msg)"")
    } catch {
        // must be exhaustive
    }
}
testTryStuff()
```"
"**Easylang** is a simple programming language with built-in graphical functions and an easy-to-use and offline usable browser IDE. Its simple syntax and semantics make it well suited as a teaching and learning programming language. You can also use it to write graphical applications that you can embed in a web page. 

*Easylang* is statically typed and has as data types only strings and numbers (floating point), resizeable arrays of strings and numbers and arrays of arrays.

[The browser IDE](https://easylang.online/ide/) includes various tutorials, including one for beginners.

```
print ""Hello world""
#
# number variable (64 bit floating point)
#
h = 3.14
print h
#
# string variable
#
str$ = ""monkey""
# strings can grow
str$ &= "" circus"" 
print str$
#
# blocks end with 'end' or a dot, a newline has no
# other meaning than a space
#
for i = 1 to 5
  sum += i * i
.
print sum
#
# functions have value and reference
# parameters, no return values
#
func gcd a b . res .
  # a and b are value parameters
  # res is a reference parameter
  while b <> 0
    # h is a local variable, because 
    # it is first used in the function
    h = b
    b = a mod b
    a = h
  .
  res = a
.
call gcd 120 35 r
print r
#
# strings can be concatenated and numbers are
# automatically converted to strings
#
print ""1 + 2 = "" & 1 + 2
#
# array of numbers
#
a[] = [ 2.1 3.14 3 ]
#
# arrays can grow
a[] &= 4
print a[]
#
# arrays, strings and numbers are copied by value
#
b[] = a[]
a[] &= 4
print a[] ; print b[]
#
# array swapping ist fast
#
swap a[] b[]
print a[] ; print b[]
# 
# array of strings
#
fruits$[] = [ ""apple"" ""banana"" ""orange"" ]
#
# for-in iterates over the elements of an array
#
for fruit$ in fruits$[]
  print fruit$
.
#
# strings are also used for single characters
#
letters$[] = str_chars ""ping""
print letters$[]
letters$[1] = ""o""
print str_join letters$[]
#
# 2-dimensional arrays are arrays of arrays
# this defines 3 arrays with length 4
#
len a[][] 3
for i range len a[][]
  len a[i][] 4
.
a[1][2] = 99
print a[][]
#
# builtin functions
if sin 90 = 1
  print ""angles are in degree""
.
print pow 2 8
# seconds since 1970
print floor sys_time
# random numbers
print randomf
print random 6 + 1
# 
# hour and minutes
print substr time_str sys_time 11 5
# 
print str_ord ""A""
print str_chr 65
# 
# set number format
numfmt 0 4
print sqrt 2
print pi
print logn 10
# 
a$[] = str_split ""10,15,22"" "",""
print a$[]
print 2 * number a$[0]
print len a$[]
print len ""Hello""
#
# With 'break n' you can leave nested loops and a function
#
names$[] = [ ]
func name2id name$ . id .
  for id range len names$[]
    if names$[id] = name$
      # leave loop and function
      break 2
    .
  .
  names$[] &= name$
.
call name2id ""alice"" id ; print id
call name2id ""bob"" id ; print id
call name2id ""alice"" id ; print i
#
# with 'repeat' you can make loops, which you can leave
# in the loop body using 'until'
#
sum = 0
repeat
  s$ = input
  until s$ = """"
  sum += number s$
.
print ""sum: "" & sum
#
# ""input"" reads a string from the ""input_data"" section, 
# if it exists, otherwise via a prompt.
#
input_data
10
-2
6
```

Built-in graphic primitives and event-driven programming

```
# simple drawing with the mouse
# 
set_linewidth 4
set_color 900
# the colors are coded from 0 to 999, with 
# the left digit specifying the red component,
# the middle digit the green component and
# the right digit the blue component. 
# 
on mouse_down
  down = 1
  move_pen mouse_x mouse_y
  # moves the drawing pen to the actual mouse position
  draw_circle 2
.
on mouse_up
  down = 0
.
on mouse_move
  if down = 1
    draw_line mouse_x mouse_y
  .
.
```

```
# an animated pendulum
#
on animate
  # The animate event occurs after each screen refresh.
  #
  clear_screen
  move_pen 50 50
  draw_circle 1
  x = 50 + 40 * sin ang
  y = 50 - 40 * cos ang
  draw_line x y
  draw_circle 5
  vel += sin ang / 5
  ang += vel
.
ang = 10
```

* [More about Easylang](https://easylang.online/)

* [Source code](https://github.com/chkas/easylang)"
"Perl is a highly capable, feature-rich programming language with over 25 years of development.

Perl runs on over 100 platforms from portables to mainframes and is suitable for both rapid prototyping and large scale development projects.

```perl
# Single line comments start with a number sign.

#### Strict and warnings

use strict;
use warnings;

# All perl scripts and modules should include these lines. Strict causes
# compilation to fail in cases like misspelled variable names, and
# warnings will print warning messages in case of common pitfalls like
# concatenating to an undefined value.

#### Perl variable types

#  Variables begin with a sigil, which is a symbol showing the type.
#  A valid variable name starts with a letter or underscore,
#  followed by any number of letters, numbers, or underscores.

### Perl has three main variable types: $scalar, @array, and %hash.

## Scalars
#  A scalar represents a single value:
my $animal = ""camel"";
my $answer = 42;
my $display = ""You have $answer ${animal}s.\n"";

# Scalar values can be strings, integers or floating point numbers, and
# Perl will automatically convert between them as required.

# Strings in single quotes are literal strings. Strings in double quotes
# will interpolate variables and escape codes like ""\n"" for newline.

## Arrays
#  An array represents a list of values:
my @animals = (""camel"", ""llama"", ""owl"");
my @numbers = (23, 42, 69);
my @mixed   = (""camel"", 42, 1.23);

# Array elements are accessed using square brackets, with a $ to
# indicate one value will be returned.
my $second = $animals[1];

# The size of an array is retrieved by accessing the array in a scalar
# context, such as assigning it to a scalar variable or using the
# ""scalar"" operator.

my $num_animals = @animals;
print ""Number of numbers: "", scalar(@numbers), ""\n"";

# Arrays can also be interpolated into double-quoted strings, and the
# elements are separated by a space character by default.

print ""We have these numbers: @numbers\n"";

# Be careful when using double quotes for strings containing symbols
# such as email addresses, as it will be interpreted as a variable.

my @example = ('secret', 'array');
my $oops_email = ""foo@example.com""; # 'foosecret array.com'
my $ok_email = 'foo@example.com';

## Hashes
#   A hash represents a set of key/value pairs:

my %fruit_color = (""apple"", ""red"", ""banana"", ""yellow"");

#  You can use whitespace and the ""=>"" operator to lay them out more
#  nicely:

my %fruit_color = (
  apple  => ""red"",
  banana => ""yellow"",
);

# Hash elements are accessed using curly braces, again with the $ sigil.
my $color = $fruit_color{apple};

# All of the keys or values that exist in a hash can be accessed using
# the ""keys"" and ""values"" functions.
my @fruits = keys %fruit_color;
my @colors = values %fruit_color;

# Scalars, arrays and hashes are documented more fully in perldata.
# (perldoc perldata).

#### References

# More complex data types can be constructed using references, which
# allow you to build arrays and hashes within arrays and hashes.

my $array_ref = \@array;
my $hash_ref = \%hash;
my @array_of_arrays = (\@array1, \@array2, \@array3);

# You can also create anonymous arrays or hashes, returning a reference:

my $fruits = [""apple"", ""banana""];
my $colors = {apple => ""red"", banana => ""yellow""};

# References can be dereferenced by prefixing the appropriate sigil.

my @fruits_array = @$fruits;
my %colors_hash = %$colors;

# As a shortcut, the arrow operator can be used to dereference and
# access a single value.

my $first = $array_ref->[0];
my $value = $hash_ref->{banana};

# See perlreftut and perlref for more in-depth documentation on
# references.

#### Conditional and looping constructs

# Perl has most of the usual conditional and looping constructs.

if ($var) {
  ...
} elsif ($var eq 'bar') {
  ...
} else {
  ...
}

unless (condition) {
  ...
}
# This is provided as a more readable version of ""if (!condition)""

# the Perlish post-condition way
print ""Yow!"" if $zippy;
print ""We have no bananas"" unless $bananas;

#  while
while (condition) {
  ...
}

my $max = 5;
# for loops and iteration
for my $i (0 .. $max) {
  print ""index is $i"";
}

for my $element (@elements) {
  print $element;
}

map {print} @elements;

# implicitly

for (@elements) {
  print;
}

# iterating through a hash (for and foreach are equivalent)

foreach my $key (keys %hash) {
  print $key, ': ', $hash{$key}, ""\n"";
}

# the Perlish post-condition way again
print for @elements;

# iterating through the keys and values of a referenced hash
print $hash_ref->{$_} for keys %$hash_ref;

#### Regular expressions

# Perl's regular expression support is both broad and deep, and is the
# subject of lengthy documentation in perlrequick, perlretut, and
# elsewhere. However, in short:

# Simple matching
if (/foo/)       { ... }  # true if $_ contains ""foo""
if ($x =~ /foo/) { ... }  # true if $x contains ""foo""

# Simple substitution

$x =~ s/foo/bar/;         # replaces foo with bar in $x
$x =~ s/foo/bar/g;        # replaces ALL INSTANCES of foo with bar in $x


#### Files and I/O

# You can open a file for input or output using the ""open()"" function.

# For reading:
open(my $in,  ""<"",  ""input.txt"")  or die ""Can't open input.txt: $!"";
# For writing (clears file if it exists):
open(my $out, "">"",  ""output.txt"") or die ""Can't open output.txt: $!"";
# For writing (appends to end of file):
open(my $log, "">>"", ""my.log"")     or die ""Can't open my.log: $!"";

# You can read from an open filehandle using the ""<>"" operator.  In
# scalar context it reads a single line from the filehandle, and in list
# context it reads the whole file in, assigning each line to an element
# of the list:

my $line  = <$in>;
my @lines = <$in>;

# You can iterate through the lines in a file one at a time with a while loop:

while (my $line = <$in>) {
  print ""Found apples\n"" if $line =~ m/apples/;
}

# You can write to an open filehandle using the standard ""print""
# function.

print $out @lines;
print $log $msg, ""\n"";

#### Writing subroutines

# Writing subroutines is easy:

sub logger {
  my $logmessage = shift;

  open my $logfile, "">>"", ""my.log"" or die ""Could not open my.log: $!"";

  print $logfile $logmessage;
}

# Now we can use the subroutine just as any other built-in function:

logger(""We have a logger subroutine!"");

#### Modules

# A module is a set of Perl code, usually subroutines, which can be used
# in other Perl code. It is usually stored in a file with the extension
# .pm so that Perl can find it.

package MyModule;
use strict;
use warnings;

sub trim {
  my $string = shift;
  $string =~ s/^\s+//;
  $string =~ s/\s+$//;
  return $string;
}

1;

# From elsewhere:

use MyModule;
MyModule::trim($string);

# The Exporter module can help with making subroutines exportable, so
# they can be used like this:

use MyModule 'trim';
trim($string);

# Many Perl modules can be downloaded from CPAN (http://www.cpan.org/)
# and provide a range of features to help you avoid reinventing the
# wheel.  A number of popular modules like Exporter are included with
# the Perl distribution itself. See perlmod for more details on modules
# in Perl.

#### Objects

# Objects in Perl are just references that know which class (package)
# they belong to, so that methods (subroutines) called on it can be
# found there. The bless function is used in constructors (usually new)
# to set this up. However, you never need to call it yourself if you use
# a module like Moose or Moo (see below).

package MyCounter;
use strict;
use warnings;

sub new {
  my $class = shift;
  my $self = {count => 0};
  return bless $self, $class;
}

sub count {
  my $self = shift;
  return $self->{count};
}

sub increment {
  my $self = shift;
  $self->{count}++;
}

1;

# Methods can be called on a class or object instance with the arrow
# operator.

use MyCounter;
my $counter = MyCounter->new;
print $counter->count, ""\n""; # 0
$counter->increment;
print $counter->count, ""\n""; # 1

# The modules Moose and Moo from CPAN can help you set up your object
# classes. They provide a constructor and simple syntax for declaring
# attributes. This class can be used equivalently to the one above.

package MyCounter;
use Moo; # imports strict and warnings

has 'count' => (is => 'rwp', default => 0, init_arg => undef);

sub increment {
  my $self = shift;
  $self->_set_count($self->count + 1);
}

1;

# Object-oriented programming is covered more thoroughly in perlootut,
# and its low-level implementation in Perl is covered in perlobj.
```

#### FAQ

perlfaq contains questions and answers related to many common tasks, and often provides suggestions for good CPAN modules to use.

#### Further Reading

 - [perl-tutorial](http://perl-tutorial.org/)
 - [Learn at www.perl.com](http://www.perl.org/learn.html)
 - [perldoc](http://perldoc.perl.org/)
 - and perl built-in : `perldoc perlintro`"
"Texinfo is a documentation format you can use to create various types of
documents from the same source.  Its main usage is to create documentation
manuals and info pages for GNU projects.

Texinfo is a markup language that contains text and *@-commands* that specify
what the generator should do.

## Initial File

A simple example of a simple manual:

```
\input texinfo
@setfilename simple-document.info
@documentencoding UTF-8
@settitle simple-document
@c This is a comment
@c Replace simple-document above (twice) with the actual document title

@c Automake will take care of version.texi
@include version.texi

@copying
Copyright @copyright{} YEAR MY NAME

@c GFDL is common for GNU projects
@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@titlepage
@end titlepage

@c Now starts the actual content
@contents

@c The first node must always be Top
@node Top
@c And we give it a title
@top simple-document

This document quickly describes Texinfo features.

@c This is the ToC:
@menu
* Introduction::           A short summary of the chapter

@detailmenu
--- The Detailed Node Listing ---

Introduction

* Formatting::             How to format text nicely
* Links::                  Linking to other resources, pages, or manuals

@end detailmenu
@end menu

@node Introduction
@chapter Introduction

Each node must have the same name as the menu item that was defined in the ToC.

@node Formatting
@section Formatting
@c Add something to the content index, so people can get here when searching
@c for something else
@cindex bold text
@cindex titles

Similar to chapters, sections must have the same name and appear in the same order.

@subsection This is a subsection title
@subsubsection This is a sub-subsection title

Each block of text is a paragraph. You can use multiple lines for the paragraph
like so, only empty lines separate paragraphs.

Common formatting include @emph{emphasis}, @code{inline code}. Specific type of
text can be marked as well: @file{file.txt}, @option{--learn-fast},
@command{ls} or @var{variable}. You can escape the command character like
so: @@, and a newline with a single @@ at the end of the line.

You can add different types of blocks:

@example
Here is an example
@end example

@lisp
'(this is lisp code)
@end lisp

@itemize
@item An element in an unordered list
@item A second element in the same list
@end itemize

@enumerate
@item This list is similar
@item But ordered
@end enumerate

@quotation
A quotation block, by someone famous maybe
@end quotation

@table @asis
@item element title
element description

@item second element title
second element description. Note that the description part can span multiple
paragraphs, contain other blocks etc. This is usually used as a definition
list.

@code{@@asis} wraps the element title, and tells Texinfo to use them as-is.
@end table

@table @code
@item do-x
This item title is now wrapped in a code block, as in @code{@@code{do-x}}
@end table

@c content index can appear at any place in the document, not necessarily after
@c titles.
@cindex function definition
@deffn {Kind of Function} function_name @var{arg1} @var{arg2} @
  @var{arg3} @var{arg4} [@var{optional5}]
This text describes the function. Note how we could use multiple lines for the
function synopsis by escaping the line with a single @@.

This again can contain multiple paragraphs or blocks.
@end deffn

@node Links
@section Links

There are various types of links you can use. A simple link to a URL with
@uref{https://github.com} and optionally with it a title:
@uref{https://github.com, GitHub}. An email address @email{me@@me.me}.
A node in this document, @xref{Introduction}. Always use the exact node name
for that one. @code{xref} will include the text ``see'' before the link. To
insert something different, use @pxref{Introduction} (``See'') or
@xref{Introduction} (nothing is inserted). With an additional argument, you
can change the text of the link, @xref{Introduction, this introduction}.

It is possible to link to external manuals with these commands by adding
more arguments, as in @code{@@xref{Node name,,, manual-name, link text}},
@xref{Overview,,, texinfo, Texinfo's manual} for the complete reference
on Texinfo!

@bye
```

## How to Use It

With `automake`, all you need to do is to give it the path to your manual
in `Makefile.am`:

```
info_TEXINFOS= doc/simple-manual.texi
```

Then, get your info manual with `make doc/simple-manual.info` or in other formats,
e.g. HTML with `make doc/simple-manual.html`.

## Readings

- [Official manual](https://www.gnu.org/software/texinfo/manual/texinfo/html_node/)"
"**Microsoft DirectX** is a collection of application programming interfaces (APIs) for handling tasks related to
multimedia, especially game programming and video, on Microsoft platforms. Originally, the names of these APIs
all began with Direct, such as Direct3D, DirectDraw, DirectMusic, DirectPlay, DirectSound, and so forth. [...]
Direct3D (the 3D graphics API within DirectX) is widely used in the development of video games for Microsoft
Windows and the Xbox line of consoles.<sup>[1]</sup>

In this tutorial we will be focusing on DirectX 9, which is not as low-level as it's successors, which are aimed at programmers very familiar with how graphics hardware works. It makes a great starting point for learning Direct3D. In this tutorial I will be using the Win32-API for window handling and the DirectX 2010 SDK.

## Window creation

```cpp
#include <Windows.h>

bool _running{ false };

LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    // Handle incoming message.
    switch (msg) {
        // Set running to false if the user tries to close the window.
        case WM_DESTROY:
            _running = false;
            PostQuitMessage(0);
            break;
    }
    // Return the handled event.
    return DefWindowProc(hWnd, msg, wParam, lParam);
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine, int nCmdShow) {
    // Set window properties we want to use.
    WNDCLASSEX wndEx{ };
    wndEx.cbSize        = sizeof(WNDCLASSEX);        // structure size
    wndEx.style         = CS_VREDRAW | CS_HREDRAW;   // class styles
    wndEx.lpfnWndProc   = WndProc;                   // window procedure
    wndEx.cbClsExtra    = 0;                         // extra memory (struct)
    wndEx.cbWndExtra    = 0;                         // extra memory (window)
    wndEx.hInstance     = hInstance;                 // module instance
    wndEx.hIcon         = LoadIcon(nullptr, IDI_APPLICATION); // icon
    wndEx.hCursor       = LoadCursor(nullptr, IDC_ARROW);     // cursor
    wndEx.hbrBackground = (HBRUSH) COLOR_WINDOW;     // background color
    wndEx.lpszMenuName  = nullptr;                   // menu name
    wndEx.lpszClassName = ""DirectXClass"";            // register class name
    wndEx.hIconSm       = nullptr;                   // small icon (taskbar)
    // Register created class for window creation.
    RegisterClassEx(&wndEx);
    // Create a new window handle.
    HWND hWnd{ nullptr };
    // Create a new window handle using the registered class.
    hWnd = CreateWindow(""DirectXClass"",      // registered class
                        ""directx window"",    // window title
                        WS_OVERLAPPEDWINDOW, // window style
                        50, 50,              // x, y (position)
                        1024, 768,           // width, height (size)
                        nullptr,             // parent window
                        nullptr,             // menu
                        hInstance,           // module instance
                        nullptr);            // struct for infos
    // Check if a window handle has been created.
    if (!hWnd)
        return -1;   
    // Show and update the new window.
    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);
    // Start the game loop and send incoming messages to the window procedure.
    _running = true;
    MSG msg{ };
    while (_running) {
        while (PeekMessage(&msg, hWnd, 0, 0, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }  
    return 0;
}
```

This should create a window, that can the moved, resized and closed.

## Direct3D initialization

```cpp
// Includes DirectX 9 structures and functions.
// Remember to link ""d3d9.lib"" and ""d3dx9.lib"".
// For ""d3dx9.lib"" the DirectX SDK (June 2010) is needed.
// Don't forget to set your subsystem to Windows.
#include <d3d9.h>
#include <d3dx9.h>
// Includes the ComPtr, a smart pointer automatically releasing COM objects.
#include <wrl.h>
using namespace Microsoft::WRL;
// Next we define some Direct3D9 interface structs we need.
ComPtr<IDirect3D9> _d3d{ };
ComPtr<IDirect3DDevice9> _device{ };
```

With all interfaces declared we can now initialize Direct3D.

```cpp
bool InitD3D(HWND hWnd) {
    // Store the size of the window rectangle.
    RECT clientRect{ };
    GetClientRect(hWnd, &clientRect);
    // Initialize Direct3D
    _d3d = Direct3DCreate9(D3D_SDK_VERSION);
    // Get the display mode which format will be the window format.
    D3DDISPLAYMODE displayMode{ };
    _d3d->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, // use default graphics card
                                &displayMode);      // display mode pointer
    // Next we have to set some presentation parameters.
    D3DPRESENT_PARAMETERS pp{ };
    pp.BackBufferWidth = clientRect.right;    // width is window width
    pp.BackBufferHeight = clientRect.bottom;  // height is window height
    pp.BackBufferFormat = displayMode.Format; // use adapter format
    pp.BackBufferCount = 1;                   // 1 back buffer (default)
    pp.SwapEffect = D3DSWAPEFFECT_DISCARD;    // discard after presentation
    pp.hDeviceWindow = hWnd;                  // associated window handle
    pp.Windowed = true;                       // display in window mode
    pp.Flags = 0;                             // no special flags
    // Variable to store results of methods to check if everything succeeded.
    HRESULT result{ };
    result = _d3d->CreateDevice(D3DADAPTER_DEFAULT, // use default graphics card
                                D3DDEVTYPE_HAL,     // use hardware acceleration
                                hWnd,               // the window handle
                                D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                    // vertices are processed by the hardware
                                &pp,       // the present parameters
                                &_device); // struct to store the device
    // Return false if the device creation failed.
    // It is helpful to set breakpoints at the return line.
    if (FAILED(result))
        return false;
    // Create a viewport which hold information about which region to draw to.
    D3DVIEWPORT9 viewport{ };
    viewport.X = 0;         // start at top left corner
    viewport.Y = 0;         // ..
    viewport.Width = clientRect.right;   // use the entire window
    viewport.Height = clientRect.bottom; // ..
    viewport.MinZ = 0.0f;   // minimum view distance
    viewport.MaxZ = 100.0f; // maximum view distance
    // Apply the created viewport.
    result = _device->SetViewport(&viewport);
    // Always check if something failed.
    if (FAILED(result))
        return false;
    // Everything was successful, return true.
    return true;
}
// ...
// Back in our WinMain function we call our initialization function.
// ...
// Check if Direct3D initialization succeeded, else exit the application.
if (!InitD3D(hWnd))
    return -1;
        
MSG msg{ };
while (_running) {
    while (PeekMessage(&msg, hWnd, 0, 0, PM_REMOVE)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    // Clear to render target to a specified color.
    _device->Clear(0,               // number of rects to clear
                   nullptr,         // indicates to clear the entire window
                   D3DCLEAR_TARGET, // clear all render targets
                   D3DXCOLOR{ 1.0f, 0.0f, 0.0f, 1.0f }, // color (red)
                   0.0f,            // depth buffer clear value
                   0);              // stencil buffer clear value
    // ...
    // Drawing operations go here.
    // ...
    // Flip the front- and backbuffer.
    _device->Present(nullptr,  // no source rectangle
                     nullptr,  // no destination rectangle
                     nullptr,  // don't change the current window handle
                     nullptr); // pretty much always nullptr
}
// ...
```

Now the window should be displayed in a bright red color.

## Vertex Buffer

Let's create a vertex buffer to store the vertices for our triangle

```cpp
// At the top of the file we need to add a include.
#include <vector>
// First we declare a new ComPtr holding a vertex buffer.
ComPtr<IDirect3DVertexBuffer9> _vertexBuffer{ };
// Lets define a function to calculate the byte size of a std::vector
template <typename T>
unsigned int GetByteSize(const std::vector<T>& vec) {
    return sizeof(vec[0]) * vec.size();
}
// Define ""flexible vertex format"" describing the content of our vertex struct.
// Use the defined color as diffuse color.
const unsigned long VertexStructFVF = D3DFVF_XYZ | D3DFVF_DIFFUSE;
// Define a struct representing the vertex data the buffer will hold.
struct VStruct {
    float x, y, z;   // store the 3D position
    D3DCOLOR color;  // store a color
};
// Declare a new function to create a vertex buffer.
IDirect3DVertexBuffer9* CreateBuffer(const std::vector<VStruct>& vertices) {
    // Declare the buffer to be returned.
    IDirect3DVertexBuffer9* buffer{ };
    HRESULT result{ };
    result = _device->CreateVertexBuffer(
                 GetByteSize(vertices), // vector size in bytes
                 0,                     // data usage
                 VertexStructFVF,       // FVF of the struct
                 D3DPOOL_DEFAULT,       // use default pool for the buffer
                 &buffer,               // receiving buffer
                 nullptr);              // special shared handle
    // Check if buffer was created successfully.
    if (FAILED(result))
        return nullptr;
    // Create a data pointer for copying the vertex data
    void* data{ };
    // Lock the buffer to get a buffer for data storage.
    result = buffer->Lock(0,                     // byte offset
                          GetByteSize(vertices), // size to lock
                          &data,                 // receiving data pointer
                          0);                    // special lock flags
    // Check if buffer was locked successfully.
    if (FAILED(result))
        return nullptr;
    // Copy the vertex data using C standard libraries memcpy.
    memcpy(data, vertices.data(), GetByteSize(vertices));
    buffer->Unlock();
    // Set the FVF Direct3D uses for rendering.
    _device->SetFVF(VertexStructFVF);
    // If everything was successful return the filled vertex buffer.
    return buffer;
}
```

In our **WinMain** we can now call the new function after the Direct3D initialization.

```cpp
// ...
if (!InitD3D(hWnd))
    return -1;
// Define the vertices we need to draw a triangle.
// Values are declared in a clockwise direction else Direct3D would cull them.
// If you want to disable culling just call:
// _device->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
std::vector<VStruct> vertices {
    // Bottom left
    VStruct{ -1.0f, -1.0f, 1.0f, D3DXCOLOR{ 1.0f, 0.0f, 0.0f, 1.0f } },
    // Top left
    VStruct{ -1.0f,  1.0f, 1.0f, D3DXCOLOR{ 0.0f, 1.0f, 0.0f, 1.0f } },
    // Top right
    VStruct{  1.0f,  1.0f, 1.0f, D3DXCOLOR{ 0.0f, 0.0f, 1.0f, 1.0f } }
};
// Try to create the vertex buffer else exit the application.
if (!(_vertexBuffer = CreateBuffer(vertices)))
    return -1;
// ...
```

## Transformations

Before we can use the vertex buffer to draw our primitives, we first need to set up the matrices.

```cpp
// Lets create a new functions for the matrix transformations.
bool SetupTransform() {
    // Create a view matrix that transforms world space to
    // view space.
    D3DXMATRIX view{ };
    // Use a left-handed coordinate system.
    D3DXMatrixLookAtLH(
        &view,                              // receiving matrix
        &D3DXVECTOR3{ 0.0f, 0.0f, -20.0f }, // ""camera"" position
        &D3DXVECTOR3{ 0.0f, 0.0f, 0.0f },   // position where to look at
        &D3DXVECTOR3{ 0.0f, 1.0f, 0.0f });  // positive y-axis is up
    HRESULT result{ };
    result = _device->SetTransform(D3DTS_VIEW, &view); // apply the view matrix
    if (FAILED(result))
        return false;
    // Create a projection matrix that defines the view frustrum.
    // It transforms the view space to projection space.
    D3DXMATRIX projection{ };
    // Create a perspective projection using a left-handed coordinate system.
    D3DXMatrixPerspectiveFovLH(
        &projection,         // receiving matrix
        D3DXToRadian(60.0f), // field of view in radians
        1024.0f / 768.0f,    // aspect ratio (width / height)
        0.0f,                // minimum view distance
        100.0f);             // maximum view distance
    result = _device->SetTransform(D3DTS_PROJECTION, &projection);
    if (FAILED(result))
        return false;
    // Disable lighting for now so we can see what we want to render.
    result = _device->SetRenderState(D3DRS_LIGHTING, false);
    // View and projection matrix are successfully applied, return true.
    return true;
}
// ...
// Back in the WinMain function we can now call the transformation function.
// ...
if (!(_vertexBuffer = CreateVertexBuffer(vertices)))
    return -1;
// Call the transformation setup function.
if (!SetupTransform())
    return -1;
// ...
```

## Rendering

Now that everything is setup we can start drawing our first 2D triangle in 3D space.

```cpp
// ...
if (!SetupTransform())
    return -1;
// First we have to bind our vertex buffer to the data stream.
HRESULT result{ };
result = _device->SetStreamSource(0,                   // use the default stream
                                  _vertexBuffer.Get(), // pass the vertex buffer
                                  0,                   // no offset
                                  sizeof(VStruct));    // size of vertex struct
if (FAILED(result))
    return -1;

// Create a world transformation matrix and set it to an identity matrix.
D3DXMATRIX world{ };
D3DXMatrixIdentity(&world);
// Create a scalation matrix scaling our primitive by 10 in the x,
// 10 in the y and keeping the z direction.
D3DXMATRIX scaling{ };
D3DXMatrixScaling(&scaling, // matrix to scale
                  10,       // x scaling
                  10,       // y scaling
                  1);       // z scaling
// Create a rotation matrix storing the current rotation of our primitive.
// We set the current rotation matrix to an identity matrix for now.
D3DXMATRIX rotation{ };
D3DXMatrixIdentity(&rotation);
// Now we multiply the scalation and rotation matrix and store the result
// in the world matrix.
D3DXMatrixMultiply(&world,     // destination matrix
                   &scaling,   // matrix 1
                   &rotation); // matrix 2
// Apply the current world matrix.
_device->SetTransform(D3DTS_WORLD, &world);
// Disable culling so we can see the back of our primitive when it rotates.
_device->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
// The default cullmode is D3DCULL_CW.
// After we used our the rotation matrix for multiplication we can set it
// to rotate a small amount.
// D3DXToRadian() function converts degree to radians.
D3DXMatrixRotationY(&rotation,           // matrix to rotate
                    D3DXToRadian(0.5f)); // rotation angle in radians

MSG msg{ };
    while (_running) {
    // ...
        _device->Clear(0, nullptr, D3DCLEAR_TARGET,
                       D3DXCOLOR{ 0.0f, 0.0f, 0.0f, 1.0f }, 0.0f, 0);
        // With everything setup we can call the draw function.
        _device->BeginScene();
        _device->DrawPrimitive(D3DPT_TRIANGLELIST, // primitive type
                               0,                  // start vertex
                               1);                 // primitive count
        _device->EndScene();
    
        _device->Present(nullptr, nullptr, nullptr, nullptr);
        // We can keep multiplying the world matrix with our rotation matrix
        // to add it's rotation to the world matrix.
        D3DXMatrixMultiply(&world, &world, &rotation);
        // Update the modified world matrix.
        _device->SetTransform(D3DTS_WORLD, &world);
    // ...
```

You should now be viewing a 10x10 units colored triangle from 20 units away, rotating around its origin.<br>
You can find the complete working code here: [DirectX - 1](https://pastebin.com/YkSF2rkk)

## Indexing

To make it easier to draw primitives sharing a lot of vertices we can use indexing, so we only have to declare the unique vertices and put the order they are called in another array.

```cpp
// First we declare a new ComPtr for our index buffer.
ComPtr<IDirect3DIndexBuffer9> _indexBuffer{ };
// ...
// Declare a function creating a index buffer from a std::vector
IDirect3DIndexBuffer9* CreateIBuffer(std::vector<unsigned int>& indices) {
    IDirect3DIndexBuffer9* buffer{ };
    HRESULT result{ };
    result = _device->CreateIndexBuffer(
                 GetByteSize(indices), // vector size in bytes
                 0,                    // data usage 
                 D3DFMT_INDEX32,       // format is 32 bit int
                 D3DPOOL_DEFAULT,      // default pool
                 &buffer,              // receiving buffer
                 nullptr);             // special shared handle
    if (FAILED(result))
        return nullptr;
    // Create a data pointer pointing to the buffer data.
    void* data{ };
    result = buffer->Lock(0,                    // byte offset
                          GetByteSize(indices), // byte size
                          &data,                // receiving data pointer
                          0);                   // special lock flag
    if (FAILED(result))
        return nullptr;
    // Copy the index data and unlock after copying.
    memcpy(data, indices.data(), GetByteSize(indices));
    buffer->Unlock();
    // Return the filled index buffer.
    return buffer;
}
// ...
// In our WinMain we can now change the vertex data and create new index data.
// ...
std::vector<VStruct> vertices {
    VStruct{ -1.0f, -1.0f, 1.0f, D3DXCOLOR{ 1.0f, 0.0f, 0.0f, 1.0f } },
    VStruct{ -1.0f,  1.0f, 1.0f, D3DXCOLOR{ 0.0f, 1.0f, 0.0f, 1.0f } },
    VStruct{  1.0f,  1.0f, 1.0f, D3DXCOLOR{ 0.0f, 0.0f, 1.0f, 1.0f } },
    // Add a vertex for the bottom right.
    VStruct{  1.0f, -1.0f, 1.0f, D3DXCOLOR{ 1.0f, 1.0f, 0.0f, 1.0f } }
};
// Declare the index data, here we build a rectangle from two triangles.
std::vector<unsigned int> indices {
    0, 1, 2, // the first triangle (b,left -> t,left -> t,right)
    0, 2, 3  // the second triangle (b,left -> t,right -> b,right)
};
// ...
// Now we call the ""CreateIBuffer"" function to create a index buffer.
// ...
if (!(_indexBuffer = CreateIBuffer(indices)))
    return -1;
// ...
// After binding the vertex buffer we have to bind the index buffer to
// use indexed rendering.
result = _device->SetStreamSource(0, _vertexBuffer.Get(), 0, sizeof(VStruct));
if (FAILED(result))
    return -1;
// Bind the index data to the default data stream.
result = _device->SetIndices(_indexBuffer.Get())
if (FAILED(result))
    return -1;
// ...
// Now we replace the ""DrawPrimitive"" function with an indexed version.
_device->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, // primitive type
                              0,                  // base vertex index
                              0,                  // minimum index
                              indices.size(),     // amount of vertices
                              0,                  // start in index buffer
                              2);                 // primitive count
// ...
```

Now you should see a colored rectangle made up of 2 triangles. If you set the primitive count in the ""DrawIndexedPrimitive"" method to 1 only the first triangle should be rendered and if you set the start of the index buffer to 3 and the primitive count to 1 only the second triangle should be rendered.<br>
You can find the complete working code here: [DirectX - 2](https://pastebin.com/yWBPWPRG)

## Vertex declaration

Instead of using the old ""flexible vertex format"" we should use vertex declarations instead, as the FVF declarations get converted to vertex declarations internally anyway.

```cpp
// First we have to REMOVE the following lines:
const unsigned long VertexStructFVF = D3DFVF_XYZ | D3DFVF_DIFFUSE;
// and
_device->SetFVF(VertexStructFVF);
// ...
// We also have to change the vertex buffer creation FVF-flag.
result = _device->CreateVertexBuffer(
                      GetByteSize(vertices),
                      0,
                      0,        // <- 0 indicates we use vertex declarations
                      D3DPOOL_DEFAULT,
                      &buffer,
                      nullptr); 
// Next we have to declare a new ComPtr.
ComPtr<IDirect3DVertexDeclaration9> _vertexDecl{ };
// ...
result = _device->SetIndices(_indexBuffer.Get());
if (FAILED(result))
    return -1;
// Now we have to declare and apply the vertex declaration.
// Create a vector of vertex elements making up the vertex declaration.
std::vector<D3DVERTEXELEMENT9> vertexDeclDesc {
    { 0,                     // stream index
      0,                     // byte offset from the struct beginning
      D3DDECLTYPE_FLOAT3,    // data type (3d float vector)
      D3DDECLMETHOD_DEFAULT, // tessellator operation
      D3DDECLUSAGE_POSITION,  // usage of the data
      0 },                   // index (multiples usage of the same type)
    { 0,
      12,                    // byte offset (3 * sizeof(float) bytes)
      D3DDECLTYPE_D3DCOLOR,
      D3DDECLMETHOD_DEFAULT,
      D3DDECLUSAGE_COLOR,
      0 },
    D3DDECL_END()            // marks the end of the vertex declaration
};
// After having defined the vector we can create a vertex declaration from it.
result = _device->CreateVertexDeclaration(
                      vertexDeclDesc.data(), // the vertex element array
                      &_vertexDecl);         // receiving pointer
if (FAILED(result)) 
    return -1;
// Apply the created vertex declaration.
_device->SetVertexDeclaration(_vertexDecl.Get());
// ...
```

## Shader

The maximum shader model for Direct3D 9 is shader model 3.0. Even though every modern graphics card should support it, it is best to check for capabilities.

```cpp
// ...
_device->SetVertexDeclaration(_vertexDecl.Get());
// First we have to request the device capabilities.
D3DCAPS9 deviceCaps{ };
_device->GetDeviceCaps(&deviceCaps);
// Now we check if shader model 3.0 is supported for the vertex shader.
if (deviceCaps.VertexShaderVersion < D3DVS_VERSION(3, 0))
    return -1;
// And the same for the pixel shader.
if (deviceCaps.PixelShaderVersion < D3DPS_VERSION(3, 0))
    return -1;
```

Now that we are sure shader model 3.0 is supported let's create the vertex and pixel shader files.
DirectX 9 introduced the HLSL (**High Level Shading Language**), a C-like shader language, which
simplified the shader programming a lot, as you could only write shaders in shader assembly in DirectX 8.
Let's create a simple vertex- and pixel shader. 

**Vertex Shader**

```cpp
// 3 4x4 float matrices representing the matrices we set in the fixed-function
// pipeline by using the SetTransform() method.
float4x4 projectionMatrix;
float4x4 viewMatrix;
float4x4 worldMatrix;
// The input struct to the vertex shader.
// It holds a 3d float vector for the position and a 4d float vector
// for the color.
struct VS_INPUT {
    float3 position : POSITION;
    float4 color : COLOR;
};
// The output struct of the vertex shader, that is passed to the pixel shader.
struct VS_OUTPUT {
    float4 position : POSITION;
    float4 color : COLOR;
};
// The main function of the vertex shader returns the output it sends to the
// pixel shader and receives it's input as a parameter.
VS_OUTPUT main(VS_INPUT input) {
    // Declare a empty struct, that the vertex shader returns.
    VS_OUTPUT output;
    // Set the output position to the input position and set
    // the w-component to 1, as the input position is a 3d vector and
    // the output position a 4d vector.
    output.position = float4(input.position, 1.0f);
    // Multiply the output position step by step with the world, view and
    // projection matrices.
    output.position = mul(output.position, worldMatrix);	
    output.position = mul(output.position, viewMatrix);
    output.position = mul(output.position, projectionMatrix);
	// Pass the input color unchanged to the pixel shader.
    output.color = input.color;
    // Return the output struct to the pixel shader.
    // The position value is automatically used as the vertex position.
    return output;
}
```

**Pixel Shader**

```cpp
// The pixel shader input struct must be the same as the vertex shader output!
struct PS_INPUT {
    float4 position : POSITION;
    float4 color : COLOR;
};
// The pixel shader simply returns a 4d vector representing the vertex color.
// It receives it's input as a parameter just like the vertex shader.
// We have to declare the output semantic as color to it gets interpreted
// correctly.
float4 main(PS_INPUT input) : COLOR {
    return input.color;
}
```

For more on semantics: [DirectX - Semantics](https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics#vertex-shader-semantics)

Now we have to do quite some changes to the code.

```cpp
ComPtr<IDirect3DDevice9> _device{ };
ComPtr<IDirect3DVertexBuffer9> _vertexBuffer{ };
ComPtr<IDirect3DIndexBuffer9> _indexBuffer{ };
ComPtr<IDirect3DVertexDeclaration9> _vertexDecl{ };
// We have to add a ComPtr for the vertex- and pixel shader, aswell as one
// for the constants (matrices) in our vertex shader.
ComPtr<IDirect3DVertexShader9> _vertexShader{ };
ComPtr<IDirect3DPixelShader9> _pixelShader{ };
ComPtr<ID3DXConstantTable> _vertexTable{ };
// Declare the world and rotation matrix as global, because we use them in
// WinMain and SetupTransform now.
D3DXMATRIX _worldMatrix{ };
D3DXMATRIX _rotationMatrix{ };
// ...
bool SetupTransform() {
    // Set the world and rotation matrix to an identity matrix.
    D3DXMatrixIdentity(&_worldMatrix);
    D3DXMatrixIdentity(&_rotationMatrix);
	
    D3DXMATRIX scaling{ };
    D3DXMatrixScaling(&scaling, 10, 10, 1);
    D3DXMatrixMultiply(&_worldMatrix, &scaling, &_rotationMatrix);
    // After multiplying the scalation and rotation matrix the have to pass
    // them to the shader, by using a method from the constant table
    // of the vertex shader.
    HRESULT result{ };
    result = _vertexTable->SetMatrix(
                         _device.Get(),   // direct3d device
                         ""worldMatrix"",   // matrix name in the shader
                          &_worldMatrix); // pointer to the matrix
    if (FAILED(result))
        return false;

    D3DXMATRIX view{ };
    D3DXMatrixLookAtLH(&view, &D3DXVECTOR3{ 0.0f, 0.0f, -20.0f },
           &D3DXVECTOR3{ 0.0f, 0.0f, 0.0f }, &D3DXVECTOR3{ 0.0f, 1.0f, 0.0f });
    // Do the same for the view matrix.
    result = _vertexTable->SetMatrix(
	                       _device.Get(), // direct 3d device
	                       ""viewMatrix"",  // matrix name
	                       &view);        // matrix
    if (FAILED(result))
        return false;

    D3DXMATRIX projection{ };
    D3DXMatrixPerspectiveFovLH(&projection, D3DXToRadian(60.0f),
        1024.0f / 768.0f, 0.0f, 100.0f);
    // And also for the projection matrix.
    result = _vertexTable->SetMatrix(
	                       _device.Get(),
	                       ""projectionMatrix"",
	                       &projection);
    if (FAILED(result))
        return false;

    D3DXMatrixRotationY(&_rotationMatrix, D3DXToRadian(0.5f));
    return true;
}
// ...
// Vertex and index buffer creation aswell as initialization stay unchanged.
// ...
// After checking that shader model 3.0 is available we have to compile and
// create the shaders.
// Declare two temporary buffers storing the compiled shader code.
ID3DXBuffer* vertexShaderBuffer{ };
ID3DXBuffer* pixelShaderBuffer{ };
result = D3DXCompileShaderFromFile(""vertex.hlsl"",  // shader name
                                   nullptr,        // macro definitions
                                   nullptr,        // special includes
                                   ""main"",         // entry point name
                                   ""vs_3_0"",       // shader model version
                                   0,              // special flags
                                   &vertexShaderBuffer, // code buffer
                                   nullptr,        // error message
                                   &_vertexTable); // constant table
if (FAILED(result))
    return -1;
// After the vertex shader compile the pixel shader.
result = D3DXCompileShaderFromFile(""pixel.hlsl"",
                                   nullptr,
                                   nullptr,
                                   ""main"",
                                   ""ps_3_0"", // pixel shader model 3.0
                                   0,
                                   &pixelShaderBuffer,
                                   nullptr,
                                   nullptr); // no need for a constant table
if (FAILED(result))
    return -1;
// Create the vertex shader from the code buffer.
result = _device->CreateVertexShader(
             (DWORD*)vertexShaderBuffer->GetBufferPointer(), // code buffer
             &_vertexShader); // vertex shader pointer
if (FAILED(result))
    return -1;
	
result = _device->CreatePixelShader(
             (DWORD*)pixelShaderBuffer->GetBufferPointer(),
             &_pixelShader);
if (FAILED(result))
    return -1;
// Release the temporary code buffers after the shaders are created.
vertexShaderBuffer->Release();
pixelShaderBuffer->Release();
// Apply the vertex- and pixel shader.
_device->SetVertexShader(_vertexShader.Get());
_device->SetPixelShader(_pixelShader.Get());
// Apply the transform after the shaders have been set.
if (!SetupTransform())
    return -1;
// You can also REMOVE the call so set the lighting render state.
_device->SetRenderState(D3DRS_LIGHTING, false);
```

You can find the complete code here: [DirectX - 3](https://pastebin.com/y4NrvawY)

## Texturing

```cpp
// First we need to declare a ComPtr for the texture.
ComPtr<IDirect3DTexture9> _texture{ };
// Then we have to change the vertex struct.
struct VStruct {
    float x, y, z;
    float u, v;      // Add texture u and v coordinates
    D3DCOLOR color;
};
// In the vertex declaration we have to add the texture coordinates.
// the top left of the texture is u: 0, v: 0.
std::vector<VStruct> vertices {
    VStruct{ -1.0f, -1.0f, 1.0f, 0.0f, 1.0f, ... }, // bottom left
    VStruct{ -1.0f,  1.0f, 1.0f, 0.0f, 0.0f, ... }, // top left
    VStruct{  1.0f,  1.0f, 1.0f, 1.0f, 0.0f, ... }, // top right
    VStruct{  1.0f, -1.0f, 1.0f, 1.0f, 1.0f, ... }  // bottom right
};
// Next is the vertex declaration.
std::vector<D3DVERTEXELEMENT9> vertexDecl{
    {0, 0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0},
    // Add a 2d float vector used for texture coordinates.
    {0, 12, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0},
    // The color offset is not (3 + 2) * sizeof(float) = 20 bytes
    {0, 20, D3DDECLTYPE_D3DCOLOR, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR, 0},
    D3DDECL_END()
};
// Now we have to load the texture and pass its to the shader.
// ...
_device->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
// Create a Direct3D texture from a png file.
result = D3DXCreateTextureFromFile(_device.Get(), // direct3d device
                                   ""texture.png"", // texture path
                                   &_texture);    // receiving texture pointer
if (FAILED(result))
    return -1;
// Attach the texture to shader stage 0, which is equal to texture register 0
// in the pixel shader.
_device->SetTexture(0, _texture.Get());
```

With the main code ready we now have to adjust the shaders to these changes.

**Vertex Shader**

```cpp
float4x4 projectionMatrix;
float4x4 viewMatrix;
float4x4 worldMatrix;
// Add the texture coordinates to the vertex shader in- and output.
struct VS_INPUT {
    float3 position : POSITION;
    float2 texcoord : TEXCOORD;
    float4 color : COLOR;
};

struct VS_OUTPUT {
    float4 position : POSITION;
    float2 texcoord : TEXCOORD;
    float4 color : COLOR;
};

VS_OUTPUT main(VS_INPUT input) {
    VS_OUTPUT output;
    
    output.position = float4(input.position, 1.0f);
    output.position = mul(output.position, worldMatrix);	
    output.position = mul(output.position, viewMatrix);
    output.position = mul(output.position, projectionMatrix);

    output.color = input.color;
    // Set the texcoord output to the input.
    output.texcoord = input.texcoord;
    
    return output;
}
```

**Pixel Shader**

```cpp
// Create  a sampler called ""sam0"" using sampler register 0, which is equal
// to the texture stage 0, to which we passed the texture.
sampler sam0 : register(s0);

struct PS_INPUT {
    float4 position : POSITION;
    float2 texcoord : TEXCOORD;
    float4 color : COLOR;
};

float4 main(PS_INPUT input) : COLOR{
    // Do a linear interpolation between the texture color and the input color
    // using 75% of the input color.
    // tex2D returns the texture data at the specified texture coordinate.
    return lerp(tex2D(sam0, input.texcoord), input.color, 0.75f);
}
```

## Quotes
<sup>[1]</sup>[DirectX - Wikipedia](https://en.wikipedia.org/wiki/DirectX)"
"C++ is a systems programming language that,
[according to its inventor Bjarne Stroustrup](https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote),
was designed to

- be a ""better C""
- support data abstraction
- support object-oriented programming
- support generic programming

Though its syntax can be more difficult or complex than newer languages,
it is widely used because it compiles to native instructions that can be
directly run by the processor and offers tight control over hardware (like C)
while offering high-level features such as generics, exceptions, and classes.
This combination of speed and functionality makes C++
one of the most widely-used programming languages.

```c++
//////////////////
// Comparison to C
//////////////////

// C++ is _almost_ a superset of C and shares its basic syntax for
// variable declarations, primitive types, and functions.

// Just like in C, your program's entry point is a function called
// main with an integer return type.
// This value serves as the program's exit status.
// See https://en.wikipedia.org/wiki/Exit_status for more information.
int main(int argc, char** argv)
{
    // Command line arguments are passed in by argc and argv in the same way
    // they are in C.
    // argc indicates the number of arguments,
    // and argv is an array of C-style strings (char*)
    // representing the arguments.
    // The first argument is the name by which the program was called.
    // argc and argv can be omitted if you do not care about arguments,
    // giving the function signature of int main()

    // An exit status of 0 indicates success.
    return 0;
}

// However, C++ varies in some of the following ways:

// In C++, character literals are chars
sizeof('c') == sizeof(char) == 1

// In C, character literals are ints
sizeof('c') == sizeof(int)


// C++ has strict prototyping
void func(); // function which accepts no arguments

// In C
void func(); // function which may accept any number of arguments

// Use nullptr instead of NULL in C++
int* ip = nullptr;

// C standard headers are available in C++.
// C headers end in .h, while
// C++ headers are prefixed with ""c"" and have no "".h"" suffix.

// The C++ standard version:
#include <cstdio>

// The C standard version:
#include <stdio.h>

int main()
{
    printf(""Hello, world!\n"");
    return 0;
}

///////////////////////
// Function overloading
///////////////////////

// C++ supports function overloading
// provided each function takes different parameters.

void print(char const* myString)
{
    printf(""String %s\n"", myString);
}

void print(int myInt)
{
    printf(""My int is %d"", myInt);
}

int main()
{
    print(""Hello""); // Resolves to void print(const char*)
    print(15); // Resolves to void print(int)
}

/////////////////////////////
// Default function arguments
/////////////////////////////

// You can provide default arguments for a function
// if they are not provided by the caller.

void doSomethingWithInts(int a = 1, int b = 4)
{
    // Do something with the ints here
}

int main()
{
    doSomethingWithInts();      // a = 1,  b = 4
    doSomethingWithInts(20);    // a = 20, b = 4
    doSomethingWithInts(20, 5); // a = 20, b = 5
}

// Default arguments must be at the end of the arguments list.

void invalidDeclaration(int a = 1, int b) // Error!
{
}


/////////////
// Namespaces
/////////////

// Namespaces provide separate scopes for variable, function,
// and other declarations.
// Namespaces can be nested.

namespace First {
    namespace Nested {
        void foo()
        {
            printf(""This is First::Nested::foo\n"");
        }
    } // end namespace Nested
} // end namespace First

namespace Second {
    void foo()
    {
        printf(""This is Second::foo\n"");
    }
    void bar()
    {
    	printf(""This is Second::bar\n"");
    }
}

void foo()
{
    printf(""This is global foo\n"");
}

int main()
{
    // Includes all symbols from namespace Second into the current scope. Note
    // that while bar() works, simply using foo() no longer works, since it is
    // now ambiguous whether we're calling the foo in namespace Second or the
    // top level.
    using namespace Second;

    bar(); // prints ""This is Second::bar""
    Second::foo(); // prints ""This is Second::foo""
    First::Nested::foo(); // prints ""This is First::Nested::foo""
    ::foo(); // prints ""This is global foo""
}

///////////////
// Input/Output
///////////////

// C++ input and output uses streams
// cin, cout, and cerr represent stdin, stdout, and stderr.
// << is the insertion operator and >> is the extraction operator.

#include <iostream> // Include for I/O streams

using namespace std; // Streams are in the std namespace (standard library)

int main()
{
   int myInt;

   // Prints to stdout (or terminal/screen)
   cout << ""Enter your favorite number:\n"";
   // Takes in input
   cin >> myInt;

   // cout can also be formatted
   cout << ""Your favorite number is "" << myInt << '\n';
   // prints ""Your favorite number is <myInt>""

   cerr << ""Used for error messages"";
}

//////////
// Strings
//////////

// Strings in C++ are objects and have many member functions
#include <string>

using namespace std; // Strings are also in the namespace std (standard library)

string myString = ""Hello"";
string myOtherString = "" World"";

// + is used for concatenation.
cout << myString + myOtherString; // ""Hello World""

cout << myString + "" You""; // ""Hello You""

// C++ strings are mutable.
myString.append("" Dog"");
cout << myString; // ""Hello Dog""


/////////////
// References
/////////////

// In addition to pointers like the ones in C,
// C++ has _references_.
// These are pointer types that cannot be reassigned once set
// and cannot be null.
// They also have the same syntax as the variable itself:
// No * is needed for dereferencing and
// & (address of) is not used for assignment.

using namespace std;

string foo = ""I am foo"";
string bar = ""I am bar"";


string& fooRef = foo; // This creates a reference to foo.
fooRef += "". Hi!""; // Modifies foo through the reference
cout << fooRef; // Prints ""I am foo. Hi!""

// Doesn't reassign ""fooRef"". This is the same as ""foo = bar"", and
//   foo == ""I am bar""
// after this line.
cout << &fooRef << endl; //Prints the address of foo
fooRef = bar;
cout << &fooRef << endl; //Still prints the address of foo
cout << fooRef;  // Prints ""I am bar""

// The address of fooRef remains the same, i.e. it is still referring to foo.


const string& barRef = bar; // Create a const reference to bar.
// Like C, const values (and pointers and references) cannot be modified.
barRef += "". Hi!""; // Error, const references cannot be modified.

// Sidetrack: Before we talk more about references, we must introduce a concept
// called a temporary object. Suppose we have the following code:
string tempObjectFun() { ... }
string retVal = tempObjectFun();

// What happens in the second line is actually:
//   - a string object is returned from tempObjectFun
//   - a new string is constructed with the returned object as argument to the
//     constructor
//   - the returned object is destroyed
// The returned object is called a temporary object. Temporary objects are
// created whenever a function returns an object, and they are destroyed at the
// end of the evaluation of the enclosing expression (Well, this is what the
// standard says, but compilers are allowed to change this behavior. Look up
// ""return value optimization"" if you're into this kind of details). So in this
// code:
foo(bar(tempObjectFun()))

// assuming foo and bar exist, the object returned from tempObjectFun is
// passed to bar, and it is destroyed before foo is called.

// Now back to references. The exception to the ""at the end of the enclosing
// expression"" rule is if a temporary object is bound to a const reference, in
// which case its life gets extended to the current scope:

void constReferenceTempObjectFun() {
  // constRef gets the temporary object, and it is valid until the end of this
  // function.
  const string& constRef = tempObjectFun();
  ...
}

// Another kind of reference introduced in C++11 is specifically for temporary
// objects. You cannot have a variable of its type, but it takes precedence in
// overload resolution:

void someFun(string& s) { ... }  // Regular reference
void someFun(string&& s) { ... }  // Reference to temporary object

string foo;
someFun(foo);  // Calls the version with regular reference
someFun(tempObjectFun());  // Calls the version with temporary reference

// For example, you will see these two versions of constructors for
// std::basic_string:
basic_string(const basic_string& other);
basic_string(basic_string&& other);

// Idea being if we are constructing a new string from a temporary object (which
// is going to be destroyed soon anyway), we can have a more efficient
// constructor that ""salvages"" parts of that temporary string. You will see this
// concept referred to as ""move semantics"".

/////////////////////
// Enums
/////////////////////

// Enums are a way to assign a value to a constant most commonly used for
// easier visualization and reading of code
enum ECarTypes
{
  Sedan,
  Hatchback,
  SUV,
  Wagon
};

ECarTypes GetPreferredCarType()
{
	return ECarTypes::Hatchback;
}

// As of C++11 there is an easy way to assign a type to the enum which can be
// useful in serialization of data and converting enums back-and-forth between
// the desired type and their respective constants
enum ECarTypes : uint8_t
{
  Sedan, // 0
  Hatchback, // 1
  SUV = 254, // 254
  Hybrid // 255
};

void WriteByteToFile(uint8_t InputValue)
{
	// Serialize the InputValue to a file
}

void WritePreferredCarTypeToFile(ECarTypes InputCarType)
{
	// The enum is implicitly converted to a uint8_t due to its declared enum type
	WriteByteToFile(InputCarType);
}

// On the other hand you may not want enums to be accidentally cast to an integer
// type or to other enums so it is instead possible to create an enum class which
// won't be implicitly converted
enum class ECarTypes : uint8_t
{
  Sedan, // 0
  Hatchback, // 1
  SUV = 254, // 254
  Hybrid // 255
};

void WriteByteToFile(uint8_t InputValue)
{
	// Serialize the InputValue to a file
}

void WritePreferredCarTypeToFile(ECarTypes InputCarType)
{
	// Won't compile even though ECarTypes is a uint8_t due to the enum
	// being declared as an ""enum class""!
	WriteByteToFile(InputCarType);
}

//////////////////////////////////////////
// Classes and object-oriented programming
//////////////////////////////////////////

// First example of classes
#include <iostream>

// Declare a class.
// Classes are usually declared in header (.h or .hpp) files.
class Dog {
    // Member variables and functions are private by default.
    std::string name;
    int weight;

// All members following this are public
// until ""private:"" or ""protected:"" is found.
public:

    // Default constructor
    Dog();

    // Member function declarations (implementations to follow)
    // Note that we use std::string here instead of placing
    // using namespace std;
    // above.
    // Never put a ""using namespace"" statement in a header.
    void setName(const std::string& dogsName);

    void setWeight(int dogsWeight);

    // Functions that do not modify the state of the object
    // should be marked as const.
    // This allows you to call them if given a const reference to the object.
    // Also note the functions must be explicitly declared as _virtual_
    // in order to be overridden in derived classes.
    // Functions are not virtual by default for performance reasons.
    virtual void print() const;

    // Functions can also be defined inside the class body.
    // Functions defined as such are automatically inlined.
    void bark() const { std::cout << name << "" barks!\n""; }

    // Along with constructors, C++ provides destructors.
    // These are called when an object is deleted or falls out of scope.
    // This enables powerful paradigms such as RAII
    // (see below)
    // The destructor should be virtual if a class is to be derived from;
    // if it is not virtual, then the derived class' destructor will
    // not be called if the object is destroyed through a base-class reference
    // or pointer.
    virtual ~Dog();

}; // A semicolon must follow the class definition.

// Class member functions are usually implemented in .cpp files.
Dog::Dog()
{
    std::cout << ""A dog has been constructed\n"";
}

// Objects (such as strings) should be passed by reference
// if you are modifying them or const reference if you are not.
void Dog::setName(const std::string& dogsName)
{
    name = dogsName;
}

void Dog::setWeight(int dogsWeight)
{
    weight = dogsWeight;
}

// Notice that ""virtual"" is only needed in the declaration, not the definition.
void Dog::print() const
{
    std::cout << ""Dog is "" << name << "" and weighs "" << weight << ""kg\n"";
}

Dog::~Dog()
{
    std::cout << ""Goodbye "" << name << '\n';
}

int main() {
    Dog myDog; // prints ""A dog has been constructed""
    myDog.setName(""Barkley"");
    myDog.setWeight(10);
    myDog.print(); // prints ""Dog is Barkley and weighs 10 kg""
    return 0;
} // prints ""Goodbye Barkley""

// Inheritance:

// This class inherits everything public and protected from the Dog class
// as well as private but may not directly access private members/methods
// without a public or protected method for doing so
class OwnedDog : public Dog {

public:
    void setOwner(const std::string& dogsOwner);

    // Override the behavior of the print function for all OwnedDogs. See
    // https://en.wikipedia.org/wiki/Polymorphism_(computer_science)#Subtyping
    // for a more general introduction if you are unfamiliar with
    // subtype polymorphism.
    // The override keyword is optional but makes sure you are actually
    // overriding the method in a base class.
    void print() const override;

private:
    std::string owner;
};

// Meanwhile, in the corresponding .cpp file:

void OwnedDog::setOwner(const std::string& dogsOwner)
{
    owner = dogsOwner;
}

void OwnedDog::print() const
{
    Dog::print(); // Call the print function in the base Dog class
    std::cout << ""Dog is owned by "" << owner << '\n';
    // Prints ""Dog is <name> and weights <weight>""
    //        ""Dog is owned by <owner>""
}

//////////////////////////////////////////
// Initialization and Operator Overloading
//////////////////////////////////////////

// In C++ you can overload the behavior of operators such as +, -, *, /, etc.
// This is done by defining a function which is called
// whenever the operator is used.

#include <iostream>
using namespace std;

class Point {
public:
    // Member variables can be given default values in this manner.
    double x = 0;
    double y = 0;

    // Define a default constructor which does nothing
    // but initialize the Point to the default value (0, 0)
    Point() { };

    // The following syntax is known as an initialization list
    // and is the proper way to initialize class member values
    Point (double a, double b) :
        x(a),
        y(b)
    { /* Do nothing except initialize the values */ }

    // Overload the + operator.
    Point operator+(const Point& rhs) const;

    // Overload the += operator
    Point& operator+=(const Point& rhs);

    // It would also make sense to add the - and -= operators,
    // but we will skip those for brevity.
};

Point Point::operator+(const Point& rhs) const
{
    // Create a new point that is the sum of this one and rhs.
    return Point(x + rhs.x, y + rhs.y);
}

// It's good practice to return a reference to the leftmost variable of
// an assignment. `(a += b) == c` will work this way.
Point& Point::operator+=(const Point& rhs)
{
    x += rhs.x;
    y += rhs.y;
    
    // `this` is a pointer to the object, on which a method is called.
    return *this;
}

int main () {
    Point up (0,1);
    Point right (1,0);
    // This calls the Point + operator
    // Point up calls the + (function) with right as its parameter
    Point result = up + right;
    // Prints ""Result is upright (1,1)""
    cout << ""Result is upright ("" << result.x << ',' << result.y << "")\n"";
    return 0;
}

/////////////////////
// Templates
/////////////////////

// Templates in C++ are mostly used for generic programming, though they are
// much more powerful than generic constructs in other languages. They also
// support explicit and partial specialization and functional-style type
// classes; in fact, they are a Turing-complete functional language embedded
// in C++!

// We start with the kind of generic programming you might be familiar with. To
// define a class or function that takes a type parameter:
template<class T>
class Box {
public:
    // In this class, T can be used as any other type.
    void insert(const T&) { ... }
};

// During compilation, the compiler actually generates copies of each template
// with parameters substituted, so the full definition of the class must be
// present at each invocation. This is why you will see template classes defined
// entirely in header files.

// To instantiate a template class on the stack:
Box<int> intBox;

// and you can use it as you would expect:
intBox.insert(123);

// You can, of course, nest templates:
Box<Box<int> > boxOfBox;
boxOfBox.insert(intBox);

// Until C++11, you had to place a space between the two '>'s, otherwise '>>'
// would be parsed as the right shift operator.

// You will sometimes see
//   template<typename T>
// instead. The 'class' keyword and 'typename' keywords are _mostly_
// interchangeable in this case. For the full explanation, see
//   https://en.wikipedia.org/wiki/Typename
// (yes, that keyword has its own Wikipedia page).

// Similarly, a template function:
template<class T>
void barkThreeTimes(const T& input)
{
    input.bark();
    input.bark();
    input.bark();
}

// Notice that nothing is specified about the type parameters here. The compiler
// will generate and then type-check every invocation of the template, so the
// above function works with any type 'T' that has a const 'bark' method!

Dog fluffy;
fluffy.setName(""Fluffy"")
barkThreeTimes(fluffy); // Prints ""Fluffy barks"" three times.

// Template parameters don't have to be classes:
template<int Y>
void printMessage() {
  cout << ""Learn C++ in "" << Y << "" minutes!"" << endl;
}

// And you can explicitly specialize templates for more efficient code. Of
// course, most real-world uses of specialization are not as trivial as this.
// Note that you still need to declare the function (or class) as a template
// even if you explicitly specified all parameters.
template<>
void printMessage<10>() {
  cout << ""Learn C++ faster in only 10 minutes!"" << endl;
}

printMessage<20>();  // Prints ""Learn C++ in 20 minutes!""
printMessage<10>();  // Prints ""Learn C++ faster in only 10 minutes!""


/////////////////////
// Exception Handling
/////////////////////

// The standard library provides a few exception types
// (see https://en.cppreference.com/w/cpp/error/exception)
// but any type can be thrown as an exception
#include <exception>
#include <stdexcept>

// All exceptions thrown inside the _try_ block can be caught by subsequent
// _catch_ handlers.
try {
    // Do not allocate exceptions on the heap using _new_.
    throw std::runtime_error(""A problem occurred"");
}

// Catch exceptions by const reference if they are objects
catch (const std::exception& ex)
{
    std::cout << ex.what();
}

// Catches any exception not caught by previous _catch_ blocks
catch (...)
{
    std::cout << ""Unknown exception caught"";
    throw; // Re-throws the exception
}

///////
// RAII
///////

// RAII stands for ""Resource Acquisition Is Initialization"".
// It is often considered the most powerful paradigm in C++
// and is the simple concept that a constructor for an object
// acquires that object's resources and the destructor releases them.

// To understand how this is useful,
// consider a function that uses a C file handle:
void doSomethingWithAFile(const char* filename)
{
    // To begin with, assume nothing can fail.

    FILE* fh = fopen(filename, ""r""); // Open the file in read mode.

    doSomethingWithTheFile(fh);
    doSomethingElseWithIt(fh);

    fclose(fh); // Close the file handle.
}

// Unfortunately, things are quickly complicated by error handling.
// Suppose fopen can fail, and that doSomethingWithTheFile and
// doSomethingElseWithIt return error codes if they fail.
//  (Exceptions are the preferred way of handling failure,
//   but some programmers, especially those with a C background,
//   disagree on the utility of exceptions).
// We now have to check each call for failure and close the file handle
// if a problem occurred.
bool doSomethingWithAFile(const char* filename)
{
    FILE* fh = fopen(filename, ""r""); // Open the file in read mode
    if (fh == nullptr) // The returned pointer is null on failure.
        return false; // Report that failure to the caller.

    // Assume each function returns false if it failed
    if (!doSomethingWithTheFile(fh)) {
        fclose(fh); // Close the file handle so it doesn't leak.
        return false; // Propagate the error.
    }
    if (!doSomethingElseWithIt(fh)) {
        fclose(fh); // Close the file handle so it doesn't leak.
        return false; // Propagate the error.
    }

    fclose(fh); // Close the file handle so it doesn't leak.
    return true; // Indicate success
}

// C programmers often clean this up a little bit using goto:
bool doSomethingWithAFile(const char* filename)
{
    FILE* fh = fopen(filename, ""r"");
    if (fh == nullptr)
        return false;

    if (!doSomethingWithTheFile(fh))
        goto failure;

    if (!doSomethingElseWithIt(fh))
        goto failure;

    fclose(fh); // Close the file
    return true; // Indicate success

failure:
    fclose(fh);
    return false; // Propagate the error
}

// If the functions indicate errors using exceptions,
// things are a little cleaner, but still sub-optimal.
void doSomethingWithAFile(const char* filename)
{
    FILE* fh = fopen(filename, ""r""); // Open the file in shared_ptrread mode
    if (fh == nullptr)
        throw std::runtime_error(""Could not open the file."");

    try {
        doSomethingWithTheFile(fh);
        doSomethingElseWithIt(fh);
    }
    catch (...) {
        fclose(fh); // Be sure to close the file if an error occurs.
        throw; // Then re-throw the exception.
    }

    fclose(fh); // Close the file
    // Everything succeeded
}

// Compare this to the use of C++'s file stream class (fstream)
// fstream uses its destructor to close the file.
// Recall from above that destructors are automatically called
// whenever an object falls out of scope.
void doSomethingWithAFile(const std::string& filename)
{
    // ifstream is short for input file stream
    std::ifstream fh(filename); // Open the file

    // Do things with the file
    doSomethingWithTheFile(fh);
    doSomethingElseWithIt(fh);

} // The file is automatically closed here by the destructor

// This has _massive_ advantages:
// 1. No matter what happens,
//    the resource (in this case the file handle) will be cleaned up.
//    Once you write the destructor correctly,
//    It is _impossible_ to forget to close the handle and leak the resource.
// 2. Note that the code is much cleaner.
//    The destructor handles closing the file behind the scenes
//    without you having to worry about it.
// 3. The code is exception safe.
//    An exception can be thrown anywhere in the function and cleanup
//    will still occur.

// All idiomatic C++ code uses RAII extensively for all resources.
// Additional examples include
// - Memory using unique_ptr and shared_ptr
// - Containers - the standard library linked list,
//   vector (i.e. self-resizing array), hash maps, and so on
//   all automatically destroy their contents when they fall out of scope.
// - Mutexes using lock_guard and unique_lock


/////////////////////
// Smart Pointer
/////////////////////

// Generally a smart pointer is a class which wraps a ""raw pointer"" (usage of ""new""
// respectively malloc/calloc in C). The goal is to be able to
// manage the lifetime of the object being pointed to without ever needing to explicitly delete 
// the object. The term itself simply describes a set of pointers with the
// mentioned abstraction.
// Smart pointers should preferred over raw pointers, to prevent
// risky memory leaks, which happen if you forget to delete an object.

// Usage of a raw pointer:
Dog* ptr = new Dog();
ptr->bark();
delete ptr;

// By using a smart pointer, you don't have to worry about the deletion
// of the object anymore.
// A smart pointer describes a policy, to count the references to the
// pointer. The object gets destroyed when the last
// reference to the object gets destroyed.

// Usage of ""std::shared_ptr"":
void foo()
{
// It's no longer necessary to delete the Dog.
std::shared_ptr<Dog> doggo(new Dog());
doggo->bark();
}

// Beware of possible circular references!!!
// There will be always a reference, so it will be never destroyed!
std::shared_ptr<Dog> doggo_one(new Dog());
std::shared_ptr<Dog> doggo_two(new Dog());
doggo_one = doggo_two; // p1 references p2
doggo_two = doggo_one; // p2 references p1

// There are several kinds of smart pointers. 
// The way you have to use them is always the same.
// This leads us to the question: when should we use each kind of smart pointer?
// std::unique_ptr - use it when you just want to hold one reference to
// the object.
// std::shared_ptr - use it when you want to hold multiple references to the
// same object and want to make sure that it's deallocated
// when all references are gone.
// std::weak_ptr - use it when you want to access
// the underlying object of a std::shared_ptr without causing that object to stay allocated.
// Weak pointers are used to prevent circular referencing.


/////////////////////
// Containers
/////////////////////

// Containers or the Standard Template Library are some predefined templates.
// They manage the storage space for its elements and provide
// member functions to access and manipulate them.

// Few containers are as follows:

// Vector (Dynamic array)
// Allow us to Define the Array or list of objects at run time
#include <vector>
string val;
vector<string> my_vector; // initialize the vector
cin >> val;
my_vector.push_back(val); // will push the value of 'val' into vector (""array"") my_vector
my_vector.push_back(val); // will push the value into the vector again (now having two elements)

// To iterate through a vector we have 2 choices:
// Either classic looping (iterating through the vector from index 0 to its last index):
for (int i = 0; i < my_vector.size(); i++) {
	cout << my_vector[i] << endl; // for accessing a vector's element we can use the operator []
}

// or using an iterator:
vector<string>::iterator it; // initialize the iterator for vector
for (it = my_vector.begin(); it != my_vector.end(); ++it) {
	cout << *it  << endl;
}

// Set
// Sets are containers that store unique elements following a specific order.
// Set is a very useful container to store unique values in sorted order
// without any other functions or code.

#include<set>
set<int> ST;    // Will initialize the set of int data type
ST.insert(30);  // Will insert the value 30 in set ST
ST.insert(10);  // Will insert the value 10 in set ST
ST.insert(20);  // Will insert the value 20 in set ST
ST.insert(30);  // Will insert the value 30 in set ST
// Now elements of sets are as follows
//  10 20 30

// To erase an element
ST.erase(20);  // Will erase element with value 20
// Set ST: 10 30
// To iterate through Set we use iterators
set<int>::iterator it;
for(it=ST.begin();it!=ST.end();it++) {
	cout << *it << endl;
}
// Output:
// 10
// 30

// To clear the complete container we use Container_name.clear()
ST.clear();
cout << ST.size();  // will print the size of set ST
// Output: 0

// NOTE: for duplicate elements we can use multiset
// NOTE: For hash sets, use unordered_set. They are more efficient but
// do not preserve order. unordered_set is available since C++11

// Map
// Maps store elements formed by a combination of a key value
// and a mapped value, following a specific order.

#include<map>
map<char, int> mymap;  // Will initialize the map with key as char and value as int

mymap.insert(pair<char,int>('A',1));
// Will insert value 1 for key A
mymap.insert(pair<char,int>('Z',26));
// Will insert value 26 for key Z

// To iterate
map<char,int>::iterator it;
for (it=mymap.begin(); it!=mymap.end(); ++it)
    std::cout << it->first << ""->"" << it->second << std::endl;
// Output:
// A->1
// Z->26

// To find the value corresponding to a key
it = mymap.find('Z');
cout << it->second;

// Output: 26

// NOTE: For hash maps, use unordered_map. They are more efficient but do
// not preserve order. unordered_map is available since C++11.

// Containers with object keys of non-primitive values (custom classes) require
// compare function in the object itself or as a function pointer. Primitives
// have default comparators, but you can override it.
class Foo {
public:
    int j;
    Foo(int a) : j(a) {}
};
struct compareFunction {
    bool operator()(const Foo& a, const Foo& b) const {
        return a.j < b.j;
    }
};
// this isn't allowed (although it can vary depending on compiler)
// std::map<Foo, int> fooMap;
std::map<Foo, int, compareFunction> fooMap;
fooMap[Foo(1)]  = 1;
fooMap.find(Foo(1)); //true


///////////////////////////////////////
// Lambda Expressions (C++11 and above)
///////////////////////////////////////

// lambdas are a convenient way of defining an anonymous function
// object right at the location where it is invoked or passed as
// an argument to a function.

// For example, consider sorting a vector of pairs using the second
// value of the pair

vector<pair<int, int> > tester;
tester.push_back(make_pair(3, 6));
tester.push_back(make_pair(1, 9));
tester.push_back(make_pair(5, 0));

// Pass a lambda expression as third argument to the sort function
// sort is from the <algorithm> header

sort(tester.begin(), tester.end(), [](const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second < rhs.second;
    });

// Notice the syntax of the lambda expression,
// [] in the lambda is used to ""capture"" variables
// The ""Capture List"" defines what from the outside of the lambda should be available inside the function body and how.
// It can be either:
//     1. a value : [x]
//     2. a reference : [&x]
//     3. any variable currently in scope by reference [&]
//     4. same as 3, but by value [=]
// Example:

vector<int> dog_ids;
// number_of_dogs = 3;
for(int i = 0; i < 3; i++) {
	dog_ids.push_back(i);
}

int weight[3] = {30, 50, 10};

// Say you want to sort dog_ids according to the dogs' weights
// So dog_ids should in the end become: [2, 0, 1]

// Here's where lambda expressions come in handy

sort(dog_ids.begin(), dog_ids.end(), [&weight](const int &lhs, const int &rhs) {
        return weight[lhs] < weight[rhs];
    });
// Note we captured ""weight"" by reference in the above example.
// More on Lambdas in C++ : https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11

///////////////////////////////
// Range For (C++11 and above)
///////////////////////////////

// You can use a range for loop to iterate over a container
int arr[] = {1, 10, 3};

for(int elem: arr){
	cout << elem << endl;
}

// You can use ""auto"" and not worry about the type of the elements of the container
// For example:

for(auto elem: arr) {
	// Do something with each element of arr
}

/////////////////////
// Fun stuff
/////////////////////

// Aspects of C++ that may be surprising to newcomers (and even some veterans).
// This section is, unfortunately, wildly incomplete; C++ is one of the easiest
// languages with which to shoot yourself in the foot.

// You can override private methods!
class Foo {
  virtual void bar();
};
class FooSub : public Foo {
  virtual void bar();  // Overrides Foo::bar!
};


// 0 == false == NULL (most of the time)!
bool* pt = new bool;
*pt = 0; // Sets the value points by 'pt' to false.
pt = 0;  // Sets 'pt' to the null pointer. Both lines compile without warnings.

// nullptr is supposed to fix some of that issue:
int* pt2 = new int;
*pt2 = nullptr; // Doesn't compile
pt2 = nullptr;  // Sets pt2 to null.

// There is an exception made for bools.
// This is to allow you to test for null pointers with if(!ptr),
// but as a consequence you can assign nullptr to a bool directly!
*pt = nullptr;  // This still compiles, even though '*pt' is a bool!


// '=' != '=' != '='!
// Calls Foo::Foo(const Foo&) or some variant (see move semantics) copy
// constructor.
Foo f2;
Foo f1 = f2;

// Calls Foo::Foo(const Foo&) or variant, but only copies the 'Foo' part of
// 'fooSub'. Any extra members of 'fooSub' are discarded. This sometimes
// horrifying behavior is called ""object slicing.""
FooSub fooSub;
Foo f1 = fooSub;

// Calls Foo::operator=(Foo&) or variant.
Foo f1;
f1 = f2;


///////////////////////////////////////
// Tuples (C++11 and above)
///////////////////////////////////////

#include<tuple>

// Conceptually, Tuples are similar to old data structures (C-like structs)
// but instead of having named data members,
// its elements are accessed by their order in the tuple.

// We start with constructing a tuple.
// Packing values into tuple
auto first = make_tuple(10, 'A');
const int maxN = 1e9;
const int maxL = 15;
auto second = make_tuple(maxN, maxL);

// Printing elements of 'first' tuple
cout << get<0>(first) << "" "" << get<1>(first) << '\n'; //prints : 10 A

// Printing elements of 'second' tuple
cout << get<0>(second) << "" "" << get<1>(second) << '\n'; // prints: 1000000000 15

// Unpacking tuple into variables

int first_int;
char first_char;
tie(first_int, first_char) = first;
cout << first_int << "" "" << first_char << '\n';  // prints : 10 A

// We can also create tuple like this.

tuple<int, char, double> third(11, 'A', 3.14141);
// tuple_size returns number of elements in a tuple (as a constexpr)

cout << tuple_size<decltype(third)>::value << '\n'; // prints: 3

// tuple_cat concatenates the elements of all the tuples in the same order.

auto concatenated_tuple = tuple_cat(first, second, third);
// concatenated_tuple becomes = (10, 'A', 1e9, 15, 11, 'A', 3.14141)

cout << get<0>(concatenated_tuple) << '\n'; // prints: 10
cout << get<3>(concatenated_tuple) << '\n'; // prints: 15
cout << get<5>(concatenated_tuple) << '\n'; // prints: 'A'


///////////////////////////////////
// Logical and Bitwise operators
//////////////////////////////////

// Most of the operators in C++ are same as in other languages

// Logical operators

// C++ uses Short-circuit evaluation for boolean expressions, i.e, the second argument is executed or
// evaluated only if the first argument does not suffice to determine the value of the expression

true && false // Performs **logical and** to yield false
true || false // Performs **logical or** to yield true
! true        // Performs **logical not** to yield false

// Instead of using symbols equivalent keywords can be used
true and false // Performs **logical and** to yield false
true or false  // Performs **logical or** to yield true
not true       // Performs **logical not** to yield false

// Bitwise operators

// **<<** Left Shift Operator
// << shifts bits to the left
4 << 1 // Shifts bits of 4 to left by 1 to give 8
// x << n can be thought as x * 2^n


// **>>** Right Shift Operator
// >> shifts bits to the right
4 >> 1 // Shifts bits of 4 to right by 1 to give 2
// x >> n can be thought as x / 2^n

~4    // Performs a bitwise not
4 | 3 // Performs bitwise or
4 & 3 // Performs bitwise and
4 ^ 3 // Performs bitwise xor

// Equivalent keywords are
compl 4    // Performs a bitwise not
4 bitor 3  // Performs bitwise or
4 bitand 3 // Performs bitwise and
4 xor 3    // Performs bitwise xor


```
Further Reading:

* An up-to-date language reference can be found at [CPP Reference](http://cppreference.com/w/cpp).
* A tutorial  for beginners or experts, covering many modern features and good practices: [LearnCpp.com](https://www.learncpp.com/)
* A tutorial covering basics of language and setting up coding environment is available at [TheChernoProject - C++](https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb).
* Additional resources may be found at [CPlusPlus](http://cplusplus.com)."
"Haml is a markup language predominantly used with Ruby that cleanly and simply describes the HTML of any web document without the use of inline code. It is a popular alternative to using Rails templating language (.erb) and allows you to embed Ruby code into your markup.

It aims to reduce repetition in your markup by closing tags for you based on the structure of the indents in your code. The result is markup that is well-structured, DRY, logical, and easier to read.

You can also use Haml on a project independent of Ruby, by installing the Haml gem on your machine and using the command line to convert it to html.

```shell
$ haml input_file.haml output_file.html
```


```haml
/ -------------------------------------------
/ Indenting
/ -------------------------------------------

/
  Because of the importance indentation has on how your code is rendered, the
  indents should be consistent throughout the document. Any differences in
  indentation will throw an error. It's common-practice to use two spaces,
  but it's really up to you, as long as they're constant.


/ -------------------------------------------
/ Comments
/ -------------------------------------------

/ This is what a comment looks like in Haml.

/
  To write a multi line comment, indent your commented code to be
  wrapped by the forward slash

-# This is a silent comment, which means it won't be rendered into the doc at all


/ -------------------------------------------
/ Html elements
/ -------------------------------------------

/ To write your tags, use the percent sign followed by the name of the tag
%body
  %header
    %nav

/ Notice no closing tags. The above code would output
  <body>
    <header>
      <nav></nav>
    </header>
  </body>

/
  The div tag is the default element, so it can be omitted.
  You can define only class/id using . or #
  For example

%div.my_class
  %div#my_id

/ Can be written
.my_class
  #my_id

/ To add content to a tag, add the text directly after the declaration
%h1 Headline copy

/ To write multiline content, nest it instead
%p
  This is a lot of content that we could probably split onto two
  separate lines.

/
  You can escape html by using the ampersand and equals sign ( &= ). This
  converts html-sensitive characters (&, /, :) into their html encoded
  equivalents. For example

%p
  &= ""Yes & yes""

/ would output 'Yes &amp; yes'

/ You can unescape html by using the bang and equals sign ( != )
%p
  != ""This is how you write a paragraph tag <p></p>""

/ which would output 'This is how you write a paragraph tag <p></p>'

/ CSS classes can be added to your tags either by chaining .classnames to the tag
%div.foo.bar

/ or as part of a Ruby hash
%div{:class => 'foo bar'}

/ Attributes for any tag can be added in the hash
%a{:href => '#', :class => 'bar', :title => 'Bar'}

/ For boolean attributes assign the value 'true'
%input{:selected => true}

/ To write data-attributes, use the :data key with its value as another hash
%div{:data => {:attribute => 'foo'}}

/ For Ruby version 1.9 or higher you can use Ruby's new hash syntax
%div{ data: { attribute: 'foo' } }

/ Also you can use HTML-style attribute syntax.
%a(href='#' title='bar')

/ And both syntaxes together
%a(href='#'){ title: @my_class.title }


/ -------------------------------------------
/ Inserting Ruby
/ -------------------------------------------

/
  To output a Ruby value as the contents of a tag, use an equals sign followed
  by the Ruby code

%h1= book.name

%p
  = book.author
  = book.publisher


/ To run some Ruby code without rendering it to the html, use a hyphen instead
- books = ['book 1', 'book 2', 'book 3']

/ Allowing you to do all sorts of awesome, like Ruby blocks
- books.shuffle.each_with_index do |book, index|
  %h1= book

  - if book do
    %p This is a book
    
/ Adding ordered / unordered list
%ul
  %li
    =item1
    =item2

/
  Again, no need to add the closing tags to the block, even for the Ruby.
  Indentation will take care of that for you.

/ -------------------------------------------
/ Inserting Table with bootstrap classes
/ -------------------------------------------

%table.table.table-hover
  %thead
    %tr
      %th Header 1
      %th Header 2
    
    %tr
      %td Value1
      %td value2
    
  %tfoot
    %tr
      %td
        Foot value


/ -------------------------------------------
/ Inline Ruby / Ruby interpolation
/ -------------------------------------------

/ Include a Ruby variable in a line of plain text using #{}
%p Your highest scoring game is #{best_game}


/ -------------------------------------------
/ Filters
/ -------------------------------------------

/
  Filters pass the block to another filtering program and return the result in Haml
  To use a filter, type a colon and the name of the filter

/ Markdown filter
:markdown
  # Header

  Text **inside** the *block*

/ The code above is compiled into
<h1>Header</h1>

<p>Text <strong>inside</strong> the <em>block</em></p>

/ Javascript filter
:javascript
  console.log('This is inline <script>');

/ is compiled into
<script>
  console.log('This is inline <script>');
</script>

/
  There are many types of filters (:markdown, :javascript, :coffee, :css, :ruby and so on)
  Also you can define your own filters using Haml::Filters

```

## Additional resources

- [What is HAML?](http://haml.info/) - A good introduction that does a much better job of explaining the benefits of using HAML.
- [Official Docs](http://haml.info/docs/yardoc/file.REFERENCE.html) - If you'd like to go a little deeper."
"Clojure is a Lisp family language developed for the Java Virtual Machine. It has
a much stronger emphasis on pure [functional programming](https://en.wikipedia.org/wiki/Functional_programming) than
Common Lisp, but includes several [STM](https://en.wikipedia.org/wiki/Software_transactional_memory) utilities to handle
state as it comes up.

This combination allows it to handle concurrent processing very simply,
and often automatically.

(You need a version of Clojure 1.2 or newer)


```clojure
; Comments start with semicolons.

; Clojure is written in ""forms"", which are just
; lists of things inside parentheses, separated by whitespace.
;
; The clojure reader assumes that the first thing is a
; function or macro to call, and the rest are arguments.

; The first call in a file should be ns, to set the namespace
(ns learnclojure)

; More basic examples:

; str will create a string out of all its arguments
(str ""Hello"" "" "" ""World"") ; => ""Hello World""

; Math is straightforward
(+ 1 1) ; => 2
(- 2 1) ; => 1
(* 1 2) ; => 2
(/ 2 1) ; => 2

; Equality is =
(= 1 1) ; => true
(= 2 1) ; => false

; You need not for logic, too
(not true) ; => false

; Nesting forms works as you expect
(+ 1 (- 3 2)) ; = 1 + (3 - 2) => 2

; Types
;;;;;;;;;;;;;

; Clojure uses Java's object types for booleans, strings and numbers.
; Use `class` to inspect them.
(class 1) ; Integer literals are java.lang.Long by default
(class 1.); Float literals are java.lang.Double
(class """"); Strings always double-quoted, and are java.lang.String
(class false) ; Booleans are java.lang.Boolean
(class nil); The ""null"" value is called nil

; If you want to create a literal list of data, use ' to stop it from
; being evaluated
'(+ 1 2) ; => (+ 1 2)
; (shorthand for (quote (+ 1 2)))

; You can eval a quoted list
(eval '(+ 1 2)) ; => 3

; Collections & Sequences
;;;;;;;;;;;;;;;;;;;

; Lists are linked-list data structures, while Vectors are array-backed.
; Vectors and Lists are java classes too!
(class [1 2 3]); => clojure.lang.PersistentVector
(class '(1 2 3)); => clojure.lang.PersistentList

; A list would be written as just (1 2 3), but we have to quote
; it to stop the reader thinking it's a function.
; Also, (list 1 2 3) is the same as '(1 2 3)

; ""Collections"" are just groups of data
; Both lists and vectors are collections:
(coll? '(1 2 3)) ; => true
(coll? [1 2 3]) ; => true

; ""Sequences"" (seqs) are abstract descriptions of lists of data.
; Only lists are seqs.
(seq? '(1 2 3)) ; => true
(seq? [1 2 3]) ; => false

; A seq need only provide an entry when it is accessed.
; So, seqs which can be lazy -- they can define infinite series:
(range 4) ; => (0 1 2 3)
(range) ; => (0 1 2 3 4 ...) (an infinite series)
(take 4 (range)) ;  (0 1 2 3)

; Use cons to add an item to the beginning of a list or vector
(cons 4 [1 2 3]) ; => (4 1 2 3)
(cons 4 '(1 2 3)) ; => (4 1 2 3)

; Conj will add an item to a collection in the most efficient way.
; For lists, they insert at the beginning. For vectors, they insert at the end.
(conj [1 2 3] 4) ; => [1 2 3 4]
(conj '(1 2 3) 4) ; => (4 1 2 3)

; Use concat to add lists or vectors together
(concat [1 2] '(3 4)) ; => (1 2 3 4)

; Use filter, map to interact with collections
(map inc [1 2 3]) ; => (2 3 4)
(filter even? [1 2 3]) ; => (2)

; Use reduce to reduce them
(reduce + [1 2 3 4])
; = (+ (+ (+ 1 2) 3) 4)
; => 10

; Reduce can take an initial-value argument too
(reduce conj [] '(3 2 1))
; = (conj (conj (conj [] 3) 2) 1)
; => [3 2 1]

; Functions
;;;;;;;;;;;;;;;;;;;;;

; Use fn to create new functions. A function always returns
; its last statement.
(fn [] ""Hello World"") ; => fn

; (You need extra parens to call it)
((fn [] ""Hello World"")) ; => ""Hello World""

; You can create a var using def
(def x 1)
x ; => 1

; Assign a function to a var
(def hello-world (fn [] ""Hello World""))
(hello-world) ; => ""Hello World""

; You can shorten this process by using defn
(defn hello-world [] ""Hello World"")

; The [] is the list of arguments for the function.
(defn hello [name]
  (str ""Hello "" name))
(hello ""Steve"") ; => ""Hello Steve""

; You can also use this shorthand to create functions:
(def hello2 #(str ""Hello "" %1))
(hello2 ""Julie"") ; => ""Hello Julie""

; You can have multi-variadic functions, too
(defn hello3
  ([] ""Hello World"")
  ([name] (str ""Hello "" name)))
(hello3 ""Jake"") ; => ""Hello Jake""
(hello3) ; => ""Hello World""

; Functions can pack extra arguments up in a seq for you
(defn count-args [& args]
  (str ""You passed "" (count args) "" args: "" args))
(count-args 1 2 3) ; => ""You passed 3 args: (1 2 3)""

; You can mix regular and packed arguments
(defn hello-count [name & args]
  (str ""Hello "" name "", you passed "" (count args) "" extra args""))
(hello-count ""Finn"" 1 2 3)
; => ""Hello Finn, you passed 3 extra args""


; Maps
;;;;;;;;;;

; Hash maps and array maps share an interface. Hash maps have faster lookups
; but don't retain key order.
(class {:a 1 :b 2 :c 3}) ; => clojure.lang.PersistentArrayMap
(class (hash-map :a 1 :b 2 :c 3)) ; => clojure.lang.PersistentHashMap

; Arraymaps will automatically become hashmaps through most operations
; if they get big enough, so you don't need to worry.

; Maps can use any hashable type as a key, but usually keywords are best
; Keywords are like strings with some efficiency bonuses
(class :a) ; => clojure.lang.Keyword

(def stringmap {""a"" 1, ""b"" 2, ""c"" 3})
stringmap  ; => {""a"" 1, ""b"" 2, ""c"" 3}

(def keymap {:a 1, :b 2, :c 3})
keymap ; => {:a 1, :c 3, :b 2}

; By the way, commas are always treated as whitespace and do nothing.

; Retrieve a value from a map by calling it as a function
(stringmap ""a"") ; => 1
(keymap :a) ; => 1

; Keywords can be used to retrieve their value from a map, too!
(:b keymap) ; => 2

; Don't try this with strings.
;(""a"" stringmap)
; => Exception: java.lang.String cannot be cast to clojure.lang.IFn

; Retrieving a non-present key returns nil
(stringmap ""d"") ; => nil

; Use assoc to add new keys to hash-maps
(def newkeymap (assoc keymap :d 4))
newkeymap ; => {:a 1, :b 2, :c 3, :d 4}

; But remember, clojure types are immutable!
keymap ; => {:a 1, :b 2, :c 3}

; Use dissoc to remove keys
(dissoc keymap :a :b) ; => {:c 3}

; Sets
;;;;;;

(class #{1 2 3}) ; => clojure.lang.PersistentHashSet
(set [1 2 3 1 2 3 3 2 1 3 2 1]) ; => #{1 2 3}

; Add a member with conj
(conj #{1 2 3} 4) ; => #{1 2 3 4}

; Remove one with disj
(disj #{1 2 3} 1) ; => #{2 3}

; Test for existence by using the set as a function:
(#{1 2 3} 1) ; => 1
(#{1 2 3} 4) ; => nil

; There are more functions in the clojure.sets namespace.

; Useful forms
;;;;;;;;;;;;;;;;;

; Logic constructs in clojure are just macros, and look like
; everything else
(if false ""a"" ""b"") ; => ""b""
(if false ""a"") ; => nil

; Use let to create temporary bindings
(let [a 1 b 2]
  (> a b)) ; => false

; Group statements together with do
(do
  (print ""Hello"")
  ""World"") ; => ""World"" (prints ""Hello"")

; Functions have an implicit do
(defn print-and-say-hello [name]
  (print ""Saying hello to "" name)
  (str ""Hello "" name))
(print-and-say-hello ""Jeff"") ;=> ""Hello Jeff"" (prints ""Saying hello to Jeff"")

; So does let
(let [name ""Urkel""]
  (print ""Saying hello to "" name)
  (str ""Hello "" name)) ; => ""Hello Urkel"" (prints ""Saying hello to Urkel"")


; Use the threading macros (-> and ->>) to express transformations of
; data more clearly.

; The ""Thread-first"" macro (->) inserts into each form the result of
; the previous, as the first argument (second item)
(->  
   {:a 1 :b 2} 
   (assoc :c 3) ;=> (assoc {:a 1 :b 2} :c 3)
   (dissoc :b)) ;=> (dissoc (assoc {:a 1 :b 2} :c 3) :b)

; This expression could be written as:
; (dissoc (assoc {:a 1 :b 2} :c 3) :b)
; and evaluates to {:a 1 :c 3}

; The double arrow does the same thing, but inserts the result of
; each line at the *end* of the form. This is useful for collection
; operations in particular:
(->>
   (range 10)
   (map inc)     ;=> (map inc (range 10)
   (filter odd?) ;=> (filter odd? (map inc (range 10))
   (into []))    ;=> (into [] (filter odd? (map inc (range 10)))
                 ; Result: [1 3 5 7 9]

; When you are in a situation where you want more freedom as where to
; put the result of previous data transformations in an 
; expression, you can use the as-> macro. With it, you can assign a
; specific name to transformations' output and use it as a
; placeholder in your chained expressions:

(as-> [1 2 3] input
  (map inc input);=> You can use last transform's output at the last position
  (nth input 2) ;=>  and at the second position, in the same expression
  (conj [4 5 6] input 8 9 10)) ;=> or in the middle !
                               ; Result: [4 5 6 4 8 9 10]


; Modules
;;;;;;;;;;;;;;;

; Use ""use"" to get all functions from the module
(use 'clojure.set)

; Now we can use set operations
(intersection #{1 2 3} #{2 3 4}) ; => #{2 3}
(difference #{1 2 3} #{2 3 4}) ; => #{1}

; You can choose a subset of functions to import, too
(use '[clojure.set :only [intersection]])

; Use require to import a module
(require 'clojure.string)

; Use / to call functions from a module
; Here, the module is clojure.string and the function is blank?
(clojure.string/blank? """") ; => true

; You can give a module a shorter name on import
(require '[clojure.string :as str])
(str/replace ""This is a test."" #""[a-o]"" str/upper-case) ; => ""THIs Is A tEst.""
; (#"""" denotes a regular expression literal)

; You can use require (and use, but don't) from a namespace using :require.
; You don't need to quote your modules if you do it this way.
(ns test
  (:require
    [clojure.string :as str]
    [clojure.set :as set]))

; Java
;;;;;;;;;;;;;;;;;

; Java has a huge and useful standard library, so
; you'll want to learn how to get at it.

; Use import to load a java module
(import java.util.Date)

; You can import from an ns too.
(ns test
  (:import java.util.Date
           java.util.Calendar))

; Use the class name with a ""."" at the end to make a new instance
(Date.) ; <a date object>

; Use . to call methods. Or, use the "".method"" shortcut
(. (Date.) getTime) ; <a timestamp>
(.getTime (Date.)) ; exactly the same thing.

; Use / to call static methods
(System/currentTimeMillis) ; <a timestamp> (system is always present)

; Use doto to make dealing with (mutable) classes more tolerable
(import java.util.Calendar)
(doto (Calendar/getInstance)
  (.set 2000 1 1 0 0 0)
  .getTime) ; => A Date. set to 2000-01-01 00:00:00

; STM
;;;;;;;;;;;;;;;;;

; Software Transactional Memory is the mechanism clojure uses to handle
; persistent state. There are a few constructs in clojure that use this.

; An atom is the simplest. Pass it an initial value
(def my-atom (atom {}))

; Update an atom with swap!.
; swap! takes a function and calls it with the current value of the atom
; as the first argument, and any trailing arguments as the second
(swap! my-atom assoc :a 1) ; Sets my-atom to the result of (assoc {} :a 1)
(swap! my-atom assoc :b 2) ; Sets my-atom to the result of (assoc {:a 1} :b 2)

; Use '@' to dereference the atom and get the value
my-atom  ;=> Atom<#...> (Returns the Atom object)
@my-atom ; => {:a 1 :b 2}

; Here's a simple counter using an atom
(def counter (atom 0))
(defn inc-counter []
  (swap! counter inc))

(inc-counter)
(inc-counter)
(inc-counter)
(inc-counter)
(inc-counter)

@counter ; => 5

; Other STM constructs are refs and agents.
; Refs: http://clojure.org/refs
; Agents: http://clojure.org/agents
```

### Further Reading

This is far from exhaustive, but hopefully it's enough to get you on your feet.

Clojure.org has lots of articles:
[http://clojure.org/](http://clojure.org/)

Clojuredocs.org has documentation with examples for most core functions:
[http://clojuredocs.org/quickref/Clojure%20Core](http://clojuredocs.org/quickref/Clojure%20Core)

4Clojure is a great way to build your clojure/FP skills:
[https://4clojure.oxal.org/](https://4clojure.oxal.org/)

Clojure-doc.org (yes, really) has a number of getting started articles:
[http://clojure-doc.org/](http://clojure-doc.org/)

Clojure for the Brave and True has a great introduction to Clojure and a free online version:
[https://www.braveclojure.com/clojure-for-the-brave-and-true/](https://www.braveclojure.com/clojure-for-the-brave-and-true/)"
"## Getting Started with Pug

Pug is a little language that compiles into the HTML. It has cleaner syntax 
with additional features like if statements and loops. It can also be used 
as a server side templating language for server languages like NodeJS.

### The Language
```pug

//- Single Line Comment

//- Multi Line
    Comment

//- ---TAGS---
//- Basic
div
//- <div></div>
h1
//- <h1></h1>
my-customTag
//- <my-customTag></my-customTag>

//- Sibling
div
div
//- <div></div>
    <div></div>

//- Child
div
  div
//- <div>
      <div></div>
    </div>

//- Text
h1 Hello there
//- <h1>Hello there</h1>

//- Multi Line Text
div.
  Hello
  There
//- <div>
      Hello
      There
    </div>

//- ---ATTRIBUTES---
div(class=""my-class"" id=""my-id"" my-custom-attrs=""data"" enabled)
//- <div class=""my-class"" id=""my-id"" my-custom-attrs=""data"" enabled></div>

//- Short Hand
span.my-class
//- <span class=""my-class""></span>
.my-class
//- <div class=""my-class""></div>
div#my-id
//- <div id=""my-id""></div>
div#my-id.my-class
//- <div class=""my-class"" id=""my-id""></div>


//- ---JS---
- const lang = ""pug"";

//- Multi Line JS
-
  const lang = ""pug"";
  const awesome = true;

//- JS Classes
- const myClass = ['class1', 'class2', 'class3']
div(class=myClass)
//- <div class=""class1 class2 class3""></div>

//- JS Styles
- const myStyles = {'color':'white', 'background-color':'blue'}
div(styles=myStyles)
//- <div styles=""{&quot;color&quot;:&quot;white&quot;,&quot;background-color&quot;:&quot;blue&quot;}""></div>

//- JS Attributes
- const myAttributes = {""src"": ""photo.png"", ""alt"": ""My Photo""}
img&attributes(myAttributes)
//- <img src=""photo.png"" alt=""My Photo"">
- let disabled = false
input(type=""text"" disabled=disabled)
//- <input type=""text"">
- disabled = true
input(type=""text"" disabled=disabled)
//- <input type=""text"" disabled>

//- JS Templating
- const name = ""Bob"";
h1 Hi #{name}
h1= name
//- <h1>Hi Bob</h1>
//- <h1>Bob</h1>

//- ---LOOPS---

//- 'each' and 'for' do the same thing we will use 'each' only.

each value, i in [1,2,3]
  p=value
//-
  <p>1</p>
  <p>2</p>
  <p>3</p>

each value, index in [1,2,3]
  p=value + '-' + index
//-
  <p>1-0</p>
  <p>2-1</p>
  <p>3-2</p>

each value in []
  p=value
//- 

each value in []
  p=value
else
  p No Values are here

//- <p>No Values are here</p>

//- ---CONDITIONALS---

- const number = 5
if number < 5
  p number is less then 5
else if number > 5
  p number is greater then 5
else
  p number is 5
//- <p>number is 5</p>

- const orderStatus = ""Pending"";
case orderStatus
  when ""Pending""
    p.warn Your order is pending
  when ""Completed""
    p.success Order is Completed.
  when -1
    p.error Error Occurred
  default
    p No Order Record Found
//- <p class=""warn"">Your order is pending</p>

//- --INCLUDE--
//- File path -> ""includes/nav.png""
h1 Company Name
nav
  a(href=""index.html"") Home
  a(href=""about.html"") About Us

//- File path -> ""index.png""
html
  body
    include includes/nav.pug
//-
  <html>
    <body>
      <h1>Company Name</h1>
      <nav><a href=""index.html"">Home</a><a href=""about.html"">About Us</a></nav>
    </body>
  </html>

//- Importing JS and CSS
script
  include scripts/index.js
style
  include styles/theme.css

//- ---MIXIN---
mixin basic
  div Hello
+basic
//- <div>Hello</div>

mixin comment(name, comment)
  div
    span.comment-name= name
    div.comment-text= comment
+comment(""Bob"", ""This is Awesome"")
//- 
  <div>
    <span class=""comment-name"">Bob</span>
    <div class=""comment-text"">This is Awesome</div>
  </div>

```


### Additional Resources
- [The Site](https://pugjs.org/)
- [The Docs](https://pugjs.org/api/getting-started.html)
- [Github Repo](https://github.com/pugjs/pug)"
"Sass is a CSS extension language that adds features such as variables, nesting, mixins and more.
Sass (and other preprocessors, such as [Less](http://lesscss.org/)) help developers write maintainable and DRY (Don't Repeat Yourself) code.

Sass has two different syntax options to choose from. SCSS, which has the same syntax as CSS but with the added features of Sass. Or Sass (the original syntax), which uses indentation rather than curly braces and semicolons.
This tutorial is written using SCSS.

If you're already familiar with CSS3, you'll be able to pick up Sass relatively quickly. It does not provide any new styling properties but rather the tools to write your CSS more efficiently and make maintenance much easier.

```scss


//Single line comments are removed when Sass is compiled to CSS.

/* Multi line comments are preserved. */



/* Variables
============================== */



/* You can store a CSS value (such as a color) in a variable.
Use the '$' symbol to create a variable. */

$primary-color: #A3A4FF;
$secondary-color: #51527F;
$body-font: 'Roboto', sans-serif;

/* You can use the variables throughout your stylesheet.
Now if you want to change a color, you only have to make the change once. */

body {
	background-color: $primary-color;
	color: $secondary-color;
	font-family: $body-font;
}

/* This would compile to: */
body {
	background-color: #A3A4FF;
	color: #51527F;
	font-family: 'Roboto', sans-serif;
}

/* This is much more maintainable than having to change the color
each time it appears throughout your stylesheet. */



/* Control Directives
============================== */

/* Sass lets you use @if, @else, @for, @while, and @each to control the
   compilation of your code to CSS. */

/* @if/@else blocks behave exactly as you might expect */

$debug: true !default;

@mixin debugmode {
	@if $debug {
		@debug ""Debug mode enabled"";

		display: inline-block;
	}
	@else {
		display: none;
	}
}

.info {
	@include debugmode;
}

/* If $debug is set to true, .info is displayed; if it's set to false then
.info is not displayed.

Note: @debug will output debugging information to the command line.
Useful for checking variables while debugging your SCSS. */

.info {
	display: inline-block;
}

/* @for is a control loop that iterates through a range of values.
Particularly useful for setting styles on a collection of items.
There are two forms, ""through"" and ""to"". The former includes the last value,
the latter stops at the last value. */

@for $c from 1 to 4 {
	div:nth-of-type(#{$c}) {
		left: ($c - 1) * 900 / 3;
	}
}

@for $c from 1 through 3 {
	.myclass-#{$c} {
		color: rgb($c * 255 / 3, $c * 255 / 3, $c * 255 / 3);
	}
}

/* Will compile to: */

div:nth-of-type(1) {
	left: 0;
}

div:nth-of-type(2) {
	left: 300;
}

div:nth-of-type(3) {
	left: 600;
}

.myclass-1 {
	color: #555555;
}

.myclass-2 {
	color: #aaaaaa;
}

.myclass-3 {
	color: white;
// SASS automatically converts #FFFFFF to white
}

/* @while is very straightforward: */

$columns: 4;
$column-width: 80px;

@while $columns > 0 {
	.col-#{$columns} {
		width: $column-width;
		left: $column-width * ($columns - 1);
	}

	$columns: $columns - 1;
}

/* Will output the following CSS: */

.col-4 {
	width: 80px;
	left: 240px;
}

.col-3 {
	width: 80px;
	left: 160px;
}

.col-2 {
	width: 80px;
	left: 80px;
}

.col-1 {
	width: 80px;
	left: 0px;
}

/* @each functions like @for, except using a list instead of ordinal values
Note: you specify lists just like other variables, with spaces as
delimiters. */

$social-links: facebook twitter linkedin reddit;

.social-links {
	@each $sm in $social-links {
		.icon-#{$sm} {
			background-image: url(""images/#{$sm}.png"");
		}
	}
}

/* Which will output: */

.social-links .icon-facebook {
	background-image: url(""images/facebook.png"");
}

.social-links .icon-twitter {
	background-image: url(""images/twitter.png"");
}

.social-links .icon-linkedin {
	background-image: url(""images/linkedin.png"");
}

.social-links .icon-reddit {
	background-image: url(""images/reddit.png"");
}


/* Mixins
==============================*/

/* If you find you are writing the same code for more than one
element, you might want to store that code in a mixin.

Use the '@mixin' directive, plus a name for your mixin. */

@mixin center {
	display: block;
	margin-left: auto;
	margin-right: auto;
	left: 0;
	right: 0;
}

/* You can use the mixin with '@include' and the mixin name. */

div {
	@include center;
	background-color: $primary-color;
}

/* Which would compile to: */
div {
	display: block;
	margin-left: auto;
	margin-right: auto;
	left: 0;
	right: 0;
	background-color: #A3A4FF;
}

/* You can use mixins to create a shorthand property. */

@mixin size($width, $height) {
	width: $width;
	height: $height;
}

/* Which you can invoke by passing width and height arguments. */

.rectangle {
	@include size(100px, 60px);
}

.square {
	@include size(40px, 40px);
}

/* Compiles to: */
.rectangle {
  width: 100px;
  height: 60px;
}

.square {
  width: 40px;
  height: 40px;
}



/* Functions
============================== */



/* Sass provides functions that can be used to accomplish a variety of
   tasks. Consider the following */

/* Functions can be invoked by using their name and passing in the
   required arguments */
body {
  width: round(10.25px);
}

.footer {
  background-color: fade_out(#000000, 0.25);
}

/* Compiles to: */

body {
  width: 10px;
}

.footer {
  background-color: rgba(0, 0, 0, 0.75);
}

/* You may also define your own functions. Functions are very similar to
   mixins. When trying to choose between a function or a mixin, remember
   that mixins are best for generating CSS while functions are better for
   logic that might be used throughout your Sass code. The examples in
   the 'Math Operators' section are ideal candidates for becoming a reusable
   function. */

/* This function will take a target size and the parent size and calculate
   and return the percentage */

@function calculate-percentage($target-size, $parent-size) {
  @return $target-size / $parent-size * 100%;
}

$main-content: calculate-percentage(600px, 960px);

.main-content {
  width: $main-content;
}

.sidebar {
  width: calculate-percentage(300px, 960px);
}

/* Compiles to: */

.main-content {
  width: 62.5%;
}

.sidebar {
  width: 31.25%;
}



/* Extend (Inheritance)
============================== */



/* Extend is a way to share the properties of one selector with another. */

.display {
	@include size(5em, 5em);
	border: 5px solid $secondary-color;
}

.display-success {
	@extend .display;
	border-color: #22df56;
}

/* Compiles to: */
.display, .display-success {
  width: 5em;
  height: 5em;
  border: 5px solid #51527F;
}

.display-success {
  border-color: #22df56;
}

/* Extending a CSS statement is preferable to creating a mixin
   because of the way Sass groups together the classes that all share
   the same base styling. If this was done with a mixin, the width,
   height, and border would be duplicated for each statement that
   called the mixin. While it won't affect your workflow, it will
   add unnecessary bloat to the files created by the Sass compiler. */



/* Nesting
============================== */



/* Sass allows you to nest selectors within selectors */

ul {
	list-style-type: none;
	margin-top: 2em;

	li {
		background-color: #FF0000;
	}
}

/* '&' will be replaced by the parent selector. */
/* You can also nest pseudo-classes. */
/* Keep in mind that over-nesting will make your code less maintainable.
Best practices recommend going no more than 3 levels deep when nesting.
For example: */

ul {
	list-style-type: none;
	margin-top: 2em;

	li {
		background-color: red;

		&:hover {
		  background-color: blue;
		}

		a {
		  color: white;
		}
	}
}

/* Compiles to: */

ul {
  list-style-type: none;
  margin-top: 2em;
}

ul li {
  background-color: red;
}

ul li:hover {
  background-color: blue;
}

ul li a {
  color: white;
}



/* Partials and Imports
============================== */



/* Sass allows you to create partial files. This can help keep your Sass
   code modularized. Partial files should begin with an '_', e.g. _reset.css.
   Partials are not generated into CSS. */

/* Consider the following CSS which we'll put in a file called _reset.css */

html,
body,
ul,
ol {
  margin: 0;
  padding: 0;
}

/* Sass offers @import which can be used to import partials into a file.
   This differs from the traditional CSS @import statement which makes
   another HTTP request to fetch the imported file. Sass takes the
   imported file and combines it with the compiled code. */

@import 'reset';

body {
  font-size: 16px;
  font-family: Helvetica, Arial, Sans-serif;
}

/* Compiles to: */

html, body, ul, ol {
  margin: 0;
  padding: 0;
}

body {
  font-size: 16px;
  font-family: Helvetica, Arial, Sans-serif;
}



/* Placeholder Selectors
============================== */



/* Placeholders are useful when creating a CSS statement to extend. If you
   wanted to create a CSS statement that was exclusively used with @extend,
   you can do so using a placeholder. Placeholders begin with a '%' instead
   of '.' or '#'. Placeholders will not appear in the compiled CSS. */

%content-window {
  font-size: 14px;
  padding: 10px;
  color: #000;
  border-radius: 4px;
}

.message-window {
  @extend %content-window;
  background-color: #0000ff;
}

/* Compiles to: */

.message-window {
  font-size: 14px;
  padding: 10px;
  color: #000;
  border-radius: 4px;
}

.message-window {
  background-color: #0000ff;
}



/* Math Operations
============================== */



/* Sass provides the following operators: +, -, *, /, and %. These can
   be useful for calculating values directly in your Sass files instead
   of using values that you've already calculated by hand. Below is an example
   of a setting up a simple two column design. */

$content-area: 960px;
$main-content: 600px;
$sidebar-content: 300px;

$main-size: $main-content / $content-area * 100%;
$sidebar-size: $sidebar-content / $content-area * 100%;
$gutter: 100% - ($main-size + $sidebar-size);

body {
  width: 100%;
}

.main-content {
  width: $main-size;
}

.sidebar {
  width: $sidebar-size;
}

.gutter {
  width: $gutter;
}

/* Compiles to: */

body {
  width: 100%;
}

.main-content {
  width: 62.5%;
}

.sidebar {
  width: 31.25%;
}

.gutter {
  width: 6.25%;
}

```

## SASS or Sass?
Have you ever wondered whether Sass is an acronym or not? You probably haven't, but I'll tell you anyway. The name of the language is a word, ""Sass"", and not an acronym.
Because people were constantly writing it as ""SASS"", the creator of the language jokingly called it ""Syntactically Awesome StyleSheets"".


## Practice Sass
If you want to play with Sass in your browser, check out [SassMeister](http://sassmeister.com/).
You can use either syntax, just go into the settings and select either Sass or SCSS.


## Compatibility
Sass can be used in any project as long as you have a program to compile it into CSS. You'll want to verify that the CSS you're using is compatible with your target browsers.

[QuirksMode CSS](http://www.quirksmode.org/css/) and [CanIUse](http://caniuse.com) are great resources for checking compatibility.


## Further reading
* [Official Documentation](http://sass-lang.com/documentation/file.SASS_REFERENCE.html)
* [The Sass Way](http://thesassway.com/) provides tutorials (beginner-advanced) and articles."
"Q# is a high-level domain-specific language which enables developers to write quantum algorithms. Q# programs can be executed on a quantum simulator running on a classical computer and (in future) on quantum computers.

```C#
// Single-line comments start with //


/////////////////////////////////////
// 1. Quantum data types and operators

// The most important part of quantum programs is qubits. 
// In Q# type Qubit represents the qubits which can be used.
// This will allocate an array of two new qubits as the variable qs.
using (qs = Qubit[2]) {

    // The qubits have internal state that you cannot access to read or modify directly.
    // You can inspect the current state of your quantum program 
    // if you're running it on a classical simulator.
    // Note that this will not work on actual quantum hardware!
    DumpMachine();

    // If you want to change the state of a qubit
    // you have to do this by applying quantum gates to the qubit.
    H(qs[0]);    // This changes the state of the first qubit 
                // from |0⟩ (the initial state of allocated qubits) 
                // to (|0⟩ + |1⟩) / sqrt(2).
    // qs[1] = |1⟩; - this does NOT work, you have to manipulate a qubit by using gates.

    // You can apply multi-qubit gates to several qubits.
    CNOT(qs[0], qs[1]);

    // You can also apply a controlled version of a gate: 
    // a gate that is applied if all control qubits are in |1⟩ state.
    // The first argument is an array of control qubits, 
    // the second argument is the target qubit.
    Controlled Y([qs[0]], qs[1]); 

    // If you want to apply an anti-controlled gate 
    // (a gate that is applied if all control qubits are in |0⟩ state), 
    // you can use a library function.
    ApplyControlledOnInt(0, X, [qs[0]], qs[1]);

    // To read the information from the quantum system, you use measurements.
    // Measurements return a value of Result data type: Zero or One.
    // You can print measurement results as a classical value.
    Message($""Measured {M(qs[0])}, {M(qs[1])}"");
}


/////////////////////////////////////
// 2. Classical data types and operators

// Numbers in Q# can be stored in Int, BigInt or Double.
let i = 1;            // This defines an Int variable i equal to 1
let bi = 1L;          // This defines a BigInt variable bi equal to 1
let d = 1.0;          // This defines a Double variable d equal to 1

// Arithmetic is done as expected, as long as the types are the same
let n = 2 * 10;                // = 20
// Q# does not have implicit type cast, 
// so to perform arithmetic on values of different types, 
// you need to cast type explicitly
let nd = IntAsDouble(2) * 1.0; // = 20.0

// Boolean type is called Bool
let trueBool = true;
let falseBool = false;

// Logic operators work as expected
let andBool = true and false;
let orBool = true or false;
let notBool = not false;

// Strings
let str = ""Hello World!"";

// Equality is ==
let x = 10 == 15; // is false

// Range is a sequence of integers and can be defined like: start..step..stop
let xi = 1..2..7; // Gives the sequence 1,3,5,7

// Assigning new value to a variable:
// by default all Q# variables are immutable;
// if the variable was defined using let, you cannot reassign its value.

// When you want to make a variable mutable, you have to declare it as such, 
// and use the set word to update value
mutable xii = true;
set xii = false;

// You can create an array for any data type like this
let xiii = new Double[10];

// Getting an element from an array 
let xiv = xiii[8];

// Assigning a new value to an array element
mutable xv = new Double[10];
set xv w/= 5 <- 1;


/////////////////////////////////////
// 3. Control flow

// If structures work a little different than most languages
if (a == 1) {
    // ...
} elif (a == 2) {
    // ... 
} else {
    // ...
}

// Foreach loops can be used to iterate over an array
for (qubit in qubits) {
    X(qubit);
}

// Regular for loops can be used to iterate over a range of numbers
for (index in 0 .. Length(qubits) - 1) {
    X(qubits[index]);
}

// While loops are restricted for use in classical context only
mutable index = 0;
while (index < 10) {
    set index += 1;
}

// Quantum equivalent of a while loop is a repeat-until-success loop.
// Because of the probabilistic nature of quantum computing sometimes
// you want to repeat a certain sequence of operations 
// until a specific condition is achieved; you can use this loop to express this.
repeat {
    // Your operation here
}
until (success criteria) // This could be a measurement to check if the state is reached
fixup {
    // Resetting to the initial conditions, if required
}


/////////////////////////////////////
// 4. Putting it all together

// Q# code is written in operations and functions
operation ApplyXGate(source : Qubit) : Unit {
    X(source);
}

// If the operation implements a unitary transformation, you can define 
// adjoint and controlled variants of it. 
// The easiest way to do that is to add ""is Adj + Ctl"" after Unit. 
// This will tell the compiler to generate the variants automatically.
operation ApplyXGateCA (source : Qubit) : Unit is Adj + Ctl {
    X(source);
}

// Now you can call Adjoint ApplyXGateCA and Controlled ApplyXGateCA.


// To run Q# code, you can put @EntryPoint() before the operation you want to run first
@EntryPoint()
operation XGateDemo() : Unit {
    using (q = Qubit()) {
        ApplyXGate(q);
    }
}

// Here is a simple example: a quantum random number generator. 
// We will generate a classical array of random bits using quantum code.
@EntryPoint()
operation QRNGDemo() : Unit {
    mutable bits = new Int[5];                // Array we'll use to store bits
    using (q = Qubit()) {                     // Allocate a qubit
        for (i in 0 .. 4) {                   // Generate each bit independently
            H(q);                             // Hadamard gate sets equal superposition
            let result = M(q);                // Measure qubit gets 0|1 with 50/50 prob
            let bit = result == Zero ? 0 | 1; // Convert measurement result to integer
            set bits w/= i <- bit;            // Write generated bit to an array
        }
    }
    Message($""{bits}"");                       // Print the result
}
```


## Further Reading

The [Quantum Katas][1] offer great self-paced tutorials and programming exercises to learn quantum computing and Q#. 

[Q# Documentation][2] is official Q# documentation, including language reference and user guides.

[1]: https://github.com/microsoft/QuantumKatas
[2]: https://docs.microsoft.com/quantum/"
"OCaml is a strictly evaluated functional language with some imperative
features.

Along with Standard ML and its dialects it belongs to ML language family.
F# is also heavily influenced by OCaml.

Just like Standard ML, OCaml features both an interpreter, that can be
used interactively, and a compiler.
The interpreter binary is normally called `ocaml` and the compiler is `ocamlopt`.
There is also a bytecode compiler, `ocamlc`, but there are few reasons to use it.

It is strongly and statically typed, but instead of using manually written
type annotations, it infers types of expressions using the
[Hindley-Milner](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system)
algorithm.
It makes type annotations unnecessary in most cases, but can be a major
source of confusion for beginners.

When you are in the top level loop, OCaml will print the inferred type
after you enter an expression

```
# let inc x = x	+ 1 ;;
val inc : int -> int = <fun>
# let a = 99 ;;
val a : int = 99
```

For a source file you can use the `ocamlc -i /path/to/file.ml` command
to print all names and type signatures

```
$ cat sigtest.ml
let inc x = x + 1
let add x y = x + y

let a = 1

$ ocamlc -i ./sigtest.ml
val inc : int -> int
val add : int -> int -> int
val a : int
```

Note that type signatures of functions of multiple arguments are
written in [curried](https://en.wikipedia.org/wiki/Currying) form.
A function that takes multiple arguments can be
represented as a composition of functions that take only one argument.
The `f(x,y) = x + y` function from the example above applied to
arguments 2 and 3 is equivalent to the `f0(y) = 2 + y` function applied to 3.
Hence the `int -> int -> int` signature.


```ocaml
(*** Comments ***)

(* Comments are enclosed in (* and *). It's fine to nest comments. *)

(* There are no single-line comments. *)


(*** Variables and functions ***)

(* Expressions can be separated by a double semicolon "";;"".
   In many cases it's redundant, but in this tutorial we use it after
   every expression for easy pasting into the interpreter shell.
   Unnecessary use of expression separators in source code files
   is often considered to be a bad style. *)

(* Variable and function declarations use the ""let"" keyword. *)
let x = 10 ;;

(* OCaml allows single quote characters in identifiers.
   Single quote doesn't have a special meaning in this case, it's often used
   in cases when in other languages one would use names like ""foo_tmp"". *)
let foo = 1 ;;
let foo' = foo * 2 ;;

(* Since OCaml compiler infers types automatically, you normally don't need to
   specify argument types explicitly. However, you can do it if
   you want or need to. *)
let inc_int (x: int) : int = x + 1 ;;

(* One of the cases when explicit type annotations may be needed is
   resolving ambiguity between two record types that have fields with
   the same name. The alternative is to encapsulate those types in
   modules, but both topics are a bit out of scope of this
   tutorial. *)

(* You need to mark recursive function definitions as such with ""rec"" keyword. *)
let rec factorial n =
    if n = 0 then 1
    else n * factorial (n-1)
;;

(* Function application usually doesn't need parentheses around arguments *)
let fact_5 = factorial 5 ;;

(* ...unless the argument is an expression. *)
let fact_4 = factorial (5-1) ;;
let sqr2 = sqr (-2) ;;

(* Every function must have at least one argument.
   Since some functions naturally don't take any arguments, there's
   ""unit"" type for it that has the only one value written as ""()"" *)
let print_hello () = print_endline ""hello world"" ;;

(* Note that you must specify ""()"" as the argument when calling it. *)
print_hello () ;;

(* Calling a function with an insufficient number of arguments
   does not cause an error, it produces a new function. *)
let make_inc x y = x + y ;; (* make_inc is int -> int -> int *)
let inc_2 = make_inc 2 ;;   (* inc_2 is int -> int *)
inc_2 3 ;; (* Evaluates to 5 *)

(* You can use multiple expressions in the function body.
   The last expression becomes the return value. All other
   expressions must be of the ""unit"" type.
   This is useful when writing in imperative style, the simplest
   form of which is inserting a debug print. *)
let print_and_return x =
    print_endline (string_of_int x);
    x
;;

(* Since OCaml is a functional language, it lacks ""procedures"".
   Every function must return something. So functions that do not
   really return anything and are called solely for their side
   effects, like print_endline, return a value of ""unit"" type. *)


(* Definitions can be chained with the ""let ... in"" construct.
   This is roughly the same as assigning values to multiple
   variables before using them in expressions in imperative
   languages. *)
let x = 10 in
let y = 20 in
x + y ;;

(* Alternatively you can use the ""let ... and ... in"" construct.
   This is especially useful for mutually recursive functions,
   with ordinary ""let ... in"" the compiler will complain about
   unbound values. *)
let rec
  is_even = function
  | 0 -> true
  | n -> is_odd (n-1)
and
  is_odd = function
  | 0 -> false
  | n -> is_even (n-1)
;;

(* Anonymous functions use the following syntax: *)
let my_lambda = fun x -> x * x ;;

(*** Operators ***)

(* There is little distinction between operators and functions.
   Every operator can be called as a function. *)

(+) 3 4  (* Same as 3 + 4 *)

(* There's a number of built-in operators. One unusual feature is
   that OCaml doesn't just refrain from any implicit conversions
   between integers and floats, it also uses different operators
   for floats. *)
12 + 3 ;; (* Integer addition. *)
12.0 +. 3.0 ;; (* Floating point addition. *)

12 / 3 ;; (* Integer division. *)
12.0 /. 3.0 ;; (* Floating point division. *)
5 mod 2 ;; (* Remainder. *)

(* Unary minus is a notable exception, it's polymorphic.
   However, it also has ""pure"" integer and float forms. *)
- 3 ;; (* Polymorphic, integer *)
- 4.5 ;; (* Polymorphic, float *)
~- 3 (* Integer only *)
~- 3.4 (* Type error *)
~-. 3.4 (* Float only *)

(* You can define your own operators or redefine existing ones.
   Unlike Standard ML or Haskell, only certain symbols can be
   used for operator names and the operator's first symbol determines
   its associativity and precedence rules. *)
let (+) a b = a - b ;; (* Surprise maintenance programmers. *)

(* More useful: a reciprocal operator for floats.
   Unary operators must start with ""~"". *)
let (~/) x = 1.0 /. x ;;
~/4.0 (* = 0.25 *)


(*** Built-in data structures ***)

(* Lists are enclosed in square brackets, items are separated by
   semicolons. *)
let my_list = [1; 2; 3] ;; (* Has type ""int list"". *)

(* Tuples are (optionally) enclosed in parentheses, items are separated
   by commas. *)
let first_tuple = 3, 4 ;; (* Has type ""int * int"". *)
let second_tuple = (4, 5) ;;

(* Corollary: if you try to separate list items by commas, you get a list
   with a tuple inside, probably not what you want. *)
let bad_list = [1, 2] ;; (* Becomes [(1, 2)] *)

(* You can access individual list items with the List.nth function. *)
List.nth my_list 1 ;;

(* There are higher-order functions for lists such as map and filter. *)
List.map (fun x -> x * 2) [1; 2; 3] ;;
List.filter (fun x -> x mod 2 = 0) [1; 2; 3; 4] ;;

(* You can add an item to the beginning of a list with the ""::"" constructor
   often referred to as ""cons"". *)
1 :: [2; 3] ;; (* Gives [1; 2; 3] *)

(* Arrays are enclosed in [| |] *)
let my_array = [| 1; 2; 3 |] ;;

(* You can access array items like this: *)
my_array.(0) ;;


(*** Strings and characters ***)

(* Use double quotes for string literals. *)
let my_str = ""Hello world"" ;;

(* Use single quotes for character literals. *)
let my_char = 'a' ;;

(* Single and double quotes are not interchangeable. *)
let bad_str = 'syntax error' ;; (* Syntax error. *)

(* This will give you a single character string, not a character. *)
let single_char_str = ""w"" ;;

(* Strings can be concatenated with the ""^"" operator. *)
let some_str = ""hello"" ^ ""world"" ;;

(* Strings are not arrays of characters.
   You can't mix characters and strings in expressions.
   You can convert a character to a string with ""String.make 1 my_char"".
   There are more convenient functions for this purpose in additional
   libraries such as Core.Std that may not be installed and/or loaded
   by default. *)
let ocaml = (String.make 1 'O') ^ ""Caml"" ;;

(* There is a printf function. *)
Printf.printf ""%d %s"" 99 ""bottles of beer"" ;;

(* There's also unformatted read and write functions. *)
print_string ""hello world\n"" ;;
print_endline ""hello world"" ;;
let line = read_line () ;;


(*** User-defined data types ***)

(* You can define types with the ""type some_type ="" construct. Like in this
   useless type alias: *)
type my_int = int ;;

(* More interesting types include so called type constructors.
   Constructors must start with a capital letter. *)
type ml = OCaml | StandardML ;;
let lang = OCaml ;;  (* Has type ""ml"". *)

(* Type constructors don't need to be empty. *)
type my_number = PlusInfinity | MinusInfinity | Real of float ;;
let r0 = Real (-3.4) ;; (* Has type ""my_number"". *)

(* Can be used to implement polymorphic arithmetics. *)
type number = Int of int | Float of float ;;

(* Point on a plane, essentially a type-constrained tuple *)
type point2d = Point of float * float ;;
let my_point = Point (2.0, 3.0) ;;

(* Types can be parameterized, like in this type for ""list of lists
   of anything"". 'a can be substituted with any type. *)
type 'a list_of_lists = 'a list list ;;
type int_list_list = int list_of_lists ;;

(* Types can also be recursive. Like in this type analogous to
   a built-in list of integers. *)
type my_int_list = EmptyList | IntList of int * my_int_list ;;
let l = IntList (1, EmptyList) ;;


(*** Pattern matching ***)

(* Pattern matching is somewhat similar to the switch statement in imperative
   languages, but offers a lot more expressive power.

   Even though it may look complicated, it really boils down to matching
   an argument against an exact value, a predicate, or a type constructor.
   The type system is what makes it so powerful. *)

(** Matching exact values.  **)

let is_zero x =
    match x with
    | 0 -> true
    | _ -> false  (* The ""_"" means ""anything else"". *)
;;

(* Alternatively, you can use the ""function"" keyword. *)
let is_one = function
| 1 -> true
| _ -> false
;;

(* Matching predicates, aka ""guarded pattern matching"". *)
let abs x =
    match x with
    | x when x < 0 -> -x
    | _ -> x
;;

abs 5 ;; (* 5 *)
abs (-5) (* 5 again *)

(** Matching type constructors **)

type animal = Dog of string | Cat of string ;;

let say x =
    match x with
    | Dog x -> x ^ "" says woof""
    | Cat x -> x ^ "" says meow""
;;

say (Cat ""Fluffy"") ;; (* ""Fluffy says meow"". *)

(** Traversing data structures with pattern matching **)

(* Recursive types can be traversed with pattern matching easily.
   Let's see how we can traverse a data structure of the built-in list type.
   Even though the built-in cons (""::"") looks like an infix operator,
   it's actually a type constructor and can be matched like any other. *)
let rec sum_list l =
    match l with
    | [] -> 0
    | head :: tail -> head + (sum_list tail)
;;

sum_list [1; 2; 3] ;; (* Evaluates to 6 *)

(* Built-in syntax for cons obscures the structure a bit, so we'll make
   our own list for demonstration. *)

type int_list = Nil | Cons of int * int_list ;;
let rec sum_int_list l =
  match l with
      | Nil -> 0
      | Cons (head, tail) -> head + (sum_int_list tail)
;;

let t = Cons (1, Cons (2, Cons (3, Nil))) ;;
sum_int_list t ;;
```

## Further reading

* Visit the official website to get the compiler and read the docs: <http://ocaml.org/>
* Quick tutorial on OCaml: <https://ocaml.org/docs/up-and-running>
* Complete online OCaml v5 playground: <https://ocaml.org/play>
* An up-to-date (2022) book (with free online version) ""Real World OCaml"": <https://www.cambridge.org/core/books/real-world-ocaml-functional-programming-for-the-masses/052E4BCCB09D56A0FE875DD81B1ED571>
* Online interactive textbook ""OCaml Programming: Correct + Efficient + Beautiful"" from Cornell University: <https://cs3110.github.io/textbook/cover.html>
* Try interactive tutorials and a web-based interpreter by OCaml Pro: <http://try.ocamlpro.com/>"
"The Coq system is a proof assistant. It is designed to build and verify mathematical proofs. The Coq system contains the functional programming language Gallina and is capable of proving properties about programs written in this language.

Coq is a dependently typed language. This means that the types of the language may depend on the values of variables. In this respect, it is similar to other related languages such as Agda, Idris, F*, Lean, and others. Via the Curry-Howard correspondence, programs, properties and proofs are formalized in the same language.

Coq is developed in OCaml and shares some syntactic and conceptual similarity with it. Coq is a language containing many fascinating but difficult topics. This tutorial will focus on the programming aspects of Coq, rather than the proving. It may be helpful, but not necessary to learn some OCaml first, especially if you are unfamiliar with functional programming. This tutorial is based upon its OCaml equivalent

The standard usage model of Coq is to write it with interactive tool assistance, which operates like a high powered REPL. Two common such editors are the CoqIDE and Proof General Emacs mode.

Inside Proof General `Ctrl+C Ctrl+<Enter>` will evaluate up to your cursor.


```coq
(*** Comments ***)

(* Comments are enclosed in (* and *). It's fine to nest comments. *)

(* There are no single-line comments. *)

(*** Variables and functions ***)

(* The Coq proof assistant can be controlled and queried by a command
   language called the vernacular. Vernacular keywords are capitalized and
   the commands end with a period.  Variable and function declarations are
   formed with the Definition vernacular. *)

Definition x := 10.

(* Coq can sometimes infer the types of arguments, but it is common practice
   to annotate with types. *)

Definition inc_nat (x : nat) : nat := x + 1.

(* There exists a large number of vernacular commands for querying
   information.  These can be very useful. *)

Compute (1 + 1). (* 2 : nat *) (* Compute a result. *)

Check tt. (* tt : unit *) (* Check the type of an expressions *)

About plus. (* Prints information about an object *)

(* Print information including the definition *)
Print true. (* Inductive bool : Set := true : Bool | false : Bool *)

Search nat. (* Returns a large list of nat related values *)
Search ""_ + _"". (* You can also search on patterns *)
Search (?a -> ?a -> bool). (* Patterns can have named parameters  *)
Search (?a * ?a).

(* Locate tells you where notation is coming from. Very helpful when you
   encounter new notation. *)

Locate ""+"".

(* Calling a function with insufficient number of arguments does not cause
   an error, it produces a new function. *)
Definition make_inc x y := x + y. (* make_inc is nat -> nat -> nat *)
Definition inc_2 := make_inc 2.   (* inc_2 is nat -> nat *)
Compute inc_2 3. (* Evaluates to 5 *)


(* Definitions can be chained with ""let ... in"" construct.  This is roughly
   the same to assigning values to multiple variables before using them in
   expressions in imperative languages. *)

Definition add_xy : nat := let x := 10 in
                           let y := 20 in
                           x + y.

(* Pattern matching is somewhat similar to switch statement in imperative
   languages, but offers a lot more expressive power. *)

Definition is_zero (x : nat) :=
    match x with
    | 0 => true
    | _ => false  (* The ""_"" pattern means ""anything else"". *)
    end.

(* You can define recursive function definition using the Fixpoint
   vernacular.*)

Fixpoint factorial n := match n with
                        | 0 => 1
                        | (S n') => n * factorial n'
                        end.

(* Function application usually doesn't need parentheses around arguments *)
Compute factorial 5. (* 120 : nat *)

(* ...unless the argument is an expression. *)
Compute factorial (5-1). (* 24 : nat *)

(* You can define mutually recursive functions using ""with"" *)
Fixpoint is_even (n : nat) : bool := match n with
  | 0 => true
  | (S n) => is_odd n
end with
  is_odd n := match n with
  | 0 => false
  | (S n) => is_even n
              end.

(* As Coq is a total programming language, it will only accept programs when
   it can understand they terminate. It can be most easily seen when the
   recursive call is on a pattern matched out subpiece of the input, as then
   the input is always decreasing in size. Getting Coq to understand that
   functions terminate is not always easy. See the references at the end of
   the article for more on this topic. *)

(* Anonymous functions use the following syntax: *)

Definition my_square : nat -> nat := fun x => x * x.

Definition my_id (A : Type) (x : A) : A := x.
Definition my_id2 : forall A : Type, A -> A := fun A x => x.
Compute my_id nat 3. (* 3 : nat *)

(* You can ask Coq to infer terms with an underscore *)
Compute my_id _ 3.

(* An implicit argument of a function is an argument which can be inferred
   from contextual knowledge. Parameters enclosed in {} are implicit by
   default *)

Definition my_id3 {A : Type} (x : A) : A := x.
Compute my_id3 3. (* 3 : nat *)

(* Sometimes it may be necessary to turn this off. You can make all
   arguments explicit again with @ *)

Compute @my_id3 nat 3.

(* Or give arguments by name *)
Compute my_id3 (A:=nat) 3.

(* Coq has the ability to extract code to OCaml, Haskell, and Scheme *)
Require Extraction.
Extraction Language OCaml.
Extraction ""factorial.ml"" factorial.
(* The above produces a file factorial.ml and factorial.mli that holds:

type nat =
| O
| S of nat

(** val add : nat -> nat -> nat **)

let rec add n m =
  match n with
  | O -> m
  | S p -> S (add p m)

(** val mul : nat -> nat -> nat **)

let rec mul n m =
  match n with
  | O -> O
  | S p -> add m (mul p m)

(** val factorial : nat -> nat **)

let rec factorial n = match n with
| O -> S O
| S n' -> mul n (factorial n')
*)


(*** Notation ***)

(* Coq has a very powerful Notation system that can be used to write
   expressions in more natural forms. *)

Compute Nat.add 3 4. (* 7 : nat *)
Compute 3 + 4. (* 7 : nat *)

(* Notation is a syntactic transformation applied to the text of the program
   before being evaluated. Notation is organized into notation scopes. Using
   different notation scopes allows for a weak notion of overloading. *)

(* Imports the Zarith module holding definitions related to the integers Z *)

Require Import ZArith.

(* Notation scopes can be opened *)
Open Scope Z_scope.

(* Now numerals and addition are defined on the integers. *)
Compute 1 + 7. (* 8 : Z *)

(* Integer equality checking *)
Compute 1 =? 2. (* false : bool *)

(* Locate is useful for finding the origin and definition of notations *)
Locate ""_ =? _"". (* Z.eqb x y : Z_scope *)
Close Scope Z_scope.

(* We're back to nat being the default interpretation of ""+"" *)
Compute 1 + 7. (* 8 : nat *)

(* Scopes can also be opened inline with the shorthand % *)
Compute (3 * -7)%Z. (* -21%Z : Z *)

(* Coq declares by default the following interpretation scopes: core_scope,
   type_scope, function_scope, nat_scope, bool_scope, list_scope, int_scope,
   uint_scope. You may also want the numerical scopes Z_scope (integers) and
   Q_scope (fractions) held in the ZArith and QArith module respectively. *)

(* You can print the contents of scopes *)
Print Scope nat_scope.
(*
Scope nat_scope
Delimiting key is nat
Bound to classes nat Nat.t
""x 'mod' y"" := Nat.modulo x y
""x ^ y"" := Nat.pow x y
""x ?= y"" := Nat.compare x y
""x >= y"" := ge x y
""x > y"" := gt x y
""x =? y"" := Nat.eqb x y
""x <? y"" := Nat.ltb x y
""x <=? y"" := Nat.leb x y
""x <= y <= z"" := and (le x y) (le y z)
""x <= y < z"" := and (le x y) (lt y z)
""n <= m"" := le n m
""x < y <= z"" := and (lt x y) (le y z)
""x < y < z"" := and (lt x y) (lt y z)
""x < y"" := lt x y
""x / y"" := Nat.div x y
""x - y"" := Init.Nat.sub x y
""x + y"" := Init.Nat.add x y
""x * y"" := Init.Nat.mul x y
*)

(* Coq has exact fractions available as the type Q in the QArith module.
   Floating point numbers and real numbers are also available but are a more
   advanced topic, as proving properties about them is rather tricky. *)

Require Import QArith.

Open Scope Q_scope.
Compute 1. (* 1 : Q *)

(* Only 1 and 0 are interpreted as fractions by Q_scope *)
Compute 2. (* 2 : nat *)
Compute (2 # 3). (* The fraction 2/3 *)
Compute (1 # 3) ?= (2 # 6). (* Eq : comparison *)
Close Scope Q_scope.

Compute ( (2 # 3) / (1 # 5) )%Q. (* 10 # 3 : Q *)


(*** Common data structures ***)

(* Many common data types are included in the standard library *)

(* The unit type has exactly one value, tt *)
Check tt. (* tt : unit *)

(* The option type is useful for expressing computations that might fail *)
Compute None. (* None : option ?A *)
Check Some 3. (* Some 3 : option nat *)

(* The type sum A B allows for values of either type A or type B *)
Print sum.
Check inl 3. (* inl 3 : nat + ?B *)
Check inr true. (* inr true : ?A + bool *)
Check sum bool nat. (* (bool + nat)%type : Set *)
Check (bool + nat)%type. (* Notation for sum *)

(* Tuples are (optionally) enclosed in parentheses, items are separated
   by commas. *)
Check (1, true). (* (1, true) : nat * bool *)
Compute prod nat bool. (* (nat * bool)%type : Set *)

Definition my_fst {A B : Type} (x : A * B) : A := match x with
                                                  | (a,b) => a
                                                  end.

(* A destructuring let is available if a pattern match is irrefutable *)
Definition my_fst2 {A B : Type} (x : A * B) : A := let (a,b) := x in
                                                   a.

(*** Lists ***)

(* Lists are built by using cons and nil or by using notation available in
   list_scope. *)
Compute cons 1 (cons 2 (cons 3 nil)). (*  (1 :: 2 :: 3 :: nil)%list : list nat *)
Compute (1 :: 2 :: 3 :: nil)%list.

(* There is also list notation available in the ListNotations modules *)
Require Import List.
Import ListNotations.
Compute [1 ; 2 ; 3]. (* [1; 2; 3] : list nat *)


(* There is a large number of list manipulation functions available,
   including:

• length
• head : first element (with default)
• tail : all but first element
• app : appending
• rev : reverse
• nth : accessing n-th element (with default)
• map : applying a function
• flat_map : applying a function returning lists
• fold_left : iterator (from head to tail)
• fold_right : iterator (from tail to head)

 *)

Definition my_list : list nat := [47; 18; 34].

Compute List.length my_list. (* 3 : nat *)

(* All functions in coq must be total, so indexing requires a default value *)
Compute List.nth 1 my_list 0. (* 18 : nat *)
Compute List.map (fun x => x * 2) my_list. (* [94; 36; 68] : list nat *)
Compute List.filter (fun x => Nat.eqb (Nat.modulo x 2) 0) my_list.
                                               (* [18; 34] : list nat *)
Compute (my_list ++ my_list)%list. (* [47; 18; 34; 47; 18; 34] : list nat *)

(*** Strings ***)

Require Import Strings.String.

(* Use double quotes for string literals. *)
Compute ""hi""%string.

Open Scope string_scope.

(* Strings can be concatenated with the ""++"" operator. *)
Compute String.append ""Hello "" ""World"". (* ""Hello World"" : string *)
Compute ""Hello "" ++ ""World"". (* ""Hello World"" : string *)

(* Strings can be compared for equality *)
Compute String.eqb ""Coq is fun!"" ""Coq is fun!"". (* true : bool *)
Compute ""no"" =? ""way"". (* false : bool *)

Close Scope string_scope.

(*** Other Modules ***)

(* Other Modules in the standard library that may be of interest:

• Logic : Classical logic and dependent equality
• Arith : Basic Peano arithmetic
• PArith : Basic positive integer arithmetic
• NArith : Basic binary natural number arithmetic
• ZArith : Basic relative integer arithmetic

• Numbers : Various approaches to natural, integer and cyclic numbers
            (currently axiomatically and on top of 2^31 binary words)
• Bool : Booleans (basic functions and results)

• Lists : Monomorphic and polymorphic lists (basic functions and results),
          Streams (infinite sequences defined with co-inductive types)
• Sets : Sets (classical, constructive, finite, infinite, power set, etc.)
• FSets : Specification and implementations of finite sets and finite maps
          (by lists and by AVL trees)
• Reals : Axiomatization of real numbers (classical, basic functions,
          integer part, fractional part, limit, derivative, Cauchy series,
          power series and results,...)
• Relations : Relations (definitions and basic results)
• Sorting : Sorted list (basic definitions and heapsort correctness)
• Strings : 8-bit characters and strings
• Wellfounded : Well-founded relations (basic results)
 *)

(*** User-defined data types ***)

(* Because Coq is dependently typed, defining type aliases is no different
   than defining an alias for a value. *)

Definition my_three : nat := 3.
Definition my_nat : Type := nat.

(* More interesting types can be defined using the Inductive vernacular.
   Simple enumeration can be defined like so *)

Inductive ml := OCaml | StandardML | Coq.
Definition lang := Coq.  (* Has type ""ml"". *)

(* For more complicated types, you will need to specify the types of the
   constructors. *)

(* Type constructors don't need to be empty. *)
Inductive my_number := plus_infinity
                     | nat_value : nat -> my_number.
Compute nat_value 3. (* nat_value 3 : my_number *)


(* Record syntax is sugar for tuple-like types. It defines named accessor
   functions for the components. Record types are defined with the notation
   {...} *)

Record Point2d (A : Set) := mkPoint2d { x2 : A ; y2 : A }.
(* Record values are constructed with the notation {|...|} *)
Definition mypoint : Point2d nat :=  {| x2 := 2 ; y2 := 3 |}.
Compute x2 nat mypoint. (* 2 : nat *)
Compute mypoint.(x2 nat). (* 2 : nat *)

(* Types can be parameterized, like in this type for ""list of lists of
   anything"". 'a can be substituted with any type. *)

Definition list_of_lists a := list (list a).
Definition list_list_nat := list_of_lists nat.

(* Types can also be recursive. Like in this type analogous to
   built-in list of naturals. *)

Inductive my_nat_list :=
  EmptyList | NatList : nat -> my_nat_list -> my_nat_list.

Compute NatList 1 EmptyList. (*  NatList 1 EmptyList : my_nat_list *)

(** Matching type constructors **)

Inductive animal := Dog : string -> animal | Cat : string -> animal.

Definition say x :=
    match x with
    | Dog x => (x ++ "" says woof"")%string
    | Cat x => (x ++ "" says meow"")%string
    end.

Compute say (Cat ""Fluffy""). (* ""Fluffy says meow"". *)

(** Traversing data structures with pattern matching **)

(* Recursive types can be traversed with pattern matching easily.
   Let's see how we can traverse a data structure of the built-in list type.
   Even though the built-in cons (""::"") looks like an infix operator,
   it's actually a type constructor and can be matched like any other. *)
Fixpoint sum_list l :=
    match l with
    | [] => 0
    | head :: tail => head + (sum_list tail)
    end.

Compute sum_list [1; 2; 3]. (* Evaluates to 6 *)


(*** A Taste of Proving ***)

(* Explaining the proof language is out of scope for this tutorial, but here
   is a taste to whet your appetite. Check the resources below for more. *)

(* A fascinating feature of dependently type based theorem provers is that
   the same primitive constructs underly the proof language as the
   programming features.  For example, we can write and prove the
   proposition A and B implies A in raw Gallina *)

Definition my_theorem : forall A B, A /\ B -> A :=
  fun A B ab => match ab with
                  | (conj a b) => a
                end.

(* Or we can prove it using tactics. Tactics are a macro language to help
   build proof terms in a more natural style and automate away some
   drudgery. *)

Theorem my_theorem2 : forall A B, A /\ B -> A.
Proof.
  intros A B ab.  destruct ab as [ a b ]. apply a.
Qed.

(* We can easily prove simple polynomial equalities using the
   automated tactic ring. *)

Require Import Ring.
Require Import Arith.
Theorem simple_poly : forall (x : nat), (x + 1) * (x + 2) = x * x + 3 * x + 2.
  Proof. intros. ring. Qed.

(* Here we prove the closed form for the sum of all numbers 1 to n using
   induction *)

Fixpoint sumn (n : nat) : nat :=
  match n with
  | 0 => 0
  | (S n') => n + (sumn n')
  end.

Theorem sum_formula : forall n, 2 * (sumn n) = (n + 1) * n.
Proof. intros n. induction n.
       - reflexivity. (* 0 = 0 base case *)
       - simpl. ring [IHn]. (* induction step *)
Qed.
```

With this we have only scratched the surface of Coq. It is a massive
ecosystem with many interesting and peculiar topics leading all the way up
to modern research.

## Further reading

* [The Coq reference manual](https://coq.inria.fr/refman/)
* [Software Foundations](https://softwarefoundations.cis.upenn.edu/)
* [Certified Programming with Dependent Types](http://adam.chlipala.net/cpdt/)
* [Mathematical Components](https://math-comp.github.io/mcb/)
* [Coq'Art: The Calculus of Inductive Constructions](http://www.cse.chalmers.se/research/group/logic/TypesSS05/resources/coq/CoqArt/)
* [FRAP](http://adam.chlipala.net/frap/)"
"The MIPS (Microprocessor without Interlocked Pipeline Stages) Assembly language
is designed to work with the MIPS microprocessor paradigm designed by J. L. 
Hennessy in 1981. These RISC processors are used in embedded systems such as 
gateways and routers.

[Read More](https://en.wikipedia.org/wiki/MIPS_architecture)

```asm
# Comments are denoted with a '#'

# Everything that occurs after a '#' will be ignored by the assembler's lexer.

# Programs typically contain a .data and .text sections

.data # Section where data is stored in memory (allocated in RAM), similar to
      # variables in higher-level languages

  # Declarations follow a ( label: .type value(s) ) form of declaration
  hello_world: .asciiz ""Hello World\n""      # Declare a null terminated string
  num1: .word 42                            # Integers are referred to as words
                                            # (32-bit value)

  arr1: .word 1, 2, 3, 4, 5                 # Array of words
  arr2: .byte 'a', 'b'                      # Array of chars (1 byte each)
  buffer: .space 60                         # Allocates space in the RAM 
                                            # (not cleared to 0)

  # Datatype sizes
  _byte: .byte 'a'                          # 1 byte
  _halfword: .half 53                       # 2 bytes
  _word: .word 3                            # 4 bytes
  _float: .float 3.14                       # 4 bytes
  _double: .double 7.0                      # 8 bytes

  .align 2                                  # Memory alignment of data, where
                                            # number indicates byte alignment
                                            # in powers of 2. (.align 2
                                            # represents word alignment since
                                            # 2^2 = 4 bytes)

.text                                       # Section that contains 
                                            # instructions and program logic
.globl _main                                # Declares an instruction label as
                                            # global, making it accessible to
                                            # other files

  _main:                                    # MIPS programs execute 
                                            # instructions sequentially, where 
                                            # the code under this label will be
                                            # executed first

    # Let's print ""hello world""
    la $a0, hello_world                     # Load address of string stored
                                            # in memory
    li $v0, 4                               # Load the syscall value (number
                                            # indicating which syscall to make)
    syscall                                 # Perform the specified syscall
                                            # with the given argument ($a0)

    # Registers (used to hold data during program execution)
    # $t0 - $t9                             # Temporary registers used for 
                                            # intermediate calculations inside 
                                            # subroutines (not saved across 
                                            # function calls)

    # $s0 - $s7                             # Saved registers where values are 
                                            # saved across subroutine calls. 
                                            # Typically saved in stack

    # $a0 - $a3                             # Argument registers for passing in 
                                            # arguments for subroutines
    # $v0 - $v1                             # Return registers for returning 
                                            # values to caller function

    # Types of load/store instructions
    la $t0, label                           # Copy the address of a value in
                                            # memory specified by the label
                                            # into register $t0
    lw $t0, label                           # Copy a word value from memory
    lw $t1, 4($s0)                          # Copy a word value from an address
                                            # stored in a register with an
                                            # offset of 4 bytes (addr + 4)
    lb $t2, label                           # Copy a byte value to the 
                                            # lower order portion of 
                                            # the register $t2
    lb $t2, 0($s0)                          # Copy a byte value from the source
                                            # address in $s0 with offset 0
    # Same idea with 'lh' for halfwords

    sw $t0, label                           # Store word value into
                                            # memory address mapped by label
    sw $t0, 8($s0)                          # Store word value into address 
                                            # specified in $s0 and offset of
                                            # 8 bytes
    # Same idea using 'sb' and 'sh' for bytes and halfwords. 'sa' does not exist

### Math ###
  _math:
    # Remember to load your values into a register
    lw $t0, num                             # From the data section
    li $t0, 5                               # Or from an immediate (constant)
    li $t1, 6
    add $t2, $t0, $t1                       # $t2 = $t0 + $t1
    sub $t2, $t0, $t1                       # $t2 = $t0 - $t1
    mul $t2, $t0, $t1                       # $t2 = $t0 * $t1
    div $t2, $t0, $t1                       # $t2 = $t0 / $t1 (Might not be 
                                            # supported in some versions of MARS)
    div $t0, $t1                            # Performs $t0 / $t1. Get the 
                                            # quotient using 'mflo' and 
                                            # remainder using 'mfhi'

    # Bitwise Shifting
    sll $t0, $t0, 2                         # Bitwise shift to the left with 
                                            # immediate (constant value) of 2
    sllv $t0, $t1, $t2                      # Shift left by a variable amount
                                            # in register
    srl $t0, $t0, 5                         # Bitwise shift to the right (does 
                                            # not sign preserve, sign-extends 
                                            # with 0)
    srlv $t0, $t1, $t2                      # Shift right by a variable amount 
                                            # in a register
    sra $t0, $t0, 7                         # Bitwise arithmetic shift to  
                                            # the right (preserves sign)
    srav $t0, $t1, $t2                      # Shift right by a variable amount 
                                            # in a register

    # Bitwise operators
    and $t0, $t1, $t2                       # Bitwise AND
    andi $t0, $t1, 0xFFF                    # Bitwise AND with immediate
    or $t0, $t1, $t2                        # Bitwise OR
    ori $t0, $t1, 0xFFF                     # Bitwise OR with immediate
    xor $t0, $t1, $t2                       # Bitwise XOR
    xori $t0, $t1, 0xFFF                    # Bitwise XOR with immediate
    nor $t0, $t1, $t2                       # Bitwise NOR

## BRANCHING ##
  _branching:
    # The basic format of these branching instructions typically follow <instr>
    # <reg1> <reg2> <label> where label is the label we want to jump to if the
    # given conditional evaluates to true
    # Sometimes it is easier to write the conditional logic backward, as seen
    # in the simple if statement example below

    beq $t0, $t1, reg_eq                    # Will branch to reg_eq if
                                            # $t0 == $t1, otherwise
                                            # execute the next line
    bne $t0, $t1, reg_neq                   # Branches when $t0 != $t1
    b branch_target                         # Unconditional branch, will 
                                            # always execute
    beqz $t0, req_eq_zero                   # Branches when $t0 == 0
    bnez $t0, req_neq_zero                  # Branches when $t0 != 0
    bgt $t0, $t1, t0_gt_t1                  # Branches when $t0 > $t1
    bge $t0, $t1, t0_gte_t1                 # Branches when $t0 >= $t1
    bgtz $t0, t0_gt0                        # Branches when $t0 > 0
    blt $t0, $t1, t0_gt_t1                  # Branches when $t0 < $t1
    ble $t0, $t1, t0_gte_t1                 # Branches when $t0 <= $t1
    bltz $t0, t0_lt0                        # Branches when $t0 < 0
    slt $s0, $t0, $t1                       # ""Set on Less Than""
                                            # when $t0 < $t1 with result in $s0 
                                            # (1 for true)

    # Simple if statement
    # if (i == j)
    #     f = g + h;
    #  f = f - i;

    # Let $s0 = f, $s1 = g, $s2 = h, $s3 = i, $s4 = j
    bne $s3, $s4, L1 # if (i !=j)
    add $s0, $s1, $s2 # f = g + h

    L1:
      sub $s0, $s0, $s3 # f = f - i
    
    # Below is an example of finding the max of 3 numbers
    # A direct translation in Java from MIPS logic:
    # if (a > b)
    #   if (a > c)
    #     max = a;
    #   else
    #     max = c;
    # else
    #   if (b > c)
    #     max = b;
    #   else
    #     max = c;

    # Let $s0 = a, $s1 = b, $s2 = c, $v0 = return register
    ble $s0, $s1, a_LTE_b                   # if(a <= b) branch(a_LTE_b)
    ble $s0, $s2, max_C                     # if(a > b && a <=c) branch(max_C)
    move $v0, $s0                           # else [a > b && a > c] max = a
    j done                                  # Jump to the end of the program

    a_LTE_b:                                # Label for when a <= b
      ble $s1, $s2, max_C                   # if(a <= b && b <= c) branch(max_C)
      move $v0, $s1                         # if(a <= b && b > c) max = b
      j done                                # Jump to done

    max_C:
      move $v0, $s2                         # max = c

    done:                                   # End of program

## LOOPS ##
  _loops:
    # The basic structure of loops is having an exit condition and a jump 
    # instruction to continue its execution
    li $t0, 0
    while:
      bgt $t0, 9, end_while                 # While $t0 is less than 10, 
                                            # keep iterating
      #actual loop content would go here
      addi $t0, $t0, 1                      # Increment the value
      j while                               # Jump back to the beginning of 
                                            # the loop
    end_while:

    # 2D Matrix Traversal
    # Assume that $a0 stores the address of an integer matrix which is 3 x 3
    li $t0, 0                               # Counter for i
    li $t1, 0                               # Counter for j
    matrix_row:
      bgt $t0, 3, matrix_row_end

      matrix_col:
        bgt $t1, 3, matrix_col_end

        # Do stuff

        addi $t1, $t1, 1                  # Increment the col counter
      matrix_col_end:

      # Do stuff

      addi $t0, $t0, 1
    matrix_row_end:

## FUNCTIONS ##
  _functions:
    # Functions are callable procedures that can accept arguments and return 
    # values all denoted with labels, like above

    main:                                 # Programs begin with main func
      jal return_1                        # jal will store the current PC in $ra
                                          # and then jump to return_1

      # What if we want to pass in args?
      # First we must pass in our parameters to the argument registers
      li $a0, 1
      li $a1, 2
      jal sum                             # Now we can call the function

      # How about recursion?
      # This is a bit more work since we need to make sure we save and restore
      # the previous PC in $ra since jal will automatically overwrite 
      # on each call
      li $a0, 3
      jal fact

      li $v0, 10
      syscall
    
    # This function returns 1
    return_1:
      li $v0, 1                           # Load val in return register $v0
      jr $ra                              # Jump back to old PC to continue exec


    # Function with 2 args
    sum:
      add $v0, $a0, $a1
      jr $ra                              # Return

    # Recursive function to find factorial
    fact:
      addi $sp, $sp, -8                   # Allocate space in stack
      sw $s0, ($sp)                       # Store reg that holds current num
      sw $ra, 4($sp)                      # Store previous PC

      li $v0, 1                           # Init return value
      beq $a0, 0, fact_done               # Finish if param is 0

      # Otherwise, continue recursion
      move $s0, $a0                       # Copy $a0 to $s0
      sub $a0, $a0, 1
      jal fact

      mul $v0, $s0, $v0                   # Multiplication is done

      fact_done:
        lw $s0, ($sp)
        lw $ra, 4($sp)                     # Restore the PC
        addi $sp, $sp, 8

        jr $ra

## MACROS ##
  _macros:
    # Macros are extremely useful for substituting repeated code blocks with a
    # single label for better readability
    # These are in no means substitutes for functions
    # These must be declared before it is used

    # Macro for printing newlines (since these can be very repetitive)
    .macro println()
      la $a0, newline                     # New line string stored here
      li $v0, 4
      syscall
    .end_macro

    println()                             # Assembler will copy that block of
                                          # code here before running

    # Parameters can be passed in through macros.
    # These are denoted by a '%' sign with any name you choose
    .macro print_int(%num)
      li $v0, 1
      lw $a0, %num
      syscall
    .end_macro
    
    li $t0, 1
    print_int($t0)
    
    # We can also pass in immediates for macros
    .macro immediates(%a, %b)
      add $t0, %a, %b
    .end_macro

    immediates(3, 5)

    # Along with passing in labels
    .macro print(%string)
      la $a0, %string
      li $v0, 4
      syscall
    .end_macro

    print(hello_world)

## ARRAYS ##
.data
  list: .word 3, 0, 1, 2, 6                 # This is an array of words
  char_arr: .asciiz ""hello""                 # This is a char array
  buffer: .space 128                        # Allocates a block in memory, does
                                            # not automatically clear
                                            # These blocks of memory are aligned
                                            # next to each other

.text
  la $s0, list                              # Load address of list
  li $t0, 0                                 # Counter
  li $t1, 5                                 # Length of the list

  loop:
    bge $t0, $t1, end_loop

    lw $a0, ($s0)
    li $v0, 1
    syscall                                 # Print the number

    addi $s0, $s0, 4                        # Size of a word is 4 bytes
    addi $t0, $t0, 1                        # Increment
    j loop
  end_loop:

## INCLUDE ##
# You do this to import external files into your program (behind the scenes, 
# it really just takes whatever code that is in that file and places it where
# the include statement is)
.include ""somefile.asm""

```"
"This is a tutorial on how to do some typical statistical programming tasks using Python. It's intended for people basically familiar with Python and experienced at statistical programming in a language like R, Stata, SAS, SPSS, or MATLAB.

```python



# 0. Getting set up ====

"""""" To get started, pip install the following: jupyter, numpy, scipy, pandas,
    matplotlib, seaborn, requests.
        Make sure to do this tutorial in a Jupyter notebook so that you get
    the inline plots and easy documentation lookup. The shell command to open 
    one is simply `jupyter notebook`, then click New -> Python.
""""""

# 1. Data acquisition ====

"""""" One reason people choose Python over R is that they intend to interact a lot
    with the web, either by scraping pages directly or requesting data through
    an API. You can do those things in R, but in the context of a project
    already using Python, there's a benefit to sticking with one language.
""""""

import requests  # for HTTP requests (web scraping, APIs)
import os

# web scraping
r = requests.get(""https://github.com/adambard/learnxinyminutes-docs"")
r.status_code  # if 200, request was successful
r.text  # raw page source
print(r.text)  # prettily formatted
# save the page source in a file:
os.getcwd()  # check what's the working directory
with open(""learnxinyminutes.html"", ""wb"") as f:
    f.write(r.text.encode(""UTF-8""))

# downloading a csv
fp = ""https://raw.githubusercontent.com/adambard/learnxinyminutes-docs/master/""
fn = ""pets.csv""
r = requests.get(fp + fn)
print(r.text)
with open(fn, ""wb"") as f:
    f.write(r.text.encode(""UTF-8""))

"""""" for more on the requests module, including APIs, see
    http://docs.python-requests.org/en/latest/user/quickstart/
""""""

# 2. Reading a CSV file ====

"""""" Wes McKinney's pandas package gives you 'DataFrame' objects in Python. If
    you've used R, you will be familiar with the idea of the ""data.frame"" already.
""""""

import pandas as pd
import numpy as np
import scipy as sp
pets = pd.read_csv(fn)
pets
#        name  age  weight species
# 0    fluffy    3      14     cat
# 1  vesuvius    6      23    fish
# 2       rex    5      34     dog

"""""" R users: note that Python, like most C-influenced programming languages, starts
    indexing from 0. R starts indexing at 1 due to Fortran influence.
""""""

# two different ways to print out a column
pets.age
pets[""age""]

pets.head(2)  # prints first 2 rows
pets.tail(1)  # prints last row

pets.name[1]  # 'vesuvius'
pets.species[0]  # 'cat'
pets[""weight""][2]  # 34

# in R, you would expect to get 3 rows doing this, but here you get 2:
pets.age[0:2]
# 0    3
# 1    6

sum(pets.age) * 2  # 28
max(pets.weight) - min(pets.weight)  # 20

"""""" If you are doing some serious linear algebra and number-crunching, you may
    just want arrays, not DataFrames. DataFrames are ideal for combining columns
    of different types.
""""""

# 3. Charts ====

import matplotlib as mpl
import matplotlib.pyplot as plt
%matplotlib inline

# To do data visualization in Python, use matplotlib

plt.hist(pets.age);

plt.boxplot(pets.weight);

plt.scatter(pets.age, pets.weight)
plt.xlabel(""age"")
plt.ylabel(""weight"");

# seaborn sits atop matplotlib and makes plots prettier

import seaborn as sns

plt.scatter(pets.age, pets.weight)
plt.xlabel(""age"")
plt.ylabel(""weight"");

# there are also some seaborn-specific plotting functions
# notice how seaborn automatically labels the x-axis on this barplot
sns.barplot(pets[""age""])

# R veterans can still use ggplot
from ggplot import *
ggplot(aes(x=""age"",y=""weight""), data=pets) + geom_point() + labs(title=""pets"")
# source: https://pypi.python.org/pypi/ggplot

# there's even a d3.js port: https://github.com/mikedewar/d3py

# 4. Simple data cleaning and exploratory analysis ====

"""""" Here's a more complicated example that demonstrates a basic data
    cleaning workflow leading to the creation of some exploratory plots
    and the running of a linear regression.
        The data set was transcribed from Wikipedia by hand. It contains
    all the Holy Roman Emperors and the important milestones in their lives
    (birth, death, coronation, etc.).
        The goal of the analysis will be to explore whether a relationship
    exists between emperor birth year and emperor lifespan.
    data source: https://en.wikipedia.org/wiki/Holy_Roman_Emperor
""""""

# load some data on Holy Roman Emperors
url = ""https://raw.githubusercontent.com/adambard/learnxinyminutes-docs/master/hre.csv""
r = requests.get(url)
fp = ""hre.csv""
with open(fp, ""wb"") as f:
    f.write(r.text.encode(""UTF-8""))

hre = pd.read_csv(fp)

hre.head()
""""""
   Ix      Dynasty        Name        Birth             Death
0 NaN  Carolingian   Charles I  2 April 742    28 January 814
1 NaN  Carolingian     Louis I          778       20 June 840
2 NaN  Carolingian   Lothair I          795  29 September 855
3 NaN  Carolingian    Louis II          825     12 August 875
4 NaN  Carolingian  Charles II  13 June 823     6 October 877

       Coronation 1   Coronation 2 Ceased to be Emperor
0   25 December 800            NaN       28 January 814
1  11 September 813  5 October 816          20 June 840
2       5 April 823            NaN     29 September 855
3        Easter 850     18 May 872        12 August 875
4   29 December 875            NaN        6 October 877
""""""

# clean the Birth and Death columns

import re  # module for regular expressions

rx = re.compile(r'\d+$')  # match trailing digits

"""""" This function applies the regular expression to an input column (here Birth,
    Death), flattens the resulting list, converts it to a Series object, and
    finally converts the type of the Series object from string to integer. For
    more information into what different parts of the code do, see:
      - https://docs.python.org/2/howto/regex.html
      - http://stackoverflow.com/questions/11860476/how-to-unlist-a-python-list
      - http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.html
""""""

from functools import reduce

def extractYear(v):
    return(pd.Series(reduce(lambda x, y: x + y, map(rx.findall, v), [])).astype(int))

hre[""BirthY""] = extractYear(hre.Birth)
hre[""DeathY""] = extractYear(hre.Death)

# make a column telling estimated age
hre[""EstAge""] = hre.DeathY.astype(int) - hre.BirthY.astype(int)

# simple scatterplot, no trend line, color represents dynasty
sns.lmplot(""BirthY"", ""EstAge"", data=hre, hue=""Dynasty"", fit_reg=False)

# use scipy to run a linear regression
from scipy import stats
(slope, intercept, rval, pval, stderr) = stats.linregress(hre.BirthY, hre.EstAge)
# code source: http://wiki.scipy.org/Cookbook/LinearRegression

# check the slope
slope  # 0.0057672618839073328

# check the R^2 value:
rval**2  # 0.020363950027333586

# check the p-value
pval  # 0.34971812581498452

# use seaborn to make a scatterplot and plot the linear regression trend line
sns.lmplot(""BirthY"", ""EstAge"", data=hre)

"""""" For more information on seaborn, see
      - http://web.stanford.edu/~mwaskom/software/seaborn/
      - https://github.com/mwaskom/seaborn
    For more information on SciPy, see
      - http://wiki.scipy.org/SciPy
      - http://wiki.scipy.org/Cookbook/
    To see a version of the Holy Roman Emperors analysis using R, see
      - http://github.com/e99n09/R-notes/blob/master/holy_roman_emperors_dates.R
""""""

```

If you want to learn more, get _Python for Data Analysis_ by Wes McKinney. It's a superb resource and I used it as a reference when writing this tutorial.

You can also find plenty of interactive IPython tutorials on subjects specific to your interests, like Cam Davidson-Pilon's <a href=""http://camdavidsonpilon.github.io/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/"" Title=""Probabilistic Programming and Bayesian Methods for Hackers"">Probabilistic Programming and Bayesian Methods for Hackers</a>.

Some more modules to research:
   - text analysis and natural language processing: nltk, http://www.nltk.org
   - social network analysis: igraph, http://igraph.org/python/"
"R is a statistical computing language. It has lots of libraries for uploading and cleaning data sets, running statistical procedures, and making graphs. You can also run `R` commands within a LaTeX document.

```r

# Comments start with hash signs, also known as number symbols (#).

# You can't make multi-line comments,
# but you can stack multiple comments like so.

# in Windows you can use CTRL-ENTER to execute a line.
# on Mac it is COMMAND-ENTER



#############################################################################
# Stuff you can do without understanding anything about programming
#############################################################################

# In this section, we show off some of the cool stuff you can do in
# R without understanding anything about programming. Do not worry
# about understanding everything the code does. Just enjoy!

data()          # browse pre-loaded data sets
data(rivers)    # get this one: ""Lengths of Major North American Rivers""
ls()            # notice that ""rivers"" now appears in the workspace
head(rivers)    # peek at the data set
# 735 320 325 392 524 450

length(rivers)  # how many rivers were measured?
# 141
summary(rivers) # what are some summary statistics?
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
#  135.0   310.0   425.0   591.2   680.0  3710.0

# make a stem-and-leaf plot (a histogram-like data visualization)
stem(rivers)

#  The decimal point is 2 digit(s) to the right of the |
#
#   0 | 4
#   2 | 011223334555566667778888899900001111223333344455555666688888999
#   4 | 111222333445566779001233344567
#   6 | 000112233578012234468
#   8 | 045790018
#  10 | 04507
#  12 | 1471
#  14 | 56
#  16 | 7
#  18 | 9
#  20 |
#  22 | 25
#  24 | 3
#  26 |
#  28 |
#  30 |
#  32 |
#  34 |
#  36 | 1

stem(log(rivers)) # Notice that the data are neither normal nor log-normal!
# Take that, Bell curve fundamentalists.

#  The decimal point is 1 digit(s) to the left of the |
#
#  48 | 1
#  50 |
#  52 | 15578
#  54 | 44571222466689
#  56 | 023334677000124455789
#  58 | 00122366666999933445777
#  60 | 122445567800133459
#  62 | 112666799035
#  64 | 00011334581257889
#  66 | 003683579
#  68 | 0019156
#  70 | 079357
#  72 | 89
#  74 | 84
#  76 | 56
#  78 | 4
#  80 |
#  82 | 2

# make a histogram:
hist(rivers, col = ""#333333"", border = ""white"", breaks = 25)
hist(log(rivers), col = ""#333333"", border = ""white"", breaks = 25)
# play around with these parameters, you'll do more plotting later

# Here's another neat data set that comes pre-loaded. R has tons of these.
data(discoveries)
plot(discoveries, col = ""#333333"", lwd = 3, xlab = ""Year"",
     main=""Number of important discoveries per year"")
plot(discoveries, col = ""#333333"", lwd = 3, type = ""h"", xlab = ""Year"",
     main=""Number of important discoveries per year"")

# Rather than leaving the default ordering (by year),
# we could also sort to see what's typical:
sort(discoveries)
#  [1]  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  1  1  1  2  2  2  2
# [26]  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  3  3  3
# [51]  3  3  3  3  3  3  3  3  3  3  3  3  3  3  3  3  3  4  4  4  4  4  4  4  4
# [76]  4  4  4  4  5  5  5  5  5  5  5  6  6  6  6  6  6  7  7  7  7  8  9 10 12

stem(discoveries, scale = 2)
#
#  The decimal point is at the |
#
#   0 | 000000000
#   1 | 000000000000
#   2 | 00000000000000000000000000
#   3 | 00000000000000000000
#   4 | 000000000000
#   5 | 0000000
#   6 | 000000
#   7 | 0000
#   8 | 0
#   9 | 0
#  10 | 0
#  11 |
#  12 | 0

max(discoveries)
# 12
summary(discoveries)
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
#    0.0     2.0     3.0     3.1     4.0    12.0

# Roll a die a few times
round(runif(7, min = .5, max = 6.5))
# 1 4 6 1 4 6 4
# Your numbers will differ from mine unless we set the same random.seed(31337)

# Draw from a standard Gaussian 9 times
rnorm(9)
# [1]  0.07528471  1.03499859  1.34809556 -0.82356087  0.61638975 -1.88757271
# [7] -0.59975593  0.57629164  1.08455362



##################################################
# Data types and basic arithmetic
##################################################

# Now for the programming-oriented part of the tutorial.
# In this section you will meet the important data types of R:
# integers, numerics, characters, logicals, and factors.
# There are others, but these are the bare minimum you need to
# get started.

# INTEGERS
# Long-storage integers are written with L
5L          # 5
class(5L)   # ""integer""
# (Try ?class for more information on the class() function.)
# In R, every single value, like 5L, is considered a vector of length 1
length(5L)  # 1
# You can have an integer vector with length > 1 too:
c(4L, 5L, 8L, 3L)          # 4 5 8 3
length(c(4L, 5L, 8L, 3L))  # 4
class(c(4L, 5L, 8L, 3L))   # ""integer""

# NUMERICS
# A ""numeric"" is a double-precision floating-point number
5           # 5
class(5)    # ""numeric""
# Again, everything in R is a vector;
# you can make a numeric vector with more than one element
c(3, 3, 3, 2, 2, 1) # 3 3 3 2 2 1
# You can use scientific notation too
5e4         # 50000
6.02e23     # Avogadro's number
1.6e-35     # Planck length
# You can also have infinitely large or small numbers
class(Inf)  # ""numeric""
class(-Inf) # ""numeric""
# You might use ""Inf"", for example, in integrate(dnorm, 3, Inf);
# this obviates Z-score tables.

# BASIC ARITHMETIC
# You can do arithmetic with numbers
# Doing arithmetic on a mix of integers and numerics gives you another numeric
10L + 66L   # 76    # integer plus integer gives integer
53.2 - 4    # 49.2  # numeric minus numeric gives numeric
2.0 * 2L    # 4     # numeric times integer gives numeric
3L / 4      # 0.75  # integer over numeric gives numeric
3 %% 2      # 1     # the remainder of two numerics is another numeric
# Illegal arithmetic yields you a ""not-a-number"":
0 / 0       # NaN
class(NaN)  # ""numeric""
# You can do arithmetic on two vectors with length greater than 1,
# so long as the larger vector's length is an integer multiple of the smaller
c(1, 2, 3) + c(1, 2, 3)     # 2 4 6
# Since a single number is a vector of length one, scalars are applied 
# elementwise to vectors
(4 * c(1, 2, 3) - 2) / 2    # 1 3 5
# Except for scalars, use caution when performing arithmetic on vectors with 
# different lengths. Although it can be done, 
c(1, 2, 3, 1, 2, 3) * c(1, 2)               # 1 4 3 2 2 6
# Matching lengths is better practice and easier to read most times
c(1, 2, 3, 1, 2, 3) * c(1, 2, 1, 2, 1, 2)   # 1 4 3 2 2 6

# CHARACTERS
# There's no difference between strings and characters in R
""Horatio""           # ""Horatio""
class(""Horatio"")    # ""character""
class(""H"")          # ""character""
# Those were both character vectors of length 1
# Here is a longer one:
c(""alef"", ""bet"", ""gimmel"", ""dalet"", ""he"")
# => ""alef""   ""bet""    ""gimmel"" ""dalet""  ""he""
length(c(""Call"",""me"",""Ishmael"")) # 3
# You can do regex operations on character vectors:
substr(""Fortuna multis dat nimis, nulli satis."", 9, 15)  # ""multis ""
gsub('u', 'ø', ""Fortuna multis dat nimis, nulli satis."") # ""Fortøna møltis dat nimis, nølli satis.""
# R has several built-in character vectors:
letters
# =>
#  [1] ""a"" ""b"" ""c"" ""d"" ""e"" ""f"" ""g"" ""h"" ""i"" ""j"" ""k"" ""l"" ""m"" ""n"" ""o"" ""p"" ""q"" ""r"" ""s""
# [20] ""t"" ""u"" ""v"" ""w"" ""x"" ""y"" ""z""
month.abb # ""Jan"" ""Feb"" ""Mar"" ""Apr"" ""May"" ""Jun"" ""Jul"" ""Aug"" ""Sep"" ""Oct"" ""Nov"" ""Dec""

# LOGICALS
# In R, a ""logical"" is a boolean
                
class(TRUE)     # ""logical""
class(FALSE)    # ""logical""
# Their behavior is normal
TRUE == TRUE    # TRUE
TRUE == FALSE   # FALSE
FALSE != FALSE  # FALSE
FALSE != TRUE   # TRUE
# Missing data (NA) is logical, too
class(NA)       # ""logical""
# Use | and & for logic operations.
# OR
TRUE | FALSE    # TRUE
# AND
TRUE & FALSE    # FALSE
# Applying | and & to vectors returns elementwise logic operations
c(TRUE, FALSE, FALSE) | c(FALSE, TRUE, FALSE)   # TRUE TRUE FALSE
c(TRUE, FALSE, TRUE) & c(FALSE, TRUE, TRUE)     # FALSE FALSE TRUE
# You can test if x is TRUE
isTRUE(TRUE)    # TRUE
# Here we get a logical vector with many elements:
c(""Z"", ""o"", ""r"", ""r"", ""o"") == ""Zorro""   # FALSE FALSE FALSE FALSE FALSE
c(""Z"", ""o"", ""r"", ""r"", ""o"") == ""Z""       # TRUE FALSE FALSE FALSE FALSE

# FACTORS
# The factor class is for categorical data
# Factors can be ordered (like grade levels) or unordered (like colors)
factor(c(""blue"", ""blue"", ""green"", NA, ""blue""))
#  blue blue green   <NA>   blue
# Levels: blue green
# The ""levels"" are the values the categorical data can take
# Note that missing data does not enter the levels
levels(factor(c(""green"", ""green"", ""blue"", NA, ""blue""))) # ""blue"" ""green""
# If a factor vector has length 1, its levels will have length 1, too
length(factor(""green""))         # 1
length(levels(factor(""green""))) # 1
# Factors are commonly seen in data frames, a data structure we will cover later
data(infert)             # ""Infertility after Spontaneous and Induced Abortion""
levels(infert$education) # ""0-5yrs""  ""6-11yrs"" ""12+ yrs""

# NULL
# ""NULL"" is a weird one; use it to ""blank out"" a vector
class(NULL) # NULL
parakeet = c(""beak"", ""feathers"", ""wings"", ""eyes"")
parakeet # ""beak""     ""feathers"" ""wings""    ""eyes""
parakeet <- NULL
parakeet # NULL

# TYPE COERCION
# Type-coercion is when you force a value to take on a different type
as.character(c(6, 8))   # ""6"" ""8""
as.logical(c(1,0,1,1))  # TRUE FALSE  TRUE  TRUE
# If you put elements of different types into a vector, weird coercions happen:
c(TRUE, 4)          # 1 4
c(""dog"", TRUE, 4)   # ""dog""  ""TRUE"" ""4""
as.numeric(""Bilbo"")
# =>
# [1] NA
# Warning message:
# NAs introduced by coercion

# Also note: those were just the basic data types
# There are many more data types, such as for dates, time series, etc.



##################################################
# Variables, loops, if/else
##################################################

# A variable is like a box you store a value in for later use.
# We call this ""assigning"" the value to the variable.
# Having variables lets us write loops, functions, and if/else statements

# VARIABLES
# Lots of way to assign stuff:
x = 5       # this is possible
y <- ""1""    # this is preferred traditionally
TRUE -> z   # this works but is weird
# Refer to the Internet for the behaviors and preferences about them.

# LOOPS
# We've got for loops
for (i in 1:4) {
	print(i)
}
# We've got while loops
a <- 10
while (a > 4) {
	cat(a, ""..."", sep = """")
	a <- a - 1
}
# Keep in mind that for and while loops run slowly in R
# Operations on entire vectors (i.e. a whole row, a whole column)
# or apply()-type functions (we'll discuss later) are preferred

# IF/ELSE
# Again, pretty standard
if (4 > 3) {
	print(""4 is greater than 3"")
} else {
	print(""4 is not greater than 3"")
}
# =>
# [1] ""4 is greater than 3""

# FUNCTIONS
# Defined like so:
jiggle <- function(x) {
	x = x + rnorm(1, sd=.1) # add in a bit of (controlled) noise
	return(x)
}
# Called like any other R function:
jiggle(5)   # 5±ε. After set.seed(2716057), jiggle(5)==5.005043



###########################################################################
# Data structures: Vectors, matrices, data frames, and arrays
###########################################################################

# ONE-DIMENSIONAL

# Let's start from the very beginning, and with something you already know: vectors.
vec <- c(8, 9, 10, 11)
vec     #  8  9 10 11
# We ask for specific elements by subsetting with square brackets
# (Note that R starts counting from 1)
vec[1]          # 8
letters[18]     # ""r""
LETTERS[13]     # ""M""
month.name[9]   # ""September""
c(6, 8, 7, 5, 3, 0, 9)[3] # 7
# We can also search for the indices of specific components,
which(vec %% 2 == 0) # 1 3
# grab just the first or last few entries in the vector,
head(vec, 1)    # 8
tail(vec, 2)    # 10 11
# or figure out if a certain value is in the vector
any(vec == 10)  # TRUE
# If an index ""goes over"" you'll get NA:
vec[6]      # NA
# You can find the length of your vector with length()
length(vec) # 4
# You can perform operations on entire vectors or subsets of vectors
vec * 4             # 32 36 40 44
vec[2:3] * 5        # 45 50
any(vec[2:3] == 8)  # FALSE
# and R has many built-in functions to summarize vectors
mean(vec)   # 9.5
var(vec)    # 1.666667
sd(vec)     # 1.290994
max(vec)    # 11
min(vec)    # 8
sum(vec)    # 38
# Some more nice built-ins:
5:15        # 5  6  7  8  9 10 11 12 13 14 15
seq(from = 0, to = 31337, by = 1337)
# =>
#  [1]     0  1337  2674  4011  5348  6685  8022  9359 10696 12033 13370 14707
# [13] 16044 17381 18718 20055 21392 22729 24066 25403 26740 28077 29414 30751

# TWO-DIMENSIONAL (ALL ONE CLASS)

# You can make a matrix out of entries all of the same type like so:
mat <- matrix(nrow = 3, ncol = 2, c(1, 2, 3, 4, 5, 6))
mat
# =>
#      [,1] [,2]
# [1,]    1    4
# [2,]    2    5
# [3,]    3    6
# Unlike a vector, the class of a matrix is ""matrix"", no matter what's in it
class(mat)      # ""matrix"" ""array""
# Ask for the first row
mat[1, ]        # 1 4
# Perform operation on the first column
3 * mat[, 1]    # 3 6 9
# Ask for a specific cell
mat[3, 2]       # 6

# Transpose the whole matrix
t(mat)
# =>
#      [,1] [,2] [,3]
# [1,]    1    2    3
# [2,]    4    5    6

# Matrix multiplication
mat %*% t(mat)
# =>
#      [,1] [,2] [,3]
# [1,]   17   22   27
# [2,]   22   29   36
# [3,]   27   36   45

# cbind() sticks vectors together column-wise to make a matrix
mat2 <- cbind(1:4, c(""dog"", ""cat"", ""bird"", ""dog""))
mat2
# =>
#      [,1] [,2]
# [1,] ""1""  ""dog""
# [2,] ""2""  ""cat""
# [3,] ""3""  ""bird""
# [4,] ""4""  ""dog""
class(mat2) # matrix
# Again, note what happened!
# Because matrices must contain entries all of the same class,
# everything got converted to the character class
c(class(mat2[, 1]), class(mat2[, 2]))

# rbind() sticks vectors together row-wise to make a matrix
mat3 <- rbind(c(1, 2, 4, 5), c(6, 7, 0, 4))
mat3
# =>
#      [,1] [,2] [,3] [,4]
# [1,]    1    2    4    5
# [2,]    6    7    0    4
# Ah, everything of the same class. No coercions. Much better.

# TWO-DIMENSIONAL (DIFFERENT CLASSES)

# For columns of different types, use a data frame
# This data structure is so useful for statistical programming,
# a version of it was added to Python in the package ""pandas"".

students <- data.frame(c(""Cedric"", ""Fred"", ""George"", ""Cho"", ""Draco"", ""Ginny""),
                       c(       3,      2,        2,     1,       0,      -1),
                       c(     ""H"",    ""G"",      ""G"",   ""R"",     ""S"",     ""G""))
names(students) <- c(""name"", ""year"", ""house"") # name the columns
class(students) # ""data.frame""
students
# =>
#     name year house
# 1 Cedric    3     H
# 2   Fred    2     G
# 3 George    2     G
# 4    Cho    1     R
# 5  Draco    0     S
# 6  Ginny   -1     G
class(students$year)    # ""numeric""
class(students[,3])     # ""factor""
# find the dimensions
nrow(students)  # 6
ncol(students)  # 3
dim(students)   # 6 3
# The data.frame() function used to convert character vectors to factor
# vectors by default; This has changed in R 4.0.0. If your R version is
# older, turn this off by setting stringsAsFactors = FALSE when you
# create the data.frame
?data.frame

# There are many twisty ways to subset data frames, all subtly unalike
students$year       # 3  2  2  1  0 -1
students[, 2]       # 3  2  2  1  0 -1
students[, ""year""]  # 3  2  2  1  0 -1

# An augmented version of the data.frame structure is the data.table
# If you're working with huge or panel data, or need to merge a few data
# sets, data.table can be a good choice. Here's a whirlwind tour:
install.packages(""data.table"") # download the package from CRAN
require(data.table) # load it
students <- as.data.table(students)
students # note the slightly different print-out
# =>
#      name year house
# 1: Cedric    3     H
# 2:   Fred    2     G
# 3: George    2     G
# 4:    Cho    1     R
# 5:  Draco    0     S
# 6:  Ginny   -1     G
students[name == ""Ginny""] # get rows with name == ""Ginny""
# =>
#     name year house
# 1: Ginny   -1     G
students[year == 2] # get rows with year == 2
# =>
#      name year house
# 1:   Fred    2     G
# 2: George    2     G
# data.table makes merging two data sets easy
# let's make another data.table to merge with students
founders <- data.table(house   = c(""G""     , ""H""    , ""R""     , ""S""),
                       founder = c(""Godric"", ""Helga"", ""Rowena"", ""Salazar""))
founders
# =>
#    house founder
# 1:     G  Godric
# 2:     H   Helga
# 3:     R  Rowena
# 4:     S Salazar
setkey(students, house)
setkey(founders, house)
students <- founders[students] # merge the two data sets by matching ""house""
setnames(students, c(""house"", ""houseFounderName"", ""studentName"", ""year""))
students[, order(c(""name"", ""year"", ""house"", ""houseFounderName"")), with = F]
# =>
#    studentName year house houseFounderName
# 1:        Fred    2     G           Godric
# 2:      George    2     G           Godric
# 3:       Ginny   -1     G           Godric
# 4:      Cedric    3     H            Helga
# 5:         Cho    1     R           Rowena
# 6:       Draco    0     S          Salazar

# data.table makes summary tables easy
students[, sum(year), by = house]
# =>
#    house V1
# 1:     G  3
# 2:     H  3
# 3:     R  1
# 4:     S  0

# To drop a column from a data.frame or data.table,
# assign it the NULL value
students$houseFounderName <- NULL
students
# =>
#    studentName year house
# 1:        Fred    2     G
# 2:      George    2     G
# 3:       Ginny   -1     G
# 4:      Cedric    3     H
# 5:         Cho    1     R
# 6:       Draco    0     S

# Drop a row by subsetting
# Using data.table:
students[studentName != ""Draco""]
# =>
#    house studentName year
# 1:     G        Fred    2
# 2:     G      George    2
# 3:     G       Ginny   -1
# 4:     H      Cedric    3
# 5:     R         Cho    1
# Using data.frame:
students <- as.data.frame(students)
students[students$house != ""G"", ]
# =>
#   house houseFounderName studentName year
# 4     H            Helga      Cedric    3
# 5     R           Rowena         Cho    1
# 6     S          Salazar       Draco    0

# MULTI-DIMENSIONAL (ALL ELEMENTS OF ONE TYPE)

# Arrays creates n-dimensional tables
# All elements must be of the same type
# You can make a two-dimensional table (sort of like a matrix)
array(c(c(1, 2, 4, 5), c(8, 9, 3, 6)), dim = c(2, 4))
# =>
#      [,1] [,2] [,3] [,4]
# [1,]    1    4    8    3
# [2,]    2    5    9    6
# You can use array to make three-dimensional matrices too
array(c(c(c(2, 300, 4), c(8, 9, 0)), c(c(5, 60, 0), c(66, 7, 847))), dim = c(3, 2, 2))
# =>
# , , 1
#
#      [,1] [,2]
# [1,]    2    8
# [2,]  300    9
# [3,]    4    0
#
# , , 2
#
#      [,1] [,2]
# [1,]    5   66
# [2,]   60    7
# [3,]    0  847

# LISTS (MULTI-DIMENSIONAL, POSSIBLY RAGGED, OF DIFFERENT TYPES)

# Finally, R has lists (of vectors)
list1 <- list(time = 1:40)
list1$price = c(rnorm(40, .5*list1$time, 4)) # random
list1
# You can get items in the list like so
list1$time # one way
list1[[""time""]] # another way
list1[[1]] # yet another way
# =>
#  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33
# [34] 34 35 36 37 38 39 40
# You can subset list items like any other vector
list1$price[4]

# Lists are not the most efficient data structure to work with in R;
# unless you have a very good reason, you should stick to data.frames
# Lists are often returned by functions that perform linear regressions

##################################################
# The apply() family of functions
##################################################

# Remember mat?
mat
# =>
#      [,1] [,2]
# [1,]    1    4
# [2,]    2    5
# [3,]    3    6
# Use apply(X, MARGIN, FUN) to apply function FUN to a matrix X
# over rows (MAR = 1) or columns (MAR = 2)
# That is, R does FUN to each row (or column) of X, much faster than a
# for or while loop would do
apply(mat, MAR = 2, jiggle)
# =>
#      [,1] [,2]
# [1,]    3   15
# [2,]    7   19
# [3,]   11   23
# Other functions: ?lapply, ?sapply

# Don't feel too intimidated; everyone agrees they are rather confusing

# The plyr package aims to replace (and improve upon!) the *apply() family.
install.packages(""plyr"")
require(plyr)
?plyr



#########################
# Loading data
#########################

# ""pets.csv"" is a file on the internet
# (but it could just as easily be a file on your own computer)
require(RCurl)
pets <- read.csv(textConnection(getURL(""https://learnxinyminutes.com/docs/pets.csv"")))
pets
head(pets, 2) # first two rows
tail(pets, 1) # last row

# To save a data frame or matrix as a .csv file
write.csv(pets, ""pets2.csv"") # to make a new .csv file
# set working directory with setwd(), look it up with getwd()

# Try ?read.csv and ?write.csv for more information



#########################
# Statistical Analysis
#########################

# Linear regression!
linearModel <- lm(price ~ time, data = list1)
linearModel # outputs result of regression
# =>
# Call:
# lm(formula = price ~ time, data = list1)
# 
# Coefficients:
# (Intercept)         time  
#      0.1453       0.4943  
summary(linearModel) # more verbose output from the regression
# =>
# Call:
# lm(formula = price ~ time, data = list1)
#
# Residuals:
#     Min      1Q  Median      3Q     Max 
# -8.3134 -3.0131 -0.3606  2.8016 10.3992 
#
# Coefficients:
#             Estimate Std. Error t value Pr(>|t|)    
# (Intercept)  0.14527    1.50084   0.097    0.923    
# time         0.49435    0.06379   7.749 2.44e-09 ***
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
# Residual standard error: 4.657 on 38 degrees of freedom
# Multiple R-squared:  0.6124,	Adjusted R-squared:  0.6022 
# F-statistic: 60.05 on 1 and 38 DF,  p-value: 2.44e-09
coef(linearModel) # extract estimated parameters
# =>
# (Intercept)        time 
#   0.1452662   0.4943490 
summary(linearModel)$coefficients # another way to extract results
# =>
#              Estimate Std. Error    t value     Pr(>|t|)
# (Intercept) 0.1452662 1.50084246 0.09678975 9.234021e-01
# time        0.4943490 0.06379348 7.74920901 2.440008e-09
summary(linearModel)$coefficients[, 4] # the p-values 
# =>
#  (Intercept)         time 
# 9.234021e-01 2.440008e-09 

# GENERAL LINEAR MODELS
# Logistic regression
set.seed(1)
list1$success = rbinom(length(list1$time), 1, .5) # random binary
glModel <- glm(success  ~ time, data = list1, family=binomial(link=""logit""))
glModel # outputs result of logistic regression
# =>
# Call:  glm(formula = success ~ time, 
#	family = binomial(link = ""logit""), data = list1)
#
# Coefficients:
# (Intercept)         time  
#     0.17018     -0.01321  
# 
# Degrees of Freedom: 39 Total (i.e. Null);  38 Residual
# Null Deviance:	    55.35 
# Residual Deviance: 55.12 	 AIC: 59.12
summary(glModel) # more verbose output from the regression
# =>
# Call:
# glm(
#	formula = success ~ time,
#	family = binomial(link = ""logit""),
#	data = list1)

# Deviance Residuals: 
#    Min      1Q  Median      3Q     Max  
# -1.245  -1.118  -1.035   1.202   1.327  
# 
# Coefficients:
#             Estimate Std. Error z value Pr(>|z|)
# (Intercept)  0.17018    0.64621   0.263    0.792
# time        -0.01321    0.02757  -0.479    0.632
# 
# (Dispersion parameter for binomial family taken to be 1)
#
#     Null deviance: 55.352  on 39  degrees of freedom
# Residual deviance: 55.121  on 38  degrees of freedom
# AIC: 59.121
# 
# Number of Fisher Scoring iterations: 3


#########################
# Plots
#########################

# BUILT-IN PLOTTING FUNCTIONS
# Scatterplots!
plot(list1$time, list1$price, main = ""fake data"")
# Plot regression line on existing plot
abline(linearModel, col = ""red"")
# Get a variety of nice diagnostics
plot(linearModel)
# Histograms!
hist(rpois(n = 10000, lambda = 5), col = ""thistle"")
# Barplots!
barplot(c(1, 4, 5, 1, 2), names.arg = c(""red"", ""blue"", ""purple"", ""green"", ""yellow""))

# GGPLOT2
# But these are not even the prettiest of R's plots
# Try the ggplot2 package for more and better graphics
install.packages(""ggplot2"")
require(ggplot2)
?ggplot2
pp <- ggplot(students, aes(x = house))
pp + geom_bar()
ll <- as.data.table(list1)
pp <- ggplot(ll, aes(x = time, price))
pp + geom_point()
# ggplot2 has excellent documentation (available http://docs.ggplot2.org/current/)



```

## How do I get R?

* Get R and the R GUI from [http://www.r-project.org/](http://www.r-project.org/)
* [RStudio](http://www.rstudio.com/ide/) is another GUI"
"M, or MUMPS (Massachusetts General Hospital Utility Multi-Programming System) is
a procedural language with a built-in NoSQL database. Or, it’s a database with
an integrated language optimized for accessing and manipulating that database.
A key feature of M is that accessing local variables in memory and persistent
storage use the same basic syntax, so there's no separate query
language to remember. This makes it fast to program with, especially for
beginners. M's syntax was designed to be concise in an era where
computer memory was expensive and limited. This concise style means that a lot
more fits on one screen without scrolling.

The M database is a hierarchical key-value store designed for high-throughput
transaction processing. The database is organized into tree structures called
""globals"", which are sparse data structures with parallels to modern formats
like JSON.

Originally designed in 1966 for the healthcare applications, M continues to be
used widely by healthcare systems and financial institutions for high-throughput
real-time applications. 

### Example

Here's an example M program to calculate the Fibonacci series:

```
fib ; compute the first few Fibonacci terms
    new i,a,b,sum
    set (a,b)=1 ; Initial conditions
    for i=1:1 do  quit:sum>1000
    . set sum=a+b
    . write !,sum
    . set a=b,b=sum
```

### Comments

```
;   Comments start with a semicolon (;)
```
### Data Types

M has two data types:

```
;   Numbers - no commas, leading and trailing 0 removed.
;       Scientific notation with 'E'.
;       Floats with IEEE 754 double-precision values (15 digits of precision)
;       Examples: 20, 1e3 (stored as 1000), 0500.20 (stored as 500.2)
;   Strings - Characters enclosed in double quotes.
;       """" is the null string. Use """" within a string for ""
;       Examples: ""hello"", ""Scrooge said, """"Bah, Humbug!""""""
```
### Commands

Commands are case insensitive, and have a shortened abbreviation, often the first letter. Commands have zero or more arguments,depending on the command. M is whitespace-aware. Spaces are treated as a delimiter between commands and arguments. Each command is separated from its arguments by 1 space. Commands with zero arguments are followed by 2 spaces.

#### W(rite)

Print data to the current device.

``` 
WRITE !,""hello world"" 
```

! is syntax for a new line. Multiple statements can be provided as additional arguments:

```
w !,""foo bar"","" "",""baz"" 
```

#### R(ead)

Retrieve input from the user

```
READ var
r !,""Wherefore art thou Romeo? "",why
```
Multiple arguments can be passed to a read command. Constants are outputted. Variables are retrieved from the user. The terminal waits for the user to enter the first variable before displaying the second prompt.

```
r !,""Better one, or two? "",lorem,"" Better two, or three? "",ipsum
```

#### S(et)

Assign a value to a variable

```
SET name=""Benjamin Franklin""
s centi=0.01,micro=10E-6
w !,centi,!,micro

;.01
;.00001
```
#### K(ill)

Remove a variable from memory or remove a database entry from disk.

```
KILL centi
k micro
```
### Globals and Arrays

In addition to local variables, M has persistent variables stored to disk called _globals_. Global names must start with a __caret__ (__^__). Globals are the built-in database of M.

Any variable can be an array with the assignment of a _subscript_. Arrays are sparse and do not have a predefined size. Arrays should be visualized like trees, where subscripts are branches and assigned values are leaves. Not all nodes in an array need to have a value. 

```
s ^cars=20
s ^cars(""Tesla"",1,""Name"")=""Model 3""
s ^cars(""Tesla"",2,""Name"")=""Model X""
s ^cars(""Tesla"",2,""Doors"")=5

w !,^cars 
; 20
w !,^cars(""Tesla"")
; null value - there's no value assigned to this node but it has children
w !,^cars(""Tesla"",1,""Name"")
; Model 3
```

Arrays are automatically sorted in order. Take advantage of the built-in sorting by setting your value of interest as the last child subscript of an array rather than its value.

```
; A log of temperatures by date and time
s ^TEMPS(""11/12"",""0600"",32)=""""
s ^TEMPS(""11/12"",""1030"",48)=""""
s ^TEMPS(""11/12"",""1400"",49)=""""
s ^TEMPS(""11/12"",""1700"",43)=""""
```
### Operators
```jinja
; Assignment:       =
; Unary:            +   Convert a string value into a numeric value.
; Arthmetic:
;                   +   addition
­;                   -   subtraction
;                   *   multiplication
;                   /   floating-point division
;                   \   integer division
;                   #   modulo
;                   **  exponentiation
; Logical:  
;                   &   and
;                   !   or
;                   '   not
; Comparison:
;                   =   equal 
;                   '=  not equal
;                   >   greater than
;                   <   less than
;                   '>  not greater / less than or equal to
;                   '<  not less / greater than or equal to
; String operators:
;                   _   concatenate
;                   [   contains ­          a contains b 
;                   ]]  sorts after  ­      a comes after b
;                   '[  does not contain
;                   ']] does not sort after
```

#### Order of operations

Operations in M are _strictly_ evaluated left to right. No operator has precedence over any other.
You should use parentheses to group expressions.

```
w 5+3*20
;160
;You probably wanted 65
w 5+(3*20) 
```

### Flow Control, Blocks, & Code Structure

A single M file is called a _routine_. Within a given routine, you can break your code up into smaller chunks with _tags_. The tag starts in column 1 and the commands pertaining to that tag are indented.

A tag can accept parameters and return a value, this is a function. A function is called with '$$':

```
; Execute the 'tag' function, which has two parameters, and write the result.
w !,$$tag^routine(a,b) 
```

M has an execution stack. When all levels of the stack have returned, the program ends. Levels are added to the stack with _do_ commands and removed with _quit_ commands.

#### D(o)

With an argument: execute a block of code & add a level to the stack. 

```
d ^routine    ;run a routine from the beginning. 
;             ;routines are identified by a caret.
d tag         ;run a tag in the current routine
d tag^routine ;run a tag in different routine
```

Argumentless do: used to create blocks of code. The block is indented with a period for each level of the block:

```
set a=1
if a=1 do  
. write !,a
. read b
. if b > 10 d
. . w !, b 
w ""hello""
```

#### Q(uit)
Stop executing this block and return to the previous stack level.
Quit can return a value.

#### N(ew)
Clear a given variable's value _for just this stack level_. Useful for preventing side effects.

Putting all this together, we can create a full example of an M routine:

```
; RECTANGLE - a routine to deal with rectangle math
    q ; quit if a specific tag is not called

main 
    n length,width ; New length and width so any previous value doesn't persist
    w !,""Welcome to RECTANGLE. Enter the dimensions of your rectangle.""
    r !,""Length? "",length,!,""Width? "",width
    d area(length,width)            ;Do a tag
    s per=$$perimeter(length,width) ;Get the value of a function
    w !,""Perimeter: "",per
    q

area(length,width)  ; This is a tag that accepts parameters. 
                    ; It's not a function since it quits with no value.
    w !, ""Area: "",length*width
    q ; Quit: return to the previous level of the stack.

perimeter(length,width)
    q 2*(length+width) ; Quits with a value; thus a function
```

### Conditionals, Looping and $Order()

F(or) loops can follow a few different patterns:

```jinja
;Finite loop with counter
;f var=start:increment:stop

f i=0:5:25 w i,"" "" ;0 5 10 15 20 25 

; Infinite loop with counter
; The counter will keep incrementing forever. Use a conditional with Quit to get out of the loop.
;f var=start:increment 

f j=1:1 w j,"" "" i j>1E3 q ; Print 1-1000 separated by a space

;Argumentless for - infinite loop. Use a conditional with Quit.
;   Also read as ""forever"" - f or for followed by two spaces.
s var=""""
f  s var=var_""%"" w !,var i var=""%%%%%%%%%%"" q  
; %
; %%
; %%%
; %%%%
; %%%%%
; %%%%%%
; %%%%%%%
; %%%%%%%%
; %%%%%%%%%
; %%%%%%%%%%

```

#### I(f), E(lse), Postconditionals

M has an if/else construct for conditional evaluation, but any command can be conditionally executed without an extra if statement using a _postconditional_. This is a condition that occurs immediately after the command, separated with a colon (:).

```jinja
; Conditional using traditional if/else
r ""Enter a number: "",num
i num>100 w !,""huge""
e i num>10 w !,""big""
e w !,""small""

; Postconditionals are especially useful in a for loop.
; This is the dominant for loop construct:
;   a 'for' statement
;   that tests for a 'quit' condition with a postconditional
;   then 'do'es an indented block for each iteration

s var=""""
f  s var=var_""%"" q:var=""%%%%%%%%%%"" d  ;Read as ""Quit if var equals ""%%%%%%%%%%""
. w !,var

;Bonus points - the $L(ength) built-in function makes this even terser

s var=""""
f  s var=var_""%"" q:$L(var)>10  d  ;
. w !,var

```
#### Array Looping - $Order
As we saw in the previous example, M has built-in functions called with a single $, compared to user-defined functions called with $$. These functions have shortened abbreviations, like commands.
One of the most useful is __$Order()__ / $O(). When given an array subscript, $O returns the next subscript in that array. When it reaches the last subscript, it returns """".

```jinja
;Let's call back to our ^TEMPS global from earlier:
; A log of temperatures by date and time
s ^TEMPS(""11/12"",""0600"",32)=""""
s ^TEMPS(""11/12"",""0600"",48)=""""
s ^TEMPS(""11/12"",""1400"",49)=""""
s ^TEMPS(""11/12"",""1700"",43)=""""
; Some more
s ^TEMPS(""11/16"",""0300"",27)=""""
s ^TEMPS(""11/16"",""1130"",32)=""""
s ^TEMPS(""11/16"",""1300"",47)=""""

;Here's a loop to print out all the dates we have temperatures for:
n date,time ; Initialize these variables with """"

; This line reads: forever; set date as the next date in ^TEMPS.
; If date was set to """", it means we're at the end, so quit.
; Do the block below
f  s date=$ORDER(^TEMPS(date)) q:date="""" d
. w !,date

; Add in times too:
f  s date=$ORDER(^TEMPS(date)) q:date=""""  d
. w !,""Date: "",date
. f  s time=$O(^TEMPS(date,time)) q:time=""""  d
. . w !,""Time: "",time

; Build an index that sorts first by temperature - 
; what dates and times had a given temperature?
n date,time,temp
f  s date=$ORDER(^TEMPS(date)) q:date=""""  d
. f  s time=$O(^TEMPS(date,time)) q:time=""""  d
. . f  s temp=$O(^TEMPS(date,time,temp)) q:temp=""""  d
. . . s ^TEMPINDEX(temp,date,time)=""""

;This will produce a global like
^TEMPINDEX(27,""11/16"",""0300"")
^TEMPINDEX(32,""11/12"",""0600"")
^TEMPINDEX(32,""11/16"",""1130"")
```

## Further Reading

There's lots more to learn about M. A great short tutorial comes from the University of Northern Iowa and  Professor Kevin O'Kane's [Introduction to the MUMPS Language][1] presentation.

To install an M interpreter / database on your computer, try a [YottaDB Docker image][2]. 

YottaDB and its precursor, GT.M, have thorough documentation on all the language features including database transactions, locking, and replication:

* [YottaDB Programmer's Guide][3]
* [GT.M Programmer's Guide][4]

[1]: https://www.cs.uni.edu/~okane/source/MUMPS-MDH/MumpsTutorial.pdf 
[2]: https://yottadb.com/product/get-started/
[3]: https://docs.yottadb.com/ProgrammersGuide/langfeat.html
[4]: http://tinco.pair.com/bhaskar/gtm/doc/books/pg/UNIX_manual/index.html"
"A Makefile defines a graph of rules for creating a target (or targets).
Its purpose is to do the minimum amount of work needed to update a
target to the most recent version of the source. Famously written over a
weekend by Stuart Feldman in 1976, it is still widely used (particularly
on Unix and Linux) despite many competitors and criticisms.

There are many varieties of make in existence, however this article
assumes that we are using GNU make which is the standard on Linux.

```make

# Comments can be written like this.

# File should be named Makefile and then can be run as `make <target>`.
# Otherwise we use `make -f ""filename"" <target>`.

# Warning - only use TABS to indent in Makefiles, never spaces!

#-----------------------------------------------------------------------
# Basics
#-----------------------------------------------------------------------

# Rules are of the format
# target: <prerequisite>
# where prerequisites are optional.

# A rule - this rule will only run if file0.txt doesn't exist.
file0.txt:
	echo ""foo"" > file0.txt
	# Even comments in these 'recipe' sections get passed to the shell.
	# Try `make file0.txt` or simply `make` - first rule is the default.

# This rule will only run if file0.txt is newer than file1.txt.
file1.txt: file0.txt
	cat file0.txt > file1.txt
	# use the same quoting rules as in the shell.
	@cat file0.txt >> file1.txt
	# @ stops the command from being echoed to stdout.
	-@echo 'hello'
	# - means that make will keep going in the case of an error.
	# Try `make file1.txt` on the commandline.

# A rule can have multiple targets and multiple prerequisites
file2.txt file3.txt: file0.txt file1.txt
	touch file2.txt
	touch file3.txt

# Make will complain about multiple recipes for the same rule. Empty
# recipes don't count though and can be used to add new dependencies.

#-----------------------------------------------------------------------
# Phony Targets
#-----------------------------------------------------------------------

# A phony target. Any target that isn't a file.
# It will never be up to date so make will always try to run it.
all: maker process

# We can declare things out of order.
maker:
	touch ex0.txt ex1.txt

# Can avoid phony rules breaking when a real file has the same name by
.PHONY: all maker process
# This is a special target. There are several others.

# A rule with a dependency on a phony target will always run
ex0.txt ex1.txt: maker

# Common phony targets are: all make clean install ...

#-----------------------------------------------------------------------
# Automatic Variables & Wildcards
#-----------------------------------------------------------------------

process: file*.txt	#using a wildcard to match filenames
	@echo $^	# $^ is a variable containing the list of prerequisites
	@echo $@	# prints the target name
	#(for multiple target rules, $@ is whichever caused the rule to run)
	@echo $<	# the first prerequisite listed
	@echo $?	# only the dependencies that are out of date
	@echo $+	# all dependencies including duplicates (unlike normal)
	#@echo $|	# all of the 'order only' prerequisites

# Even if we split up the rule dependency definitions, $^ will find them
process: ex1.txt file0.txt
# ex1.txt will be found but file0.txt will be deduplicated.

#-----------------------------------------------------------------------
# Patterns
#-----------------------------------------------------------------------

# Can teach make how to convert certain files into other files.

%.png: %.svg
	inkscape --export-png $^

# Pattern rules will only do anything if make decides to create the
# target.

# Directory paths are normally ignored when matching pattern rules. But
# make will try to use the most appropriate rule available.
small/%.png: %.svg
	inkscape --export-png --export-dpi 30 $^

# make will use the last version for a pattern rule that it finds.
%.png: %.svg
	@echo this rule is chosen

# However make will use the first pattern rule that can make the target
%.png: %.ps
	@echo this rule is not chosen if *.svg and *.ps are both present

# make already has some pattern rules built-in. For instance, it knows
# how to turn *.c files into *.o files.

# Older makefiles might use suffix rules instead of pattern rules
.png.ps:
	@echo this rule is similar to a pattern rule.

# Tell make about the suffix rule
.SUFFIXES: .png

#-----------------------------------------------------------------------
# Variables
#-----------------------------------------------------------------------
# aka. macros

# Variables are basically all string types

name = Ted
name2=""Sarah""

echo:
	@echo $(name)
	@echo ${name2}
	@echo $name    # This won't work, treated as $(n)ame.
	@echo $(name3) # Unknown variables are treated as empty strings.

# There are 4 places to set variables.
# In order of priority from highest to lowest:
# 1: commandline arguments
# 2: Makefile
# 3: shell environment variables - make imports these automatically.
# 4: make has some predefined variables

name4 ?= Jean
# Only set the variable if environment variable is not already defined.

override name5 = David
# Stops commandline arguments from changing this variable.

name4 +=grey
# Append values to variable (includes a space).

# Pattern-specific variable values (GNU extension).
echo: name2 = Sara # True within the matching rule
	# and also within its remade recursive dependencies
	# (except it can break when your graph gets too complicated!)

# Some variables defined automatically by make.
echo_inbuilt:
	echo $(CC)
	echo ${CXX}
	echo $(FC)
	echo ${CFLAGS}
	echo $(CPPFLAGS)
	echo ${CXXFLAGS}
	echo $(LDFLAGS)
	echo ${LDLIBS}

#-----------------------------------------------------------------------
# Variables 2
#-----------------------------------------------------------------------

# The first type of variables are evaluated each time they are used.
# This can be expensive, so a second type of variable exists which is
# only evaluated once. (This is a GNU make extension)

var := hello
var2 ::=  $(var) hello
#:= and ::= are equivalent.

# These variables are evaluated procedurally (in the order that they
# appear), thus breaking with the rest of the language !

# This doesn't work
var3 ::= $(var4) and good luck
var4 ::= good night

#-----------------------------------------------------------------------
# Functions
#-----------------------------------------------------------------------

# make has lots of functions available.

sourcefiles = $(wildcard *.c */*.c)
objectfiles = $(patsubst %.c,%.o,$(sourcefiles))

# Format is $(func arg0,arg1,arg2...)

# Some examples
ls:	* src/*
	@echo $(filter %.txt, $^)
	@echo $(notdir $^)
	@echo $(join $(dir $^),$(notdir $^))

#-----------------------------------------------------------------------
# Directives
#-----------------------------------------------------------------------

# Include other makefiles, useful for platform specific code
include foo.mk

sport = tennis
# Conditional compilation
report:
ifeq ($(sport),tennis)
	@echo 'game, set, match'
else
	@echo ""They think it's all over; it is now""
endif

# There are also ifneq, ifdef, ifndef

foo = true

ifdef $(foo)
bar = 'hello'
endif
```

### More Resources

+ [gnu make documentation](https://www.gnu.org/software/make/manual/)
+ [software carpentry tutorial](http://swcarpentry.github.io/make-novice/)
+ learn C the hard way [ex2](http://c.learncodethehardway.org/book/ex2.html) [ex28](http://c.learncodethehardway.org/book/ex28.html)"
"## ShutIt

ShutIt is an shell automation framework designed to be easy to use.

It is a wrapper around a Python-based expect clone (pexpect).

You can look at it as 'expect without the pain'.

It is available as a pip install.

## Hello World

Starting with the simplest example. Create a file called example.py:

```python

import shutit
session = shutit.create_session('bash')
session.send('echo Hello World', echo=True)
```

Running this with:

```bash
python example.py
```

outputs:

```bash
$ python example.py
echo ""Hello World""
echo ""Hello World""
Hello World
Ians-MacBook-Air.local:ORIGIN_ENV:RhuebR2T#
```

The first argument to 'send' is the command you want to run. The 'echo'
argument outputs the terminal interactions. By default ShutIt is silent.

'send' takes care of all the messing around with prompts and 'expects' that
you might be familiar with from expect.


## Log Into a Server

Let's say you want to log into a server and run a command. Change example.py
to:

```python
import shutit
session = shutit.create_session('bash')
session.login('ssh you@example.com', user='you', password='mypassword')
session.send('hostname', echo=True)
session.logout()
```

which will log you into your server (if you replace with your details) and
output the hostname.

```
$ python example.py
hostname
hostname
example.com
example.com:cgoIsdVv:heDa77HB#
```

Obviously that's insecure! Instead you can run:

```python
import shutit
session = shutit.create_session('bash')
password = session.get_input('', ispass=True)
session.login('ssh you@example.com', user='you', password=password)
session.send('hostname', echo=True)
session.logout()
```

which forces you to input the password:

```
$ python example.py
Input Secret:
hostname
hostname
example.com
example.com:cgoIsdVv:heDa77HB#
```

Again, the 'login' method handles the changing prompt from a login. You give
ShutIt the login command, the user you expect to log in as, and a password
(if needed), and ShutIt takes care of the rest.

'logout' handles the ending of a 'login', handling any changes to the prompt
for you.

## Log Into Multiple Servers

Let's say you have a server farm of two servers, and want to log onto both.
Just create two sessions and run similar login and send commands:

```python
import shutit
session1 = shutit.create_session('bash')
session2 = shutit.create_session('bash')
password1 = session1.get_input('Password for server1', ispass=True)
password2 = session2.get_input('Password for server2', ispass=True)
session1.login('ssh you@one.example.com', user='you', password=password1)
session2.login('ssh you@two.example.com', user='you', password=password2)
session1.send('hostname', echo=True)
session2.send('hostname', echo=True)
session1.logout()
session2.logout()
```

would output:

```bash
$ python example.py
Password for server1
Input Secret:

Password for server2
Input Secret:
hostname
hostname
one.example.com
one.example.com:Fnh2pyFj:qkrsmUNs# hostname
hostname
two.example.com
two.example.com:Gl2lldEo:D3FavQjA#
```

## Example: Monitor Multiple Servers

We can turn the above into a simple monitoring tool by adding some logic to
examine the output of a command:

```python
import shutit
capacity_command=""""""df / | awk '{print $5}' | tail -1 | sed s/[^0-9]//""""""
session1 = shutit.create_session('bash')
session2 = shutit.create_session('bash')
password1 = session.get_input('Password for server1', ispass=True)
password2 = session.get_input('Password for server2', ispass=True)
session1.login('ssh you@one.example.com', user='you', password=password1)
session2.login('ssh you@two.example.com', user='you', password=password2)
capacity = session1.send_and_get_output(capacity_command)
if int(capacity) < 10:
	print('RUNNING OUT OF SPACE ON server1!')
capacity = session2.send_and_get_output(capacity_command)
if int(capacity) < 10:
	print('RUNNING OUT OF SPACE ON server2!')
session1.logout()
session2.logout()
```

Here you use the 'send\_and\_get\_output' method to retrieve the output of the
capacity command (df).

There are much more elegant ways to do the above (e.g. have a dictionary of the
servers to iterate over), but it's up to you how clever you need the Python to
be.


## More Intricate IO - Expecting

Let's say you have an interaction with an interactive command line application
you want to automate. Here we will use telnet as a trivial example:

```python
import shutit
session = shutit.create_session('bash')
session.send('telnet', expect='elnet>', echo=True)
session.send('open google.com 80', expect='scape character', echo=True)
session.send('GET /', echo=True, check_exit=False)
session.logout()
```

Note the 'expect' argument. You only need to give a subset of telnet's
prompt to match and continue.

Note also the 'check\_exit' argument in the above, which is new. We'll come back
to that. The output of the above is:

```bash
$ python example.py
telnet
telnet> open google.com 80
Trying 216.58.214.14...
Connected to google.com.
Escape character is '^]'.
GET /
HTTP/1.0 302 Found
Cache-Control: private
Content-Type: text/html; charset=UTF-8
Referrer-Policy: no-referrer
Location: http://www.google.co.uk/?gfe_rd=cr&ei=huczWcj3GfTW8gfq0paQDA
Content-Length: 261
Date: Sun, 04 Jun 2017 10:57:10 GMT

<HTML><HEAD><meta http-equiv=""content-type"" content=""text/html;charset=utf-8"">
<TITLE>302 Moved</TITLE></HEAD><BODY>
<H1>302 Moved</H1>
The document has moved
<A HREF=""http://www.google.co.uk/?gfe_rd=cr&amp;ei=huczWcj3GfTW8gfq0paQDA"">
here
</A>.
</BODY></HTML>
Connection closed by foreign host.
```

Now back to 'check\_exit=False'. Since the telnet command returns a failure exit
code (1) and we don't want the script to fail, you set 'check\_exit=False' to
let ShutIt know you don't care about the exit code.

If you didn't pass that argument in, ShutIt gives you an interactive terminal
if there is a terminal to communicate with. This is called a 'pause point'.


## Pause Points

You can trigger a 'pause point' at any point by calling

```python
[...]
session.pause_point('This is a pause point')
[...]
```

within your script, and then continue with the script by hitting CTRL and ']'
at the same time. This is great for debugging: add a pause point, have a look
around, then continue. Try this:

```python
import shutit
session = shutit.create_session('bash')
session.pause_point('Have a look around!')
session.send('echo ""Did you enjoy your pause point?""', echo=True)
```

with output like this:

```bash
$ python example.py
Have a look around!

Ians-Air.home:ORIGIN_ENV:I00LA1Mq#  bash
imiell@Ians-Air:/space/git/shutit  ⑂ master +    
CTRL-] caught, continuing with run...
2017-06-05 15:12:33,577 INFO: Sending:  exit
2017-06-05 15:12:33,633 INFO: Output (squashed):  exitexitIans-Air.home:ORIGIN_ENV:I00LA1Mq#  [...]
echo ""Did you enjoy your pause point?""
echo ""Did you enjoy your pause point?""
Did you enjoy your pause point?
Ians-Air.home:ORIGIN_ENV:I00LA1Mq#
```


## More Intricate IO - Backgrounding

Returning to our 'monitoring multiple servers' example, let's imagine we
have a long-running task that we want to run on each server. By default, ShutIt
works serially which would take a long time. But we can run tasks in the
background to speed things up.

Here you can try an example with the trivial command: 'sleep 60'.


```python
import shutit
import time
long_command=""""""sleep 60""""""
session1 = shutit.create_session('bash')
session2 = shutit.create_session('bash')
password1 = session1.get_input('Password for server1', ispass=True)
password2 = session2.get_input('Password for server2', ispass=True)
session1.login('ssh you@one.example.com', user='you', password=password1)
session2.login('ssh you@two.example.com', user='you', password=password2)
start = time.time()
session1.send(long_command, background=True)
session2.send(long_command, background=True)
print('That took: ' + str(time.time() - start) + ' seconds to fire')
session1.wait()
session2.wait()
print('That took: ' + str(time.time() - start) + ' seconds to complete')
```

My laptop says it took 0.5 seconds to run fire those two commands, and then just
over a minute to complete (using the 'wait' method).

Again, this is trivial, but imagine you have hundreds of servers to manage like
this and you can see the power it can bring in a few lines of code and one
Python import.


## Learn More

There's a lot more that can be done with ShutIt.

To learn more, see:

[ShutIt](https://ianmiell.github.io/shutit/)
[GitHub](https://github.com/ianmiell/shutit/blob/master/README.md)

It's a broader automation framework, and the above is its 'standalone mode'.

Feedback, feature requests, 'how do I?'s highly appreciated! Reach me at
[@ianmiell](https://twitter.com/ianmiell)"
"Brainfuck (not capitalized except at the start of a sentence) is an extremely
minimal Turing-complete programming language with just 8 commands.

You can try brainfuck on your browser with [brainfuck-online](https://copy.sh/brainfuck/).

```bf
Any character not ""><+-.,[]"" (excluding quotation marks) is ignored.

Brainfuck is represented by an array with 30,000 cells initialized to zero
and a data pointer pointing at the current cell.

There are eight commands:
+ : Increments the value at the current cell by one.
- : Decrements the value at the current cell by one.
> : Moves the data pointer to the next cell (cell on the right).
< : Moves the data pointer to the previous cell (cell on the left).
. : Prints the ASCII value at the current cell (i.e. 65 = 'A').
, : Reads a single input character into the current cell.
[ : If the value at the current cell is zero, skips to the corresponding ] .
    Otherwise, move to the next instruction.
] : If the value at the current cell is zero, move to the next instruction.
    Otherwise, move backwards in the instructions to the corresponding [ .

[ and ] form a while loop. Obviously, they must be balanced.

Let's look at some basic brainfuck programs.

++++++ [ > ++++++++++ < - ] > +++++ .

This program prints out the letter 'A'. First, it increments cell #1 to 6.
Cell #1 will be used for looping. Then, it enters the loop ([) and moves
to cell #2. It increments cell #2 10 times, moves back to cell #1, and
decrements cell #1. This loop happens 6 times (it takes 6 decrements for
cell #1 to reach 0, at which point it skips to the corresponding ] and
continues on).

At this point, we're on cell #1, which has a value of 0, while cell #2 has a
value of 60. We move on cell #2, increment 5 times, for a value of 65, and then
print cell #2's value. 65 is 'A' in ASCII, so 'A' is printed to the terminal.


, [ > + < - ] > .

This program reads a character from the user input and copies the character into
cell #1. Then we start a loop. Move to cell #2, increment the value at cell #2,
move back to cell #1, and decrement the value at cell #1. This continues on
until cell #1 is 0, and cell #2 holds cell #1's old value. Because we're on
cell #1 at the end of the loop, move to cell #2, and then print out the value
in ASCII.

Also keep in mind that the spaces are purely for readability purposes. You
could just as easily write it as:

,[>+<-]>.

Try and figure out what this program does:

,>,< [ > [ >+ >+ << -] >> [- << + >>] <<< -] >>

This program takes two numbers for input, and multiplies them.

The gist is it first reads in two inputs. Then it starts the outer loop,
conditioned on cell #1. Then it moves to cell #2, and starts the inner
loop conditioned on cell #2, incrementing cell #3. However, there comes a
problem: At the end of the inner loop, cell #2 is zero. In that case,
inner loop won't work anymore since next time. To solve this problem,
we also increment cell #4, and then recopy cell #4 into cell #2.
Then cell #3 is the result.
```

And that's brainfuck. Not that hard, eh? For fun, you can write your own
brainfuck programs, or you can write a brainfuck interpreter in another
language. The interpreter is fairly simple to implement, but if you're a
masochist, try writing a brainfuck interpreter… in brainfuck.

## Further Reading
 * [esolang-wiki](https://esolangs.org/wiki/Brainfuck)
 * [learn brainfuck](http://cydathria.com/bf/brainfuck.html)
 * [other resources](http://www.muppetlabs.com/~breadbox/bf/)"
"# Asymptotic Notations

## What are they?

Asymptotic Notations are languages that allow us to analyze an algorithm's 
running time by identifying its behavior as the input size for the algorithm 
increases. This is also known as an algorithm's growth rate. Does the 
algorithm suddenly become incredibly slow when the input size grows? Does it 
mostly maintain its quick run time as the input size increases? Asymptotic 
Notation gives us the ability to answer these questions.

## Are there alternatives to answering these questions?

One way would be to count the number of primitive operations at different 
input sizes. Though this is a valid solution, the amount of work this takes 
for even simple algorithms does not justify its use.

Another way is to physically measure the amount of time an algorithm takes to 
complete given different input sizes. However, the accuracy and relativity 
(times obtained would only be relative to the machine they were computed on) 
of this method is bound to environmental variables such as computer hardware 
specifications, processing power, etc.

## Types of Asymptotic Notation

In the first section of this doc, we described how an Asymptotic Notation 
identifies the behavior of an algorithm as the input size changes. Let us 
imagine an algorithm as a function f, n as the input size, and f(n) being 
the running time. So for a given algorithm f, with input size n you get 
some resultant run time f(n). This results in a graph where the Y-axis is 
the runtime, the X-axis is the input size, and plot points are the resultants 
of the amount of time for a given input size.

You can label a function, or algorithm, with an Asymptotic Notation in many 
different ways. Some examples are, you can describe an algorithm by its best 
case, worst case, or average case. The most common is to analyze an algorithm 
by its worst case. You typically don’t evaluate by best case because those 
conditions aren’t what you’re planning for. An excellent example of this is 
sorting algorithms; particularly, adding elements to a tree structure. The 
best case for most algorithms could be as low as a single operation. However, 
in most cases, the element you’re adding needs to be sorted appropriately 
through the tree, which could mean examining an entire branch. This is 
the worst case, and this is what we plan for.

### Types of functions, limits, and simplification

```
Logarithmic Function - log n
Linear Function - an + b
Quadratic Function - an^2 + bn + c
Polynomial Function - an^z + . . . + an^2 + a*n^1 + a*n^0, where z is some 
constant
Exponential Function - a^n, where a is some constant
```

These are some fundamental function growth classifications used in 
various notations. The list starts at the slowest growing function 
(logarithmic, fastest execution time) and goes on to the fastest 
growing (exponential, slowest execution time). Notice that as ‘n’ 
or the input, increases in each of those functions, the result 
increases much quicker in quadratic, polynomial, and exponential, 
compared to logarithmic and linear.

It is worth noting that for the notations about to be discussed, 
you should do your best to use the simplest terms. This means to 
disregard constants, and lower order terms, because as the input 
size (or n in our f(n) example) increases to infinity (mathematical 
limits), the lower order terms and constants are of little to no 
importance. That being said, if you have constants that are 2^9001, 
or some other ridiculous, unimaginable amount, realize that 
simplifying skew your notation accuracy.

Since we want simplest form, lets modify our table a bit...

```
Logarithmic - log n
Linear - n
Quadratic - n^2
Polynomial - n^z, where z is some constant
Exponential - a^n, where a is some constant
```

### Big-O
Big-O, commonly written as **O**, is an Asymptotic Notation for the worst 
case, or ceiling of growth for a given function. It provides us with an 
_**asymptotic upper bound**_ for the growth rate of the runtime of an algorithm.
Say `f(n)` is your algorithm runtime, and `g(n)` is an arbitrary time 
complexity you are trying to relate to your algorithm. `f(n)` is O(g(n)), if 
for some real constants c (c > 0) and n<sub>0</sub>, `f(n)` <= `c g(n)` for every input size 
n (n > n<sub>0</sub>).

*Example 1*

```
f(n) = 3log n + 100
g(n) = log n
```

Is `f(n)` O(g(n))?
Is `3 log n + 100` O(log n)?
Let's look to the definition of Big-O.

```
3log n + 100 <= c * log n
```

Is there some pair of constants c, n<sub>0</sub> that satisfies this for all n > n<sub>0</sub>?

```
3log n + 100 <= 150 * log n, n > 2 (undefined at n = 1)
```

Yes! The definition of Big-O has been met therefore `f(n)` is O(g(n)).

*Example 2*

```
f(n) = 3*n^2
g(n) = n
```

Is `f(n)` O(g(n))?
Is `3 * n^2` O(n)?
Let's look at the definition of Big-O.

```
3 * n^2 <= c * n
```

Is there some pair of constants c, n<sub>0</sub> that satisfies this for all n > <sub>0</sub>?
No, there isn't. `f(n)` is NOT O(g(n)).

### Big-Omega
Big-Omega, commonly written as **Ω**, is an Asymptotic Notation for the best 
case, or a floor growth rate for a given function. It provides us with an 
_**asymptotic lower bound**_ for the growth rate of the runtime of an algorithm.

`f(n)` is Ω(g(n)), if for some real constants c (c > 0) and n<sub>0</sub> (n<sub>0</sub> > 0), `f(n)` is >= `c g(n)` 
for every input size n (n > n<sub>0</sub>).

### Note

The asymptotic growth rates provided by big-O and big-omega notation may or 
may not be asymptotically tight. Thus we use small-o and small-omega notation 
to denote bounds that are not asymptotically tight. 

### Small-o
Small-o, commonly written as **o**, is an Asymptotic Notation to denote the 
upper bound (that is not asymptotically tight) on the growth rate of runtime 
of an algorithm.

`f(n)` is o(g(n)), if for all real constants c (c > 0) and n<sub>0</sub> (n<sub>0</sub> > 0), `f(n)` is < `c g(n)` 
for every input size n (n > n<sub>0</sub>).

The definitions of O-notation and o-notation are similar. The main difference 
is that in f(n) = O(g(n)), the bound f(n) <= g(n) holds for _**some**_ 
constant c > 0, but in f(n) = o(g(n)), the bound f(n) < c g(n) holds for 
_**all**_ constants c > 0.

### Small-omega
Small-omega, commonly written as **ω**, is an Asymptotic Notation to denote 
the lower bound (that is not asymptotically tight) on the growth rate of 
runtime of an algorithm.

`f(n)` is ω(g(n)), if for all real constants c (c > 0) and n<sub>0</sub> (n<sub>0</sub> > 0), `f(n)` is > `c g(n)` 
for every input size n (n > n<sub>0</sub>).

The definitions of Ω-notation and ω-notation are similar. The main difference 
is that in f(n) = Ω(g(n)), the bound f(n) >= g(n) holds for _**some**_ 
constant c > 0, but in f(n) = ω(g(n)), the bound f(n) > c g(n) holds for 
_**all**_ constants c > 0.

### Theta
Theta, commonly written as **Θ**, is an Asymptotic Notation to denote the 
_**asymptotically tight bound**_ on the growth rate of runtime of an algorithm. 

`f(n)` is Θ(g(n)), if for some real constants c1, c2 and n<sub>0</sub> (c1 > 0, c2 > 0, n<sub>0</sub> > 0), 
`c1 g(n)` is < `f(n)` is < `c2 g(n)` for every input size n (n > n<sub>0</sub>).

∴ `f(n)` is Θ(g(n)) implies `f(n)` is O(g(n)) as well as `f(n)` is Ω(g(n)).

Feel free to head over to additional resources for examples on this. Big-O 
is the primary notation use for general algorithm time complexity.

### Endnotes
It's hard to keep this kind of topic short, and you should go 
through the books and online resources listed. They go into much greater depth 
with definitions and examples. More where x='Algorithms & Data Structures' is 
on its way; we'll have a doc up on analyzing actual code examples soon.

## Books

* [Algorithms](http://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X)
* [Algorithm Design](http://www.amazon.com/Algorithm-Design-Foundations-Analysis-Internet/dp/0471383651)

## Online Resources

* [MIT](http://web.mit.edu/16.070/www/lecture/big_o.pdf)
* [KhanAcademy](https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/asymptotic-notation)
* [Big-O Cheatsheet](http://bigocheatsheet.com/) - common structures, operations, and algorithms, ranked by complexity."
"Fortran is one of the oldest computer languages. It was developed in the 1950s
by IBM for numeric calculations (Fortran is an abbreviation of ""Formula
Translation""). Despite its age, it is still used for high-performance computing
such as weather prediction. However, the language has changed considerably over
the years, although mostly maintaining backwards compatibility; well known
versions are FORTRAN 77, Fortran 90, Fortran 95, Fortran 2003, Fortran 2008,
Fortran 2015, and Fortran 2018.

This overview will discuss the features of Fortran 95 since it is the most
widely implemented of the more recent specifications and the later versions are
largely similar (by comparison FORTRAN 77 is a very different language).

```fortran

! This is a comment.


program example   !declare a program called example.

    ! Code can only exist inside programs, functions, subroutines or modules.
    ! Using indentation is not required but it is recommended.


    ! Declaring Variables
    ! ===================

    ! All declarations must come before statements and expressions.

    implicit none    !prevents dynamic declaration of variables (recommended!)
    ! Implicit none must be redeclared in every function/program/module...

    ! IMPORTANT - Fortran is case insensitive.
    real z
    REAL Z2

    real :: v,x    ! WARNING: default initial values are compiler dependent!
    real :: a = 3, b=2E12, c = 0.01
    integer :: i, j, k=1, m
    real, parameter :: PI = 3.1415926535897931    !declare a constant.
    logical :: y = .TRUE. , n = .FALSE.    !boolean type.
    complex :: w = (0,1)    !sqrt(-1)
    character (len=3) :: month    !string of 3 characters.

    real :: array(6)     !declare an array of 6 reals.
    real, dimension(4) :: arrayb    !another way to declare an array.
    integer :: arrayc(-10:10)   !an array with a custom index.
    real :: array2d(3,2)    !multidimensional array.

    ! The '::' separators are not always necessary but are recommended.

    ! many other variable attributes also exist:
    real, pointer :: p    !declare a pointer.

    integer, parameter :: LP = selected_real_kind(20)
    real (kind = LP) :: d    !long precision variable.

    ! WARNING: initialising variables during declaration causes problems
    ! in functions since this automatically implies the 'save' attribute
    ! whereby values are saved between function calls. In general, separate
    ! declaration and initialisation code except for constants!


    ! Strings
    ! =======

    character :: a_char = 'i'
    character (len = 6) :: a_str = ""qwerty""
    character (len = 30) :: str_b
    character (len = *), parameter :: a_long_str = ""This is a long string.""
    !can have automatic counting of length using (len=*) but only for constants.

    str_b = a_str // "" keyboard""    !concatenate strings using // operator.


    ! Assignment & Arithmetic
    ! =======================

    Z = 1    !assign to variable z declared above (case insensitive).
    j = 10 + 2 - 3
    a = 11.54  /  (2.3 * 3.1)
    b = 2**3    !exponentiation


    ! Control Flow Statements & Operators
    ! ===================================

    ! Single-line if statement
    if (z == a) b = 4  !condition always need surrounding parentheses.

    if (z /= a) then !z not equal to a
    ! Other symbolic comparisons are < > <= >= == /=
      b = 4
    else if (z .GT. a) then !z greater than a
    ! Text equivalents to symbol operators are .LT. .GT. .LE. .GE. .EQ. .NE.
      b = 6
    else if (z < a) then !'then' must be on this line.
      b = 5 !execution block must be on a new line.
    else
      b = 10
    end if !end statement needs the 'if' (or can use 'endif').


    if (.NOT. (x < c .AND. v >= a .OR. z == z)) then   !boolean operators.
      inner: if (.TRUE.) then    !can name if-construct.
        b = 1
      endif inner    !then must name endif statement.
    endif


    i = 20
    select case (i)
      case (0)    !case i == 0
        j=0
      case (1:10)    !cases i is 1 to 10 inclusive.
        j=1
      case (11:)    !all cases where i>=11
        j=2
      case default
        j=3
    end select


    month = 'jan'
    ! Condition can be integer, logical or character type.
    ! Select constructions can also be named.
    monthly: select case (month)
      case (""jan"")
         j = 0
      case default
         j = -1
    end select monthly


    do i=2,10,2    !loops from 2 to 10 (inclusive) in increments of 2.
      innerloop: do j=1,3    !loops can be named too.
        exit    !quits the loop.
      end do innerloop
    cycle    !jump to next loop iteration.
    enddo


    ! Goto statement exists but it is heavily discouraged though.
    goto 10
    stop 1    !stops code immediately (returning specified condition code).
10  j = 201    !this line is labeled as line 10


    ! Arrays
    ! ======
    array = (/1,2,3,4,5,6/)
    array = [1,2,3,4,5,6]    !using Fortran 2003 notation.
    arrayb = [10.2,3e3,0.41,4e-5]
    array2d =  reshape([1.0,2.0,3.0,4.0,5.0,6.0], [3,2])

    ! Fortran array indexing starts from 1.
    ! (by default but can be defined differently for specific arrays).
    v = array(1)    !take first element of array.
    v = array2d(2,2)

    print *, array(3:5)    !print all elements from 3rd to 5th (inclusive).
    print *, array2d(1,:)    !print first column of 2d array.

    array = array*3 + 2    !can apply mathematical expressions to arrays.
    array = array*array    !array operations occur element-wise.
    !array = array*array2d    !these arrays would not be compatible.

    ! There are many built-in functions that operate on arrays.
    c = dot_product(array,array)    !this is the dot product.
    ! Use matmul() for matrix maths.
    c = sum(array)
    c = maxval(array)
    print *, minloc(array)
    c = size(array)
    print *, shape(array)
    m = count(array > 0)

    ! Loop over an array (could have used Product() function normally).
    v = 1
    do i = 1, size(array)
        v = v*array(i)
    end do

    ! Conditionally execute element-wise assignments.
    array = [1,2,3,4,5,6]
    where (array > 3)
        array = array + 1
    elsewhere (array == 2)
        array = 1
    elsewhere
        array = 0
    end where

    ! Implied-DO loops are a compact way to create arrays.
    array = [ (i, i = 1,6) ]    !creates an array of [1,2,3,4,5,6]
    array = [ (i, i = 1,12,2) ]    !creates an array of [1,3,5,7,9,11]
    array = [ (i**2, i = 1,6) ]    !creates an array of  [1,4,9,16,25,36]
    array = [ (4,5, i = 1,3) ]    !creates an array of [4,5,4,5,4,5]


    ! Input/Output
    ! ============

    print *, b    !print the variable 'b' to the command line

    ! We can format our printed output.
    print ""(I6)"", 320    !prints '   320'
    print ""(I6.4)"", 3    !prints '  0003'
    print ""(F6.3)"", 4.32    !prints ' 4.320'

    ! The letter indicates the expected type and the number afterwards gives
    ! the number of characters to use for printing the value.
    ! Letters can be I (integer), F (real), E (engineering format),
    ! L (logical), A (characters) ...
    print ""(I3)"", 3200    !print '***' since the number doesn't fit.

    ! we can have multiple format specifications.
    print ""(I5,F6.2,E6.2)"", 120, 43.41, 43.41
    print ""(3I5)"", 10, 20, 30    !3 repeats of integers (field width = 5).
    print ""(2(I5,F6.2))"", 120, 43.42, 340, 65.3   !repeated grouping of formats.

    ! We can also read input from the terminal.
    read *, v
    read ""(2F6.2)"", v, x    !read two numbers

    ! To read a file.
    open(unit=11, file=""records.txt"", status=""old"")
    ! The file is referred to by a 'unit number', an integer that you pick in
    ! the range 9:99. Status can be one of {'old','replace','new'}.
    read(unit=11, fmt=""(3F10.2)"") a, b, c
    close(11)

    ! To write a file.
    open(unit=12, file=""records.txt"", status=""replace"")
    write(12, ""(F10.2,F10.2,F10.2)"") c, b, a
    close(12)

    ! There are more features available than discussed here and alternative
    ! variants due to backwards compatibility with older Fortran versions.


    ! Built-in Functions
    ! ==================

    ! Fortran has around 200 functions/subroutines intrinsic to the language.
    ! Examples -
    call cpu_time(v)    !sets 'v' to a time in seconds.
    k = ior(i,j)    !bitwise OR of 2 integers.
    v = log10(x)    !log base 10.
    i = floor(b)    !returns the closest integer less than or equal to x.
    v = aimag(w)    !imaginary part of a complex number.


    ! Functions & Subroutines
    ! =======================

    ! A subroutine runs some code on some input values and can cause
    ! side-effects or modify the input values.

    call routine(a,c,v)    !subroutine call.

    ! A function takes a list of input parameters and returns a single value.
    ! However the input parameters may still be modified and side effects
    ! executed.

    m = func(3,2,k)  !function call.

    ! Function calls can also be evoked within expressions.
    Print *, func2(3,2,k)

    ! A pure function is a function that doesn't modify its input parameters
    ! or cause any side-effects.
    m = func3(3,2,k)


contains ! Zone for defining sub-programs internal to the program.

    ! Fortran has a couple of slightly different ways to define functions.

    integer function func(a,b,c)    !a function returning an integer value.
        implicit none   !best to use implicit none in function definitions too.
        integer :: a,b,c !type of input parameters defined inside the function.
        if (a >= 2) then
            func = a + b + c !the return variable defaults to the function name.
            return !can return the current value from the function at any time.
        endif
        func = a + c
        ! Don't need a return statement at the end of a function.
    end function func


    function func2(a,b,c) result(f)    !return variable declared to be 'f'.
        implicit none
        integer, intent(in) :: a,b    !can declare and enforce that variables
                                      !are not modified by the function.
        integer, intent(inout) :: c
        integer :: f     !function return type declared inside the function.
        integer :: cnt = 0    !GOTCHA - initialisation implies variable is
                              !saved between function calls.
        f = a + b - c
        c = 4    !altering the value of an input variable.
        cnt  = cnt + 1    !count number of function calls.
    end function func2


    pure function func3(a,b,c)  !a pure function can have no side-effects.
        implicit none
        integer, intent(in) :: a,b,c
        integer :: func3
        func3 = a*b*c
    end function func3


    subroutine routine(d,e,f)
        implicit none
        real, intent(inout) :: f
        real, intent(in) :: d,e
        f = 2*d + 3*e + f
    end subroutine routine


end program example   ! End of Program Definition -----------------------


! Functions and Subroutines declared externally to the program listing need
! to be declared to the program using an Interface declaration (even if they
! are in the same source file!) (see below). It is easier to define them within
! the 'contains' section of a module or program.

elemental real function func4(a) result(res)
! An elemental function is a Pure function that takes a scalar input variable
! but can also be used on an array where it will be separately applied to all
! of the elements of an array and return a new array.
    real, intent(in) :: a
    res = a**2 + 1.0
end function func4


! Modules
! =======

! A module is a useful way to collect related declarations, functions and
! subroutines together for reusability.

module fruit
    real :: apple
    real :: pear
    real :: orange
end module fruit


module fruity
    ! Declarations must be in the order: modules, interfaces, variables.
    ! (can declare modules and interfaces in programs too).

    use fruit, only: apple, pear    ! use apple and pear from fruit module.
    implicit none    !comes after module imports.

    private    !make things private to the module (default is public).
    ! Declare some variables/functions explicitly public.
    public :: apple,mycar,create_mycar
    ! Declare some variables/functions private to the module (redundant here).
    private :: func4

    ! Interfaces
    ! ==========
    ! Explicitly declare an external function/procedure within the module
    ! (better in general to put functions/procedures in the 'contains' section).
    interface
        elemental real function func4(a) result(res)
            real, intent(in) :: a
        end function func4
    end interface

    ! Overloaded functions can be defined using named interfaces.
    interface myabs
        ! Can use 'module procedure' keyword to include functions already
        ! defined within the module.
        module procedure real_abs, complex_abs
    end interface

    ! Derived Data Types
    ! ==================
    ! Can create custom structured data collections.
    type car
        character (len=100) :: model
        real :: weight    !(kg)
        real :: dimensions(3)    !i.e. length-width-height (metres).
        character :: colour
    end type car

    type(car) :: mycar    !declare a variable of your custom type.
    ! See create_mycar() routine for usage.

    ! Note: There are no executable statements in modules.

contains

    subroutine create_mycar(mycar)
        ! Demonstrates usage of a derived data type.
        implicit none
        type(car),intent(out) :: mycar

        ! Access type elements using '%' operator.
        mycar%model = ""Ford Prefect""
        mycar%colour = 'r'
        mycar%weight = 1400
        mycar%dimensions(1) = 5.0    !default indexing starts from 1!
        mycar%dimensions(2) = 3.0
        mycar%dimensions(3) = 1.5

    end subroutine

    real function real_abs(x)
        real :: x
        if (x<0) then
            real_abs = -x
        else
            real_abs = x
        end if
    end function real_abs

    real function complex_abs(z)
        complex :: z
        ! long lines can be continued using the continuation character '&'
        complex_abs = sqrt(real(z)**2 + &
                                         aimag(z)**2)
    end function complex_abs


end module fruity

```

### More Resources

For more information on Fortran:

+ [wikipedia](https://en.wikipedia.org/wiki/Fortran)
+ [Fortran-lang Organization](https://fortran-lang.org/)
+ [Fortran_95_language_features](https://en.wikipedia.org/wiki/Fortran_95_language_features)
+ [fortranwiki.org](http://fortranwiki.org)
+ [www.fortran90.org/](http://www.fortran90.org)
+ [list of Fortran 95 tutorials](http://www.dmoz.org/Computers/Programming/Languages/Fortran/FAQs%2C_Help%2C_and_Tutorials/Fortran_90_and_95/)
+ [Fortran wikibook](https://en.wikibooks.org/wiki/Fortran)
+ [Fortran resources](http://www.fortranplus.co.uk/resources/fortran_resources.pdf)
+ [Mistakes in Fortran 90 Programs That Might Surprise You](http://www.cs.rpi.edu/~szymansk/OOF90/bugs.html)"
"[Composer](https://getcomposer.org/) is a tool for dependency management in PHP. It allows you to declare the libraries your project depends on and it will manage (install/update) them for you.

# Installing

```sh
# Installs the composer.phar binary into the current directory
curl -sS https://getcomposer.org/installer | php
# If you use this approach, you will need to invoke composer like this:
php composer.phar about

# Installs the binary into ~/bin/composer
# Note: make sure ~/bin is in your shell's PATH environment variable
curl -sS https://getcomposer.org/installer | php -- --install-dir=~/bin --filename=composer
```

Windows users should follow the [Windows installation instructions](https://getcomposer.org/doc/00-intro.md#installation-windows)

## Confirming installation

```sh
# Check version and list options
composer

# Get more help for options
composer help require

# Check if Composer is able to do the things it needs, and if it's up to date
composer diagnose
composer diag # shorthand

# Updates the Composer binary to the latest version
composer self-update
composer self # shorthand
```

# Usage

Composer stores your project dependencies in `composer.json`. You can edit this file, but it is best to let Composer manage it for you.

```sh
# Create a new project in the current folder
composer init
# runs an interactive questionnaire asking you for details about your project.  Leaving them blank is fine unless you are making other projects dependent on this one.

# If a composer.json file already exists, download the dependencies
composer install

# To download the just the production dependencies, i.e. excluding development dependencies
composer install --no-dev

# Add a production dependency to this project
composer require guzzlehttp/guzzle
# will figure out what the latest version of guzzlehttp/guzzle is, download it, and add the new dependency to composer.json's require field.

composer require guzzlehttp/guzzle:6.0.*
# will download the latest version matching the pattern (eg. 6.0.2) and add the dependency to composer.json's require field

composer require --dev phpunit/phpunit:~4.5.0
# will require as a development dependency. Will use the latest version >=4.5.0 and < 4.6.0

composer require-dev phpunit/phpunit:^4.5.0
# will require as a development dependency. Will use the latest version >=4.5.0 and < 5.0

# For more information on Composer version matching, see [Composer's documentation on Versions](https://getcomposer.org/doc/articles/versions.md) for more details

# To see what packages are available to install and currently installed
composer show

# To see what packages are currently installed
composer show --installed

# To find a package with 'mailgun' in its name or description
composer search mailgun
```

[Packagist.org](https://packagist.org/) is the main repository for Composer packages. Search there for existing third-party packages.

## `composer.json` vs `composer.lock`

The `composer.json` file stores your project's floating version preferences for each dependency, along with other information.

The `composer.lock` file stores exactly which version it has downloaded for each dependency. Never edit this file.

If you include the `composer.lock` file in your git repository, every developer will install the currently used version of the dependency. Even when a new version of a dependency is released, Composer will continue to download the version recorded in the lock file.

```sh
# If you want to update all the dependencies to their newest version still matching your version preferences
composer update

# If you want the new version of a particular dependency:
composer update phpunit/phpunit

# If you wish to migrate a package to a newer version preference, you may need to remove the older package and its dependencies first.
composer remove --dev phpunit/phpunit
composer require --dev phpunit/phpunit:^5.0

```

## Autoloader

Composer creates an autoloader class you can require from your application. You can make instances of classes via their namespace.

```php
require __DIR__ . '/vendor/autoload.php';

$mailgun = new Mailgun\Mailgun(""key"");
```

### PSR-4 Autoloader

You can add your own namespaces to the autoloader.

In `composer.json`, add a 'autoload' field:

```json
{
  ""autoload"": {
    ""psr-4"": {""Acme\\"": ""src/""}
  }
}
```
This will tell the autoloader to look for anything in the `\Acme\` namespace within the `src` folder.

You can also [use PSR-0, a Classmap or just a list of files to include](https://getcomposer.org/doc/04-schema.md#autoload). There is also the `autoload-dev` field for development-only namespaces.

When adding or modifying the autoload key, you will need to rebuild the autoloader:

```sh
composer dump-autoload
composer dump # shorthand

# Optimizes PSR0 and PSR4 packages to be loaded with classmaps too. Slow to run, but improves performance on production.
composer dump-autoload --optimize --no-dev
```

# Composer's Cache

```sh
# Composer will retain downloaded packages to use in the future. Clear it with:
composer clear-cache
```

# Troubleshooting

```sh
composer diagnose
composer self-update
composer clear-cache
```

## Topics not (yet) covered in this tutorial

* Creating and distributing your own packages on Packagist.org or elsewhere
* Pre- and post- script hooks: run tasks when certain composer events take place

### References

* [Composer - Dependency Manager for PHP](https://getcomposer.org/)
* [Packagist.org](https://packagist.org/)"
"In GNOME's own words, ""Vala is a programming language that aims to bring modern programming language features to GNOME developers without imposing any additional runtime requirements and without using a different ABI compared to applications and libraries written in C.""

Vala has aspects of Java and C#, so it'll be natural to those who know either.

[Read more here.](https://wiki.gnome.org/Projects/Vala)

```vala

// Single line comment

/* Multiline
Comment */

/**
* Documentation comment
*/

/* Data Types */

char character = 'a'
unichar unicode_character = 'u' // 32-bit unicode character

int i = 2; // ints can also have guaranteed sizes (e.g. int64, uint64)
uint j = -6; // Won't compile; unsigned ints can only be positive

long k;

short l;
ushort m;

string text = ""Hello,""; // Note that the == operator will check string content

string verbatim = """"""This is a verbatim (a.k.a. raw) string. Special characters
(e.g. \n and """") are not interpreted. They may also be multiple lines long."""""";

// String Templates allow for easy string formatting
string string_template = @""$text world""; // ""$text"" evaluates to ""Hello,""

int test = 5;
int test2 = 10;
string template2 = @""$(test * test2) is a number.""; // Expression evaluation

string template_slice = string_template[7:12]; // => ""world""

// Most data types have methods for parsing.

bool parse_bool = bool.parse(""false""); // => false
int parse_int = int.parse(""-52""); // => -52
string parse_string = parse_int.to_string(); // => ""-52""

/* Basic I/O */

stdout.printf(parse_string); // Prints to console
string input = stdin.read_line(); // Gets input from console

stderr.printf(""Error message""); // Error printing

/* Arrays */

int[] int_array = new int[10]; // Array of ints with 10 slots
int better_int_array[10]; // Above expression, shortened
int_array.length; // => 10;

int[] int_array2 = {5, 10, 15, 20}; // Can be created on-the-fly

int[] array_slice = int_array2[1:3]; // Slice (copy of data)
unowned int[] array_slice_ref = int_array2[1:3]; // Reference to data

// Multi-dimensional Arrays (defined with a number of commas in the brackets)

int[,] multi_array = new int[6,4]; // 6 is the number of arrays, 4 is their size
int[,] multi_array2 = {{7, 4, 6, 4},
                       {3, 2, 4, 6},
                       {5, 9, 5, 1}}; // new int[3,4]
multi_array2[2,3] = 12; // 2 is the array, 3 is the index in the array
int first_d = multi_array2.length[0] // => 3
int second_d = multi_array2.length[1] // => 4

// Stacked arrays (e.g. int[][]) where array lengths vary are not supported.

// Multi-dimensional arrays cannot be sliced, nor can they be converted to one-
// dimensional.

int[] add_to_array = {};
add_to_array += 12; // Arrays can be dynamically added to

add_to_array.resize(20); // Array now has 20 slots

uint8[] chars = ""test message"".data;
chars.move(5, 0, 7);
stdout.printf((string) chars); // Casts the array to a string and prints it

/* Control Flow */

int a = 1;
int b = 2;
int[] foreach_demo = {2, 4, 6, 8};

while (b > a) { // While loop; checks if expression is true before executing
  b--;
}

do {
  b--;
}
while (b > a); // Do While loop; executes the code in ""do"" before while (b > a)

for (a = 0; a < 10; a++) { stdout.printf(""%d\n"", a); } // for loop

foreach (int foreach_demo_var in foreach_demo) {
  stdout.printf(""%d\n"", foreach_demo_var);
} // foreach works on any iterable collection

if (a == 0) {
  stdout.printf(""%d\n"", a);
} else if (a > 1) {
  stdout.printf(""%d\n"", a);
} else {
  stdout.printf(""A is less than 0"");
} // if-then-else

switch (a) {
  case 1:
    stdout.printf(""A is 1\n"");
    break;
  case 5:
  case 10:
    stdout.printf(""A is 5 or 10\n"");
    break;
  default:
    stdout.printf(""???\n"")
    break;
} // switch statement

/* Type Casting and Inference */

int cast_to_float = 10;
float casted_float = (float) cast_to_float; // static casting; no runtime checks

// For runtime checks, use dynamic casting.
// Dynamically casted objects must be the following:
// - Object's class is the same class as the desired type
// - Object's class is a subclass of the desired type
// - Desired class is an interface implemented by the object's class

float dyna_casted_float = cast_to_float as float // Won't compile

var inferred_string = ""hello""; // Type inference

/* Methods (a.k.a. functions) */

int method_demo(string arg1, Object arg2) { // Returns int and takes args
    return 1;
}

// Vala methods cannot be overloaded.

void some_method(string text) { }
void some_method(int number) { }  // Won't compile

// To achieve similar functionality, use default argument values.

void some_better_method(string text, int number = 0) { }

some_better_method(""text"");
some_better_method(""text"", 12);

// varargs (variable-length argument lists) are also supported.

void method_with_varargs(int arg1, ...) {
    var varargs_list = va_list(); // gets the varargs list

    string arg_string = varargs_list.arg(); // gets arguments, one after another
    int int_vararg = varargs_list.arg();

    stdout.printf(""%s, %d\n"", arg_string, int_vararg)
}

string? ok_to_be_null(int? test_int) { } // ""?"" denotes possible null value

// Delegates

delegate void DelegateDemo(char char_a);

void delegate_match(char char_a) { // Matches DelegateDemo's signature
  stdout.printf(""%d\n"");
}

void call_delegate(DelegateDemo d, char char_b) { // Takes a delegate arg
  d(char_b) // calls delegate
}

void final_delegate_demo() {
  call_delegate(delegate_match); // Passes matching method as argument
}

// Lambdas (a.k.a. Anonymous Methods) are defined with ""=>""

(a) => { stdout.printf(""%d\n"", a); } // Prints ""a""

/* Namespaces */

namespace NamespaceDemo {
  // Allows you to organize variable names
  int namespace_int = 12;
}
namespace_int += 5; // Won't compile

using NamespaceDemo;
namespace_int += 5; // Valid

/* Structs and Enums */

struct Closet {
  public uint shirts; // Default access modifier is private
  public uint jackets;
}

Closet struct_init_1 = Closet(); // or Closet struct_init_1 = {};
Closet struct_init_2 = {15, 3};
var struct_init_3 = Closet() { // Type inference also works
  shirts = 15;
  jackets = 3;
}

enum HouseSize { // An example of an enum
  SMALL,
  MODERATE,
  BIG
}

/* Classes and Object-Oriented Programming */

class Message : GLib.Object { // Class Message extends GLib's Object
  private string sender; // a private field
  public string text {get; set;} // a public property (more on that later)
  protected bool is_digital = true; // protected (this class and subclasses)
  internal bool sent = false; // internal (classes in same package)

  public void send(string sender) { // public method
    this.sender = sender;
    sent = true;
  }

  public Message() { // Constructor
    // ...
  }

}

// Since method overloading isn't possible, you can't overload constructors.
// However, you can use named constructors to achieve the same functionality.

public class Calculator : GLib.Object {

    public Calculator() {
    }

    public Calculator.with_name(string name) {
    }

    public Calculator.model(string model_id, string name = """") {
      this.with_name(@""$model_id $name""); // Chained constructors with ""this""
    }
    ~Calculator() { } // Only needed if you're using manual memory management
}

var calc1 = new Calculator.with_name(""Temp"");
var calc2 = new Calculator.model(""TI-84"");

// Signals (a.k.a. events or event listeners) are a way to execute multiple
// methods with the same signature at the same time.

public class SignalDemo : GLib.Object {
  public signal void sig_demo(int sig_demo_int); // Must be public

  public static int main(string[] args) {
    // main method; program does not compile without it

    var sig_demo_class = new SignalDemo(); // New instance of class

    sig_demo_class.sig_demo.connect((ob, sig_int) => { // Lambda used as handler
        stdout.printf(""%d\n"", sig_int); // ""ob"" is object on which it is emitted
      });

    sig_demo_class.sig_demo(27); // Signal is emitted

    return 0;
  }
}

// You may use the connect() method and attach as many handlers as you'd like.
// They'll all run at around the same time when the signal is emitted.

// Properties (getters and setters)

class Animal : GLib.Object {
  private int _legs; // prefixed with underscore to prevent name clashes

  public int legs {
    get { return _legs; }
    set { _legs = value; }
  }

  public int eyes { get; set; default = 5; } // Shorter way
  public int kingdom { get; private set; default = ""Animalia""} // Read-only

  public static void main(string args[]) {
    rabbit = new Animal();

    // All GLib.Objects have a signal ""notify"" emitted when a property changes.

    // If you specify a specific property, replace all underscores with dashes
    // to conform to the GObject naming convention.

    rabbit.notify[""eyes""].connect((s, p) => { // Remove the [""eyes""] for all
      stdout.printf(""Property '%s' has changed!\n"", p.name);
    });

    rabbit.legs = 2;
    rabbit.legs += 2;
    rabbit.eyes = 2;

  }
}

// Inheritance: Vala classes may inherit 1 class. Inheritance is not implicit.

class SuperDemo : GLib.Object {
  public int data1;
  protected int data2;
  internal int data3;
  private int data4;

  public static void test_method {  } // Statics can be called w/out an object
}
class SubDemo : SuperDemo {
  public static void main(string args[]) {
    stdout.printf((string) data1); // Will compile
    stdout.printf((string) data2); // Protected can be accessed by subclasses
    stdout.printf((string) data3); // Internal is accessible to package
    stdout.printf((string) data4); // Won't compile
  }
}

// Abstract Classes and Methods

public abstract class OperatingSystem : GLib.Object {
  public void turn_on() {
    stdout.printf(""Booted successfully.\n"");
  }
  public abstract void use_computer();
}

public class Linux : OperatingSystem {
  public override void use_computer() { // Abstract methods must be overridden
    stdout.printf(""Beep boop\n"");
  }
}

// Add default behavior to an abstract method by making it ""virtual"".

public abstract class HardDrive : GLib.Object {
  public virtual void die() {
    stdout.printf(""CLICK-CLICK-CLICK\n"");
  }
}
public class MyHD : HardDrive {
  public override void die() {
    return;
  }
}

// Interfaces: classes can implement any number of these.

interface Laptop { // May only contain abstracts or virtuals
  public abstract void turn_on();
  public abstract void turn_off();

  public abstract int cores; // Won't compile; fields cannot be abstract
  public abstract int cores {get; set;} // Will compile

  public virtual void keyboard() { // Virtuals are allowed (unlike Java/C#)
    stdout.printf(""Clickity-clack\n"");
  }
}

// The ability to use virtuals in Vala means that multiple inheritance is
// possible (albeit somewhat confined)

// Interfaces cannot implement interfaces, but they may specify that certain
// interfaces or classes must be also implemented (pre-requisites).

public interface CellPhone : Collection, GLib.Object {}

// You can get the type info of a class at runtime dynamically.

bool type_info = object is TypeName; // uses ""is"" to get a bool

Type type_info2 = object.get_type();
var type_name = type_info2.name();

Type type_info3 = typeof(Linux);
Linux type_demo = (Linux) Object.new(type_info3);

// Generics

class Computer<OperatingSystem> : GLib.Object {
  private OperatingSystem os;

  public void install_os(OperatingSystem os) {
    this.os = os;
  }
  public OperatingSystem retrieve_os() {
    return this.os;
  }
}

var new_computer = new Computer<Linux>();

/* Other Features */

// Assertions: crash if a statement is not true (at runtime)

bool is_true = true;
assert(is_true);

// Contract Programming

int contract_demo(int arg1, int arg2) {
  requires(arg1 > 0 && arg1 < 10) // Notice the lack of semicolon
  requires(arg2 >= 12)
  ensures(result >= 0)
}

// Error Handling

void error_demo(int int_ex) throws GError {
  if (int_ex != 1) {
    throw new GError(""TEST MESSAGE"");
  }
}
void error_demo2() {
  try {
    error_demo(0);
  } catch (GError ge) {
    stdout.printf(""%s\n"", ge.message);
  }
}

// Main Loop

void main() {

  var main_loop = new MainLoop();
  var time = new TimeoutSource(2000);

  time.set_callback(() => { // Executes the following lambda after 2000ms
      stdout.printf(""2000ms have passed\n"");
      main_loop.quit();
      return false;
  });

  time.attach(main_loop.get_context());

  loop.run();
}

// Pointers (manual memory management)

Object* pointer_obj = new Object(); // Creates Object instance and gives pointer

pointer_obj->some_method(); // Executes some_method
pointer_obj->some_data; // Returns some_data

delete pointer_obj;

int more = 57;
int* more_pointer = &more; // & = address-of
int indirection_demo = more_pointer*; // indirection

// Profiles: affect which Vala features are available and which libraries the
// C-code will use.
// - gobject (default)
// posix
// dova
// Use ""--profile=whatever"" when compiling.

```
* More [Vala documentation](https://valadoc.org/).
* [Alternate construction syntax](https://wiki.gnome.org/Projects/Vala/Tutorial#GObject-Style_Construction) similar to GObject
* More on [contract programming](http://en.wikipedia.org/wiki/Contract_programming)
* [Collections library](https://wiki.gnome.org/Projects/Vala/Tutorial#Collections)
* [Multithreading](https://wiki.gnome.org/Projects/Vala/Tutorial#Multi-Threading)
* Read about [building GUIs with GTK+ and Vala](http://archive.is/7C7bw).
* [D-Bus integration](https://wiki.gnome.org/Projects/Vala/Tutorial#D-Bus_Integration)"
"language: Paren
filename: learnparen.paren
contributors:
  - [""KIM Taegyoon"", ""https://github.com/kimtg""]
  - [""Claudson Martins"", ""https://github.com/claudsonm""]
---

[Paren](https://bitbucket.org/ktg/paren) is a dialect of Lisp. It is designed to be an embedded language.

Some examples are from <http://learnxinyminutes.com/docs/racket/>.

```scheme
;;; Comments
# comments

;; Single line comments start with a semicolon or a sharp sign

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1. Primitive Datatypes and Operators
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Numbers
123 ; int
3.14 ; double
6.02e+23 ; double
(int 3.14) ; => 3 : int
(double 123) ; => 123 : double

;; Function application is written (f x y z ...)
;; where f is a function and x, y, z, ... are operands
;; If you want to create a literal list of data, use (quote) to stop it from
;; being evaluated
(quote (+ 1 2)) ; => (+ 1 2)
;; Now, some arithmetic operations
(+ 1 1)  ; => 2
(- 8 1)  ; => 7
(* 10 2) ; => 20
(^ 2 3) ; => 8
(/ 5 2) ; => 2
(% 5 2) ; => 1
(/ 5.0 2) ; => 2.5

;;; Booleans
true ; for true
false ; for false
(! true) ; => false
(&& true false (prn ""doesn't get here"")) ; => false
(|| false true (prn ""doesn't get here"")) ; => true

;;; Characters are ints.
(char-at ""A"" 0) ; => 65
(chr 65) ; => ""A""

;;; Strings are fixed-length array of characters.
""Hello, world!""
""Benjamin \""Bugsy\"" Siegel""   ; backslash is an escaping character
""Foo\tbar\r\n"" ; includes C escapes: \t \r \n

;; Strings can be added too!
(strcat ""Hello "" ""world!"") ; => ""Hello world!""

;; A string can be treated like a list of characters
(char-at ""Apple"" 0) ; => 65

;; Printing is pretty easy
(pr ""I'm"" ""Paren. "") (prn ""Nice to meet you!"")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 2. Variables
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; You can create or set a variable using (set)
;; a variable name can use any character except: ();#""
(set some-var 5) ; => 5
some-var ; => 5

;; Accessing a previously unassigned variable is an exception
; x ; => Unknown variable: x : nil

;; Local binding: Use lambda calculus! 'a' and 'b' are bound to '1' and '2' only within the (fn ...)
((fn (a b) (+ a b)) 1 2) ; => 3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 3. Collections
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Lists

;; Lists are vector-like data structures. (Random access is O(1).)
(cons 1 (cons 2 (cons 3 (list)))) ; => (1 2 3)
;; 'list' is a convenience variadic constructor for lists
(list 1 2 3) ; => (1 2 3)
;; and a quote can also be used for a literal list value
(quote (+ 1 2)) ; => (+ 1 2)

;; Can still use 'cons' to add an item to the beginning of a list
(cons 0 (list 1 2 3)) ; => (0 1 2 3)

;; Lists are a very basic type, so there is a *lot* of functionality for
;; them, a few examples:
(map inc (list 1 2 3))          ; => (2 3 4)
(filter (fn (x) (== 0 (% x 2))) (list 1 2 3 4))    ; => (2 4)
(length (list 1 2 3 4))     ; => 4

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 3. Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Use 'fn' to create functions.
;; A function always returns the value of its last expression
(fn () ""Hello World"") ; => (fn () Hello World) : fn

;; Use parentheses to call all functions, including a lambda expression
((fn () ""Hello World"")) ; => ""Hello World""

;; Assign a function to a var
(set hello-world (fn () ""Hello World""))
(hello-world) ; => ""Hello World""

;; You can shorten this using the function definition syntactic sugar:
(defn hello-world2 () ""Hello World"")

;; The () in the above is the list of arguments for the function
(set hello
  (fn (name)
    (strcat ""Hello "" name)))
(hello ""Steve"") ; => ""Hello Steve""

;; ... or equivalently, using a sugared definition:
(defn hello2 (name)
  (strcat ""Hello "" name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 4. Equality
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; for numbers use '=='
(== 3 3.0) ; => true
(== 2 1) ; => false

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 5. Control Flow
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Conditionals

(if true               ; test expression
    ""this is true""   ; then expression
    ""this is false"") ; else expression
; => ""this is true""

;;; Loops

;; for loop is for number
;; (for SYMBOL START END STEP EXPR ..)
(for i 0 10 2 (pr i """")) ; => prints 0 2 4 6 8 10
(for i 0.0 10 2.5 (pr i """")) ; => prints 0 2.5 5 7.5 10

;; while loop
((fn (i)
  (while (< i 10)
    (pr i)
    (++ i))) 0) ; => prints 0123456789

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 6. Mutation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Use 'set' to assign a new value to a variable or a place
(set n 5) ; => 5
(set n (inc n)) ; => 6
n ; => 6
(set a (list 1 2)) ; => (1 2)
(set (nth 0 a) 3) ; => 3
a ; => (3 2)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 7. Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Macros let you extend the syntax of the language.
;; Paren macros are easy.
;; In fact, (defn) is a macro.
(defmacro setfn (name ...) (set name (fn ...)))
(defmacro defn (name ...) (def name (fn ...)))

;; Let's add an infix notation
(defmacro infix (a op ...) (op a ...))
(infix 1 + 2 (infix 3 * 4)) ; => 15

;; Macros are not hygienic, you can clobber existing variables!
;; They are code transformations.
```"
"Raku (formerly Perl 6) is a highly capable, feature-rich programming language
made for at least the next hundred years.

The primary Raku compiler is called [Rakudo](http://rakudo.org), which runs on
the JVM and the [MoarVM](http://moarvm.com).

Meta-note:

* Although the pound sign (`#`) is used for sentences and notes, Pod-styled
  comments (more below about them) are used whenever it's convenient.
* `# OUTPUT:` is used to represent the output of a command to any standard
   stream. If the output has a newline, it's represented by the `␤` symbol.
   The output is always enclosed by angle brackets (`«` and `»`).
* `#=>` represents the value of an expression, return value of a sub, etc.
   In some cases, the value is accompanied by a comment.
* Backticks are used to distinguish and highlight the language constructs
  from the text.

```perl6
####################################################
# 0. Comments
####################################################

# Single line comments start with a pound sign.

#`( Multiline comments use #` and a quoting construct.
  (), [], {}, 「」, etc, will work.
)

=for comment
Use the same syntax for multiline comments to embed comments.
for #`(each element in) @array {
    put #`(or print element) $_ #`(with newline);
}

# You can also use Pod-styled comments. For example:

=comment This is a comment that extends until an empty
newline is found.

=comment
The comment doesn't need to start in the same line as the directive.

=begin comment
This comment is multiline.

Empty newlines can exist here too!
=end comment

####################################################
# 1. Variables
####################################################

# In Raku, you declare a lexical variable using the `my` keyword:
my $variable;

# Raku has 3 basic types of variables: scalars, arrays, and hashes.

#
# 1.1 Scalars
#

# Scalars represent a single value. They start with the `$` sigil:
my $str = 'String';

# Double quotes allow for interpolation (which we'll see later):
my $str2 = ""$str"";

# Variable names can contain but not end with simple quotes and dashes,
# and can contain (and end with) underscores:
my $person's-belongings = 'towel'; # this works!

my $bool = True;             # `True` and `False` are Raku's boolean values.
my $inverse = !$bool;        # Invert a bool with the prefix `!` operator.
my $forced-bool = so $str;   # And you can use the prefix `so` operator
$forced-bool = ?$str;        # to turn its operand into a Bool. Or use `?`.

#
# 1.2 Arrays and Lists
#

# Arrays represent multiple values. An array variable starts with the `@`
# sigil. Unlike lists, from which arrays inherit, arrays are mutable.

my @array = 'a', 'b', 'c';
# equivalent to:
my @letters = <a b c>;
# In the previous statement, we use the quote-words (`<>`) term for array
# of words, delimited by space. Similar to perl's qw, or Ruby's %w.

@array = 1, 2, 4;

# Array indices start at 0. Here the third element is being accessed.
say @array[2]; # OUTPUT: «4␤»

say ""Interpolate an array using []: @array[]"";
# OUTPUT: «Interpolate an array using []: 1 2 3␤»

@array[0]    = -1;     # Assigning a new value to an array index
@array[0, 1] = 5, 6;   # Assigning multiple values

my @keys = 0, 2;
@array[@keys] = @letters; # Assignment using an array containing index values
say @array;               # OUTPUT: «a 6 b␤»

#
# 1.3 Hashes, or key-value Pairs.
#

# Hashes are pairs of keys and values. You can construct a `Pair` object
# using the syntax `key => value`. Hash tables are very fast for lookup,
# and are stored unordered. Keep in mind that keys get ""flattened"" in hash
# context, and any duplicated keys are deduplicated.
my %hash = 'a' => 1, 'b' => 2;

# Keys get auto-quoted when the fat comma (`=>`) is used. Trailing commas are
# okay.
%hash = a => 1, b => 2, ;

# Even though hashes are internally stored differently than arrays,
# Raku allows you to easily create a hash from an even numbered array:
%hash = <key1 value1 key2 value2>;          # Or:
%hash = ""key1"", ""value1"", ""key2"", ""value2"";

%hash = key1 => 'value1', key2 => 'value2'; # same result as above

# You can also use the ""colon pair"" syntax. This syntax is especially
# handy for named parameters that you'll see later.
%hash = :n(2),    # equivalent to `n => 2`
        :is-even, # equivalent to `:is-even(True)` or `is-even => True`
        :!is-odd, # equivalent to `:is-odd(False)` or `is-odd => False`
;
# The `:` (as in `:is-even`) and `:!` (as `:!is-odd`) constructs are known
# as the `True` and `False` shortcuts respectively.

# As demonstrated in the example below, you can use {} to get the value from a key.
# If it's a string without spaces, you can actually use the quote-words operator
# (`<>`). Since Raku doesn't have barewords, as Perl does, `{key1}` doesn't work
# though.
say %hash{'n'};     # OUTPUT: «2␤», gets value associated to key 'n'
say %hash<is-even>; # OUTPUT: «True␤», gets value associated to key 'is-even'

####################################################
# 2. Subroutines
####################################################

# Subroutines, or functions as most other languages call them, are
# created with the `sub` keyword.
sub say-hello { say ""Hello, world"" }

# You can provide (typed) arguments. If specified, the type will be checked
# at compile-time if possible, otherwise at runtime.
sub say-hello-to( Str $name ) {
    say ""Hello, $name !"";
}

# A sub returns the last value of the block. Similarly, the semicolon in
# the last expression can be omitted.
sub return-value { 5 }
say return-value;      # OUTPUT: «5␤»

sub return-empty { }
say return-empty;      # OUTPUT: «Nil␤»

# Some control flow structures produce a value, for instance `if`:
sub return-if {
	if True { ""Truthy"" }
}
say return-if;         # OUTPUT: «Truthy␤»

# Some don't, like `for`:
sub return-for {
    for 1, 2, 3 { 'Hi' }
}
say return-for;        # OUTPUT: «Nil␤»

# Positional arguments are required by default. To make them optional, use
# the `?` after the parameters' names.

# In the following example, the sub `with-optional` returns `(Any)` (Perl's
# null-like value) if no argument is passed. Otherwise, it returns its argument.
sub with-optional( $arg? ) {
    $arg;
}
with-optional;     # returns Any
with-optional();   # returns Any
with-optional(1);  # returns 1

# You can also give provide a default value when they're not passed. Doing
# this make said parameter optional. Required parameters must come before
# optional ones.

# In the sub `greeting`, the parameter `$type` is optional.
sub greeting( $name, $type = ""Hello"" ) {
  say ""$type, $name!"";
}

greeting(""Althea"");                 # OUTPUT: «Hello, Althea!␤»
greeting(""Arthur"", ""Good morning""); # OUTPUT: «Good morning, Arthur!␤»

# You can also, by using a syntax akin to the one of hashes (yay unified syntax!),
# declared named parameters and thus pass named arguments to a subroutine.
# By default, named parameter are optional and will default to `Any`.
sub with-named( $normal-arg, :$named ) {
	say $normal-arg + $named;
}
with-named(1, named => 6); # OUTPUT: «7␤»

# There's one gotcha to be aware of, here: If you quote your key, Raku
# won't be able to see it at compile time, and you'll have a single `Pair`
# object as a positional parameter, which means the function subroutine
# `with-named(1, 'named' => 6);` fails.
with-named(2, :named(5));  # OUTPUT: «7␤»

# Similar to positional parameters, you can provide your named arguments with
# default values.
sub named-def( :$def = 5 ) {
    say $def;
}
named-def;            # OUTPUT: «5»
named-def(def => 15); # OUTPUT: «15»

# In order to make a named parameter mandatory, you can append `!` to the
# parameter. This is the inverse of `?`, which makes a required parameter
# optional.

sub with-mandatory-named( :$str! )  {
    say ""$str!"";
}
with-mandatory-named(str => ""My String""); # OUTPUT: «My String!␤»
# with-mandatory-named;   # runtime error: ""Required named parameter not passed""
# with-mandatory-named(3);# runtime error: ""Too many positional parameters passed""

# If a sub takes a named boolean argument, you can use the same ""short boolean""
# hash syntax we discussed earlier.
sub takes-a-bool( $name, :$bool ) {
    say ""$name takes $bool"";
}
takes-a-bool('config', :bool);  # OUTPUT: «config takes True␤»
takes-a-bool('config', :!bool); # OUTPUT: «config takes False␤»

# Since parenthesis can be omitted when calling a subroutine, you need to use
# `&` in order to distinguish between a call to a sub with no arguments and
# the code object.

# For instance, in this example we must use `&` to store the sub `say-hello`
# (i.e., the sub's code object) in a variable, not a subroutine call.
my &s = &say-hello;
my &other-s = sub { say ""Anonymous function!"" }

# A sub can have a ""slurpy"" parameter, or what one'd call a
# ""doesn't-matter-how-many"" parameter. This is Raku's way of supporting variadic
# functions. For this, you must use `*@` (slurpy) which will ""take everything
# else"". You can have as many parameters *before* a slurpy one, but not *after*.
sub as-many($head, *@rest) {
    @rest.join(' / ') ~ "" !"";
}
say as-many('Happy', 'Happy', 'Birthday');          # OUTPUT: «Happy / Birthday !␤»
say as-many('Happy', ['Happy', 'Birthday'], 'Day'); # OUTPUT: «Happy / Birthday / Day !␤»

# Note that the splat (the *) did not consume the parameter before it.

# There are other two variations of slurpy parameters in Raku. The previous one
# (namely, `*@`), known as flattened slurpy, flattens passed arguments. The other
# two are `**@` and `+@` known as unflattened slurpy and ""single argument rule""
# slurpy respectively. The unflattened slurpy doesn't flatten its listy
# arguments (or Iterable ones).
sub b(**@arr) { @arr.perl.say };
b(['a', 'b', 'c']);             # OUTPUT: «[[""a"", ""b"", ""c""],]»
b(1, $('d', 'e', 'f'), [2, 3]); # OUTPUT: «[1, (""d"", ""e"", ""f""), [2, 3]]»
b(1, [1, 2], ([3, 4], 5));      # OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»

# On the other hand, the ""single argument rule"" slurpy follows the ""single argument
# rule"" which dictates how to handle the slurpy argument based upon context and
# roughly states that if only a single argument is passed and that argument is
# Iterable, that argument is used to fill the slurpy parameter array. In any
# other case, `+@` works like `**@`.
sub c(+@arr) { @arr.perl.say };
c(['a', 'b', 'c']);             # OUTPUT: «[""a"", ""b"", ""c""]␤»
c(1, $('d', 'e', 'f'), [2, 3]); # OUTPUT: «[1, (""d"", ""e"", ""f""), [2, 3]]␤»
c(1, [1, 2], ([3, 4], 5));      # OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»

# You can call a function with an array using the ""argument list flattening""
# operator `|` (it's not actually the only role of this operator,
# but it's one of them).
sub concat3($a, $b, $c) {
    say ""$a, $b, $c"";
}
concat3(|@array); # OUTPUT: «a, b, c␤»
                  # `@array` got ""flattened"" as a part of the argument list

####################################################
# 3. Containers
####################################################

# In Raku, values are actually stored in ""containers"". The assignment
# operator asks the container on the left to store the value on its right.
# When passed around, containers are marked as immutable which means that,
# in a function, you'll get an error if you try to mutate one of your
# arguments. If you really need to, you can ask for a mutable container by
# using the `is rw` trait.
sub mutate( $n is rw ) {
    $n++; # postfix ++ operator increments its argument but returns its old value
}
my $m = 42;
mutate $m; #=> 42, the value is incremented but the old value is returned
say $m;    # OUTPUT: «43␤»

# This works because we are passing the container $m to the `mutate` sub.
# If we try to just pass a number instead of passing a variable, it won't work
# because there is no container being passed and integers are immutable by
# themselves:

# mutate 42; # Parameter '$n' expected a writable container, but got Int value

# Similar error would be obtained, if a bound variable is passed to
# to the subroutine. In Raku, you bind a value to a variable using the binding
# operator `:=`.
my $v := 50; # binding 50 to the variable $v
# mutate $v;   # Parameter '$n' expected a writable container, but got Int value

# If what you want is a copy instead, use the `is copy` trait which will
# cause the argument to be copied and allow you to modify the argument
# inside the routine without modifying the passed argument.

# A sub itself returns a container, which means it can be marked as `rw`.
# Alternatively, you can explicitly mark the returned container as mutable
# by using `return-rw` instead of `return`.
my $x = 42;
my $y = 45;
sub x-store is rw { $x }
sub y-store       { return-rw $y }

# In this case, the parentheses are mandatory or else Raku thinks that
# `x-store` and `y-store` are identifiers.
x-store() = 52;
y-store() *= 2;

say $x; # OUTPUT: «52␤»
say $y; # OUTPUT: «90␤»

####################################################
# 4.Control Flow Structures
####################################################

#
# 4.1 if/if-else/if-elsif-else/unless
#

# Before talking about `if`, we need to know which values are ""truthy""
# (represent `True`), and which are ""falsey"" (represent `False`). Only these
# values are falsey: 0, (), {}, """", Nil, a type (like `Str`, `Int`, etc.) and
# of course, `False` itself. Any other value is truthy.
my $number = 5;
if $number < 5 {
    say ""Number is less than 5""
}
elsif $number == 5 {
    say ""Number is equal to 5""
}
else {
    say ""Number is greater than 5""
}

unless False {
    say ""It's not false!"";
}

# `unless` is the equivalent of `if not (X)` which inverts the sense of a
# conditional statement. However, you cannot use `else` or `elsif` with it.

# As you can see, you don't need parentheses around conditions. However, you
# do need the curly braces around the ""body"" block. For example,
# `if (True) say 'It's true';` doesn't work.

# You can also use their statement modifier (postfix) versions:
say ""Quite truthy"" if True;      # OUTPUT: «Quite truthy␤»
say ""Quite falsey"" unless False; # OUTPUT: «Quite falsey␤»

# The ternary operator (`??..!!`) is structured as follows `condition ??
# expression1 !! expression2` and it returns expression1 if the condition is
# true. Otherwise, it returns expression2.
my $age = 30;
say $age > 18 ?? ""You are an adult"" !! ""You are under 18"";
# OUTPUT: «You are an adult␤»

#
# 4.2 with/with-else/with-orwith-else/without
#

# The `with` statement is like `if`, but it tests for definedness rather than
# truth, and it topicalizes on the condition, much like `given` which will
# be discussed later.
my $s = ""raku"";
with   $s.index(""r"") { say ""Found a at $_""      }
orwith $s.index(""k"") { say ""Found c at $_""      }
else                 { say ""Didn't find r or k"" }

# Similar to `unless` that checks un-truthiness, you can use `without` to
# check for undefined-ness.
my $input01;
without $input01 {
    say ""No input given.""
}
# OUTPUT: «No input given.␤»

# There are also statement modifier versions for both `with` and `without`.
my $input02 = 'Hello';
say $input02 with $input02;               # OUTPUT: «Hello␤»
say ""No input given."" without $input02;

#
# 4.3 given/when, or Raku's switch construct
#

=begin comment
`given...when` looks like other languages' `switch`, but is much more
powerful thanks to smart matching and Raku's ""topic variable"", `$_`.

The topic variable `$_ `contains the default argument of a block, a loop's
current iteration (unless explicitly named), etc.

`given` simply puts its argument into `$_` (like a block would do),
 and `when` compares it using the ""smart matching"" (`~~`) operator.

Since other Raku constructs use this variable (as said before, like `for`,
blocks, `with` statement etc), this means the powerful `when` is not only
applicable along with a `given`, but instead anywhere a `$_` exists.

=end comment

given ""foo bar"" {
    say $_;            # OUTPUT: «foo bar␤»

    # Don't worry about smart matching yet. Just know `when` uses it. This is
    # equivalent to `if $_ ~~ /foo/`.
    when /foo/ {
        say ""Yay !"";
    }

    # smart matching anything with `True` is `True`, i.e. (`$a ~~ True`)
    # so you can also put ""normal"" conditionals. For example, this `when` is
    # equivalent to this `if`: `if $_ ~~ ($_.chars > 50) {...}`
    # which means: `if $_.chars > 50 {...}`
    when $_.chars > 50 {
        say ""Quite a long string !"";
    }

    # same as `when *` (using the Whatever Star)
    default {
        say ""Something else""
    }
}

#
# 4.4 Looping constructs
#

# The `loop` construct is an infinite loop if you don't pass it arguments, but
# can also be a C-style `for` loop:
loop {
    say ""This is an infinite loop !"";
    last;
}
# In the previous example, `last` breaks out of the loop very much
# like the `break` keyword in other languages.

# The `next` keyword skips to the next iteration, like `continue` in other
# languages. Note that you can also use postfix conditionals, loops, etc.
loop (my $i = 0; $i < 5; $i++) {
    next if $i == 3;
    say ""This is a C-style for loop!"";
}

# The `for` constructs iterates over a list of elements.
my @odd-array = 1, 3, 5, 7, 9;

# Accessing the array's elements with the topic variable $_.
for @odd-array {
    say ""I've got $_ !"";
}

# Accessing the array's elements with a ""pointy block"", `->`.
# Here each element is read-only.
for @odd-array -> $variable {
    say ""I've got $variable !"";
}

# Accessing the array's elements with a ""doubly pointy block"", `<->`.
# Here each element is read-write so mutating `$variable` mutates
# that element in the array.
for @odd-array <-> $variable {
    say ""I've got $variable !"";
}

# As we saw with `given`, a `for` loop's default ""current iteration"" variable
# is `$_`. That means you can use `when` in a `for`loop just like you were
# able to in a `given`.
for @odd-array {
    say ""I've got $_"";

    # This is also allowed. A dot call with no ""topic"" (receiver) is sent to
    # `$_` (topic variable) by default.
    .say;

    # This is equivalent to the above statement.
    $_.say;
}

for @odd-array {
    # You can...
    next if $_ == 3; # Skip to the next iteration (`continue` in C-like lang.)
    redo if $_ == 4; # Re-do iteration, keeping the same topic variable (`$_`)
    last if $_ == 5; # Or break out of loop (like `break` in C-like lang.)
}

# The ""pointy block"" syntax isn't specific to the `for` loop. It's just a way
# to express a block in Raku.
sub long-computation { ""Finding factors of large primes"" }
if long-computation() -> $result {
    say ""The result is $result."";
}

####################################################
# 5. Operators
####################################################

=begin comment
Since Perl languages are very much operator-based languages, Raku
operators are actually just funny-looking subroutines, in syntactic
categories, like infix:<+> (addition) or prefix:<!> (bool not).

The categories are:
    - ""prefix"": before (like `!` in `!True`).
    - ""postfix"": after (like `++` in `$a++`).
    - ""infix"": in between (like `*` in `4 * 3`).
    - ""circumfix"": around (like `[`-`]` in `[1, 2]`).
    - ""post-circumfix"": around, after another term (like `{`-`}` in
                   `%hash{'key'}`)

The associativity and precedence list are explained below.

Alright, you're set to go!

=end comment

#
# 5.1 Equality Checking
#

# `==` is numeric comparison
say 3 == 4; # OUTPUT: «False␤»
say 3 != 4; # OUTPUT: «True␤»

# `eq` is string comparison
say 'a' eq 'b';  # OUTPUT: «False␤»
say 'a' ne 'b';  # OUTPUT: «True␤», not equal
say 'a' !eq 'b'; # OUTPUT: «True␤», same as above

# `eqv` is canonical equivalence (or ""deep equality"")
say (1, 2) eqv (1, 3); # OUTPUT: «False␤»
say (1, 2) eqv (1, 2); # OUTPUT: «True␤»
say Int === Int;       # OUTPUT: «True␤»

# `~~` is the smart match operator which aliases the left hand side to $_ and
# then evaluates the right hand side.
# Here are some common comparison semantics:

# String or numeric equality
say 'Foo' ~~ 'Foo'; # OUTPUT: «True␤», if strings are equal.
say 12.5 ~~ 12.50;  # OUTPUT: «True␤», if numbers are equal.

# Regex - For matching a regular expression against the left side.
# Returns a `Match` object, which evaluates as True if regexp matches.
my $obj = 'abc' ~~ /a/;
say $obj;       # OUTPUT: «｢a｣␤»
say $obj.WHAT;  # OUTPUT: «(Match)␤»

# Hashes
say 'key' ~~ %hash; # OUTPUT: «True␤», if key exists in hash.

# Type - Checks if left side ""is of type"" (can check superclasses and roles).
say 1 ~~ Int;       # OUTPUT: «True␤»

# Smart-matching against a boolean always returns that boolean (and will warn).
say 1 ~~ True;        # OUTPUT: «True␤», smartmatch against True always matches
say False.so ~~ True; # OUTPUT: «True␤», use .so for truthiness

# General syntax is `$arg ~~ &bool-returning-function;`. For a complete list
# of combinations, refer to the table at:
# https://docs.raku.org/language/operators#index-entry-smartmatch_operator

# Of course, you also use `<`, `<=`, `>`, `>=` for numeric comparison.
# Their string equivalent are also available: `lt`, `le`, `gt`, `ge`.
say 3 > 4;       # OUTPUT: «False␤»
say 3 >= 4;      # OUTPUT: «False␤»
say 3 < 4;       # OUTPUT: «True␤»
say 3 <= 4;      # OUTPUT: «True␤»
say 'a' gt 'b';  # OUTPUT: «False␤»
say 'a' ge 'b';  # OUTPUT: «False␤»
say 'a' lt 'b';  # OUTPUT: «True␤»
say 'a' le 'b';  # OUTPUT: «True␤»

#
# 5.2 Range constructor
#

say 3 .. 7;          # OUTPUT: «3..7␤»,   both included.
say 3 ..^ 7;         # OUTPUT: «3..^7␤»,  exclude right endpoint.
say 3 ^.. 7;         # OUTPUT: «3^..7␤»,  exclude left endpoint.
say 3 ^..^ 7;        # OUTPUT: «3^..^7␤», exclude both endpoints.

# The range 3 ^.. 7 is similar like 4 .. 7 when we only consider integers.
# But when we consider decimals:

say 3.5 ~~ 4 .. 7;	 # OUTPUT: «False␤»
say 3.5 ~~ 3 ^.. 7;	 # OUTPUT: «True␤»,

# This is because the range `3 ^.. 7` only excludes anything strictly
# equal to 3. Hence, it contains decimals greater than 3. This could
# mathematically be described as 3.5 ∈ (3,7] or in set notation,
# 3.5 ∈ { x | 3 < x ≤ 7 }.

say 3 ^.. 7 ~~ 4 .. 7; # OUTPUT: «False␤»

# This also works as a shortcut for `0..^N`:
say ^10;             # OUTPUT: «^10␤», which means 0..^10

# This also allows us to demonstrate that Raku has lazy/infinite arrays,
# using the Whatever Star:
my @natural = 1..*; # 1 to Infinite! Equivalent to `1..Inf`.

# You can pass ranges as subscripts and it'll return an array of results.
say @natural[^10]; # OUTPUT: «1 2 3 4 5 6 7 8 9 10␤», doesn't run out of memory!

# NOTE: when reading an infinite list, Raku will ""reify"" the elements
# it needs, then keep them in memory. They won't be calculated more than once.
# It also will never calculate more elements than that are needed.

# An array subscript can also be a closure. It'll be called with the array's
# length as the argument. The following two examples are equivalent:
say join(' ', @array[15..*]);            # OUTPUT: «15 16 17 18 19␤»
say join(' ', @array[-> $n { 15..$n }]); # OUTPUT: «15 16 17 18 19␤»

# NOTE: if you try to do either of those with an infinite array, you'll
# trigger an infinite loop (your program won't finish).

# You can use that in most places you'd expect, even when assigning to an array:
my @numbers = ^20;

# Here the numbers increase by 6, like an arithmetic sequence; more on the
# sequence (`...`) operator later.
my @seq =  3, 9 ... * > 95;  # 3 9 15 21 27 [...] 81 87 93 99;

# In this example, even though the sequence is infinite, only the 15
# needed values will be calculated.
@numbers[5..*] = 3, 9 ... *;
say @numbers; # OUTPUT: «0 1 2 3 4 3 9 15 21 [...] 81 87␤», only 20 values

#
# 5.3 and (&&), or (||)
#

# Here `and` calls `.Bool` on both 3 and 4 and gets `True` so it returns
# 4 since both are `True`.
say (3 and 4);     # OUTPUT: «4␤», which is truthy.
say (3 and 0);     # OUTPUT: «0␤»
say (0 and 4);     # OUTPUT: «0␤»

# Here `or` calls `.Bool` on `0` and `False` which are both `False`
# so it returns `False` since both are `False`.
say (0 or False); # OUTPUT: «False␤».

# Both `and` and `or` have tighter versions which also shortcut circuits.
# They're `&&` and `||` respectively.

# `&&` returns the first operand that evaluates to `False`. Otherwise,
# it returns the last operand.
my ($a, $b, $c, $d, $e) = 1, 0, False, True, 'pi';
say $a && $b && $c; # OUTPUT: «0␤», the first falsey value
say $a && $b && $c; # OUTPUT: «False␤», the first falsey value
say $a && $d && $e; # OUTPUT: «pi␤», last operand since everything before is truthy

# `||` returns the first argument that evaluates to `True`.
say $b || $a || $d; # OUTPUT: «1␤»
say $e || $d || $a; # OUTPUT: «pi␤»

# And because you're going to want them, you also have compound assignment
# operators:
$a *= 2;        # multiply and assignment. Equivalent to $a = $a * 2;
$b %%= 5;       # divisible by and assignment. Equivalent to $b = $b %% 2;
$c div= 3;      # return divisor and assignment. Equivalent to $c = $c div 3;
$d mod= 4;      # return remainder and assignment. Equivalent to $d = $d mod 4;
@array .= sort; # calls the `sort` method and assigns the result back

####################################################
# 6. More on subs!
####################################################

# As we said before, Raku has *really* powerful subs. We're going
# to see a few more key concepts that make them better than in any
# other language :-).

#
# 6.1 Unpacking!
#

# Unpacking is the ability to ""extract"" arrays and keys
# (AKA ""destructuring""). It'll work in `my`s and in parameter lists.
my ($f, $g) = 1, 2;
say $f;                  # OUTPUT: «1␤»
my ($, $, $h) = 1, 2, 3; # keep the non-interesting values anonymous (`$`)
say $h;                  # OUTPUT: «3␤»

my ($head, *@tail) = 1, 2, 3; # Yes, it's the same as with ""slurpy subs""
my (*@small) = 1;

sub unpack_array( @array [$fst, $snd] ) {
  say ""My first is $fst, my second is $snd! All in all, I'm @array[]."";
  # (^ remember the `[]` to interpolate the array)
}
unpack_array(@tail);
# OUTPUT: «My first is 2, my second is 3! All in all, I'm 2 3.␤»

# If you're not using the array itself, you can also keep it anonymous,
# much like a scalar:
sub first-of-array( @ [$fst] ) { $fst }
first-of-array(@small); #=> 1

# However calling `first-of-array(@tail);` will throw an error (""Too many
# positional parameters passed""), which means the `@tail` has too many
# elements.

# You can also use a slurpy parameter. You could keep `*@rest` anonymous
# Here, `@rest` is `(3,)`, since `$fst` holds the `2`. This results
# since the length (.elems) of `@rest` is 1.
sub slurp-in-array(@ [$fst, *@rest]) {
    say $fst + @rest.elems;
}
slurp-in-array(@tail); # OUTPUT: «3␤»

# You could even extract on a slurpy (but it's pretty useless ;-).)
sub fst(*@ [$fst]) { # or simply: `sub fst($fst) { ... }`
    say $fst;
}
fst(1);    # OUTPUT: «1␤»

# Calling `fst(1, 2);` will throw an error (""Too many positional parameters
# passed"") though. After all, the `fst` sub declares only a single positional
# parameter.

# You can also destructure hashes (and classes, which you'll learn about later).
# The syntax is basically the same as
# `%hash-name (:key($variable-to-store-value-in))`.
# The hash can stay anonymous if you only need the values you extracted.

# In order to call the function, you must supply a hash wither created with
# curly braces or with `%()` (recommended). Alternatively, you can pass
# a variable that contains a hash.

sub key-of( % (:value($val), :qua($qua)) ) {
 	say ""Got value $val, $qua time"" ~~
        $qua == 1 ?? '' !! 's';
}

my %foo-once = %(value => 'foo', qua => 1);
key-of({value => 'foo', qua => 2});  # OUTPUT: «Got val foo, 2 times.␤»
key-of(%(value => 'foo', qua => 0)); # OUTPUT: «Got val foo, 0 times.␤»
key-of(%foo-once);                   # OUTPUT: «Got val foo, 1 time.␤»

# The last expression of a sub is returned automatically (though you may
# indicate explicitly by using the `return` keyword, of course):
sub next-index( $n ) {
 	$n + 1;
}
my $new-n = next-index(3); # $new-n is now 4

# This is true for everything, except for the looping constructs (due to
# performance reasons): there's no reason to build a list if we're just going to
# discard all the results. If you still want to build one, you can use the
# `do` statement prefix or the `gather` prefix, which we'll see later:

sub list-of( $n ) {
 	do for ^$n { $_ }
}
my @list3 = list-of(3); #=> (0, 1, 2)

#
# 6.2 Lambdas (or anonymous subroutines)
#

# You can create a lambda by using a pointy block (`-> {}`), a
# block (`{}`) or creating a `sub` without a name.

my &lambda1 = -> $argument {
	""The argument passed to this lambda is $argument""
}

my &lambda2 = {
	""The argument passed to this lambda is $_""
}

my &lambda3 = sub ($argument) {
	""The argument passed to this lambda is $argument""
}

# Both pointy blocks and blocks are pretty much the same thing, except that
# the former can take arguments, and that the latter can be mistaken as
# a hash by the parser. That being said, blocks can declare what's known
# as placeholders parameters through the twigils `$^` (for positional
# parameters) and `$:` (for named parameters). More on them later on.

my &mult = { $^numbers * $:times }
say mult 4, :times(6); #=> «24␤»

# Both pointy blocks and blocks are quite versatile when working with functions
# that accepts other functions such as `map`, `grep`, etc. For example,
# we add 3 to each value of an array using the `map` function with a lambda:
my @nums = 1..4;
my @res1 = map -> $v { $v + 3 }, @nums; # pointy block, explicit parameter
my @res2 = map { $_ + 3 },       @nums; # block using an implicit parameter
my @res3 = map { $^val + 3 },    @nums; # block with placeholder parameter

# A sub (`sub {}`) has different semantics than a block (`{}` or `-> {}`):
# A block doesn't have a ""function context"" (though it can have arguments),
# which means that if you return from it, you're going to return from the
# parent function.

# Compare:
sub is-in( @array, $elem ) {
   say map({ return True if $_ == $elem }, @array);
   say 'Hi';
}

# with:
sub truthy-array( @array ) {
    say map sub ($i) { $i ?? return True !! return False }, @array;
    say 'Hi';
}

# In the `is-in` sub, the block will `return` out of the `is-in` sub once the
# condition evaluates to `True`, the loop won't be run anymore and the
# following statement won't be executed. The last statement is only executed
# if the block never returns.

# On the contrary, the `truthy-array` sub will produce an array of `True` and
# `False`, which will printed, and always execute the last execute statement.
# Thus, the `return` only returns from the anonymous `sub`

# The `anon` declarator can be used to create an anonymous sub from a
# regular subroutine. The regular sub knows its name but its symbol is
# prevented from getting installed in the lexical scope, the method table
# and everywhere else.
my $anon-sum = anon sub summation(*@a) { [+] @a }
say $anon-sum.name;     # OUTPUT: «summation␤»
say $anon-sum(2, 3, 5); # OUTPUT: «10␤»
#say summation;         # Error: Undeclared routine: ...

# You can also use the Whatever Star to create an anonymous subroutine.
# (it'll stop at the furthest operator in the current expression).
# The following is the same as `{$_ + 3 }`, `-> { $a + 3 }`,
# `sub ($a) { $a + 3 }`, or even `{$^a + 3}` (more on this later).
my @arrayplus3v0 = map * + 3, @nums;

# The following is the same as `-> $a, $b { $a + $b + 3 }`,
# `sub ($a, $b) { $a + $b + 3 }`, or `{ $^a + $^b + 3 }` (more on this later).
my @arrayplus3v1 = map * + * + 3, @nums;

say (*/2)(4); # OUTPUT: «2␤», immediately execute the Whatever function created.
say ((*+3)/5)(5); # OUTPUT: «1.6␤», it works even in parens!

# But if you need to have more than one argument (`$_`) in a block (without
# wanting to resort to `-> {}`), you can also either `$^` and `$:` which
# declared placeholder parameters or self-declared positional/named parameters.
say map { $^a + $^b + 3 }, @nums;

# which is equivalent to the following which uses a `sub`:
map sub ($a, $b) { $a + $b + 3 }, @nums;

# Placeholder parameters are sorted lexicographically so the following two
# statements are equivalent:
say sort           { $^b <=> $^a }, @nums;
say sort -> $a, $b { $b  <=> $a  }, @nums;

#
# 6.3 Multiple Dispatch
#

# Raku can decide which variant of a `sub` to call based on the type of the
# arguments, or on arbitrary preconditions, like with a type or `where`:

# with types:
multi sub sayit( Int $n ) { # note the `multi` keyword here
    say ""Number: $n"";
}
multi sayit( Str $s ) {     # a multi is a `sub` by default
    say ""String: $s"";
}
sayit ""foo""; # OUTPUT: «String: foo␤»
sayit 25;    # OUTPUT: «Number: 25␤»
sayit True;  # fails at *compile time* with ""calling 'sayit' will never
             # work with arguments of types ...""

# with arbitrary preconditions (remember subsets?):
multi is-big(Int $n where * > 50) { ""Yes!"" }    # using a closure
multi is-big(Int $n where {$_ > 50}) { ""Yes!"" } # similar to above
multi is-big(Int $ where 10..50)  { ""Quite."" }  # Using smart-matching
multi is-big(Int $) { ""No"" }

subset Even of Int where * %% 2;
multi odd-or-even(Even) { ""Even"" } # Using the type. We don't name the argument.
multi odd-or-even($) { ""Odd"" }     # ""everything else"" hence the $ variable

# You can even dispatch based on the presence of positional and named arguments:
multi with-or-without-you($with) {
    say ""I wish I could but I can't"";
}
multi with-or-without-you(:$with) {
    say ""I can live! Actually, I can't."";
}
multi with-or-without-you {
    say ""Definitely can't live."";
}

# This is very, very useful for many purposes, like `MAIN` subs (covered
# later), and even the language itself uses it in several places.

# For example, the `is` trait is actually a `multi sub` named `trait_mod:<is>`,
# and it works off that. Thus, `is rw`, is simply a dispatch to a function with
# this signature `sub trait_mod:<is>(Routine $r, :$rw!) {}`

####################################################
# 7. About types...
####################################################

# Raku is gradually typed. This means you can specify the type of your
# variables/arguments/return types, or you can omit the type annotations in
# in which case they'll default to `Any`. Obviously you get access to a few
# base types, like `Int` and `Str`. The constructs for declaring types are
# `subset`, `class`, `role`, etc. which you'll see later.

# For now, let us examine `subset` which is a ""sub-type"" with additional
# checks. For example, ""a very big integer is an `Int` that's greater than 500"".
# You can specify the type you're subtyping (by default, `Any`), and add
# additional checks with the `where` clause.
subset VeryBigInteger of Int where * > 500;

# Or the set of the whole numbers:
subset WholeNumber of Int where * >= 0;
my WholeNumber $whole-six    = 6;  # OK
#my WholeNumber $nonwhole-one = -1; # Error: type check failed...

# Or the set of Positive Even Numbers whose Mod 5 is 1. Notice we're
# using the previously defined WholeNumber subset.
subset PENFO of WholeNumber where { $_ %% 2 and $_ mod 5 == 1 };
my PENFO $yes-penfo = 36;  # OK
#my PENFO $no-penfo  = 2;  # Error: type check failed...

####################################################
# 8. Scoping
####################################################

# In Raku, unlike many scripting languages, (such as Python, Ruby, PHP),
# you must declare your variables before using them. The `my` declarator
# we've used so far uses ""lexical scoping"". There are a few other declarators,
# (`our`, `state`, ..., ) which we'll see later. This is called
# ""lexical scoping"", where in inner blocks, you can access variables from
# outer blocks.

my $file_scoped = 'Foo';
sub outer {
    my $outer_scoped = 'Bar';
    sub inner {
        say ""$file_scoped $outer_scoped"";
    }
    &inner; # return the function
}
outer()();  # OUTPUT: «Foo Bar␤»

# As you can see, `$file_scoped` and `$outer_scoped` were captured.
# But if we were to try and use `$outer_scoped` outside the `outer` sub,
# the variable would be undefined (and you'd get a compile time error).

####################################################
# 9. Twigils
####################################################

# There are many special `twigils` (composed sigils) in Raku. Twigils
# define a variable's scope.
# The `*` and `?` twigils work on standard variables:
#     * for dynamic variables
#     ? for compile-time variables
#
# The `!` and the `.` twigils are used with Raku's objects:
#     ! for attributes (instance attribute)
#     . for methods (not really a variable)

#
# `*` twigil: Dynamic Scope
#

# These variables use the `*` twigil to mark dynamically-scoped variables.
# Dynamically-scoped variables are looked up through the caller, not through
# the outer scope.

my $*dyn_scoped_1 = 1;
my $*dyn_scoped_2 = 10;

sub say_dyn {
    say ""$*dyn_scoped_1 $*dyn_scoped_2"";
}

sub call_say_dyn {
    # Defines $*dyn_scoped_1 only for this sub.
    my $*dyn_scoped_1 = 25;

    # Will change the value of the file scoped variable.
    $*dyn_scoped_2 = 100;

    # $*dyn_scoped 1 and 2 will be looked for in the call.
    say_dyn();  # OUTPUT: «25 100␤»

    # The call to `say_dyn` uses the value of $*dyn_scoped_1 from inside
    # this sub's lexical scope even though the blocks aren't nested (they're
    # call-nested).
}
say_dyn();      # OUTPUT: «1 10␤»

# Uses $*dyn_scoped_1 as defined in `call_say_dyn` even though we are calling it
# from outside.
call_say_dyn(); # OUTPUT: «25 100␤»

# We changed the value of $*dyn_scoped_2 in `call_say_dyn` so now its
# value has changed.
say_dyn();      # OUTPUT: «1 100␤»

# TODO: Add information about remaining twigils

####################################################
# 10. Object Model
####################################################

# To call a method on an object, add a dot followed by the method name:
# `$object.method`

# Classes are declared with the `class` keyword. Attributes are declared
# with the `has` keyword, and methods declared with the `method` keyword.

# Every attribute that is private uses the `!` twigil. For example: `$!attr`.
# Immutable public attributes use the `.` twigil which creates a read-only
# method named after the attribute. In fact, declaring an attribute with `.`
# is equivalent to declaring the same attribute with `!` and then creating
# a read-only method with the attribute's name. However, this is done for us
# by Raku automatically. The easiest way to remember the `$.` twigil is
# by comparing it to how methods are called.

# Raku's object model (""SixModel"") is very flexible, and allows you to
# dynamically add methods, change semantics, etc... Unfortunately, these will
# not all be covered here, and you should refer to:
# https://docs.raku.org/language/objects.html.

class Human {
    has Str $.name;           # `$.name` is immutable but with an accessor method.
    has Str $.bcountry;       # Use `$!bcountry` to modify it inside the class.
	has Str $.ccountry is rw; # This attribute can be modified from outside.
	has Int $!age = 0;        # A private attribute with default value.

	method birthday {
		$!age += 1; # Add a year to human's age
	}

	method get-age {
		return $!age;
	}

	# This method is private to the class. Note the `!` before the
	# method's name.
	method !do-decoration {
    	return ""$!name born in $!bcountry and now lives in $!ccountry.""
  	}

  	# This method is public, just like `birthday` and `get-age`.
  	method get-info {
        # Invoking a method on `self` inside the class.
        # Use `self!priv-method` for private method.
  		say self!do-decoration;

  		# Use `self.public-method` for public method.
  		say ""Age: "", self.get-age;
  	}
};

# Create a new instance of Human class.
# NOTE: Only attributes declared with the `.` twigil can be set via the
# default constructor (more later on). This constructor only accepts named
# arguments.
my $person1 = Human.new(
	name     => ""Jord"",
	bcountry => ""Togo"",
	ccountry => ""Togo""
);

# Make human 10 years old.
$person1.birthday for 1..10;

say $person1.name;     # OUTPUT: «Jord␤»
say $person1.bcountry; # OUTPUT: «Togo␤»
say $person1.ccountry; # OUTPUT: «Togo␤»
say $person1.get-age;  # OUTPUT: «10␤»

# This fails, because the `has $.bcountry`is immutable. Jord can't change
# his birthplace.
# $person1.bcountry = ""Mali"";

# This works because the `$.ccountry` is mutable (`is rw`). Now Jord's
# current country is France.
$person1.ccountry = ""France"";

# Calling methods on the instance objects.
$person1.birthday;      #=> 1
$person1.get-info;      #=> Jord born in Togo and now lives in France. Age: 10
# $person1.do-decoration; # This fails since the method `do-decoration` is private.

#
# 10.1 Object Inheritance
#

# Raku also has inheritance (along with multiple inheritance). While
# methods are inherited, submethods are not. Submethods are useful for
# object construction and destruction tasks, such as `BUILD`, or methods that
# must be overridden by subtypes. We will learn about `BUILD` later on.

class Parent {
  	has $.age;
 	has $.name;

  	# This submethod won't be inherited by the Child class.
  	submethod favorite-color {
    	say ""My favorite color is Blue"";
  	}

  	# This method is inherited
  	method talk { say ""Hi, my name is $!name"" }
}

# Inheritance uses the `is` keyword
class Child is Parent {
  	method talk { say ""Goo goo ga ga"" }
  	# This shadows Parent's `talk` method.
  	# This child hasn't learned to speak yet!
}

my Parent $Richard .= new(age => 40, name => 'Richard');
$Richard.favorite-color;  # OUTPUT: «My favorite color is Blue␤»
$Richard.talk;            # OUTPUT: «Hi, my name is Richard␤»
# $Richard is able to access the submethod and he knows how to say his name.

my Child $Madison .= new(age => 1, name => 'Madison');
$Madison.talk;            # OUTPUT: «Goo goo ga ga␤», due to the overridden method.
# $Madison.favorite-color # does not work since it is not inherited.

# When you use `my T $var`, `$var` starts off with `T` itself in it, so you can
# call `new` on it. (`.=` is just the dot-call and the assignment operator).
# Thus, `$a .= b` is the same as `$a = $a.b`. Also note that `BUILD` (the method
# called inside `new`) will set parent's properties too, so you can pass `val =>
# 5`.

#
# 10.2 Roles, or Mixins
#

# Roles are supported too (which are called Mixins in other languages)
role PrintableVal {
  	has $!counter = 0;
  	method print {
    	say $.val;
  	}
}

# you ""apply"" a role (or mixin) with the `does` keyword:
class Item does PrintableVal {
  	has $.val;

    =begin comment
    When `does`-ed, a `role` literally ""mixes in"" the class:
    the methods and attributes are put together, which means a class
    can access the private attributes/methods of its roles (but
    not the inverse!):
    =end comment
  	method access {
  		say $!counter++;
  	}

    =begin comment
    However, this: method print {} is ONLY valid when `print` isn't a `multi`
    with the same dispatch. This means a parent class can shadow a child class's
    `multi print() {}`, but it's an error if a role does)

    NOTE: You can use a role as a class (with `is ROLE`). In this case,
    methods will be shadowed, since the compiler will consider `ROLE`
    to be a class.
    =end comment
}

####################################################
# 11. Exceptions
####################################################

# Exceptions are built on top of classes, in the package `X` (like `X::IO`).
# In Raku, exceptions are automatically 'thrown':

# open 'foo';   # OUTPUT: «Failed to open file foo: no such file or directory␤»

# It will also print out what line the error was thrown at
# and other error info.

# You can throw an exception using `die`. Here it's been commented out to
# avoid stopping the program's execution:
# die 'Error!'; # OUTPUT: «Error!␤»

# Or more explicitly (commented out too):
# X::AdHoc.new(payload => 'Error!').throw; # OUTPUT: «Error!␤»

# In Raku, `orelse` is similar to the `or` operator, except it only matches
# undefined variables instead of anything evaluating as `False`.
# Undefined values include: `Nil`, `Mu` and `Failure` as well as `Int`, `Str`
# and other types that have not been initialized to any value yet.
# You can check if something is defined or not using the defined method:
my $uninitialized;
say $uninitialized.defined; # OUTPUT: «False␤»

# When using `orelse` it will disarm the exception and alias $_ to that
# failure. This will prevent it to being automatically handled and printing
# lots of scary error messages to the screen. We can use the `exception`
# method on the `$_` variable to access the exception
open 'foo' orelse say ""Something happened {.exception}"";

# This also works:
open 'foo' orelse say ""Something happened $_"";
# OUTPUT: «Something happened Failed to open file foo: no such file or directory␤»

# Both of those above work but in case we get an object from the left side
# that is not a failure we will probably get a warning. We see below how we
# can use try` and `CATCH` to be more specific with the exceptions we catch.

#
# 11.1 Using `try` and `CATCH`
#

# By using `try` and `CATCH` you can contain and handle exceptions without
# disrupting the rest of the program. The `try` block will set the last
# exception to the special variable `$!` (known as the error variable).
# NOTE: This has no relation to $!variables seen inside class definitions.

try open 'foo';
say ""Well, I tried! $!"" if defined $!;
# OUTPUT: «Well, I tried! Failed to open file foo: no such file or directory␤»

# Now, what if we want more control over handling the exception?
# Unlike many other languages, in Raku, you put the `CATCH` block *within*
# the block to `try`. Similar to how the `$_` variable was set when we
# 'disarmed' the exception with `orelse`, we also use `$_` in the CATCH block.
# NOTE: The `$!` variable is only set *after* the `try` block has caught an
# exception. By default, a `try` block has a `CATCH` block of its own that
# catches any exception (`CATCH { default {} }`).

try {
    my $a = (0 %% 0);
    CATCH {
        default { say ""Something happened: $_"" }
    }
}
# OUTPUT: «Something happened: Attempt to divide by zero using infix:<%%>␤»

# You can redefine it using `when`s (and `default`) to handle the exceptions
# you want to catch explicitly:

try {
  open 'foo';
    CATCH {
        # In the `CATCH` block, the exception is set to the $_ variable.
        when X::AdHoc {
            say ""Error: $_""
        }
        when X::Numeric::DivideByZero {
            say ""Error: $_"";
        }

        =begin comment
        Any other exceptions will be re-raised, since we don't have a `default`.
        Basically, if a `when` matches (or there's a `default`), the
	    exception is marked as ""handled"" so as to prevent its re-throw
        from the `CATCH` block. You still can re-throw the exception
        (see below) by hand.
        =end comment
        default {
            say ""Any other error: $_""
        }
  }
}
# OUTPUT: «Failed to open file /dir/foo: no such file or directory␤»

# There are also some subtleties to exceptions. Some Raku subs return a
# `Failure`, which is a wrapper around an `Exception` object which is
# ""unthrown"". They're not thrown until you try to use the variables containing
# them unless you call `.Bool`/`.defined` on them - then they're handled.
# (the `.handled` method is `rw`, so you can mark it as `False` back yourself)
# You can throw a `Failure` using `fail`. Note that if the pragma `use fatal`
# is on, `fail` will throw an exception (like `die`).

my $value = 0/0; # We're not trying to access the value, so no problem.
try {
    say 'Value: ', $value; # Trying to use the value
    CATCH {
        default {
            say ""It threw because we tried to get the fail's value!""
        }
  }
}

# There is also another kind of exception: Control exceptions. Those are ""good""
# exceptions, which happen when you change your program's flow, using operators
# like `return`, `next` or `last`. You can ""catch"" those with `CONTROL` (not 100%
# working in Rakudo yet).

####################################################
# 12. Packages
####################################################

# Packages are a way to reuse code. Packages are like ""namespaces"", and any
# element of the six model (`module`, `role`, `class`, `grammar`, `subset` and
# `enum`) are actually packages. (Packages are the lowest common denominator)
# Packages are important - especially as Perl is well-known for CPAN,
# the Comprehensive Perl Archive Network.

# You can use a module (bring its declarations into scope) with `use`:
use JSON::Tiny; # if you installed Rakudo* or Panda, you'll have this module
say from-json('[1]').perl; # OUTPUT: «[1]␤»

# You should not declare packages using the `package` keyword (unlike Perl).
# Instead, use `class Package::Name::Here;` to declare a class, or if you only
# want to export variables/subs, you can use `module` instead.

# If `Hello` doesn't exist yet, it'll just be a ""stub"", that can be redeclared
# as something else later.
module Hello::World { # bracketed form
    # declarations here
}

# The file-scoped form which extends until the end of the file. For
# instance, `unit module Parse::Text;` will extend until of the file.

# A grammar is a package, which you could `use`. You will learn more about
# grammars in the regex section.
grammar Parse::Text::Grammar {
}

# As said before, any part of the six model is also a package.
# Since `JSON::Tiny` uses its own `JSON::Tiny::Actions` class, you can use it:
my $actions = JSON::Tiny::Actions.new;

# We'll see how to export variables and subs in the next part.

####################################################
# 13. Declarators
####################################################

# In Raku, you get different behaviors based on how you declare a variable.
# You've already seen `my` and `has`, we'll now explore the others.

# `our` - these declarations happen at `INIT` time -- (see ""Phasers"" below).
# It's like `my`, but it also creates a package variable. All packagish
# things such as `class`, `role`, etc. are `our` by default.

module Var::Increment {
    # NOTE: `our`-declared variables cannot be typed.
    our $our-var = 1;
    my $my-var = 22;

    our sub Inc {
        our sub available { # If you try to make inner `sub`s `our`...
                            # ... Better know what you're doing (Don't !).
            say ""Don't do that. Seriously. You'll get burned."";
        }

        my sub unavailable { # `sub`s are `my`-declared by default
            say ""Can't access me from outside, I'm 'my'!"";
        }
        say ++$our-var; # Increment the package variable and output its value
  }

}

say $Var::Increment::our-var; # OUTPUT: «1␤», this works!
say $Var::Increment::my-var;  # OUTPUT: «(Any)␤», this will not work!

say Var::Increment::Inc;  # OUTPUT: «2␤»
say Var::Increment::Inc;  # OUTPUT: «3␤», notice how the value of $our-var was retained.

# Var::Increment::unavailable;  # OUTPUT: «Could not find symbol '&unavailable'␤»

# `constant` - these declarations happen at `BEGIN` time. You can use
# the `constant` keyword to declare a compile-time variable/symbol:
constant Pi = 3.14;
constant $var = 1;

# And if you're wondering, yes, it can also contain infinite lists.
constant why-not = 5, 15 ... *;
say why-not[^5]; # OUTPUT: «5 15 25 35 45␤»

# `state` - these declarations happen at run time, but only once. State
# variables are only initialized one time. In other languages such as C
# they exist as `static` variables.
sub fixed-rand {
    state $val = rand;
    say $val;
}
fixed-rand for ^10; # will print the same number 10 times

# Note, however, that they exist separately in different enclosing contexts.
# If you declare a function with a `state` within a loop, it'll re-create the
# variable for each iteration of the loop. See:
for ^5 -> $a {
    sub foo {
        # This will be a different value for every value of `$a`
        state $val = rand;
    }
    for ^5 -> $b {
        # This will print the same value 5 times, but only 5. Next iteration
        # will re-run `rand`.
        say foo;
    }
}

####################################################
# 14. Phasers
####################################################

# Phasers in Raku are blocks that happen at determined points of time in
# your program. They are called phasers because they mark a change in the
# phase of a program.  For example, when the program is compiled, a for loop
# runs, you leave a block, or an exception gets thrown (The `CATCH` block is
# actually a phaser!). Some of them can be used for their return values,
# some of them can't (those that can have a ""[*]"" in the beginning of their
# explanation text). Let's have a look!

#
# 14.1 Compile-time phasers
#
BEGIN { say ""[*] Runs at compile time, as soon as possible, only once"" }
CHECK { say ""[*] Runs at compile time, as late as possible, only once"" }

#
# 14.2 Run-time phasers
#
INIT { say ""[*] Runs at run time, as soon as possible, only once"" }
END  { say ""Runs at run time, as late as possible, only once"" }

#
# 14.3 Block phasers
#
ENTER { say ""[*] Runs every time you enter a block, repeats on loop blocks"" }
LEAVE {
    say ""Runs every time you leave a block, even when an exception
    happened. Repeats on loop blocks.""
}

PRE {
    say ""Asserts a precondition at every block entry,
        before ENTER (especially useful for loops)"";
    say ""If this block doesn't return a truthy value,
        an exception of type X::Phaser::PrePost is thrown."";
}

# Example (commented out):
for 0..2 {
    # PRE { $_ > 1 } # OUTPUT: «Precondition '{ $_ > 1 }' failed
}

POST {
    say ""Asserts a postcondition at every block exit,
        after LEAVE (especially useful for loops)"";
    say ""If this block doesn't return a truthy value,
        an exception of type X::Phaser::PrePost is thrown, like PRE."";
}

# Example (commented out):
for 0..2 {
    # POST { $_ < 1 } # OUTPUT: «Postcondition '{ $_ < 1 }' failed
}

#
# 14.4 Block/exceptions phasers
#
{
    KEEP { say ""Runs when you exit a block successfully
                (without throwing an exception)"" }
    UNDO { say ""Runs when you exit a block unsuccessfully
                (by throwing an exception)"" }
}

#
# 14.5 Loop phasers
#
for ^5 {
  FIRST { say ""[*] The first time the loop is run, before ENTER"" }
  NEXT  { say ""At loop continuation time, before LEAVE"" }
  LAST  { say ""At loop termination time, after LEAVE"" }
}

#
# 14.6 Role/class phasers
#
COMPOSE {
    say ""When a role is composed into a class. /!\ NOT YET IMPLEMENTED""
}

# They allow for cute tricks or clever code...:
say ""This code took "" ~ (time - CHECK time) ~ ""s to compile"";

# ... or clever organization:
class DB {
    method start-transaction { say ""Starting transaction!"" }
    method commit            { say ""Committing transaction..."" }
    method rollback          { say ""Something went wrong. Rolling back!"" }
}

sub do-db-stuff {
    my DB $db .= new;
  	$db.start-transaction; # start a new transaction
  	KEEP $db.commit;       # commit the transaction if all went well
  	UNDO $db.rollback;     # or rollback if all hell broke loose
}

do-db-stuff();

####################################################
# 15. Statement prefixes
####################################################

# Those act a bit like phasers: they affect the behavior of the following
# code. Though, they run in-line with the executable code, so they're in
# lowercase. (`try` and `start` are theoretically in that list, but explained
# elsewhere) NOTE: all of these (except start) don't need explicit curly
# braces `{` and `}`.

#
# 15.1 `do` - It runs a block or a statement as a term.
#

# Normally you cannot use a statement as a value (or ""term""). `do` helps
# us do it. With `do`, an `if`, for example, becomes a term returning a value.
=for comment :reason<this fails since `if` is a statement>
my $value = if True { 1 }

# this works!
my $get-five = do if True { 5 }

#
# 15.1 `once` - makes sure a piece of code only runs once.
#
for ^5 {
	once say 1
};
# OUTPUT: «1␤», only prints ... once

# Similar to `state`, they're cloned per-scope.
for ^5 {
	sub { once say 1 }()
};
# OUTPUT: «1 1 1 1 1␤», prints once per lexical scope.

#
# 15.2 `gather` - co-routine thread.
#

# The `gather` constructs allows us to `take` several values from an array/list,
# much like `do`.
say gather for ^5 {
    take $_ * 3 - 1;
    take $_ * 3 + 1;
}
# OUTPUT: «-1 1 2 4 5 7 8 10 11 13␤»

say join ',', gather if False {
    take 1;
    take 2;
    take 3;
}
# Doesn't print anything.

#
# 15.3 `eager` - evaluates a statement eagerly (forces eager context).

# Don't try this at home. This will probably hang for a while (and might crash)
# so commented out.
# eager 1..*;

# But consider, this version which doesn't print anything
constant thricev0 = gather for ^3 { say take $_ };
# to:
constant thricev1 = eager gather for ^3 { say take $_ }; # OUTPUT: «0 1 2␤»

####################################################
# 16. Iterables
####################################################

# Iterables are objects that can be iterated over for things such as
# the `for` construct.

#
# 16.1 `flat` - flattens iterables.
#
say (1, 10, (20, 10) );      # OUTPUT: «(1 10 (20 10))␤»,  notice how nested
                             # lists are preserved
say (1, 10, (20, 10) ).flat; # OUTPUT: «(1 10 20 10)␤», now the iterable is flat

#
# 16.2 `lazy` - defers actual evaluation until value is fetched by forcing lazy context.
#
my @lazy-array = (1..100).lazy;
say @lazy-array.is-lazy; # OUTPUT: «True␤», check for laziness with the `is-lazy` method.

say @lazy-array;         # OUTPUT: «[...]␤», List has not been iterated on!

# This works and will only do as much work as is needed.
for @lazy-array { .print };

# (**TODO** explain that gather/take and map are all lazy)

#
# 16.3 `sink` - an `eager` that discards the results by forcing sink context.
#
constant nilthingie = sink for ^3 { .say } #=> 0 1 2
say nilthingie.perl;                       # OUTPUT: «Nil␤»

#
# 16.4 `quietly` - suppresses warnings in blocks.
#
quietly { warn 'This is a warning!' }; # No output

####################################################
# 17. More operators thingies!
####################################################

# Everybody loves operators! Let's get more of them.

# The precedence list can be found here:
# https://docs.raku.org/language/operators#Operator_Precedence
# But first, we need a little explanation about associativity:

#
# 17.1 Binary operators
#

my ($p, $q, $r) = (1, 2, 3);

# Given some binary operator § (not a Raku-supported operator), then:

# $p § $q § $r; # with a left-associative  §, this is ($p § $q) § $r
# $p § $q § $r; # with a right-associative §, this is $p § ($q § $r)
# $p § $q § $r; # with a non-associative   §, this is illegal
# $p § $q § $r; # with a chain-associative §, this is ($p § $q) and ($q § $r)§
# $p § $q § $r; # with a list-associative  §, this is `infix:<>`

#
# 17.2 Unary operators
#

# Given some unary operator § (not a Raku-supported operator), then:
# §$p§ # with left-associative  §, this is (§$p)§
# §$p§ # with right-associative §, this is §($p§)
# §$p§ # with non-associative   §, this is illegal

#
# 17.3 Create your own operators!
#

# Okay, you've been reading all of that, so you might want to try something
# more exciting?! I'll tell you a little secret (or not-so-secret):
# In Raku, all operators are actually just funny-looking subroutines.

# You can declare an operator just like you declare a sub. In the following
# example, `prefix` refers to the operator categories (prefix, infix, postfix,
# circumfix, and post-circumfix).
sub prefix:<win>( $winner ) {
	say ""$winner Won!"";
}
win ""The King""; # OUTPUT: «The King Won!␤»

# you can still call the sub with its ""full name"":
say prefix:<!>(True);      # OUTPUT: «False␤»
prefix:<win>(""The Queen""); # OUTPUT: «The Queen Won!␤»

sub postfix:<!>( Int $n ) {
    [*] 2..$n; # using the reduce meta-operator... See below ;-)!
}
say 5!; # OUTPUT: «120␤»

# Postfix operators ('after') have to come *directly* after the term.
# No whitespace. You can use parentheses to disambiguate, i.e. `(5!)!`

sub infix:<times>( Int $n, Block $r ) { # infix ('between')
    for ^$n {
        # You need the explicit parentheses to call the function in `$r`,
        # else you'd be referring at the code object itself, like with `&r`.
        $r();
    }
}
3 times -> { say ""hello"" }; # OUTPUT: «hello␤hello␤hello␤»

# It's recommended to put spaces around your infix operator calls.

# For circumfix and post-circumfix ones
multi circumfix:<[ ]>( Int $n ) {
    $n ** $n
}
say [5]; # OUTPUT: «3125␤»

# Circumfix means 'around'. Again, no whitespace.

multi postcircumfix:<{ }>( Str $s, Int $idx ) {
    $s.substr($idx, 1);
}
say ""abc""{1}; # OUTPUT: «b␤», after the term `""abc""`, and around the index (1)

# Post-circumfix is 'after a term, around something'

# This really means a lot -- because everything in Raku uses this.
# For example, to delete a key from a hash, you use the `:delete` adverb
# (a simple named argument underneath). For instance, the following statements
# are equivalent.
my %person-stans =
    'Giorno Giovanna'  => 'Gold Experience',
    'Bruno Bucciarati' => 'Sticky Fingers';
my $key = 'Bruno Bucciarati';
%person-stans{$key}:delete;
postcircumfix:<{ }>( %person-stans, 'Giorno Giovanna', :delete );
# (you can call operators like this)

# It's *all* using the same building blocks! Syntactic categories
# (prefix infix ...), named arguments (adverbs), ..., etc. used to build
# the language - are available to you. Obviously, you're advised against
# making an operator out of *everything* -- with great power comes great
# responsibility.

#
# 17.4 Meta operators!
#

# Oh boy, get ready!. Get ready, because we're delving deep into the rabbit's
# hole, and you probably won't want to go back to other languages after
# reading this. (I'm guessing you don't want to go back at this point but
# let's continue, for the journey is long and enjoyable!).

# Meta-operators, as their name suggests, are *composed* operators. Basically,
# they're operators that act on another operators.

# The reduce meta-operator is a prefix meta-operator that takes a binary
# function and one or many lists. If it doesn't get passed any argument,
# it either returns a ""default value"" for this operator (a meaningless value)
# or `Any` if there's none (examples below). Otherwise, it pops an element
# from the list(s) one at a time, and applies the binary function to the last
# result (or the first element of a list) and the popped element.

# To sum a list, you could use the reduce meta-operator with `+`, i.e.:
say [+] 1, 2, 3; # OUTPUT: «6␤», equivalent to (1+2)+3.

# To multiply a list
say [*] 1..5; # OUTPUT: «120␤», equivalent to ((((1*2)*3)*4)*5).

# You can reduce with any operator, not just with mathematical ones.
# For example, you could reduce with `//` to get first defined element
# of a list:
say [//] Nil, Any, False, 1, 5;  # OUTPUT: «False␤»
                                 # (Falsey, but still defined)
# Or with relational operators, i.e., `>` to check elements of a list
# are ordered accordingly:
say [>] 234, 156, 6, 3, -20; # OUTPUT: «True␤»

# Default value examples:
say [*] (); # OUTPUT: «1␤», empty product
say [+] (); # OUTPUT: «0␤», empty sum
say [//];   # OUTPUT: «(Any)␤»
            # There's no ""default value"" for `//`.

# You can also use it with a function you made up,
# You can also surround  using double brackets:
sub add($a, $b) { $a + $b }
say [[&add]] 1, 2, 3; # OUTPUT: «6␤»

# The zip meta-operator is an infix meta-operator that also can be used as a
# ""normal"" operator. It takes an optional binary function (by default, it
# just creates a pair), and will pop one value off of each array and call
# its binary function on these until it runs out of elements. It returns an
# array with all of these new elements.
say (1, 2) Z (3, 4); # OUTPUT: «((1, 3), (2, 4))␤»
say 1..3 Z+ 4..6;    # OUTPUT: «(5, 7, 9)␤»

# Since `Z` is list-associative (see the list above), you can use it on more
# than one list.
(True, False) Z|| (False, False) Z|| (False, False); # (True, False)

# And, as it turns out, you can also use the reduce meta-operator with it:
[Z||] (True, False), (False, False), (False, False); # (True, False)

# And to end the operator list:

# The sequence operator (`...`) is one of Raku's most powerful features:
# It's composed by the list (which might include a closure) you want Raku to
# deduce from on the left and a value (or either a predicate or a Whatever Star
# for a lazy infinite list) on the right that states when to stop.

# Basic arithmetic sequence
my @listv0 = 1, 2, 3...10;

# This dies because Raku can't figure out the end
# my @list = 1, 3, 6...10;

# As with ranges, you can exclude the last element (the iteration ends when
# the predicate matches).
my @listv1 = 1, 2, 3...^10;

# You can use a predicate (with the Whatever Star).
my @listv2 = 1, 3, 9...* > 30;

# Equivalent to the example above but using a block here.
my @listv3 = 1, 3, 9 ... { $_ > 30 };

# Lazy infinite list of fibonacci sequence, computed using a closure!
my @fibv0 = 1, 1, *+* ... *;

# Equivalent to the above example but using a pointy block.
my @fibv1 = 1, 1, -> $a, $b { $a + $b } ... *;

# Equivalent to the above example but using a block with placeholder parameters.
my @fibv2 = 1, 1, { $^a + $^b } ... *;

# In the examples with explicit parameters (i.e., $a and $b), $a and $b
# will always take the previous values, meaning that for the Fibonacci sequence,
# they'll start with $a = 1 and $b = 1 (values we set by hand), then $a = 1
# and $b = 2 (result from previous $a + $b), and so on.

# In the example we use a range as an index to access the sequence. However,
# it's worth noting that for ranges, once reified, elements aren't re-calculated.
# That's why, for instance, `@primes[^100]` will take a long time the first
# time you print it but then it will be instantaneous.
say @fibv0[^10]; # OUTPUT: «1 1 2 3 5 8 13 21 34 55␤»

####################################################
# 18. Regular Expressions
####################################################

# I'm sure a lot of you have been waiting for this one. Well, now that you know
# a good deal of Raku already, we can get started. First off, you'll have to
# forget about ""PCRE regexps"" (perl-compatible regexps).

# IMPORTANT: Don't skip them because you know PCRE. They're different. Some
# things are the same (like `?`, `+`, and `*`), but sometimes the semantics
# change (`|`). Make sure you read carefully, because you might trip over a
# new behavior.

# Raku has many features related to RegExps. After all, Rakudo parses itself.
# We're first going to look at the syntax itself, then talk about grammars
# (PEG-like), differences between `token`, `regex` and `rule` declarators,
# and some more. Side note: you still have access to PCRE regexps using the
# `:P5` modifier which we won't be discussing this in this tutorial, though.

# In essence, Raku natively implements PEG (""Parsing Expression Grammars"").
# The pecking order for ambiguous parses is determined by a multi-level
# tie-breaking test:
#  - Longest token matching: `foo\s+` beats `foo` (by 2 or more positions)
#  - Longest literal prefix: `food\w*` beats `foo\w*` (by 1)
#  - Declaration from most-derived to less derived grammars
#    (grammars are actually classes)
#  - Earliest declaration wins
say so 'a' ~~ /a/;   # OUTPUT: «True␤»
say so 'a' ~~ / a /; # OUTPUT: «True␤», more readable with some spaces!

# In all our examples, we're going to use the smart-matching operator against
# a regexp. We're converting the result using `so` to a Boolean value because,
# in fact, it's returning a `Match` object. They know how to respond to list
# indexing, hash indexing, and return the matched string. The results of the
# match are available in the `$/` variable (implicitly lexically-scoped). You
# can also use the capture variables which start at 0: `$0`, `$1', `$2`...

# You can also note that `~~` does not perform start/end checking, meaning
# the regexp can be matched with just one character of the string. We'll
# explain later how you can do it.

# In Raku, you can have any alphanumeric as a literal, everything else has
# to be escaped by using a backslash or quotes.
say so 'a|b' ~~ / a '|' b /; # OUTPUT: «True␤», it wouldn't mean the same
                             # thing if `|` wasn't escaped.
say so 'a|b' ~~ / a \| b /;  # OUTPUT: «True␤», another way to escape it.

# The whitespace in a regex is actually not significant, unless you use the
# `:s` (`:sigspace`, significant space) adverb.
say so 'a b c' ~~ / a  b  c /; #=> `False`, space is not significant here!
say so 'a b c' ~~ /:s a b c /; #=> `True`, we added the modifier `:s` here.

# If we use only one space between strings in a regex, Raku will warn us
# about space being not signicant in the regex:
say so 'a b c' ~~ / a b c /;   # OUTPUT: «False␤»
say so 'a b c' ~~ / a  b  c /; # OUTPUT: «False»

# NOTE: Please use quotes or `:s` (`:sigspace`) modifier (or, to suppress this
# warning, omit the space, or otherwise change the spacing). To fix this and make
# the spaces less ambiguous, either use at least two spaces between strings
# or use the `:s` adverb.

# As we saw before, we can embed the `:s` inside the slash delimiters, but we
# can also put it outside of them if we specify `m` for 'match':
say so 'a b c' ~~ m:s/a  b  c/; # OUTPUT: «True␤»

# By using `m` to specify 'match', we can also use other delimiters:
say so 'abc' ~~ m{a  b  c};     # OUTPUT: «True␤»
say so 'abc' ~~ m[a  b  c];     # OUTPUT: «True␤»

# `m/.../` is equivalent to `/.../`:
say 'raku' ~~ m/raku/; # OUTPUT: «True␤»
say 'raku' ~~ /raku/;  # OUTPUT: «True␤»

# Use the `:i` adverb to specify case insensitivity:
say so 'ABC' ~~ m:i{a  b  c};   # OUTPUT: «True␤»

# However, whitespace is important as for how modifiers are applied
# (which you'll see just below) ...

#
# 18.1 Quantifiers - `?`, `+`, `*` and `**`.
#

# `?` - zero or one match
say so 'ac' ~~ / a  b  c /;   # OUTPUT: «False␤»
say so 'ac' ~~ / a  b?  c /;  # OUTPUT: «True␤», the ""b"" matched 0 times.
say so 'abc' ~~ / a  b?  c /; # OUTPUT: «True␤», the ""b"" matched 1 time.

# ... As you read before, whitespace is important because it determines which
# part of the regex is the target of the modifier:
say so 'def' ~~ / a  b  c? /; # OUTPUT: «False␤», only the ""c"" is optional
say so 'def' ~~ / a  b?  c /; # OUTPUT: «False␤», whitespace is not significant
say so 'def' ~~ / 'abc'? /;   # OUTPUT: «True␤»,  the whole ""abc"" group is optional

# Here (and below) the quantifier applies only to the ""b""

# `+` - one or more matches
say so 'ac' ~~ / a  b+  c /;     # OUTPUT: «False␤», `+` wants at least one 'b'
say so 'abc' ~~ / a  b+  c /;    # OUTPUT: «True␤», one is enough
say so 'abbbbc' ~~ / a  b+  c /; # OUTPUT: «True␤», matched 4 ""b""s

# `*` - zero or more matches
say so 'ac' ~~ / a  b*  c /;     # OUTPUT: «True␤», they're all optional
say so 'abc' ~~ / a  b*  c /;    # OUTPUT: «True␤»
say so 'abbbbc' ~~ / a  b*  c /; # OUTPUT: «True␤»
say so 'aec' ~~ / a  b*  c /;    # OUTPUT: «False␤», ""b""(s) are optional, not replaceable.

# `**` - (Unbound) Quantifier
# If you squint hard enough, you might understand why exponentiation is used
# for quantity.
say so 'abc' ~~ / a  b**1  c /;         # OUTPUT: «True␤», exactly one time
say so 'abc' ~~ / a  b**1..3  c /;      # OUTPUT: «True␤», one to three times
say so 'abbbc' ~~ / a  b**1..3  c /;    # OUTPUT: «True␤»
say so 'abbbbbbc' ~~ / a  b**1..3  c /; # OUTPUT: «Fals␤», too much
say so 'abbbbbbc' ~~ / a  b**3..*  c /; # OUTPUT: «True␤», infinite ranges are ok

#
# 18.2 `<[]>` - Character classes
#

# Character classes are the equivalent of PCRE's `[]` classes, but they use a
# more raku-ish syntax:
say 'fooa' ~~ / f <[ o a ]>+ /;  # OUTPUT: «fooa␤»

# You can use ranges (`..`):
say 'aeiou' ~~ / a <[ e..w ]> /; # OUTPUT: «ae␤»

# Just like in normal regexes, if you want to use a special character, escape
# it (the last one is escaping a space which would be equivalent to using
# ' '):
say 'he-he !' ~~ / 'he-' <[ a..z \! \  ]> + /; # OUTPUT: «he-he !␤»

# You'll get a warning if you put duplicate names (which has the nice effect
# of catching the raw quoting):
'he he' ~~ / <[ h e ' ' ]> /;
# Warns ""Repeated character (') unexpectedly found in character class""

# You can also negate character classes... (`<-[]>` equivalent to `[^]` in PCRE)
say so 'foo' ~~ / <-[ f o ]> + /; # OUTPUT: «False␤»

# ... and compose them:
# any letter except ""f"" and ""o""
say so 'foo' ~~ / <[ a..z ] - [ f o ]> + /;   # OUTPUT: «False␤»

# no letter except ""f"" and ""o""
say so 'foo' ~~ / <-[ a..z ] + [ f o ]> + /;  # OUTPUT: «True␤»

# the + doesn't replace the left part
say so 'foo!' ~~ / <-[ a..z ] + [ f o ]> + /; # OUTPUT: «True␤»

#
# 18.3 Grouping and capturing
#

# Group: you can group parts of your regexp with `[]`. Unlike PCRE's `(?:)`,
# these groups are *not* captured.
say so 'abc' ~~ / a [ b ] c /;  # OUTPUT: «True␤», the grouping does nothing
say so 'foo012012bar' ~~ / foo [ '01' <[0..9]> ] + bar /; # OUTPUT: «True␤»

# The previous line returns `True`. The regex matches ""012"" one or more time
# (achieved by the the `+` applied to the group).

# But this does not go far enough, because we can't actually get back what
# we matched.

# Capture: The results of a regexp can be *captured* by using parentheses.
say so 'fooABCABCbar' ~~ / foo ( 'A' <[A..Z]> 'C' ) + bar /; # OUTPUT: «True␤»
# (using `so` here, see `$/` below)

# So, starting with the grouping explanations. As we said before, our `Match`
# object is stored inside the `$/` variable:
say $/;    # Will either print the matched object or `Nil` if nothing matched.

# As we also said before, it has array indexing:
say $/[0]; # OUTPUT: «｢ABC｣ ｢ABC｣␤»,

# The corner brackets (｢..｣) represent (and are) `Match` objects. In the
# previous example, we have an array of them.

say $0;    # The same as above.

# Our capture is `$0` because it's the first and only one capture in the
# regexp. You might be wondering why it's an array, and the answer is simple:
# Some captures (indexed using `$0`, `$/[0]` or a named one) will be an array
# if and only if they can have more than one element. Thus any capture with
# `*`, `+` and `**` (whatever the operands), but not with `?`.
# Let's use examples to see that:

# NOTE: We quoted A B C to demonstrate that the whitespace between them isn't
# significant. If we want the whitespace to *be* significant there, we can use the
# `:sigspace` modifier.
say so 'fooABCbar' ~~ / foo ( ""A"" ""B"" ""C"" )? bar /; # OUTPUT: «True␤»
say $/[0];   # OUTPUT: «｢ABC｣␤»
say $0.WHAT; # OUTPUT: «(Match)␤»
             # There can't be more than one, so it's only a single match object.

say so 'foobar' ~~ / foo ( ""A"" ""B"" ""C"" )? bar /;    # OUTPUT: «True␤»
say $0.WHAT; # OUTPUT: «(Any)␤», this capture did not match, so it's empty.

say so 'foobar' ~~ / foo ( ""A"" ""B"" ""C"" ) ** 0..1 bar /; #=> OUTPUT: «True␤»
say $0.WHAT; # OUTPUT: «(Array)␤», A specific quantifier will always capture
             # an Array, be a range or a specific value (even 1).

# The captures are indexed per nesting. This means a group in a group will be
# nested under its parent group: `$/[0][0]`, for this code:
'hello-~-world' ~~ / ( 'hello' ( <[ \- \~ ]> + ) ) 'world' /;
say $/[0].Str;    # OUTPUT: «hello~␤»
say $/[0][0].Str; # OUTPUT: «~␤»

# This stems from a very simple fact: `$/` does not contain strings, integers
# or arrays, it only contains `Match` objects. These contain the `.list`, `.hash`
# and `.Str` methods but you can also just use `match<key>` for hash access
# and `match[idx]` for array access.

# In the following example, we can see `$_` is a list of `Match` objects.
# Each of them contain a wealth of information: where the match started/ended,
# the ""ast"" (see actions later), etc. You'll see named capture below with
# grammars.
say $/[0].list.perl; # OUTPUT: «(Match.new(...),).list␤»

# Alternation - the `or` of regexes
# WARNING: They are DIFFERENT from PCRE regexps.
say so 'abc' ~~ / a [ b | y ] c /; # OUTPUT: «True␤», Either ""b"" or ""y"".
say so 'ayc' ~~ / a [ b | y ] c /; # OUTPUT: «True␤», Obviously enough...

# The difference between this `|` and the one you're used to is
# LTM (""Longest Token Matching"") strategy. This means that the engine will
# always try to match as much as possible in the string.
say 'foo' ~~ / fo | foo /; # OUTPUT: «foo», instead of `fo`, because it's longer.

# To decide which part is the ""longest"", it first splits the regex in two parts:
#
#     * The ""declarative prefix"" (the part that can be statically analyzed)
#     which includes alternations (`|`), conjunctions (`&`), sub-rule calls (not
#     yet introduced), literals, characters classes and quantifiers.
#
#     * The ""procedural part"" includes everything else: back-references,
#     code assertions, and other things that can't traditionally be represented
#     by normal regexps.

# Then, all the alternatives are tried at once, and the longest wins.

# Examples:
# DECLARATIVE | PROCEDURAL
/ 'foo' \d+     [ <subrule1> || <subrule2> ] /;

# DECLARATIVE (nested groups are not a problem)
/ \s* [ \w & b ] [ c | d ] /;

# However, closures and recursion (of named regexes) are procedural.
# There are also more complicated rules, like specificity (literals win
# over character classes).

# NOTE: The alternation in which all the branches are tried in order
# until the first one matches still exists, but is now spelled `||`.
say 'foo' ~~ / fo || foo /; # OUTPUT: «fo␤», in this case.

####################################################
# 19. Extra: the MAIN subroutine
####################################################

# The `MAIN` subroutine is called when you run a Raku file directly. It's
# very powerful, because Raku actually parses the arguments and pass them
# as such to the sub. It also handles named argument (`--foo`) and will even
# go as far as to autogenerate a `--help` flag.

sub MAIN($name) {
    say ""Hello, $name!"";
}
# Supposing the code above is in file named cli.raku, then running in the command
# line (e.g., $ raku cli.raku) produces:
# Usage:
# cli.raku <name>

# And since MAIN is a regular Raku sub, you can have multi-dispatch:
# (using a `Bool` for the named argument so that we can do `--replace`
# instead of `--replace=1`. The presence of `--replace` indicates truthness
# while its absence falseness). For example:

    # convert to IO object to check the file exists
    =begin comment
    subset File of Str where *.IO.d;

    multi MAIN('add', $key, $value, Bool :$replace) { ... }
    multi MAIN('remove', $key) { ... }
    multi MAIN('import', File, Str :$as) { ... } # omitting parameter name
    =end comment

# Thus $ raku cli.raku produces:
# Usage:
#   cli.raku [--replace] add <key> <value>
#   cli.raku remove <key>
#   cli.raku [--as=<Str>] import <File>

# As you can see, this is *very* powerful. It even went as far as to show inline
# the constants (the type is only displayed if the argument is `$`/is named).

####################################################
# 20. APPENDIX A:
####################################################

# It's assumed by now you know the Raku basics. This section is just here to
# list some common operations, but which are not in the ""main part"" of the
# tutorial to avoid bloating it up.

#
# 20.1 Operators
#

# Sort comparison - they return one value of the `Order` enum: `Less`, `Same`
# and `More` (which numerify to -1, 0 or +1 respectively).
say 1 <=> 4;     # OUTPUT: «More␤»,   sort comparison for numerics
say 'a' leg 'b'; # OUTPUT: «Lessre␤», sort comparison for string
say 1 eqv 1;     # OUTPUT: «Truere␤», sort comparison using eqv semantics
say 1 eqv 1.0;   # OUTPUT: «False␤»

# Generic ordering
say 3 before 4;    # OUTPUT: «True␤»
say 'b' after 'a'; # OUTPUT: «True␤»

# Short-circuit default operator - similar to `or` and `||`, but instead
# returns the first *defined* value:
say Any // Nil // 0 // 5;        # OUTPUT: «0␤»

# Short-circuit exclusive or (XOR) - returns `True` if one (and only one) of
# its arguments is true
say True ^^ False;               # OUTPUT: «True␤»

# Flip flops. These operators (`ff` and `fff`, equivalent to P5's `..`
# and `...`) are operators that take two predicates to test: They are `False`
# until their left side returns `True`, then are `True` until their right
# side returns `True`. Similar to ranges, you can exclude the iteration when
# it become `True`/`False` by using `^` on either side. Let's start with an
# example :

for <well met young hero we shall meet later> {
    # by default, `ff`/`fff` smart-match (`~~`) against `$_`:
    if 'met' ^ff 'meet' { # Won't enter the if for ""met""
        .say              # (explained in details below).
    }

    if rand == 0 ff rand == 1 { # compare variables other than `$_`
        say ""This ... probably will never run ..."";
    }
}

# This will print ""young hero we shall meet"" (excluding ""met""): the flip-flop
# will start returning `True` when it first encounters ""met"" (but will still
# return `False` for ""met"" itself, due to the leading `^` on `ff`), until it
# sees ""meet"", which is when it'll start returning `False`.

# The difference between `ff` (awk-style) and `fff` (sed-style) is that `ff`
# will test its right side right when its left side changes to `True`, and can
# get back to `False` right away (*except* it'll be `True` for the iteration
# that matched) while `fff` will wait for the next iteration to try its right
# side, once its left side changed:

# The output is due to the right-hand-side being tested directly (and returning
# `True`). ""B""s are printed since it matched that time (it just went back to
# `False` right away).
.say if 'B' ff 'B' for <A B C B A>; # OUTPUT: «B B␤»,

# In this case the right-hand-side wasn't tested until `$_` became ""C""
# (and thus did not match instantly).
.say if 'B' fff 'B' for <A B C B A>; #=> «B C B␤»,

# A flip-flop can change state as many times as needed:
for <test start print it stop not printing start print again stop not anymore> {
    # exclude both ""start"" and ""stop"",
    .say if $_ eq 'start' ^ff^ $_ eq 'stop'; # OUTPUT: «print it print again␤»
}

# You might also use a Whatever Star, which is equivalent to `True` for the
# left side or `False` for the right, as shown in this example.
# NOTE: the parenthesis are superfluous here (sometimes called ""superstitious
# parentheses""). Once the flip-flop reaches a number greater than 50, it'll
# never go back to `False`.
for (1, 3, 60, 3, 40, 60) {
    .say if $_ > 50 ff *;  # OUTPUT: «60␤3␤40␤60␤»
}

# You can also use this property to create an `if` that'll not go through the
# first time. In this case, the flip-flop is `True` and never goes back to
# `False`, but the `^` makes it *not run* on the first iteration
for <a b c> { .say if * ^ff *; }  # OUTPUT: «b␤c␤»

# The `===` operator, which uses `.WHICH` on the objects to be compared, is
# the value identity operator whereas the `=:=` operator, which uses `VAR()` on
# the objects to compare them, is the container identity operator.
```

If you want to go further and learn more about Raku, you can:

- Read the [Raku Docs](https://docs.raku.org/). This is a great
resource on Raku. If you are looking for something, use the search bar.
This will give you a dropdown menu of all the pages referencing your search
term (Much better than using Google to find Raku documents!).

- Read the [Raku Advent Calendar](https://rakuadventcalendar.wordpress.com/). This
is a great source of Raku snippets and explanations. If the docs don't
describe something well enough, you may find more detailed information here.
This information may be a bit older but there are many great examples and
explanations. Posts stopped at the end of 2015 when the language was declared
stable and `Raku v6.c` was released.

- Come along on `#raku` at [`irc.libera.chat`](https://web.libera.chat/?channel=#raku). The folks here are
always helpful.

- Check the [source of Raku's functions and
classes](https://github.com/rakudo/rakudo/tree/master/src/core.c). Rakudo is
mainly written in Raku (with a lot of NQP, ""Not Quite Perl"", a Raku subset
easier to implement and optimize).

- Read [the language design documents](https://design.raku.org/). They explain
Raku from an implementor point-of-view, but it's still very interesting."
"Cypher is the Neo4j’s query language to manipulate graphs easily. It reuses syntax from SQL and mixes it with kind of ascii-art to represent graphs.
This tutorial assumes that you already know graph concepts like nodes and relationships.

[Read more here.](https://neo4j.com/developer/cypher-query-language/)


Nodes
---

**Represents a record in a graph.**

`()`
It's an empty *node*, to indicate that there is a *node*, but it's not relevant for the query.

`(n)`
It's a *node* referred by the variable **n**, reusable in the query. It begins with lowercase and uses camelCase.

`(p:Person)`
You can add a *label* to your node, here **Person**. It's like a type / a class / a category. It begins with uppercase and uses camelCase.

`(p:Person:Manager)`
A node can have many *labels*.

`(p:Person {name : 'Théo Gauchoux', age : 22})`
A node can have some *properties*, here **name** and **age**. It begins with lowercase and uses camelCase.

The types allowed in properties :

 - Numeric
 - Boolean
 - String
 - List of previous primitive types

*Warning : there isn't datetime property in Cypher ! You can use String with a specific pattern or a Numeric from a specific date.*

`p.name`
You can access to a property with the dot style.


Relationships (or Edges)
---

**Connects two nodes**

`[:KNOWS]`
It's a *relationship* with the *label* **KNOWS**. It's a *label* as the node's label. It begins with uppercase and use UPPER\_SNAKE\_CASE.

`[k:KNOWS]`
The same *relationship*, referred by the variable **k**, reusable in the query, but it's not necessary.

`[k:KNOWS {since:2017}]`
The same *relationship*, with *properties* (like *node*), here **since**.

`[k:KNOWS*..4]`
It's a structural information to use in a *path* (seen later). Here, **\*..4** says ""Match the pattern, with the relationship **k** which be repeated between 1 and 4 times.


Paths
---

**The way to mix nodes and relationships.**

`(a:Person)-[:KNOWS]-(b:Person)`
A path describing that **a** and **b** know each other.

`(a:Person)-[:MANAGES]->(b:Person)`
A path can be directed. This path describes that **a** is the manager of **b**.

`(a:Person)-[:KNOWS]-(b:Person)-[:KNOWS]-(c:Person)`
You can chain multiple relationships. This path describes the friend of a friend.

`(a:Person)-[:MANAGES]->(b:Person)-[:MANAGES]->(c:Person)`
A chain can also be directed. This path describes that **a** is the boss of **b** and the big boss of **c**.

Patterns often used (from Neo4j doc) :

```
// Friend-of-a-friend 
(user)-[:KNOWS]-(friend)-[:KNOWS]-(foaf)

// Shortest path
path = shortestPath( (user)-[:KNOWS*..5]-(other) )

// Collaborative filtering
(user)-[:PURCHASED]->(product)<-[:PURCHASED]-()-[:PURCHASED]->(otherProduct)

// Tree navigation 
(root)<-[:PARENT*]-(leaf:Category)-[:ITEM]->(data:Product)

```


Create queries
---

Create a new node
```
CREATE (a:Person {name:""Théo Gauchoux""})
RETURN a
```
*`RETURN` allows to have a result after the query. It can be multiple, as `RETURN a, b`.*

Create a new relationship (with 2 new nodes)
```
CREATE (a:Person)-[k:KNOWS]-(b:Person)
RETURN a,k,b
```

Match queries
---

Match all nodes
```
MATCH (n)
RETURN n
```

Match nodes by label
```
MATCH (a:Person)
RETURN a
```

Match nodes by label and property
```
MATCH (a:Person {name:""Théo Gauchoux""})
RETURN a
```

Match nodes according to relationships (undirected)
```
MATCH (a)-[:KNOWS]-(b)
RETURN a,b
```

Match nodes according to relationships (directed)
```
MATCH (a)-[:MANAGES]->(b)
RETURN a,b
```

Match nodes with a `WHERE` clause
```
MATCH (p:Person {name:""Théo Gauchoux""})-[s:LIVES_IN]->(city:City)
WHERE s.since = 2015
RETURN p,state
```

You can use `MATCH WHERE` clause with `CREATE` clause
```
MATCH (a), (b)
WHERE a.name = ""Jacquie"" AND b.name = ""Michel""
CREATE (a)-[:KNOWS]-(b)
```


Update queries
---

Update a specific property of a node
```
MATCH (p:Person)
WHERE p.name = ""Théo Gauchoux""
SET p.age = 23
```

Replace all properties of a node
```
MATCH (p:Person)
WHERE p.name = ""Théo Gauchoux""
SET p = {name: ""Michel"", age: 23}
```

Add new property to a node
```
MATCH (p:Person)
WHERE p.name = ""Théo Gauchoux""
SET p + = {studies: ""IT Engineering""}
```

Add a label to a node
```
MATCH (p:Person)
WHERE p.name = ""Théo Gauchoux""
SET p:Internship
```


Delete queries
---

Delete a specific node (linked relationships must be deleted before)
```
MATCH (p:Person)-[relationship]-()
WHERE p.name = ""Théo Gauchoux""
DELETE relationship, p
```

Remove a property in a specific node
```
MATCH (p:Person)
WHERE p.name = ""Théo Gauchoux""
REMOVE p.age
```
*Pay attention to the `REMOVE`keyword, it's not `DELETE` !*

Remove a label from a specific node
```
MATCH (p:Person)
WHERE p.name = ""Théo Gauchoux""
DELETE p:Person
```

Delete entire database
```
MATCH (n)
OPTIONAL MATCH (n)-[r]-()
DELETE n, r
```
*Seriously, it's the `rm -rf /` of Cypher !*


Other useful clauses
---

`PROFILE`
Before a query, show the execution plan of it.

`COUNT(e)`
Count entities (nodes or relationships) matching **e**.

`LIMIT x`
Limit the result to the x first results.


Special hints
---

- There is just single-line comments in Cypher, with double-slash : // Comments
- You can execute a Cypher script stored in a **.cql** file directly in Neo4j (it's an import). However, you can't have multiple statements in this file (separated by **;**).
- Use the Neo4j shell to write Cypher, it's really awesome.
- The Cypher will be the standard query language for all graph databases (known as **OpenCypher**)."
"MongoDB is a NoSQL document database for high volume data storage.

MongoDB uses collections and documents for its storage. Each document consists
of key-value pairs using JSON-like syntax, similar to a dictionary or JavaScript
object.

Likewise, as MongoDB is a NoSQL database, it uses its own query language, Mongo
Query Language (MQL) which uses JSON for querying.

## Getting Started

### Installation

MongoDB can either be installed locally following the instructions
[here](https://docs.mongodb.com/manual/installation/) or you can create a
remotely-hosted free 512 MB cluster
[here](https://www.mongodb.com/cloud/atlas/register). Links to videos with
instructions on setup are at the bottom.

This tutorial assumes that you have the MongoDB Shell from
[here](https://www.mongodb.com/try/download/shell). You can also download the
graphical tool, MongoDB Compass, down below from the same link.

### Components

After installing MongoDB, you will notice there are multiple command line tools.
The three most important of which are:

- `mongod` - The database server which is responsible for managing data and
  handling queries
- `mongos` - The sharding router, which is needed if data will be distributed
  across multiple machines
- `mongo` - The database shell (using JavaScript) through which we can configure
  our database

Usually we start the `mongod` process and then use a separate terminal with
`mongo` to access and modify our collections.

### JSON & BSON

While queries in MongoDB are made using a JSON-like\* format, MongoDB stores its
documents internally in the Binary JSON (BSON format). BSON is not human
readable like JSON as it's a binary encoding. However, this allows for end users
to have access to more types than regular JSON, such as an integer or float
type. Many other types, such as regular expressions, dates, or raw binary are
supported too.

[Here](https://docs.mongodb.com/manual/reference/bson-types/) is the full list
of all types that are supported.

- We refer JSON-like to mean JSON but with these extended types. For example,
  you can make queries directly with a regular expression or timestamp in
  MongoDB and you can receive data that has those types too.

```js
/////////////////////////////////////////////////////////
/////////////////// Getting Started /////////////////////
/////////////////////////////////////////////////////////

// Start up the mongo database server
// NOTE - You will need to do this in a separate terminal as the process will 
// take over the terminal. You may want to use the --fork option
mongod // --fork

// Connecting to a remote Mongo server
// mongo ""mongodb+srv://host.ip.address/admin"" --username your-username

// Mongoshell has a proper JavaScript interpreter built in
3 + 2 // 5

// Show available databases
// MongoDB comes with the following databases built-in: admin, config, local
show dbs

// Switch to a new database (pre-existing or about to exist)
// NOTE: There is no ""create"" command for a database in MongoDB. 
// The database is created upon data being inserted into a collection
use employees

// Create a new collection
// NOTE: Inserting a document will implicitly create a collection anyways,
// so this is not required
db.createCollection('engineers')
db.createCollection('doctors')

// See what collections exist under employees
show collections

/////////////////////////////////////////////////////////
// Basic Create/Read/Update/Delete (CRUD) Operations: ///
/////////////////////////////////////////////////////////

/////////////// Insert (Create) /////////////////////////

// Insert one employee into the database
// Each insertion returns acknowledged true or false
// Every document has a unique _id value assigned to it automatically
db.engineers.insertOne({ name: ""Jane Doe"", age: 21, gender: 'Female' })

// Insert a list of employees into the `engineers` collection
// Can insert as an array of objects
db.engineers.insert([
  { name: ""Foo Bar"", age: 25, gender: 'Male' },
  { name: ""Baz Qux"", age: 27, gender: 'Other' },
])

// MongoDB does not enforce a schema or structure for objects
// Insert an empty object into the `engineers` collection
db.engineers.insertOne({})

// Fields are optional and do not have to match rest of documents
db.engineers.insertOne({ name: ""Your Name"", gender: ""Male"" })

// Types can vary and are preserved on insertion
// This can require additional validation in some languages to prevent problems
db.engineers.insert({ name: ['Foo', 'Bar'], age: 3.14, gender: true })

// Objects or arrays can be nested inside a document
db.engineers.insertOne({
  name: ""Your Name"",
  gender: ""Female"",
  skilledIn: [
    ""MongoDB"",
    ""NoSQL"",
  ],
  ""date-of-birth"": {
    ""date"": 1993-07-20T09:44:18.674Z,
    ""age"": 26
  },
})

// We can override the _id field
// Works fine
db.engineers.insertOne({
  _id: 1,
  name: ""An Engineer"",
  age: 25,
  gender: ""Female"",
})

// Be careful, as _id must ALWAYS be unique for the collection otherwise 
// the insertion will fail
// Fails with a WriteError indicating _id is a duplicate value
db.engineers.insertOne({
  _id: 1,
  name: ""Another Engineer"",
  age: 25,
  gender: ""Male"",
})

// Works fine as this is a different collection
db.doctors.insertOne({
  _id: 1,
  name: ""Some Doctor"",
  age: 26,
  gender: ""Other"",
})

/////////////////// Find (Read) ////////////////////////
// Queries are in the form of db.collectionName.find(<filter>)
// Where <filter> is an object

// Show everything in our database so far, limited to a 
// maximum of 20 documents at a time
// Press i to iterate this cursor to the next 20 documents
db.engineers.find({})

// We can pretty print the result of any find() query
db.engineers.find({}).pretty()

// MongoDB queries take in a JS object and search for documents with matching 
// key-value pairs
// Returns the first document matching query
// NOTE: Order of insertion is not preserved in the database, output can vary
db.engineers.findOne({ name: 'Foo Bar' })

// Returns all documents with the matching key-value properties as a cursor 
// (which can be converted to an array)
db.engineers.find({ age: 25 })

// Type matters when it comes to queries
// Returns nothing as all ages above are integer type
db.engineers.find({ age: '25' })

// find() supports nested objects and arrays just like create()
db.engineers.find({
  name: ""Your Name"",
  gender: ""Female"",
  skilledIn: [
    ""MongoDB"",
    ""NoSQL"",
  ],
  ""date-of-birth"": {
    ""date"": 1993-07-20T09:44:18.674Z,
    ""age"": 26
  },
})

///////////////////////// Update ////////////////////////
// Queries are in the form of db.collectionName.update(<filter>, <update>)
// NOTE: <update> will always use the $set operator.
// Several operators are covered later on in the tutorial.

// We can update a single object
db.engineers.updateOne({ name: 'Foo Bar' }, { $set: { name: 'John Doe', age: 100 }})

// Or update many objects at the same time
db.engineers.update({ age: 25 }, { $set: { age: 26 }})

// We can use { upsert: true } if we would like it to insert if the document doesn't already exist,
// or to update if it does
// Returns matched, upserted, modified count
db.engineers.update({ name: 'Foo Baz' },
  { $set:
    {
      age: 26,
      gender: 'Other'
    }
  },
  { upsert: true }
)

/////////////////////// Delete /////////////////////////
// Queries are in the form of db.collectionName.find(<filter>)

// Delete first document matching query, always returns deletedCount
db.engineers.deleteOne({ name: 'Foo Baz' })

// Delete many documents at once
db.engineers.deleteMany({ gender: 'Male' })

// NOTE: There are two methods db.collection.removeOne(<filter>) and 
// db.collection.removeMany(<filter>) that also delete objects but have a
// slightly different return value.
// They are not included here as they have been deprecated in the NodeJS driver.

/////////////////////////////////////////////////////////
//////////////////// Operators //////////////////////////
/////////////////////////////////////////////////////////

// Operators in MongoDB have a $ prefix. For this tutorial, we are only looking 
// at comparison and logical operators, but there are many other types of
// operators

//////////////// Comparison Operators ///////////////////

// Find all greater than or greater than equal to some condition
db.engineers.find({ $gt: { age: 25 }})
db.engineers.find({ $gte: { age: 25 }})

// Find all less than or less than equal to some condition
db.engineers.find({ $lt: { age: 25 }})
db.engineers.find({ $lte: { age: 25 }})

// Find all equal or not equal to
// Note: the $eq operator is added implicitly in most queries
db.engineers.find({ $eq: { age: 25 }})
db.engineers.find({ $ne: { age: 25 }})

// Find all that match any element in the array
db.engineers.find({ age: ${ in: [ 20, 23, 24, 25 ]}})

//////////////// Logical Operators ///////////////////

// Join two query clauses together
// NOTE: MongoDB does this implicitly for most queries
db.engineers.find({ $and: [
  gender: 'Female',
  age: {
    $gte: 18
  }
]})

// Match either query condition
db.engineers.find({ $or: [
  gender: 'Female',
  age: {
    $gte: 18
  }
]})

// Negates the query
db.engineers.find({ $not: {
  gender: 'Female'
}})

// Must match none of the query conditions
db.engineers.find({ $nor [
  gender: 'Female',
  age: {
    $gte: 18
  }
]})

/////////////////////////////////////////////////////////
//////////////// Database Operations: ///////////////////
/////////////////////////////////////////////////////////

// Delete (drop) the employees database
// THIS WILL DELETE ALL DOCUMENTS IN THE DATABASE!
db.dropDatabase()

// Create a new database with some data
use example
db.test.insertOne({ name: ""Testing data, please ignore!"", type: ""Test"" })

// Quit Mongo shell
exit

// Import/export database as BSON:

// Mongodump to export data as BSON for all databases
// Exported data is found in under ""MongoDB Database Tools/bin/dump""
// NOTE: If the command is not found, navigate to ""MongoDB Database Tools/bin"" 
// and use the executable from there mongodump

// Mongorestore to restore data from BSON
mongorestore dump

// Import/export database as JSON:
// Mongoexport to export data as JSON for all databases
mongoexport --collection=example

// Mongoimport to export data as JSON for all databases
mongoimport  --collection=example
```

## Further Reading

### Setup Videos

- [Install MongoDB - Windows 10](https://www.youtube.com/watch?v=85A6m1soKww)
- [Install MongoDB - Mac](https://www.youtube.com/watch?v=DX15WbKidXY)
- [Install MongoDB - Linux
  (Ubuntu)](https://www.youtube.com/watch?v=wD_2pojFWoE)

### Input Validation

From the examples above, if input validation or structure is a concern, I would
take a look at the following ORMs:

- [Mongoose (Node.js)](https://mongoosejs.com/docs/) - Input validation through
  schemas that support types, required values, minimum and maximum values.
- [MongoEngine (Python)](http://mongoengine.org/) - Similar to Mongoose, but I
  found it somewhat limited in my experience
- [MongoKit (Python)](https://github.com/namlook/mongokit) - Another great
  alternative to MongoEngine that I find easier to use than MongoEngine

For statically strongly typed languages (e.g. Java, C++, Rust), input validation
usually doesn't require a library as they define types and structure at compile
time.

### Resources

If you have the time to spare, I would strongly recommend the courses on
[MongoDB University](https://university.mongodb.com/). They're by MongoDB
themselves and go into much more detail while still being concise. They're a mix
of videos and quiz questions and this was how I gained my knowledge of MongoDB.

I would recommend the following video series for learning MongoDB:

- [MongoDB Crash Course - Traversy
  Media](https://www.youtube.com/watch?v=-56x56UppqQ)
- [MongoDB Tutorial for Beginners -
  Amigoscode](https://www.youtube.com/watch?v=Www6cTUymCY)

Language-specific ones that I used before:

- [Build A REST API With Node.js, Express, & MongoDB - Web Dev
  Simplified](https://www.youtube.com/watch?v=fgTGADljAeg)
- [MongoDB with Python Crash Course - Tutorial for Beginners -
  FreeCodeCamp](https://www.youtube.com/watch?v=E-1xI85Zog8)
- [How to Use MongoDB with Java - Random
  Coder](https://www.youtube.com/watch?v=reYPUvu2Giw)
- [An Introduction to Using MongoDB with Rust -
  MongoDB](https://www.youtube.com/watch?v=qFlftfLGwPM)

Most of the information above was cross-referenced with the [MongoDB
docs](https://www.mongodb.com/). Here are the docs for each section:

- [MongoDB Types](https://docs.mongodb.com/manual/reference/bson-types/) - List
  of all types that MongoDB supports natively
- [MongoDB Operators](https://docs.mongodb.com/manual/reference/operator/) -
  List of operators MongoDB supports natively
- [MongoDB CRUD](https://docs.mongodb.com/manual/reference/command/nav-crud/) -
  Commands for create, read, update, delete

If you've been enjoying MongoDB so far and want to explore intermediate
features, I would look at
[aggregation](https://docs.mongodb.com/manual/reference/command/nav-aggregation/),
[indexing](https://docs.mongodb.com/manual/indexes/), and
[sharding](https://docs.mongodb.com/manual/sharding/).

- Aggregation - useful for creating advanced queries to be executed by the
  database
- Indexing allows for caching, which allows for much faster execution of queries
- Sharding allows for horizontal data scaling and distribution between multiple
  machines."
"Nim (formerly Nimrod) is a statically typed, imperative programming language
that gives the programmer power without compromises on runtime efficiency.

Nim is efficient, expressive, and elegant.

```nim
# Single-line comments start with a #

#[
  This is a multiline comment.
  In Nim, multiline comments can be nested, beginning with #[
  ... and ending with ]#
]#

discard """"""
This can also work as a multiline comment.
Or for unparsable, broken code
""""""

var                     # Declare (and assign) variables,
  letter: char = 'n'    # with or without type annotations
  lang = ""N"" & ""im""
  nLength: int = len(lang)
  boat: float
  truth: bool = false

let            # Use let to declare and bind variables *once*.
  legs = 400   # legs is immutable.
  arms = 2_000 # _ are ignored and are useful for long numbers.
  aboutPi = 3.15

const            # Constants are computed at compile time. This provides
  debug = true   # performance and is useful in compile time expressions.
  compileBadCode = false

when compileBadCode:            # `when` is a compile time `if`
  legs = legs + 1               # This error will never be compiled.
  const input = readline(stdin) # Const values must be known at compile time.

discard 1 > 2 # Note: The compiler will complain if the result of an expression
              # is unused. `discard` bypasses this.


#
# Data Structures
#

# Tuples

var
  child: tuple[name: string, age: int]   # Tuples have *both* field names
  today: tuple[sun: string, temp: float] # *and* order.

child = (name: ""Rudiger"", age: 2) # Assign all at once with literal ()
today.sun = ""Overcast""            # or individual fields.
today.temp = 70.1

# Sequences

var
  drinks: seq[string]

drinks = @[""Water"", ""Juice"", ""Chocolate""] # @[V1,..,Vn] is the sequence literal

drinks.add(""Milk"")

if ""Milk"" in drinks:
  echo ""We have Milk and "", drinks.len - 1, "" other drinks""

let myDrink = drinks[2]

#
# Defining Types
#

# Defining your own types puts the compiler to work for you. It's what makes
# static typing powerful and useful.

type
  Name = string # A type alias gives you a new type that is interchangeable
  Age = int     # with the old type but is more descriptive.
  Person = tuple[name: Name, age: Age] # Define data structures too.
  AnotherSyntax = tuple
    fieldOne: string
    secondField: int

var
  john: Person = (name: ""John B."", age: 17)
  newage: int = 18 # It would be better to use Age than int

john.age = newage # But still works because int and Age are synonyms

type
  Cash = distinct int    # `distinct` makes a new type incompatible with its
  Desc = distinct string # base type.

var
  money: Cash = 100.Cash # `.Cash` converts the int to our type
  description: Desc  = ""Interesting"".Desc

when compileBadCode:
  john.age  = money        # Error! age is of type int and money is Cash
  john.name = description  # Compiler says: ""No way!""

#
# More Types and Data Structures
#

# Enumerations allow a type to have one of a limited number of values

type
  Color = enum cRed, cBlue, cGreen
  Direction = enum # Alternative formatting
    dNorth
    dWest
    dEast
    dSouth
var
  orient = dNorth # `orient` is of type Direction, with the value `dNorth`
  pixel = cGreen # `pixel` is of type Color, with the value `cGreen`

discard dNorth > dEast # Enums are usually an ""ordinal"" type

# Subranges specify a limited valid range

type
  DieFaces = range[1..20] # Only an int from 1 to 20 is a valid value
var
  my_roll: DieFaces = 13

when compileBadCode:
  my_roll = 23 # Error!

# Arrays

type
  RollCounter = array[DieFaces, int]  # Arrays are fixed length and
  DirNames = array[Direction, string] # indexed by any ordinal type.
  Truths = array[42..44, bool]
var
  counter: RollCounter
  directions: DirNames
  possible: Truths

possible = [false, false, false] # Literal arrays are created with [V1,..,Vn]
possible[42] = true

directions[dNorth] = ""Ahh. The Great White North!""
directions[dWest] = ""No, don't go there.""

my_roll = 13
counter[my_roll] += 1
counter[my_roll] += 1

var anotherArray = [""Default index"", ""starts at"", ""0""]

# More data structures are available, including tables, sets, lists, queues,
# and crit bit trees.
# http://nim-lang.org/docs/lib.html#collections-and-algorithms

#
# IO and Control Flow
#

# `case`, `readLine()`

echo ""Read any good books lately?""
case readLine(stdin)
of ""no"", ""No"":
  echo ""Go to your local library.""
of ""yes"", ""Yes"":
  echo ""Carry on, then.""
else:
  echo ""That's great; I assume.""

# `while`, `if`, `continue`, `break`

import strutils as str # http://nim-lang.org/docs/strutils.html
echo ""I'm thinking of a number between 41 and 43. Guess which!""
let number: int = 42
var
  raw_guess: string
  guess: int
while guess != number:
  raw_guess = readLine(stdin)
  if raw_guess == """": continue # Skip this iteration
  guess = str.parseInt(raw_guess)
  if guess == 1001:
    echo(""AAAAAAGGG!"")
    break
  elif guess > number:
    echo(""Nope. Too high."")
  elif guess < number:
    echo(guess, "" is too low"")
  else:
    echo(""Yeeeeeehaw!"")

#
# Iteration
#

for i, elem in [""Yes"", ""No"", ""Maybe so""]: # Or just `for elem in`
  echo(elem, "" is at index: "", i)

for k, v in items(@[(person: ""You"", power: 100), (person: ""Me"", power: 9000)]):
  echo v

let myString = """"""
an <example>
`string` to
play with
"""""" # Multiline raw string

for line in splitLines(myString):
  echo(line)

for i, c in myString:       # Index and letter. Or `for j in` for just letter
  if i mod 2 == 0: continue # Compact `if` form
  elif c == 'X': break
  else: echo(c)

#
# Procedures
#

type Answer = enum aYes, aNo

proc ask(question: string): Answer =
  echo(question, "" (y/n)"")
  while true:
    case readLine(stdin)
    of ""y"", ""Y"", ""yes"", ""Yes"":
      return Answer.aYes  # Enums can be qualified
    of ""n"", ""N"", ""no"", ""No"":
      return Answer.aNo
    else: echo(""Please be clear: yes or no"")

proc addSugar(amount: int = 2) = # Default amount is 2, returns nothing
  assert(amount > 0 and amount < 9000, ""Crazy Sugar"")
  for a in 1..amount:
    echo(a, "" sugar..."")

case ask(""Would you like sugar in your tea?"")
of aYes:
  addSugar(3)
of aNo:
  echo ""Oh do take a little!""
  addSugar()
# No need for an `else` here. Only `yes` and `no` are possible.

#
# FFI
#

# Because Nim compiles to C, FFI is easy:

proc strcmp(a, b: cstring): cint {.importc: ""strcmp"", nodecl.}

let cmp = strcmp(""C?"", ""Easy!"")
```

Additionally, Nim separates itself from its peers with metaprogramming,
performance, and compile-time features.

## Further Reading

* [Home Page](http://nim-lang.org)
* [Download](http://nim-lang.org/download.html)
* [Community](http://nim-lang.org/community.html)
* [FAQ](http://nim-lang.org/question.html)
* [Documentation](http://nim-lang.org/documentation.html)
* [Manual](http://nim-lang.org/docs/manual.html)
* [Standard Library](http://nim-lang.org/docs/lib.html)
* [Rosetta Code](http://rosettacode.org/wiki/Category:Nim)"
"```scheme
;; This gives an introduction to Emacs Lisp in 15 minutes (v0.2d)
;;
;; First make sure you read this text by Peter Norvig:
;; http://norvig.com/21-days.html
;;
;; Then install latest version of GNU Emacs:
;;
;; Debian: apt-get install emacs (or see your distro instructions)
;; OSX: https://emacsformacosx.com/
;; Windows: https://ftp.gnu.org/gnu/emacs/windows/
;;
;; More general information can be found at:
;; http://www.gnu.org/software/emacs/#Obtaining

;; Important warning:
;;
;; Going through this tutorial won't damage your computer unless
;; you get so angry that you throw it on the floor.  In that case,
;; I hereby decline any responsibility.  Have fun!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Fire up Emacs.
;;
;; Hit the `q' key to dismiss the welcome message.
;;
;; Now look at the gray line at the bottom of the window:
;;
;; ""*scratch*"" is the name of the editing space you are now in.
;; This editing space is called a ""buffer"".
;;
;; The scratch buffer is the default buffer when opening Emacs.
;; You are never editing files: you are editing buffers that you
;; can save to a file.
;;
;; ""Lisp interaction"" refers to a set of commands available here.
;;
;; Emacs has a built-in set of commands available in every buffer,
;; and several subsets of commands available when you activate a
;; specific mode.  Here we use the `lisp-interaction-mode', which
;; comes with commands to evaluate and navigate within Elisp code.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Semi-colons start comments anywhere on a line.
;;
;; Elisp programs are made of symbolic expressions (""sexps""):
(+ 2 2)

;; This symbolic expression reads as ""Add 2 to 2"".

;; Sexps are enclosed into parentheses, possibly nested:
(+ 2 (+ 1 1))

;; A symbolic expression contains atoms or other symbolic
;; expressions.  In the above examples, 1 and 2 are atoms,
;; (+ 2 (+ 1 1)) and (+ 1 1) are symbolic expressions.

;; From `lisp-interaction-mode' you can evaluate sexps.
;; Put the cursor right after the closing parenthesis then
;; hold down the control and hit the j keys (""C-j"" for short).

(+ 3 (+ 1 2))
;;           ^ cursor here
;; `C-j' => 6

;; `C-j' inserts the result of the evaluation in the buffer.

;; `C-xC-e' displays the same result in Emacs bottom line,
;; called the ""echo area"". We will generally use `C-xC-e',
;; as we don't want to clutter the buffer with useless text.

;; `setq' stores a value into a variable:
(setq my-name ""Bastien"")
;; `C-xC-e' => ""Bastien"" (displayed in the echo area)

;; `insert' will insert ""Hello!"" where the cursor is:
(insert ""Hello!"")
;; `C-xC-e' => ""Hello!""

;; We used `insert' with only one argument ""Hello!"", but
;; we can pass more arguments -- here we use two:

(insert ""Hello"" "" world!"")
;; `C-xC-e' => ""Hello world!""

;; You can use variables instead of strings:
(insert ""Hello, I am "" my-name)
;; `C-xC-e' => ""Hello, I am Bastien""

;; You can combine sexps into functions:
(defun hello () (insert ""Hello, I am "" my-name))
;; `C-xC-e' => hello

;; You can evaluate functions:
(hello)
;; `C-xC-e' => Hello, I am Bastien

;; The empty parentheses in the function's definition means that
;; it does not accept arguments.  But always using `my-name' is
;; boring, let's tell the function to accept one argument (here
;; the argument is called ""name""):

(defun hello (name) (insert ""Hello "" name))
;; `C-xC-e' => hello

;; Now let's call the function with the string ""you"" as the value
;; for its unique argument:
(hello ""you"")
;; `C-xC-e' => ""Hello you""

;; Yeah!

;; Take a breath.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Now switch to a new buffer named ""*test*"" in another window:

(switch-to-buffer-other-window ""*test*"")
;; `C-xC-e'
;; => [screen has two windows and cursor is in the *test* buffer]

;; Mouse over the top window and left-click to go back.  Or you can
;; use `C-xo' (i.e. hold down control-x and hit o) to go to the other
;; window interactively.

;; You can combine several sexps with `progn':
(progn
  (switch-to-buffer-other-window ""*test*"")
  (hello ""you""))
;; `C-xC-e'
;; => [The screen has two windows and cursor is in the *test* buffer]

;; Now if you don't mind, I'll stop asking you to hit `C-xC-e': do it
;; for every sexp that follows.

;; Always go back to the *scratch* buffer with the mouse or `C-xo'.

;; It's often useful to erase the buffer:
(progn
  (switch-to-buffer-other-window ""*test*"")
  (erase-buffer)
  (hello ""there""))

;; Or to go back to the other window:
(progn
  (switch-to-buffer-other-window ""*test*"")
  (erase-buffer)
  (hello ""you"")
  (other-window 1))

;; You can bind a value to a local variable with `let':
(let ((local-name ""you""))
  (switch-to-buffer-other-window ""*test*"")
  (erase-buffer)
  (hello local-name)
  (other-window 1))

;; No need to use `progn' in that case, since `let' also combines
;; several sexps.

;; Let's format a string:
(format ""Hello %s!\n"" ""visitor"")

;; %s is a place-holder for a string, replaced by ""visitor"".
;; \n is the newline character.

;; Let's refine our function by using format:
(defun hello (name)
  (insert (format ""Hello %s!\n"" name)))

(hello ""you"")

;; Let's create another function which uses `let':
(defun greeting (name)
  (let ((your-name ""Bastien""))
    (insert (format ""Hello %s!\n\nI am %s.""
                    name       ; the argument of the function
                    your-name  ; the let-bound variable ""Bastien""
                    ))))

;; And evaluate it:
(greeting ""you"")

;; Some functions are interactive:
(read-from-minibuffer ""Enter your name: "")

;; Evaluating this function returns what you entered at the prompt.

;; Let's make our `greeting' function prompt for your name:
(defun greeting (from-name)
  (let ((your-name (read-from-minibuffer ""Enter your name: "")))
    (insert (format ""Hello!\n\nI am %s and you are %s.""
                    from-name ; the argument of the function
                    your-name ; the let-bound var, entered at prompt
                    ))))

(greeting ""Bastien"")

;; Let's complete it by displaying the results in the other window:
(defun greeting (from-name)
  (let ((your-name (read-from-minibuffer ""Enter your name: "")))
    (switch-to-buffer-other-window ""*test*"")
    (erase-buffer)
    (insert (format ""Hello %s!\n\nI am %s."" your-name from-name))
    (other-window 1)))

;; Now test it:
(greeting ""Bastien"")

;; Take a breath.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Let's store a list of names:
;; If you want to create a literal list of data, use ' to stop it from
;; being evaluated - literally, ""quote"" the data.
(setq list-of-names '(""Sarah"" ""Chloe"" ""Mathilde""))

;; Get the first element of this list with `car':
(car list-of-names)

;; Get a list of all but the first element with `cdr':
(cdr list-of-names)

;; Add an element to the beginning of a list with `push':
(push ""Stephanie"" list-of-names)

;; NOTE: `car' and `cdr' don't modify the list, but `push' does.
;; This is an important difference: some functions don't have any
;; side-effects (like `car') while others have (like `push').

;; Let's call `hello' for each element in `list-of-names':
(mapcar 'hello list-of-names)

;; Refine `greeting' to say hello to everyone in `list-of-names':
(defun greeting ()
    (switch-to-buffer-other-window ""*test*"")
    (erase-buffer)
    (mapcar 'hello list-of-names)
    (other-window 1))

(greeting)

;; Remember the `hello' function we defined above?  It takes one
;; argument, a name.  `mapcar' calls `hello', successively using each
;; element of `list-of-names' as the argument for `hello'.

;; Now let's arrange a bit what we have in the displayed buffer:

(defun replace-hello-by-bonjour ()
    (switch-to-buffer-other-window ""*test*"")
    (goto-char (point-min))
    (while (search-forward ""Hello"")
      (replace-match ""Bonjour""))
    (other-window 1))

;; (goto-char (point-min)) goes to the beginning of the buffer.
;; (search-forward ""Hello"") searches for the string ""Hello"".
;; (while x y) evaluates the y sexp(s) while x returns something.
;; If x returns `nil' (nothing), we exit the while loop.

(replace-hello-by-bonjour)

;; You should see all occurrences of ""Hello"" in the *test* buffer
;; replaced by ""Bonjour"".

;; You should also get an error: ""Search failed: Hello"".
;;
;; To avoid this error, you need to tell `search-forward' whether it
;; should stop searching at some point in the buffer, and whether it
;; should silently fail when nothing is found:

;; (search-forward ""Hello"" nil t) does the trick:

;; The `nil' argument says: the search is not bound to a position.
;; The `'t' argument says: silently fail when nothing is found.

;; We use this sexp in the function below, which doesn't throw an error:

(defun hello-to-bonjour ()
    (switch-to-buffer-other-window ""*test*"")
    (erase-buffer)
    ;; Say hello to names in `list-of-names'
    (mapcar 'hello list-of-names)
    (goto-char (point-min))
    ;; Replace ""Hello"" by ""Bonjour""
    (while (search-forward ""Hello"" nil t)
      (replace-match ""Bonjour""))
    (other-window 1))

(hello-to-bonjour)

;; Let's boldify the names:

(defun boldify-names ()
    (switch-to-buffer-other-window ""*test*"")
    (goto-char (point-min))
    (while (re-search-forward ""Bonjour \\(.+\\)!"" nil t)
      (add-text-properties (match-beginning 1)
                           (match-end 1)
                           (list 'face 'bold)))
    (other-window 1))

;; This functions introduces `re-search-forward': instead of
;; searching for the string ""Bonjour"", you search for a pattern,
;; using a ""regular expression"" (abbreviated in the prefix ""re-"").

;; The regular expression is ""Bonjour \\(.+\\)!"" and it reads:
;; the string ""Bonjour "", and
;; a group of            | this is the \\( ... \\) construct
;;   any character       | this is the .
;;   possibly repeated   | this is the +
;; and the ""!"" string.

;; Ready?  Test it!

(boldify-names)

;; `add-text-properties' adds... text properties, like a face.

;; OK, we are done.  Happy hacking!

;; If you want to know more about a variable or a function:
;;
;; C-h v a-variable RET
;; C-h f a-function RET
;;
;; To read the Emacs Lisp manual with Emacs:
;;
;; C-h i m elisp RET
;;
;; To read an online introduction to Emacs Lisp:
;; https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html
```

### Further Reading
- [GNU Elisp Manual](https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html)
- [Emacs Wiki](https://www.emacswiki.org/emacs/LearningEmacs)
- [Emacs Docs](https://emacsdocs.org/docs/elisp/Emacs-Lisp)
- [Mpre Elisp Docs](https://www.math.utah.edu/docs/info/elisp_22.html)"
"**Qt** is a widely-known framework for developing cross-platform software that can be run on various software and hardware platforms with little or no change in the code, while having the power and speed of native applications. Though **Qt** was originally written in *C++*, there are its ports to other languages: *[PyQt](https://learnxinyminutes.com/docs/pyqt/)*, *QtRuby*, *PHP-Qt*, etc.

**Qt** is great for creating applications with graphical user interface (GUI). This tutorial is how to do it in *C++*.

```c++
/*
 * Let's start classically
 */

// all headers from Qt framework start with capital letter 'Q'
#include <QApplication>
#include <QLineEdit>

int main(int argc, char *argv[]) {
	 // create an object to manage application-wide resources
    QApplication app(argc, argv);

    // create line edit widget and show it on screen
    QLineEdit lineEdit(""Hello world!"");
    lineEdit.show();

    // start the application's event loop
    return app.exec();
}
```

GUI-related part of **Qt** is all about *widgets* and *connections* between them.

[READ MORE ABOUT WIDGETS](http://doc.qt.io/qt-5/qtwidgets-index.html)

```c++
/*
 * Let's create a label and a button.
 * A label should appear when a button is pressed.
 * 
 * Qt code is speaking for itself.
 */
 
#include <QApplication>
#include <QDialog>
#include <QVBoxLayout>
#include <QPushButton>
#include <QLabel>

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    QDialog dialogWindow;
    dialogWindow.show();
    
    // add vertical layout 
    QVBoxLayout layout;
    dialogWindow.setLayout(&layout);  

    QLabel textLabel(""Thanks for pressing that button"");
    layout.addWidget(&textLabel);
    textLabel.hide();

    QPushButton button(""Press me"");
    layout.addWidget(&button);
    
    // show hidden label when the button is pressed
    QObject::connect(&button, &QPushButton::pressed,
                     &textLabel, &QLabel::show);

    return app.exec();
}
```

Notice that *QObject::connect* part. This method is used to connect *SIGNALS* of one objects to *SLOTS* of another.

**Signals** are being emitted when certain things happen with objects, like *pressed* signal is emitted when user presses on QPushButton object.

**Slots** are *actions* that might be performed in response to received signals.

[READ MORE ABOUT SLOTS AND SIGNALS](http://doc.qt.io/qt-5/signalsandslots.html)


Next, let's learn that we can not only use standard widgets but also extend their behaviour using inheritance. Let's create a button and count how many times it was pressed. For this purpose we define our own class *CounterLabel*.  It must be declared in separate file because of specific Qt architecture.

```c++
// counterlabel.hpp

#ifndef COUNTERLABEL
#define COUNTERLABEL

#include <QLabel>

class CounterLabel : public QLabel {
    Q_OBJECT  // Qt-defined macros that must be present in every custom widget

public:
    CounterLabel() : counter(0) {
        setText(""Counter has not been increased yet"");  // method of QLabel
    }

public slots:
    // action that will be called in response to button press
    void increaseCounter() {
        setText(QString(""Counter value: %1"").arg(QString::number(++counter)));
    }

private:
    int counter;
};

#endif // COUNTERLABEL
```

```c++
// main.cpp
// Almost the same as in previous example

#include <QApplication>
#include <QDialog>
#include <QVBoxLayout>
#include <QPushButton>
#include <QString>
#include ""counterlabel.hpp""

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    QDialog dialogWindow;
    dialogWindow.show();

    QVBoxLayout layout;
    dialogWindow.setLayout(&layout);

    CounterLabel counterLabel;
    layout.addWidget(&counterLabel);

    QPushButton button(""Push me once more"");
    layout.addWidget(&button);
    QObject::connect(&button, &QPushButton::pressed,
                     &counterLabel, &CounterLabel::increaseCounter);

    return app.exec();
}
```

That's it! Of course, Qt framework is much much larger than the part that was covered in this tutorial, so be ready to read and practice.

## Further reading

- [Qt 4.8 tutorials](http://doc.qt.io/qt-4.8/tutorials.html)
- [Qt 5 tutorials](http://doc.qt.io/qt-5/qtexamplesandtutorials.html)

Good luck and have fun!"
"MessagePack is an efficient binary serialization format. It lets you exchange data among multiple languages like JSON. The benefits over other formats is that it's faster and smaller. 

In MessagePack, small integers are encoded into a single byte, and typical short strings require only one extra byte in addition to the strings themselves. This makes MessagePack useful for efficient transmission over wire.

```

# 0. Understanding The Structure ====

JSON, 40 Bytes UTF-8
	
----------------------------------------------
| {""name"":""John Doe"",""age"":12}		         |
----------------------------------------------
|  {""         | 7B 22                        |
|    name     | 6E 61 6D 65                  |
|  "":""        | 22 3A 22                     |
|    John Doe | 4A 6F 68 6E 20 44 6F 65      |
|  "",""        | 22 2C 22                     |
|    age      | 61 67 65                     |
|  "":         | 22 3A 20                     |
|    12       | 31 32                        |
|  }          | 7D                           |
----------------------------------------------


MessagePack, 27 Bytes UTF-8
	
----------------------------------------------
| ‚¤name¨John Doe£age.12                     |
----------------------------------------------
|  ‚¤         | 82 84                        |
|    name     | 6E 61 6D 65                  |
|  ¨          | A8                           |
|    John Doe | 4A 6F 68 6E 20 44 6F 65      |
|  £          | A3                           |
|    age      | 61 67 65                     |
|  .          | 0C                           |
|    12       | 31 32                        |
----------------------------------------------

# 1. JAVA ====

"""""" Installing with Maven
""""""

<dependencies>
  ...
  <dependency>
    <groupId>org.msgpack</groupId>
    <artifactId>msgpack</artifactId>
    <version>${msgpack.version}</version>
  </dependency>
  ...
</dependencies>


"""""" Simple Serialization/Deserialization
""""""

// Create serialize objects.
List<String> src = new ArrayList<String>();
src.add(""msgpack"");
src.add(""kumofs"");

MessagePack msgpack = new MessagePack();
// Serialize
byte[] raw = msgpack.write(src);

// Deserialize directly using a template
List<String> dst1 = msgpack.read(raw, Templates.tList(Templates.TString));
System.out.println(dst1.get(0));
System.out.println(dst1.get(1));

// Or, Deserialze to Value then convert type.
Value dynamic = msgpack.read(raw);
List<String> dst2 = new Converter(dynamic)
    .read(Templates.tList(Templates.TString));
System.out.println(dst2.get(0));
System.out.println(dst2.get(1));


# 2. RUBY ====

"""""" Installing the Gem
""""""

gem install msgpack

"""""" Streaming API
""""""

# serialize a 2-element array [e1, e2]
pk = MessagePack::Packer.new(io)
pk.write_array_header(2).write(e1).write(e2).flush

# deserialize objects from an IO
u = MessagePack::Unpacker.new(io)
u.each { |obj| ... }

# event-driven deserialization
def on_read(data)
  @u ||= MessagePack::Unpacker.new
  @u.feed_each(data) { |obj| ... }
end

# 3. NODE.JS ====

"""""" Installing with NPM
""""""

npm install msgpack5 --save

"""""" Using in Node
""""""

var msgpack = require('msgpack5')() // namespace our extensions
  , a       = new MyType(2, 'a')
  , encode  = msgpack.encode
  , decode  = msgpack.decode

msgpack.register(0x42, MyType, mytipeEncode, mytipeDecode)

console.log(encode({ 'hello': 'world' }).toString('hex'))
// 81a568656c6c6fa5776f726c64
console.log(decode(encode({ 'hello': 'world' })))
// { hello: 'world' }
console.log(encode(a).toString('hex'))
// d5426161
console.log(decode(encode(a)) instanceof MyType)
// true
console.log(decode(encode(a)))
// { value: 'a', size: 2 }

function MyType(size, value) {
  this.value = value
  this.size  = size
}

function mytipeEncode(obj) {
  var buf = new Buffer(obj.size)
  buf.fill(obj.value)
  return buf
}

function mytipeDecode(data) {
  var result = new MyType(data.length, data.toString('utf8', 0, 1))
    , i

  for (i = 0; i < data.length; i++) {
    if (data.readUInt8(0) != data.readUInt8(i)) {
      throw new Error('should all be the same')
    }
  }

  return result
}

```


# References

- [MessagePack](http://msgpack.org/index.html)
- [MsgPack vs. JSON: Cut your client-server exchange traffic by 50% with one line of code](http://indiegamr.com/cut-your-data-exchange-traffic-by-up-to-50-with-one-line-of-code-msgpack-vs-json/)"
"# Cairo

Cairo is a Turing-complete language that allows you write provable programs
(where one party can prove to another that a certain computation was executed
correctly) on StarkNet.

## StarkNet

StarkNet is a decentralized ZK-rollup that operates as an Ethereum layer 2
chain.

In this document, we are going to be going in-depth into understanding Cairo's
syntax and how you could create and deploy a Cairo smart contract on StarkNet.

**NB: As at the time of this writing, StarkNet is still at v0.10.3, with Cairo
1.0 coming soon. The ecosystem is young and evolving very fast, so you might
want to check the [official docs](https://www.cairo-lang.org/docs) to confirm
this document is still up-to-date. Pull requests are welcome!**

## Setting Up A Development Environment

Before we get started writing codes, we will need to setup a Cairo development
environment, for writing, compiling and deploying our contracts to StarkNet.
For the purpose of this tutorial we are going to be using the
[Protostar Framework](https://github.com/software-mansion/protostar).
Installation steps can be found in the docs
[here](https://docs.swmansion.com/protostar/docs/tutorials/installation).
Note that Protostar supports just Mac and Linux OS, Windows users might need to
use WSL, or go for other alternatives such as the Official
[StarkNet CLI](https://www.cairo-lang.org/docs/quickstart.html) or
[Nile from Openzeppelin](https://github.com/OpenZeppelin/nile)

Once you're done with the installations, run the command `protostar -v` to
confirm your installation was successful. If successful, you should see your
Protostar version displayed on the screen.

## Initializing a new project

Protostar similar to Truffle for solidity development can be installed once and
used for multiple projects. To initialize a new Protostar project, run the
following command:

```
protostar init
```

It would then request the project's name and the library's directory name,
you'd need to fill in this, and a new project will be initialized successfully.

## Compiling, Declaring, Deploying and Interacting with StarkNet Contracts

Within the `src` folder you'll find a boilerplate contract that comes with
initializing a new Protostar project, `main.cairo`. We are going to be
compiling, declaring and deploying this contract.

### Compiling Contracts

To compile a Cairo contract using Protostar, ensure a path to the contract is
specified in the `[contracts]` section of the `protostar.toml` file. Once
you've done that, open your terminal and run the command:

```
protostar build
```

And you should get an output similar to what you see below, with a `main.json`
and `main_abi.json` files created in the `build` folder.
<img src=""./images/cairo/build.png"" alt=""building your contract"">

### Declaring Contracts

With the recent StarkNet update to 0.10.3, the DEPLOY transaction was
deprecated and no longer works. To deploy a transaction, you must first declare
a Contract to obtain the class hash, then deploy the declared contract using the
[Universal Deployer Contract](https://community.starknet.io/t/universal-deployer-contract-proposal/1864).

Before declaring or deploying your contract using Protostar, you should set the
private key associated with the specified account address in a file, or in the
terminal. To set your private key in the terminal, run the command:

```
export PROTOSTAR_ACCOUNT_PRIVATE_KEY=[YOUR PRIVATE KEY HERE]
```

Then to declare our contract using Protostar run the following command (for
visual clarity, the backslash sign symbolizes the continuing line):

```
protostar declare ./build/main.json \
  --network testnet \
  --account 0x0691622bBFD29e835bA4004e7425A4e9630840EbD11c5269DE51C16774585b16 \
  --max-fee auto
```

where `network` specifies the network we are deploying to, `account` specifies
account whose private key we are using, `max-fee` specifies the maximum fee to
be paid for the transaction. You should get the class hash outputted as seen
below:
<img src=""./images/cairo/declare.png"" alt=""declaring your contract"">

### Deploying Contracts

After obtaining our class hash from declaring, we can now deploy using the
command below:

```
protostar \
  deploy 0x02a5de1b145e18dfeb31c7cd7ff403714ededf5f3fdf75f8b0ac96f2017541bc \
  --network testnet \
  --account 0x0691622bBFD29e835bA4004e7425A4e9630840EbD11c5269DE51C16774585b16 \
  --max-fee auto
```

where `0x02a5de1b145e18dfeb31c7cd7ff403714ededf5f3fdf75f8b0ac96f2017541bc` is
the class hash of our contract.
<img src=""./images/cairo/deploy.png"" alt=""deploying your contract"">

### Interacting with Contracts

To interact with your deployed contract, we will be using `Argent X`
(alternative: `Braavos`), and `Starkscan` (alternative: `Voyager`). To install
and setup `Argent X`, see this
[guide](https://www.argent.xyz/learn/how-to-create-an-argent-x-wallet/).

Copy your contract address, displayed on screen from the previous step, and
head over to [Starkscan](https://testnet.starkscan.co/) to search for the
contract. Once found, you can make write calls to the contract in the following
sequence:

+ click on the ""connect wallet"" button,
  <img src=""./images/cairo/connect.png"" alt=""connect wallet"">
+ select `Argent X` and approve the connection
  <img src=""./images/cairo/connect2.png"" alt=""connect to argentX"">
+ you can now make read and write calls easily.

## Let's learn Cairo

First let's look at a default contract that comes with Protostar which allows
you to set balance on deployment, increase, and get the balance.

```
// Language directive - instructs compiler its a StarkNet contract
%lang starknet

// Library imports from the Cairo-lang library
from starkware.cairo.common.math import assert_nn
from starkware.cairo.common.cairo_builtins import HashBuiltin

// @dev Storage variable that stores the balance of a user.
// @storage_var is a decorator that instructs the compiler the function
//   below it is a storage variable.
@storage_var
func balance() -> (res: felt) {}

// @dev Constructor writes the balance variable to 0 on deployment
// Constructors sets storage variables on deployment. Can accept arguments too.
@constructor
func constructor{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
range_check_ptr}() {
  balance.write(0); 
  return();
}

// @dev increase_balance updates the balance variable
// @param amount the amount you want to add to balance
// @external is a decorator that specifies the func below it is an external
//   function.
@external
func increase_balance{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
range_check_ptr}(amount: felt){
  with_attr error_message(""Amount must be positive. Got: {amount}."") {
    assert_nn(amount);
  }

  let (res) = balance.read();
  balance.write(res + amount);
  return ();
}

// @dev returns the balance variable
// @view is a decorator that specifies the func below it is a view function.
@view
func get_balance{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
range_check_ptr}() -> (res: felt) {
  let (res) = balance.read();
  return (res,);
}
```

Before proceeding to the main lessons, try to build, deploy and interact with
this contract.
NB: You should be at `main.cairo` if you are using Protostar.

### 1. The Felt data type

Unlike solidity, where you have access to various data types, Cairo comes with
just a single data type `..felts`. Felts stands for Field elements, and are a
252 bit integer in the range `0<=x<=P` where `P` is a prime number. You can
create a `Uint256` in Cairo by utlizing a struct of two 128 bits felts.

```
struct Uint256 {
  low: felt, // The low 128 bits of the value.
  high: felt, // The high 128 bits of the value.
}
```

To avoid running into issues with divisions, it's safer to work with the
`unsigned_div_rem` method from Cairo-lang's library.

### 2. Lang Directive and Imports

To get started with writing a StarkNet contract, you must specify the directive:

```
%lang starknet
```

This directive informs the compiler you are writing a contract and not a
program. The difference between both is contracts have access to StarkNet's
storage, programs don't and as such are stateless.

There are important functions you might need to import from the official
Cairo-lang library or Openzeppelin's, e.g.

```
from starkware.cairo.common.cairo_builtins import HashBuiltin
from cairo_contracts.src.openzeppelin.token.erc20.library import ERC20
from starkware.cairo.common.uint256 import Uint256
from starkware.cairo.common.bool import TRUE
```

### 3. Data Structures

+ Storage variables: Cairo's storage is a map with `2^251` slots, where each
  slot is a felt which is initialized to `0`. You create one using the
  `@storage_var` decorator.

  ```
  @storage_var
  func names() -> (name: felt) {}
  ```

+ Storage mappings: Unlike Solidity where mappings have a separate keyword, in
  Cairo you create mappings using storage variables.

  ```
  @storage_var
  func names(address: felt) -> (name: felt) {}
  ```

+ Structs: are a means to create custom data types in Cairo. A `struct` has a
  size, which is the sum of the sizes of its members. The size can be
  retrieved using `MyStruct.SIZE`. You create a struct in Cairo using the
  `struct` keyword.

  ```
  struct Person {
    name: felt,
    age: felt,
    address: felt,
  }
  ```

+ Constants: Constants are fixed and as such can't be altered after being set.
  They evaluate to an integer (field element) at compile time. To create a
  constant in Cairo, you use the `const` keyword. It's proper practice to
  capitalize constant names.

  ```
  const USER = 0x01C6cfC1DB2ae90dACEA243F0a8C2F4e32560F7cDD398e4dA2Cc56B733774E9b
  ```

+ Arrays: Arrays can be defined as a `pointer(felt*)` to the first element of
  the array. As an array is populated, its elements take up contigous memory
  cells. The `alloc` keyword can be used to dynamically allocate a new memory
  segment, which can be used to store an array:

  ```
  let (myArray: felt*) = alloc ();
  assert myArray[0] = 1;
  assert myArray[1] = 2;
  assert myArray[3] = 3;
  ```

  You can also use the `new` operator to create fixed-size arrays using
  tuples. The new operator is useful as it enables you allocate memory and
  initialize the object in one instruction

  ```
  func foo() {
    tempvar arr: felt* = new (1, 1, 2, 3, 5);
    assert arr[4] = 5;
    return ();
  }
  ```

+ Tuples: A tuple is a finite, ordered, unchangeable list of elements. It is
  represented as a comma-separated list of elements enclosed by parentheses.
  Their elements may be of any combination of valid types.

  ```
  local tuple0: (felt, felt, felt) = (7, 9, 13);
  ```

+ Events: Events allows a contract emit information during the course of its
  execution, that can be used outside of StarkNet. An event can be created,
  subsequently emitted:

  ```
  @event
  func name_stored(address, name) {}

  name_stored.emit(address, name);
  ```

### 4. Constructors, External and View functions

+ Constructors: Constructors are a way to intialize state variables on
  contract deployment. You create a constructor using the `@constructor`
  decorator.

  ```
  @constructor
  func constructor{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
  range_check_ptr}(_name: felt) {
    let (caller) = get_caller_address();
    names.write(caller, _name);
    return ();
  }
  ```

+ External functions: External functions are functions that modifies the state
  of the network. You create an external function using the `@external`
  decorator:

  ```
  @external
  func store_name{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
  range_check_ptr}(_name: felt){
    let (caller) = get_caller_address();
    names.write(caller, _name);
    stored_name.emit(caller, _name);
    return ();
  }
  ```

+ View functions: View functions do not modify the state of the blockchain.
  You can create a view function using the `@view` decorator.

  ```
  @view
  func get_name{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
  range_check_ptr}(_address: felt) -> (name: felt){
    let (name) = names.read(_address);
    return (name,);
  }
  ```

    NB: Unlike Solidity, Cairo supports just External and View function types.
    You can alternatively also create an internal function by not adding any
    decorator to the function.

### 5. Decorators

All functions in Cairo are specified by the `func` keyword, which can be
confusing. Decorators are used by the compiler to distinguish between these
functions.

Here are the most common decorators you'll encounter in Cairo:

+ `@storage_var` — used for specifying state variables.
+ `@constructor` — used for specifying constructors.
+ `@external` — used for specifying functions that write to a state variable.
+ `@event` — used for specifying events
+ `@view` — used to specify functions reading from a state variable
+ `@contract_interface` — used for specifying function interfaces.
+ `@l1_handler` — used for specifying functions that processes message sent from
  an L1 contract in a messaging bridge.

### 6. BUILTINS, HINTS & IMPLICIT Arguments

+ `BUILTINS` are predefined optimized low-level execution units, which are
  added to Cairo’s CPU board. They help perform predefined computations like
  pedersen hashing, bitwise operations etc, which are expensive to perform in
  Vanilla Cairo. Each builtin in Cairo is assigned a separate memory location,
  accessible through regular Cairo memory calls using implicit parameters. You
  specify them using the `%builtins` directive

  Here is a list of available builtins in Cairo:

    + `output` — the output builtin is used for writing program outputs
    + `pedersen` — the pedersen builtin is used for pedersen hashing
      computations
    + `range_check` — This builtin is mostly used for integer comparisons,
      and facilitates check to confirm that a field element is within a range
      `[0, 2^128)`
    + `ecdsa` — the ecdsa builtin is used for verifying ECDSA signatures
    + `bitwise` — the bitwise builtin is used for carrying out bitwise
      operations on felts

+ `HINTS` are pieces of Python codes, which contains instructions that only
  the prover sees and executes. From the point of view of the verifier these
  hints do not exist. To specify a hint in Cairo, you need to encapsulate it
  within `%{` and `%}`. It is good practice to avoid using hints as much as
  you can in your contracts, as hints are not added to the bytecode, and thus
  do not count in the total number of execution steps.

  ```
  %{
    # Python hint goes here
  %}
  ```

+ `IMPLICIT ARGUMENTS` are not restricted to the function body, but can be
  inherited by other functions calls that require them. Implicit arguments are
  passed in between curly bracelets, like you can see below:

  ```
  func store_name{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
  range_check_ptr}(_name: felt){
    let (caller) = get_caller_address();
    names.write(caller, _name);
    stored_name.emit(caller, _name);
    return ();
  }
  ```

### 7. Error Messages and Access Controls

You can create custom errors in Cairo which is outputted to the user upon failed
execution. This can be very useful for implementing checks and proper access
control mechanisms. An example is preventing a user to call a function except
user is `admin`.

```
// imports
from starkware.starknet.common.syscalls import get_caller_address

// create an admin constant
const ADMIN = 0x01C6cfC1DB2ae90dACEA243F0a8C2F4e32560F7cDD398e4dA2Cc56B733774E9b

// implement access control
with_attr error_message(""You do not have access to make this action!""){
  let (caller) = get_caller_address();
  assert ADMIN = caller;
}

// using an assert statement throws if condition is not true, thus
// returning the specified error.
```

### 8. Contract Interfaces

Contract interfaces provide a means for one contract to invoke or call the
external function of another contract. To create a contract interface, you use
the `@contract_interface` keyword:

```
@contract_interface
  namespace IENS {
    func store_name(_name: felt) {
    }

    func get_name(_address: felt) -> (name: felt) {
    }
  }
```

Once a contract interface is specified, any contract can make calls to that
contract passing in the contract address as the first parameter like this:

```
IENS.store_name(contract_address, _name);
```

Note that Interfaces exclude the function body/logic and the implicit
arguments.

### 9. Recursions

Due to the unavailability of loops, Recursion is the go-to for similar
operations. In simple terms, a recursive function is one which calls itself
repeatedly.

A good example to demonstrate this is writing a function for getting the nth
fibonacci number:

```
@external
func fibonacci{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
range_check_ptr}(n : felt) -> (result : felt){
  alloc_locals;
  if (n == 0){
    return (0);
  }
  if (n == 1){
    return (1);
  }
  let (local x) = fibonacci(n - 1);
  let (local y) = fibonacci(n - 2);
  return (result=(x + y));
}
```

The nth fibonacci term is the sum of the `nth - 1` and the `nth - 2` numbers,
that's why we get these two as `(x,y)` using recursion.

NB: when implementing recursive functions, always remember to implement a base
case (`n==0`, `n==1` in our case), to prevent stack overflows.

### 10. Registers

Registers holds values that may change over time. There are 3 major types of
registers:

+ `ap` (allocation pointer) points to a yet unused memory. Temporary variables
   created using `let`, `tempvar` are held here, and thus susceptible to being
   revoked.
+ `fp` (frame pointer) points to the frame of the current function. The address
  of all the function arguments and local variables are relative to this
  register and as such can never be revoked.
+ `pc` (program counter) points to the current instruction.

### 11. Revoked References

Revoked references occur when there is a call instruction to another function,
between the definition of a reference variable that depends on `ap` (temp
variables) and its usage. This occurs as the compiler may not be able to compute
the change of `ap` (as one may jump to the label from another place in the
program, or call a function that might change ap in an unknown way).

Here is an example to demonstrate what I mean:

```
@external
func get_balance{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
range_check_ptr}() -> (res: felt) {
  return (res=100);
}

@external
func double_balance{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
range_check_ptr}() -> (res: felt) {
  let multiplier = 2;
  let (balance) = get_balance();
  let new_balance = balance * multiplier;
  return (res=new_balance);
}
```

If you run that code, you'll run into the revoked reference error as we are
trying to access the `multiplier` variable after calling the `get_balance`
function.

In simple cases you can resolve revoked references by adding the keyword
`alloc_locals` within function scopes. In more complex cases you might need to
create a local variable to resolve it.

```
// resolving the `double_balance` function:
@external
func double_balance{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
range_check_ptr}() -> (res: felt) {
  alloc_locals;
  let multiplier = 2;
  let (balance) = get_balance();
  let new_balance = balance * multiplier;
  return (res=new_balance);
}
```

### 12. Understanding Cairo's Punctuations

+ `;` (semicolon). Used at the end of each instruction
+ `()` (parentheses). Used in a function declaration, if statements, and in a
  tuple declaration
+ `{}` (curly braces). Used in a declaration of implicit arguments and to define
  code blocks.
+ `[]` (square brackets). Standalone brackets represent the value at a
  particular address location (such as the allocation pointer, `[ap]`). Brackets
  following a pointer or a tuple act as a subscript operator, where `x[2]`
  represents the element with index `2` in `x`.
+ `*` (single asterisk). Refers to the pointer of an expression.
+ `%` (percent sign). Appears at the start of a directive, such as `%builtins`
  or `%lang`.
+ `%{` and `%}` represent Python hints.
+ `_` (underscore). A placeholder to handle values that are not used, such as an
  unused function return value.

## Full Contract Example

Below is a simple automated market maker contract example that implements most
of what we just learnt! Re-write, deploy, have fun!

```
%lang starknet

from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.cairo.common.hash import hash2
from starkware.cairo.common.alloc import alloc
from starkware.cairo.common.math import (assert_le, assert_nn_le,
  unsigned_div_rem)
from starkware.starknet.common.syscalls import (get_caller_address,
  storage_read, storage_write)


// CONSTANTS
//
// @dev the maximum amount of each token that belongs to the AMM
const BALANCE_UPPER_BOUND = 2 ** 64;

const TOKEN_TYPE_A = 1;
const TOKEN_TYPE_B = 2;

// @dev Ensure the user's balances are much smaller than the pool's balance
const POOL_UPPER_BOUND = 2 ** 30;
const ACCOUNT_BALANCE_BOUND = 1073741; // (2 ** 30 / 1000)


// STORAGE VARIABLES
//
// @dev A map from account and token type to corresponding balance
@storage_var
func account_balance(account_id: felt, token_type: felt) -> (balance: felt) {}

// @dev a map from token type to corresponding pool balance
@storage_var
func pool_balance(token_type: felt) -> (balance: felt) {}


// GETTERS
//
// @dev returns account balance for a given token
// @param account_id Account to be queried
// @param token_type Token to be queried
@view
func get_account_token_balance{syscall_ptr: felt*, pedersen_ptr:
HashBuiltin*, range_check_ptr}(
  account_id: felt, token_type: felt
  ) -> (balance: felt) {
  return account_balance.read(account_id, token_type);
}

// @dev return the pool's balance
// @param token_type Token type to get pool balance
@view
func get_pool_token_balance{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
range_check_ptr}(
  token_type: felt
  ) -> (balance: felt) {
  return pool_balance.read(token_type);
}


// EXTERNALS
//
// @dev set pool balance for a given token
// @param token_type Token whose balance is to be set
// @param balance Amount to be set as balance
@external
func set_pool_token_balance{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
range_check_ptr}(
  token_type: felt, balance: felt
  ) {
  with_attr error_message(""exceeds maximum allowed tokens!""){
    assert_nn_le(balance, BALANCE_UPPER_BOUND - 1);
  }

  pool_balance.write(token_type, balance);
  return ();
}

// @dev add demo token to the given account
// @param token_a_amount amount of token a to be added
// @param token_b_amount amount of token b to be added
@external
func add_demo_token{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
range_check_ptr}(
    token_a_amount: felt, token_b_amount: felt
  ) {
  alloc_locals;
  let (account_id) = get_caller_address();

  modify_account_balance(account_id=account_id, token_type=TOKEN_TYPE_A,
    amount=token_a_amount);
  modify_account_balance(account_id=account_id, token_type=TOKEN_TYPE_B,
    amount=token_b_amount);

  return ();
}

// @dev intialize AMM
// @param token_a amount of token a to be set in pool
// @param token_b amount of token b to be set in pool
@external
func init_pool{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
range_check_ptr}(
  token_a: felt, token_b: felt
  ) {
  with_attr error_message(""exceeds maximum allowed tokens!""){
    assert_nn_le(token_a, POOL_UPPER_BOUND - 1);
    assert_nn_le(token_b, POOL_UPPER_BOUND - 1);
  }

  set_pool_token_balance(token_type=TOKEN_TYPE_A, balance=token_a);
  set_pool_token_balance(token_type=TOKEN_TYPE_B, balance=token_b);

  return ();
}


// @dev swaps token between the given account and the pool
// @param token_from token to be swapped
// @param amount_from amount of token to be swapped
// @return amount_to the token swapped to
@external
func swap{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
  token_from: felt, amount_from: felt
  ) -> (amount_to: felt) {
  alloc_locals;
  let (account_id) = get_caller_address();

  // verify token_from is TOKEN_TYPE_A or TOKEN_TYPE_B
  with_attr error_message(""token not allowed in pool!""){
    assert (token_from - TOKEN_TYPE_A) * (token_from - TOKEN_TYPE_B) = 0;
    }

  // check requested amount_from is valid
  with_attr error_message(""exceeds maximum allowed tokens!""){
    assert_nn_le(amount_from, BALANCE_UPPER_BOUND - 1);
    }

  // check user has enough funds
  let (account_from_balance) =
    get_account_token_balance(account_id=account_id, token_type=token_from);
  with_attr error_message(""insufficient balance!""){
    assert_le(amount_from, account_from_balance);
    }

  let (token_to) = get_opposite_token(token_type=token_from);
  let (amount_to) = do_swap(account_id=account_id, token_from=token_from,
    token_to=token_to, amount_from=amount_from);

  return (amount_to=amount_to);
}


// INTERNALS
//
// @dev internal function that updates account balance for a given token
// @param account_id Account whose balance is to be modified
// @param token_type Token type to be modified
// @param amount Amount Amount to be added
func modify_account_balance{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
range_check_ptr}(
  account_id: felt, token_type: felt, amount: felt
  ) {
  let (current_balance) = account_balance.read(account_id, token_type);
  tempvar new_balance = current_balance + amount;

  with_attr error_message(""exceeds maximum allowed tokens!""){
    assert_nn_le(new_balance, BALANCE_UPPER_BOUND - 1);
    }

  account_balance.write(account_id=account_id, token_type=token_type,
    value=new_balance);
  return ();
}

// @dev internal function that swaps tokens between the given account and
// the pool
// @param account_id Account whose tokens are to be swapped
// @param token_from Token type to be swapped from
// @param token_to Token type to be swapped to
// @param amount_from Amount to be swapped
func do_swap{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*,
range_check_ptr}(
  account_id: felt, token_from: felt, token_to: felt, amount_from: felt
  ) -> (amount_to: felt) {
  alloc_locals;

  // get pool balance
  let (local amm_from_balance) = get_pool_token_balance(token_type =
    token_from);
  let (local amm_to_balance) = get_pool_token_balance(token_type=token_to);

  // calculate swap amount
  let (local amount_to, _) = unsigned_div_rem((amm_to_balance *
    amount_from), (amm_from_balance + amount_from));

  // update token_from balances
  modify_account_balance(account_id=account_id, token_type=token_from,
    amount=-amount_from);
  set_pool_token_balance(token_type=token_from, balance=(amm_from_balance
    + amount_from));

  // update token_to balances
  modify_account_balance(account_id=account_id, token_type=token_to,
    amount=amount_to);
  set_pool_token_balance(token_type=token_to, balance=(amm_to_balance -
    amount_to));

  return (amount_to=amount_to);
}


// @dev internal function to get the opposite token type
// @param token_type Token whose opposite pair needs to be gotten
func get_opposite_token(token_type: felt) -> (t: felt) {
  if(token_type == TOKEN_TYPE_A) {
    return (t=TOKEN_TYPE_B);
  } else {
    return (t=TOKEN_TYPE_A);
  }
}
```

## Additional Resources

+ [Official documentation](https://www.cairo-lang.org/docs/)
+ [Starknet EDU](https://medium.com/starknet-edu)
+ [Journey through Cairo](https://medium.com/@darlingtonnnam/journey-through-cairo-i-setting-up-protostar-and-argentx-for-local-development-ba40ae6c5524)
+ [Demystifying Cairo whitepaper](https://medium.com/@pban/demystifying-cairo-white-paper-part-i-b71976ad0108)
+ [Learn about StarkNet with Argent](https://www.argent.xyz/learn/tag/starknet/)

## Development Frameworks

+ [Protostar](https://docs.swmansion.com/protostar/docs/tutorials/installation)
+ [Nile](https://github.com/OpenZeppelin/nile)
+ [StarkNet CLI](https://www.cairo-lang.org/docs/quickstart.html)

## Helpful Libraries

+ [Cairo-lang](https://github.com/starkware-libs/cairo-lang)
+ [Openzeppelin](https://github.com/OpenZeppelin/cairo-contracts)

## Educational Repos

+ [StarkNet Cairo 101](https://github.com/starknet-edu/starknet-cairo-101)
+ [StarkNet ERC721](https://github.com/starknet-edu/starknet-erc721)
+ [StarkNet ERC20](https://github.com/starknet-edu/starknet-erc20)
+ [L1 -> L2 Messaging](https://github.com/starknet-edu/starknet-messaging-bridge)
+ [StarkNet Debug](https://github.com/starknet-edu/starknet-debug)
+ [StarkNet Accounts](https://github.com/starknet-edu/starknet-accounts)
+ [Min-Starknet](https://github.com/Darlington02/min-starknet)

## Security

+ [Amarna static analysis for Cairo programs](https://blog.trailofbits.com/2022/04/20/amarna-static-analysis-for-cairo-programs/)
+ [Cairo and StarkNet security by Ctrl03](https://ctrlc03.github.io/)
+ [How to hack almost any Cairo smart contract](https://medium.com/ginger-security/how-to-hack-almost-any-starknet-cairo-smart-contract-67b4681ac0f6)
+ [Analyzing Cairo code using Armana](https://dic0de.substack.com/p/analyzing-cairo-code-using-amarna?sd=pf)

## Future TO-DOs

Update tutorial to fit Cairo 1.0"
"GDScript is a dynamically typed scripting language made specifically for
free and open source game engine Godot. GDScript's syntax is similar to
Python's. Its main advantages are ease of use and tight integration with
the engine. It's a perfect fit for game development.

## Basics

```nim
# Single-line comments are written using hash symbol.
""""""
  Multi-line
  comments
  are
  written
  using
  docstrings.
""""""

# Script file is a class in itself and you can optionally define a name for it.
class_name MyClass

# Inheritance
extends Node2D

# Member variables
var x = 8 # int
var y = 1.2 # float
var b = true # bool
var s = ""Hello World!"" # String
var a = [1, false, ""brown fox""] # Array - similar to list in Python,
                                # it can hold different types
                                # of variables at once.
var d = {
  ""key"" : ""value"",
  42 : true
} # Dictionary holds key-value pairs.
var p_arr = PoolStringArray([""Hi"", ""there"", ""!""]) # Pool arrays can
                                                  # only hold a certain type.

# Built-in vector types:
var v2 = Vector2(1, 2)
var v3 = Vector3(1, 2, 3)

# Constants
const ANSWER_TO_EVERYTHING = 42
const BREAKFAST = ""Spam and eggs!""

# Enums
enum { ZERO, ONE , TWO, THREE }
enum NamedEnum { ONE = 1, TWO, THREE }

# Exported variables are visible in the inspector.
export(int) var age
export(float) var height
export var person_name = ""Bob"" # Export type hints are unnecessary
                        # if you set a default value.

# Functions
func foo():
  pass # pass keyword is a placeholder for future code

func add(first, second):
  return first + second

# Printing values
func printing():
  print(""GDScript "", ""is "", "" awesome."")
  prints(""These"", ""words"", ""are"", ""divided"", ""by"", ""spaces."")
  printt(""These"", ""words"", ""are"", ""divided"", ""by"", ""tabs."")
  printraw(""This gets printed to system console."")

# Math
func doing_math():
  var first = 8
  var second = 4
  print(first + second) # 12
  print(first - second) # 4
  print(first * second) # 32
  print(first / second) # 2
  print(first % second) # 0
  # There are also +=, -=, *=, /=, %= etc.,
  # however no ++ or -- operators.
  print(pow(first, 2)) # 64
  print(sqrt(second)) # 2
  printt(PI, TAU, INF, NAN) # built-in constants

# Control flow
func control_flow():
  x = 8
  y = 2 # y was originally a float,
        # but we can change its type to int
        # using the power of dynamic typing!
  
  if x < y:
    print(""x is smaller than y"")
  elif x > y:
    print(""x is bigger than y"")
  else:
    print(""x and y are equal"")
  
  var a = true
  var b = false
  var c = false
  if a and b or not c: # alternatively you can use &&, || and !
    print(""This is true!"")

  for i in range(20): # GDScript's range is similar to Python's
    print(i) # so this will print numbers from 0 to 19

  for i in 20: # unlike Python, you can loop over an int directly
    print(i) # so this will also print numbers from 0 to 19

  for i in [""two"", 3, 1.0]: # iterating over an array
    print(i)
  
  while x > y:
    printt(x, y)
    y += 1

  x = 2
  y = 10
  while x < y:
    x += 1
    if x == 6:
      continue # 6 won't get printed because of continue statement
    prints(""x is equal to:"", x)
    if x == 7:
      break # loop will break on 7, so 8, 9 and 10 won't get printed

  match x:
    1:
      print(""Match is similar to switch."")
    2:
      print(""However you don't need to put cases before each value."")
    3:
      print(""Furthermore each case breaks on default."")
      break # ERROR! Break statement is unnecessary!
    4:
      print(""If you need fallthrough use continue."")
      continue
    _:
      print(""Underscore is a default case."")
  
  # ternary operator (one line if-else statement)
  prints(""x is"", ""positive"" if x >= 0 else ""negative"")

# Casting
func casting_examples():
  var i = 42
  var f = float(42) # cast using variables constructor
  var b = i as bool # or using ""as"" keyword

# Override functions
# By a convention built-in overridable functions start with an underscore,
# but in practice you can override virtually any function.

# _init is called when object gets initialized
# This is the object's constructor.
func _init():
  # Initialize object's internal stuff here.
  pass

# _ready gets called when script's node and
# its children have entered the scene tree.
func _ready():
  pass

# _process gets called on every frame.
func _process(delta):
  # The delta argument passed to this function is a number of seconds,
  # which passed between the last frame and the current one.
  print(""Delta time equals: "", delta)

# _physics_process gets called on every physics frame.
# That means delta should be constant.
func _physics_process(delta):
  # Simple movement using vector addition and multiplication.
  var direction = Vector2(1, 0) # or Vector2.RIGHT
  var speed = 100.0
  self.global_position += direction * speed * delta
  # self refers to current class instance

# When overriding you can call parent's function using the dot operator
# like here:
func get_children():
  # Do some additional things here.
  var r = .get_children() # call parent's implementation
  return r

# Inner class
class InnerClass:
  extends Object

  func hello():
    print(""Hello from inner class!"")

func use_inner_class():
  var ic = InnerClass.new()
  ic.hello()
  ic.free() # use free for memory cleanup
```

## Accessing other nodes in the scene tree

```nim
extends Node2D

var sprite # This variable will hold the reference.

# You can get references to other nodes in _ready.
func _ready() -> void:
  # NodePath is useful for accessing nodes.
  # Create NodePath by passing String to its constructor:
  var path1 = NodePath(""path/to/something"")
  # Or by using NodePath literal:
  var path2 = @""path/to/something""
  # NodePath examples:
  var path3 = @""Sprite"" # relative path, immediate child of the current node
  var path4 = @""Timers/Firerate"" # relative path, child of the child
  var path5 = @"".."" # current node's parent
  var path6 = @""../Enemy"" # current node's sibling
  var path7 = @""/root"" # absolute path, equivalent to get_tree().get_root()
  var path8 = @""/root/Main/Player/Sprite"" # absolute path to Player's Sprite
  var path9 = @""Timers/Firerate:wait_time"" # accessing properties
  var path10 = @""Player:position:x"" # accessing subproperties

  # Finally, to get a reference use one of these:
  sprite = get_node(@""Sprite"") as Sprite # always cast to the type you expect
  sprite = get_node(""Sprite"") as Sprite # here String gets
                                        # implicitly casted to NodePath
  sprite = get_node(path3) as Sprite
  sprite = get_node_or_null(""Sprite"") as Sprite
  sprite = $Sprite as Sprite

func _process(delta):
  # Now we can reuse the reference in other places.
  prints(""Sprite has global_position of"", sprite.global_position)

# Use onready keyword to assign a value to
# a variable just before _ready executes.
# This is a commonly used syntax sugar.
onready var tween = $Tween as Tween

# You can export NodePath, so you can assign it within the inspector.
export var nodepath = @""""
onready var reference = get_node(nodepath) as Node
```

## Signals

Signal system is Godot's implementation of the observer programming
pattern. Here's an example:

```nim
class_name Player extends Node2D

var hp = 10

signal died() # define signal
signal hurt(hp_old, hp_new) # signals can take arguments

func apply_damage(dmg):
  var hp_old = hp
  hp -= dmg
  emit_signal(""hurt"", hp_old, hp) # emit signal and pass arguments
  if hp <= 0:
    emit_signal(""died"")

func _ready():
  # connect signal ""died"" to function ""_on_death"" defined in self
  self.connect(""died"", self, ""_on_death"")

func _on_death():
  self.queue_free() # destroy Player on death
```

## Type hints

GDScript can optionally use static typing.

```nim
extends Node

var x: int # define typed variable
var y: float = 4.2
var z := 1.0 # infer type based on default value using := operator

onready var node_ref_typed := $Child as Node

export var speed := 50.0

const CONSTANT := ""Typed constant.""

func _ready() -> void:
  # function returns nothing
  x = ""string"" # ERROR! Type can't be changed!
  return

func join(arg1: String, arg2: String) -> String:
  # function takes two Strings and returns a String
  return arg1 + arg2

func get_child_at(index: int) -> Node:
  # function takes an int and returns a Node
  return get_children()[index]

signal example(arg: int) # ERROR! Signals can't take typed arguments!
```

## Further Reading

* [Godot's Website](https://godotengine.org/)
* [Godot Docs](https://docs.godotengine.org/en/stable/)
* [Getting started with GDScript](https://docs.godotengine.org/en/stable/getting_started/scripting/gdscript/index.html)
* [NodePath](https://docs.godotengine.org/en/stable/classes/class_nodepath.html)
* [Signals](https://docs.godotengine.org/en/stable/getting_started/step_by_step/signals.html)
* [GDQuest](https://www.gdquest.com/)
* [GDScript.com](https://gdscript.com/)"
"TOML stands for Tom's Obvious, Minimal Language. It is a data serialisation language designed to be a minimal configuration file format that's easy to read due to obvious semantics.

It is an alternative to YAML and JSON. It aims to be more human friendly than JSON and simpler that YAML. TOML is designed to map unambiguously to a hash table. TOML should be easy to parse into data structures in a wide variety of languages.

Be warned, TOML's spec is still changing a lot. Until it's marked as 1.0, you
should assume that it is unstable and act accordingly. This document follows TOML v0.4.0. 

```toml
# Comments in TOML look like this.

################
# SCALAR TYPES #
################

# Our root object (which continues for the entire document) will be a map,
# which is equivalent to a dictionary, hash or object in other languages.

# The key, equals sign, and value must be on the same line
# (though some values can be broken over multiple lines).
key = ""value""
string = ""hello""
number = 42
float = 3.14
boolean = true
dateTime = 1979-05-27T07:32:00-08:00
scientificNotation = 1e+12
""key can be quoted"" = true # Both "" and ' are fine
""key may contain"" = ""letters, numbers, underscores, and dashes""

# A bare key must be non-empty, but an empty quoted key is allowed
"""" = ""blank""     # VALID but discouraged
'' = 'blank'     # VALID but discouraged

##########
# String #
##########

# All strings must contain only valid UTF-8 characters.
# We can escape characters and some of them have a compact escape sequence.
# For example, \t add a tabulation. Refers to the spec to get all of them.
basicString = ""are surrounded by quotation marks. \""I'm quotable\"". Name\tJos""

multiLineString = """"""
are surrounded by three quotation marks
on each side and allow newlines.""""""

literalString = 'are surrounded by single quotes. Escaping are not allowed.'

multiLineLiteralString = '''
are surrounded by three single quotes on each side
and allow newlines. Still no escaping.
The first newline is trimmed in raw strings.
   All other whitespace
   is preserved. #! are preserved?
'''

# For binary data it is recommended that you use Base64, another ASCII or UTF8
# encoding. The handling of that encoding will be application specific.

###########
# Integer #
###########

## Integers can start with a +, a - or nothing.
## Leading zeros are not allowed. Hex, octal, and binary forms are not allowed.
## Values that cannot be expressed as a series of digits are not allowed.
int1 = +42
int2 = 0
int3 = -21
integerRange = 64

## You can use underscores to enhance readability. Each
## underscore must be surrounded by at least one digit.
int4 = 5_349_221
int5 = 1_2_3_4_5     # VALID but discouraged

#########
# Float #
#########

# Floats are an integer followed by a fractional and/or an exponent part.
flt1 = 3.1415
flt2 = -5e6
flt3 = 6.626E-34

###########
# Boolean #
###########

bool1 = true
bool2 = false
boolMustBeLowercase = true

############
# Datetime #
############

date1 = 1979-05-27T07:32:00Z # UTC time, following RFC 3339/ISO 8601 spec
date2 = 1979-05-26T15:32:00+08:00 # with RFC 3339/ISO 8601 offset
date3 = 1979-05-27T07:32:00 # without offset
date4 = 1979-05-27 # without offset or time

####################
# COLLECTION TYPES #
####################

#########
# Array #
#########

array1 = [ 1, 2, 3 ]
array2 = [ ""Commas"", ""are"", ""delimiters"" ]
array3 = [ ""Don't mix"", ""different"", ""types"" ]
array4 = [ [ 1.2, 2.4 ], [""all"", 'strings', """"""are the same"""""", '''type'''] ]
array5 = [
  ""Whitespace"", ""is"", ""ignored""
]

#########
# Table #
#########

# Tables (or hash tables or dictionaries) are collections of key/value
# pairs. They appear in square brackets on a line by themselves.
# Empty tables are allowed and simply have no key/value pairs within them.
[table]

# Under that, and until the next table or EOF are the key/values of that table.
# Key/value pairs within tables are not guaranteed to be in any specific order.
[table-1]
key1 = ""some string""
key2 = 123

[table-2]
key1 = ""another string""
key2 = 456

# Dots are prohibited in bare keys because dots are used to signify nested tables.
# Naming rules for each dot separated part are the same as for keys.
[dog.""tater.man""]
type = ""pug""

# In JSON land, that would give you the following structure:
# { ""dog"": { ""tater.man"": { ""type"": ""pug"" } } }

# Whitespace around dot-separated parts is ignored, however, best practice is to
# not use any extraneous whitespace.
[a.b.c]            # this is best practice
[ d.e.f ]          # same as [d.e.f]
[ j . ""ʞ"" . 'l' ]  # same as [j.""ʞ"".'l']

# You don't need to specify all the super-tables if you don't want to. TOML knows
# how to do it for you.
# [x] you
# [x.y] don't
# [x.y.z] need these
[x.y.z.w] # for this to work

# As long as a super-table hasn't been directly defined and hasn't defined a
# specific key, you may still write to it.
[a.b]
c = 1

[a]
d = 2

# Will generate the following in JSON:
# { ""a"": {""b"": {""c"": 1}, ""d"": 2 } }

# You cannot define any key or table more than once. Doing so is invalid.

# DO NOT DO THIS
[a]
b = 1

[a]
c = 2

# DO NOT DO THIS EITHER
[a]
b = 1

[a.b]
c = 2

# All table names must be non-empty.
[]     # INVALID
[a.]   # INVALID
[a..b] # INVALID
[.b]   # INVALID
[.]    # INVALID

################
# Inline table #
################

inlineTables = { areEnclosedWith = ""{ and }"", mustBeInline = true }
point = { x = 1, y = 2 }

###################
# Array of Tables #
###################

# An array of tables can be expressed by using a table name in double brackets.
# Each table with the same double bracketed name will be an item in the array.
# The tables are inserted in the order encountered.

[[products]]
name = ""array of table""
sku = 738594937
emptyTableAreAllowed = true

[[products]]

[[products]]
name = ""Nail""
sku = 284758393
color = ""gray""
```
The equivalent in JSON would be:

```json
{ 
  ""products"": [
    {
      ""name"": ""array of table"",
      ""sku"": 7385594937,
      ""emptyTableAreAllowed"": true
    },
    {},
    {
      ""name"": ""Nail"",
      ""sku"": 284758393,
      ""color"": ""gray""
    }
  ]
}
```

```toml
# You can create nested arrays of tables as well. Each double-bracketed
# sub-table will belong to the nearest table element above it.

[[fruit]]
  name = ""apple"" # I am a property in fruit table/map

  [fruit.geometry]
    shape = ""round""
    note = ""I am a property in geometry table/map""

  [[fruit.color]]
    name = ""red""
    note = ""I am an array item in apple fruit's table/map""

  [[fruit.color]]
    name = ""green""
    note = ""I am in the same array as red""

[[fruit]]
  name = ""banana""

  [[fruit.color]]
    name = ""yellow""
    note = ""I am an array item in banana fruit's table/map""

```

The equivalent in JSON would be:

```

{
  ""fruit"": [
    {
      ""name"": ""apple"",
      ""geometry"": { ""shape"": ""round"", ""note"": ""...""},
      ""color"": [
        { ""name"": ""red"", ""note"": ""..."" },
        { ""name"": ""green"", ""note"": ""..."" }
      ]
    },
    {
      ""name"": ""banana"",
      ""color"": [
        { ""name"": ""yellow"", ""note"": ""..."" }
      ]
    }
  ]
}
```

### More Resources

+ [TOML official repository](https://github.com/toml-lang/toml)"
"```tex
% All comment lines start with %
% There are no multi-line comments

% LaTeX is NOT a ""What You See Is What You Get"" word processing software like
% MS Word, or OpenOffice Writer

% Every LaTeX command starts with a backslash (\)

% LaTeX documents start with a defining the type of document it's compiling
% Other document types include book, report, presentations, etc.
% The options for the document appear in the [] brackets. In this case
% it specifies we want to use 12pt font.
\documentclass[12pt]{article}

% Next we define the packages the document uses.
% If you want to include graphics, colored text, or
% source code from another language file into your document,
% you need to enhance the capabilities of LaTeX. This is done by adding packages.
% I'm going to include the float and caption packages for figures
% and hyperref package for hyperlinks
\usepackage{caption}
\usepackage{float}
\usepackage{hyperref}

% We can define some other document properties too!
\author{Chaitanya Krishna Ande, Colton Kohnke, Sricharan Chiruvolu \& \\
Svetlana Golubeva}
\date{\today}
\title{Learn \LaTeX{} in Y Minutes!}

% Now we're ready to begin the document
% Everything before this line is called ""The Preamble""
\begin{document}
% if we set the author, date, title fields, we can have LaTeX
% create a title page for us.
\maketitle

% If we have sections, we can create table of contents. We have to compile our
% document twice to make it appear in right order.
% It is a good practice to separate the table of contents form the body of the
% document. To do so we use \newpage command
\newpage
\tableofcontents

\newpage

% Most research papers have abstract, you can use the predefined commands for this.
% This should appear in its logical order, therefore, after the top matter,
% but before the main sections of the body.
% This command is available in the document classes article and report.
\begin{abstract}
 \LaTeX{} documentation written as \LaTeX! How novel and totally not
 my idea!
\end{abstract}

% Section commands are intuitive.
% All the titles of the sections are added automatically to the table of contents.
\section{Introduction}
Hello, my name is Colton and together we're going to explore \LaTeX!

\section{Another section}
This is the text for another section. I think it needs a subsection.

\subsection{This is a subsection} % Subsections are also intuitive.
I think we need another one.

\subsubsection{Pythagoras}
Much better now.
\label{subsec:pythagoras}

% By using the asterisk we can suppress LaTeX's inbuilt numbering.
% This works for other LaTeX commands as well.
\section*{This is an unnumbered section}
However not all sections have to be numbered!

\section{Some Text notes}
%\section{Spacing} % Need to add more information about space intervals
\LaTeX{} is generally pretty good about placing text where it should
go. If
a line \\ needs \\ to \\ break \\ you add \textbackslash\textbackslash{}
to the source code.

Separate paragraphs by empty lines.

You need to add a tilde after abbreviations (if not followed by a comma) for a
non-breaking space, because otherwise the spacing after the dot is too large:
E.g., i.e., etc.~are are such abbreviations.

\section{Lists}
Lists are one of the easiest things to create in \LaTeX! I need to go shopping
tomorrow, so let's make a grocery list.
\begin{enumerate} % This creates an ""enumerate"" environment.
  % \item tells the enumerate to increment
  \item Salad.
  \item 27 watermelon.
  \item A single jackrabbit.
  % we can even override the item number by using []
  \item[how many?] Medium sized squirt guns.

  Not a list item, but still part of the enumerate.

\end{enumerate} % All environments must have an end.

\section{Math}

One of the primary uses for \LaTeX{} is to produce academic articles
or technical papers. Usually in the realm of math and science. As such,
we need to be able to add special symbols to our paper!

Math has many symbols, far beyond what you can find on a keyboard;
Set and relation symbols, arrows, operators, and Greek letters to name a few.

Sets and relations play a vital role in many mathematical research papers.
Here's how you state all x that belong to X, $\forall x \in X$.
% Notice how I needed to add $ signs before and after the symbols. This is
% because when writing, we are in text-mode.
% However, the math symbols only exist in math-mode.
% We can enter math-mode from text mode with the $ signs.
% The opposite also holds true. Variable can also be rendered in math-mode.
% We can also enter math mode with \[\]

\[a^2 + b^2 = c^2 \]

My favorite Greek letter is $\xi$. I also like $\beta$, $\gamma$ and $\sigma$.
I haven't found a Greek letter yet that \LaTeX{} doesn't know
about!

Operators are essential parts of a mathematical document:
trigonometric functions ($\sin$, $\cos$, $\tan$),
logarithms and exponentials ($\log$, $\exp$),
limits ($\lim$), etc.~have pre-defined LaTeX commands.
Let's write an equation to see how it's done:
$\cos(2\theta) = \cos^{2}(\theta) - \sin^{2}(\theta)$

Fractions (Numerator-denominators) can be written in these forms:

% 10 / 7
$$ ^{10}/_{7} $$

% Relatively complex fractions can be written as
% \frac{numerator}{denominator}
$$ \frac{n!}{k!(n - k)!} $$

We can also insert equations in an ``equation environment''.

% Display math with the equation 'environment'
\begin{equation} % enters math-mode
    c^2 = a^2 + b^2.
    \label{eq:pythagoras} % for referencing
\end{equation} % all \begin statements must have an end statement

We can then reference our new equation!
Eqn.~\ref{eq:pythagoras} is also known as the Pythagoras Theorem which is also
the subject of Sec.~\ref{subsec:pythagoras}. A lot of things can be labeled:
figures, equations, sections, etc.

Summations and Integrals are written with sum and int commands:

% Some LaTeX compilers will complain if there are blank lines
% In an equation environment.
\begin{equation}
  \sum_{i=0}^{5} f_{i}
\end{equation}
\begin{equation}
  \int_{0}^{\infty} \mathrm{e}^{-x} \mathrm{d}x
\end{equation}

\section{Figures}

Let's insert a figure. Figure placement can get a little tricky.
Basic options are [t] for top, [b] for bottom, [h] for here (approximately).
I definitely have to lookup the placement options each time.
% See https://en.wikibooks.org/wiki/LaTeX/Floats,_Figures_and_Captions for more details

\begin{figure}[H] % H here denoted the placement option.
    \centering % centers the figure on the page
    % Inserts a figure scaled to 0.8 the width of the page.
    %\includegraphics[width=0.8\linewidth]{right-triangle.png}
    % Commented out for compilation purposes. Please use your imagination.
    \caption{Right triangle with sides $a$, $b$, $c$}
    \label{fig:right-triangle}
\end{figure}

\subsection{Table}
We can also insert Tables in the same way as figures.

\begin{table}[H]
  \caption{Caption for the Table.}
  % the {} arguments below describe how each row of the table is drawn.
  % The basics are simple: one letter for each column, to control alignment:
  % basic options are: c, l, r and p for centered, left, right and paragraph
  % optionally, you can add a | for a vertical line
  % See https://en.wikibooks.org/wiki/LaTeX/Tables for more details
  \begin{tabular}{c|cc}  % here it means ""centered | vertical line, centered centered""
    Number &  First Name & Last Name \\ % Column rows are separated by &
    \hline % a horizontal line
    1 & Biggus & Dickus \\
    2 & Monty & Python
  \end{tabular}
  % it will approximately be displayed like this
  % Number | First Name     Last Name
  % -------|---------------------------  % because of \hline
  %   1    |   Biggus        Dickus
  %   2    |   Monty         Python
\end{table}

\section{Getting \LaTeX{} to not compile something (i.e.~Source Code)}
Let's say we want to include some code into our \LaTeX{} document,
we would then need \LaTeX{} to not try and interpret that text and
instead just print it to the document. We do this with a verbatim
environment.

% There are other packages that exist (i.e. minty, lstlisting, etc.)
% but verbatim is the bare-bones basic one.
\begin{verbatim}
  print(""Hello World!"")
  a%b; % look! We can use % signs in verbatim.
  random = 4; #decided by fair random dice roll, https://www.xkcd.com/221/
  See https://www.explainxkcd.com/wiki/index.php/221:_Random_Number
\end{verbatim}

\section{Compiling}

By now you're probably wondering how to compile this fabulous document
and look at the glorious glory that is a \LaTeX{} pdf.
(Yes, this document actually does compile).

Getting to the final document using \LaTeX{} consists of the following
steps:
  \begin{enumerate}
    \item Write the document in plain text (the ``source code'').
    \item Compile source code to produce a pdf.
     The compilation step looks like this (in Linux): \\
     \begin{verbatim}
        > pdflatex learn-latex.tex
     \end{verbatim}
  \end{enumerate}

A number of \LaTeX{} editors combine both Step 1 and Step 2 in the
same piece of software. So, you get to see Step 1, but not Step 2 completely.
Step 2 is still happening behind the scenes\footnote{In cases, where you use
references (like Eqn.~\ref{eq:pythagoras}), you may need to run Step 2
multiple times, to generate an intermediary *.aux file.}.
% Also, this is how you add footnotes to your document!
% with a simple \footnote{...} command. They are numbered ¹, ², ... by default.

You write all your formatting information in plain text in Step 1.
The compilation part in Step 2 takes care of producing the document in the
format you defined in Step 1.

\section{Hyperlinks}
We can also insert hyperlinks in our document. To do so we need to include the
package hyperref into preamble with the command:
\begin{verbatim}
    \usepackage{hyperref}
\end{verbatim}

There exists two main types of links: visible URL \\
\url{https://learnxinyminutes.com/docs/latex/}, or
\href{https://learnxinyminutes.com/docs/latex/}{shadowed by text}
% You can not add extra-spaces or special symbols into shadowing text since it
% will cause mistakes during the compilation

This package also produces list of thumbnails in the output PDF document and
active links in the table of contents.

\section{Writing in ASCII or other encodings}

By default, historically LaTeX accepts inputs which are pure ASCII (128),
but not extended ASCII, meaning without accents (à, è etc.) and non-Latin symbols.

It is easy to insert accents and basic Latin symbols, with backslash shortcuts
Like \,c, \'e, \`A, \ae and \oe etc.  % for ç, é, À, etc
% See https://en.wikibooks.org/wiki/LaTeX/Special_Characters#Escaped_codes for more

To write directly in UTF-8, when compiling with pdflatex, use
\begin{verbatim}
    \usepackage[utf8]{inputenc}
\end{verbatim}
The selected font has to support the glyphs used for your document, you have to add
\begin{verbatim}
    \usepackage[T1]{fontenc}
\end{verbatim}

Since LuaTeX and XeLaTeX were designed with built-in support for UTF-8, making
life easier for writing in non-Latin alphabets.

\section{End}

That's all for now!

% Most often, you would want to have a references section in your document.
% The easiest way to set this up would be by using the bibliography section
\begin{thebibliography}{1}
  % similar to other lists, the \bibitem command can be used to list items
  % each entry can then be cited directly in the body of the text
  \bibitem{latexwiki} The amazing \LaTeX{} wikibook: \emph{https://en.wikibooks.org/wiki/LaTeX}
  \bibitem{latextutorial} An actual tutorial: \emph{http://www.latex-tutorial.com}
\end{thebibliography}

% end the document
\end{document}
```

## More on LaTeX

* The amazing LaTeX Wikibook: [https://en.wikibooks.org/wiki/LaTeX](https://en.wikibooks.org/wiki/LaTeX)
* An actual tutorial: [http://www.latex-tutorial.com/](http://www.latex-tutorial.com/)
* A quick guide for learning LaTeX: [Learn LaTeX in 30 minutes](https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes)
* An interactive platform to learn LaTeX (installationfree) [learnlatex.org/](https://www.learnlatex.org/)
* Stack Exchange's question and answer site about TeX, LaTeX, ConTeXt, etc. [tex.stackexchange.com](https://tex.stackexchange.com/)"
"Fish (**f**riendly **i**nteractive **sh**ell) is the name of an exotic shell. That is a shell with a syntax that is derived from neither the Bourne-Shell nor the C-Shell. 

The advantage of fish is that many features that you want in a modern shell come out-of-the-box, so you don't have to install additional software like zsh and oh-my-zsh.

Examples of these features are autosuggestions, 24-bit colors, Man Page Completions (meaning fish automatically parses your man pages and suggests additional options for your commands) or the ability to make options through a web page (when a GUI is installed).

It was released in February 2005.

[Read more](https://fishshell.com/docs/current/language.html)

[Installation guide](https://github.com/fish-shell/fish-shell#getting-fish)


# Guide

Be sure you have the newest fish shell. This was made with version 3.3.0. To test, type:
> fish -v

To start the fish shell, type:
> fish

to exit, type:
> exit

or press <kbd>Ctrl + D</kbd>

Now, right out of the gate, there's one annoying thing in fish. It's the welcome message. Who needs that, right? When your shell is started, just type:
> set -U fish_greeting """"

To set that to the wanted value,  .


If you want to execute a single command written in bash, without switching to that shell, you can type:
> bash -c 'echo ""fish is better than bash""'

In fish, you can use single or double quotes.
The escape character is a `\`

You can change your configuration of fish either by editing the config file
> vim ~/.config/fish/config.fish

or by opening the aforementioned web settings:

>fish_config

Adding something to your fish PATH Variable is easy:
> fish_path_add ~/cowsay

Can you do that with bash, huh? No, you always have to look it up... It's just that easy!

But there's more. Most fish-specific commands start, you guessed it, with 'fish'. Just type in `fish` and press <kbd>TAB</kbd>. And there you have one of the many cool features of fish: The autocompletion that **just works.**
Now you can navigate with <kbd>TAB</kbd>, <kbd>Shift + TAB</kbd> and your Arrow-Keys <kbd>←</kbd><kbd>↑</kbd><kbd>→</kbd><kbd>↓</kbd>.

To get help, contact your local psychiatrist or type `man`. That will bring up the manual for that command, for example:
> man set

If you finally tried fish, you can see something other in fish that's really cool. Everything has cool colors, if you type in something wrong, it is red, without even executing, if you put something in quotes, you see where it ends and why that quote doesn't work, because there's another qoutation mark in the quote at position 26. 

fish has even more cool things, like wildcards.
For example, type
> ls *.fish

That will list all fish files in your current directory.

You can have multiple wildcards per command or even a recursive wildcard, `**`, which basically means it includes files and directories, that fit.
For example the following command would return (in your case):
> ls ~/images/**.jpg

```
~/images/nudes/pewdiepie.jpg
~/images/nudes/peppa.jpg
~/images/screenshots/2020-42-69.jpg
~/images/omegalul.jpg
```

Of course, you can also pipe the output of a command to another command

>echo sick egg, nadia. no u do really goofy shit.   | grep [udense]

write to a file:

>echo This\ is\ text > file.txt

(noticed the escape character?)
Add to a file:

>echo This\ is\ a\ line >> file.txt

>echo This\ is\ a\ second\ line >> file.txt

For Autocompletion, just always press <kbd>TAB</kbd>. You will be surprised how many things fish knows.

To use variables, just type `$VAR`, like in bash.

> echo ""My home is $HOME""

> My home is /home/myuser

Here comes a difference between single and double quotes. If you use a variable in single quotes, it will not substitute it.

> echo 'My home is $HOME'

> My home is $HOME

More on variables later.

To execute two commands, separate them with `;`
> echo Lol; echo this is fun

The status code of the last command is stored in `$status`

You can use && for two commands that depend on each other.

> set var lol && echo $var

You can also use and, 
which executes if the previous command was successful

or 
which executes if the previous command was not successful

and not
which inverts the exit status of a command.

For example:


> if not  echo It's very late I should not waste my time with this  

>> echo Nobody heard you  

>end

(You can of course do all of that in the shell)


---
Now let's start with the scripting part of fish. 

As with every shell, you can not only execute commands in the shell, but also as files, saved as a  `.fish` file.
(You can also execute `.sh` files with fish syntax, but I always use `.fish` for fish-syntax scripts to distinguish them from bash script files)

```bash
# This is a comment in fish.
# 
# If you execute a file without specifying an interpreter, 
# meaning the software that runs your script, you need to tell the shell, 
# where that interpreter is. 
# For fish you just add the following comment as the first line in your script:

#!/bin/fish

# When executing via e.g. fish /path/to/script.fish
# you don't need that, because you specified fish as an interpreter

# Let's start with variables.
# for use inside a program, you can use the syntax
set name = 'My Variable'


# use
set -x name value
# to eXport
set -e name
# to Erase

# a variable set with a space doesn't get sent as two arguments, but as one, as you would expect it. 
set turtlefolder 'Turtle Folder'
mkdir $turtlefolder

# This will create one folder, as expected, not two, like in bash... 
# Who would even want that? tHiS iS a fEaTurE, nOt a bUg...

# you can even have lists as variables. This actually makes sense, because if you want to have a variable that would create two folders, you just give mkdir a list of your foldernames.

# you can then count the entries in that list with:
count $PATH

# Not only is everything awesome, but in fish, everything is also a list. 
# So $PWD for example is a list of length 1. 
# To make a list, just give the set command multiple arguments:
set list entry1 entry2 entry3
# that way you can also append something to an existing variable:
set PATH $PATH ~/cowsay/

# But, as previously mentioned, we also have a simpler way to do that specifically in fish.
# As with every Array/List, you can access it with 
$listvar[2]
# there's also ranges with 
$listvar[1..5] 
# and you can use negative numbers like 
$listvar[-1]
# e.g to access the last element.



# You can also do fancy cartesian products when you combine two list variables:
set a 1 2 3
set 1 a b c
echo $a$1
# Will output : 1a 2a 3a 1b 2b 3b 1c 2c 3c

# Of course, if you separate them, it will see them as two separate arguments and echo them one after the other. THAT is expected behavior @bash.

# There are also other useful things, like command substitutions. For example, when you want to output the returns of two commands in one line. In bash you would do that with
echo ""`ls` is in $PWD"" 
# or 
echo ""$(ls) is in $PWD"" 

# if you ask me, that's unnecessary. I always type in the wrong apostrophe. Why not just use two parenthesis, like in fish?
echo (ls) is in $PWD

# Yep, that easy. And thanks to fish's highlighting you can instantly see, if you typed it in correctly.

# And, as you would expect, if you ask me, your commands don't work in quotes. I mean why bash? Ok I'll stop now. But in fish, just do:
echo (ls)"" is in $PWD""
# or
set myvar ""The file""(ls -a)"" is in the directory $PWD""
# will make a List with the string and all files. Try it out. Isn't that cool?

# And to separate these variables in separate arguments, just put a space between them:

set myvar ""The files"" (ls -a) "" are in the directory $PWD""

# There's also if, else if, else
if grep fish /etc/shells
    echo Found fish
else if grep bash /etc/shells
    echo Found bash
else
    echo Got nothing
end

# A little weird is that you compare stuff with one = sign , of course because we don't need it to set variables, but still... and the keyword ""test"":
if test $var = ""test""
    echo yes 
else 
    echo no
end

# Of course, there's also switch case with
switch $OS
case Linux
    echo ""you're good""
case Windows
    echo ""install Gentoo""
case Arch
    echo ""I use arch btw""
case '*'
    echo ""what OS is $OS, please?""
end


# functions in fish get their arguments through the $argv variable. The syntax is following:

function print
    echo $argv
end

# There are also events, like the ""fish_exit""-event (What may that be, hmm?).

# You can use them by adding them to the function definition:

function on_exit --on-event fish_exit
    echo fish is now exiting
end

# find events with the command
functions --handlers


# You can use the functions command to learn more about, well, functions. 
# For example you can print the source code of every function:
functions cd
functions print
# or get the names of all functions:
functions

# There's while Loops, of course
while test $var = lol
    echo lol
end

# for Loops (with wildcards, they are even cooler):
for image in *.jpg
    echo $image
end

# there's an equivalent to the range(0, 5) in Python, so you can also do the standard for loops with numbers:

set files (ls)
for number in (seq 10)
    echo ""$files[$number] is file number $number""
end

# Cool!

# The bashrc equivalent is not fishrc, but the previously mentioned config.fish file in ~/.config/fish/

# To add a function to fish, though, you should create a simple .fish file in that directory. Don't just paste that function in the config.fish. That's ugly. 

# If you have more, just add it, but those are the most important basics.

```"
"Whip is a LISP-dialect made for scripting and simplified concepts.
It has also borrowed a lot of functions and syntax from Haskell (a non-related language).

These docs were written by the creator of the language himself. So is this line.

```scheme
; Comments are like LISP. Semi-colons...

; Majority of first-level statements are inside ""forms""
; which are just things inside parens separated by whitespace
not_in_form
(in_form)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 1. Numbers, Strings, and Operators

; Whip has one number type (which is a 64-bit IEEE 754 double, from JavaScript).
3 ; => 3
1.5 ; => 1.5

; Functions are called if they are the first element in a form
(called_function args)

; Majority of operations are done with functions
; All the basic arithmetic is pretty straight forward
(+ 1 1) ; => 2
(- 2 1) ; => 1
(* 1 2) ; => 2
(/ 2 1) ; => 2
; even modulo
(% 9 4) ; => 1
; JavaScript-style uneven division.
(/ 5 2) ; => 2.5

; Nesting forms works as you expect.
(* 2 (+ 1 3)) ; => 8

; There's a boolean type.
true
false

; Strings are created with "".
""Hello, world""

; Single chars are created with '.
'a'

; Negation uses the 'not' function.
(not true) ; => false
(not false) ; => true

; But the majority of non-haskell functions have shortcuts
; not's shortcut is a '!'.
(! (! true)) ; => true

; Equality is `equal` or `=`.
(= 1 1) ; => true
(equal 2 1) ; => false

; For example, inequality would be combining the not and equal functions.
(! (= 2 1)) ; => true

; More comparisons
(< 1 10) ; => true
(> 1 10) ; => false
; and their word counterpart.
(lesser 1 10) ; => true
(greater 1 10) ; => false

; Strings can be concatenated with +.
(+ ""Hello "" ""world!"") ; => ""Hello world!""

; You can use JavaScript's comparative abilities.
(< 'a' 'b') ; => true
; ...and type coercion
(= '5' 5)

; The `at` or @ function will access characters in strings, starting at 0.
(at 0 'a') ; => 'a'
(@ 3 ""foobar"") ; => 'b'

; There is also the `null` and `undefined` variables.
null ; used to indicate a deliberate non-value
undefined ; user to indicate a value that hasn't been set

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 2. Variables, Lists, and Dicts

; Variables are declared with the `def` or `let` functions.
; Variables that haven't been set will be `undefined`.
(def some_var 5)
; `def` will keep the variable in the global context.
; `let` will only have the variable inside its context, and has a weirder syntax.
(let ((a_var 5)) (+ a_var 5)) ; => 10
(+ a_var 5) ; = undefined + 5 => undefined

; Lists are arrays of values of any type.
; They basically are just forms without functions at the beginning.
(1 2 3) ; => [1, 2, 3] (JavaScript syntax)

; Dictionaries are Whip's equivalent to JavaScript 'objects' or Python 'dicts'
; or Ruby 'hashes': an unordered collection of key-value pairs.
{""key1"" ""value1"" ""key2"" 2 3 3}

; Keys are just values, either identifier, number, or string.
(def my_dict {my_key ""my_value"" ""my other key"" 4})
; But in Whip, dictionaries get parsed like: value, whitespace, value;
; with more whitespace between each. So that means
{""key"" ""value""
""another key""
1234
}
; is evaluated to the same as
{""key"" ""value"" ""another key"" 1234}

; Dictionary definitions can be accessed used the `at` function
; (like strings and lists.)
(@ ""my other key"" my_dict) ; => 4

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 3. Logic and Control sequences

; The `if` function is pretty simple, though different than most imperative langs.
(if true ""returned if first arg is true"" ""returned if first arg is false"")
; => ""returned if first arg is true""

; And for the sake of ternary operator legacy
; `?` is if's unused shortcut.
(? false true false) ; => false

; `both` is a logical 'and' statement, and `either` is a logical 'or'.
(both true true) ; => true
(both true false) ; => false
(either true false) ; => true
(either false false) ; => false
; And their shortcuts are
; & => both
; ^ => either
(& true true) ; => true
(^ false true) ; => true

;;;;;;;;;
; Lambdas

; Lambdas in Whip are declared with the `lambda` or `->` function.
; And functions are really just lambdas with names.
(def my_function (-> (x y) (+ (+ x y) 10)))
;         |       |    |          |
;         |       |    |    returned value(with scope containing argument vars)
;         |       | arguments
;         | lambda declaration function
;         |
;   name of the to-be-declared lambda

(my_function 10 10) ; = (+ (+ 10 10) 10) => 30

; Obviously, all lambdas by definition are anonymous and
; technically always used anonymously. Redundancy.
((lambda (x) x) 10) ; => 10

;;;;;;;;;;;;;;;;
; Comprehensions

; `range` or `..` generates a list of numbers for
; each number between its two args.
(range 1 5) ; => (1 2 3 4 5)
(.. 0 2)    ; => (0 1 2)

; `map` applies its first arg (which should be a lambda/function)
; to each item in the following arg (which should be a list)
(map (-> (x) (+ x 1)) (1 2 3)) ; => (2 3 4)

; Reduce
(reduce + (.. 1 5))
; equivalent to
((+ (+ (+ 1 2) 3) 4) 5)

; Note: map and reduce don't have shortcuts

; `slice` or `\` is just like JavaScript's .slice()
; But do note, it takes the list as the first argument, not the last.
(slice (.. 1 5) 2) ; => (3 4 5)
(\ (.. 0 100) -5) ; => (96 97 98 99 100)

; `append` or `<<` is self explanatory
(append 4 (1 2 3)) ; => (1 2 3 4)
(<< ""bar"" (""foo"")) ; => (""foo"" ""bar"")

; Length is self explanatory.
(length (1 2 3)) ; => 3
(_ ""foobar"") ; => 6

;;;;;;;;;;;;;;;
; Haskell fluff

; First item in list
(head (1 2 3)) ; => 1
; List from second to last elements in list
(tail (1 2 3)) ; => (2 3)
; Last item in list
(last (1 2 3)) ; => 3
; Reverse of `tail`
(init (1 2 3)) ; => (1 2)
; List from first to specified elements in list
(take 1 (1 2 3 4)) ; (1 2)
; Reverse of `take`
(drop 1 (1 2 3 4)) ; (3 4)
; Lowest value in list
(min (1 2 3 4)) ; 1
; Highest value in list
(max (1 2 3 4)) ; 4
; If value is in list or object
(elem 1 (1 2 3)) ; true
(elem ""foo"" {""foo"" ""bar""}) ; true
(elem ""bar"" {""foo"" ""bar""}) ; false
; Reverse list order
(reverse (1 2 3 4)) ; => (4 3 2 1)
; If value is even or odd
(even 1) ; => false
(odd 1) ; => true
; Split string into list of strings by whitespace
(words ""foobar nachos cheese"") ; => (""foobar"" ""nachos"" ""cheese"")
; Join list of strings together.
(unwords (""foo"" ""bar"")) ; => ""foobar""
; Successor and Predecessor
(pred 21) ; => 20
(succ 20) ; => 21
```

For more info, check out the [repo](http://github.com/L8D/whip)"
"RDF (Resource Description Framework) is a [W3C
standard](https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/) data
model. The W3C has standardized several RDF syntaxes; examples below use the
most popular one, [Turtle](https://www.w3.org/TR/turtle/).

One nice advantage of Turtle files is that if you concatenate any two
syntactically valid Turtle files, you will have another syntactically valid
Turtle file. This is one of many things about RDF that ease data integration.

The W3C standard query language for RDF datasets is
[SPARQL](https://www.w3.org/TR/sparql11-query/).

RDF expresses all facts as three-part {subject, predicate, object} statements
known as triples. Because the same entity can be the subject of some triples
and the object of others, a set of triples can represent a graph data
structure. A large-scale storage system for triples is called a triplestore,
and falls into the graph database category of NoSQL databases.

RDF subjects and predicates must be URIs (Uniform Resource Identifiers), which
usually look like URLs but function as identifiers, not locators. The use of
URIs provides context for resource identifiers to make them unambiguous—for
example, to tell a book title from a job title.

```
# The hash symbol is the comment delimiter. 

# Turtle triple statements end with periods like natural language sentences.

# These two triples tell us that the mythical Example Company's
# employee 134 has a hire date of 2022-11-12 and a family name of Smith:

<http://example.com/emp134> <http://example.com/hireDate> ""2022-11-12"" .
<http://example.com/emp134> <http://example.com/familyName> ""Smith"" .

# Declaring prefixes to stand in for namespaces reduces verbosity. These
# declarations typically go at the beginning of the file, but the only
# requirement is that they come before the first use of the prefix they declare.

@prefix ex: <http://example.com/> .
ex:emp134 ex:hireDate ""2022-11-12"" .
ex:emp134 ex:familyName ""Smith"" .

# A semicolon means that the next triple uses the same subject as the last
# one. This is handy for listing data about a single resource. The following
# example means the same thing as the previous one.

@prefix ex: <http://example.com/> .
ex:emp134 ex:hireDate ""2022-11-12"" ;
          ex:familyName ""Smith"" .

# A comma means that the next triple has the same subject and predicate as
# the previous one.

ex:emp134 ex:nickname ""Smithy"", ""Skipper"", ""Big J"". 

# Three single or double quote marks at the beginning and end of a value let
# you define a  multi-line string value.

ex:emp134 ex:description """"""
Skipper joined the company in November. 

He always has a joke for everyone."""""" . 

# Using URIs from existing standard vocabulary namespaces eases both data
# integration and interoperability with the large amount of RDF that already
# exists. Mixing and matching of standard and local custom namespaces is
# common.

@prefix vcard: <http://www.w3.org/2006/vcard/ns#> .
ex:emp134 ex:hireDate ""2022-11-12"" ;
          vcard:family-name ""Smith"" .

# Related RDF standards provide vocabularies that are popular for basic
# facts. The rdfs:label predicate from the RDF Schema standard is a common 
# way to indicate a human-readable name.

@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
ex:hireDate rdfs:label ""hire date"" . 

# String object values can include language codes, making
# multi-lingual representation of entities easier for applications
# reading the data (for example, when generating a user interface).

ex:hireDate rdfs:label ""hire date""@en, ""date d'embauche""@fr  . 

# Representing a triple's object with a URI (or prefixed name) is not required
# but lets you connect up triples into a graph.

ex:emp134 vcard:family-name ""Smith"" .
ex:emp113 vcard:family-name ""Jones"" ;
          ex:reportsTo ex:emp134 . 

# Objects can be datatypes from the XML Schema part 2 standard or your own
# custom datatypes.

@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
ex:emp134 vcard:family-name ""Smith""^^xsd:string ;  # default data type
          ex:hireDate ""2022-11-12""^^xsd:date ;
          ex:rating ""3.5""^^ex:someCustomType . 

# The use of schemas with RDF is optional. Schemas may describe all or a
# subset of a dataset. They use a vocabulary described by the W3C RDF Schema
# (RDFS) standard, usually with a prefix of rdfs.

# These schemas are descriptive, to ease the accommodation of new
# datasets, not proscriptive rules about how new data should be 
# created. The following declares a class. (Note that RDFS is itself 
# expressed in triples.)

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> . 
ex:Person rdf:type rdfs:Class .

# The following triple means the same as the preceding one but 
# uses a Turtle shortcut for terseness and more readability.

ex:Person a rdfs:Class .

# That last triple declares that ex:Person is an instance of a class, and the
# following declares that employee 113 is an instance of the class Employee.

ex:emp113 a ex:Employee . 

# The first triple below is actually unnecessary because a typical
# RDFS processor will infer from the second one that ex:Employee is a
# class. (Only a subset of RDF parsers perform RDFS inferencing.)

ex:Employee a rdfs:Class .
ex:Employee rdfs:subClassOf ex:Person .

# An RDF parser that reads the last four triples shown and understands
# RDFS will infer that ex:emp113 is an instance of ex:Person, because
# it's an instance of ex:Employee, a subclass of ex:Person.

# RDFS lets you declare properties and associate them with classes. 
# Properties are first class resources and don't ""belong"" to classes 
# in the object-oriented sense. rdfs:domain means ""the following object 
# class uses the property named by this triple's subject"". rdfs:range 
# means ""the property named by this triple's subject will have a value of 
# the following class or type"". 

ex:birthday rdf:type rdf:Property ; 
            rdfs:domain ex:Person ;
            rdfs:range xsd:date .

```

## Further Reading

* [RDF Primer — Turtle version](https://www.w3.org/2007/02/turtle/primer/) from the W3C
* [What is RDF?](https://www.bobdc.com/blog/whatisrdf/) on bobdc.com
* [What is RDFS?](https://www.bobdc.com/blog/whatisrdfs/) on bobdc.com 
* [Introduction to RDF and SPARQL](https://data.europa.eu/sites/default/files/d2.1.2_training_module_1.3_introduction_to_rdf_sparql_en_edp.pdf) at data.europa.eu"
"RST, Restructured Text, is a file format created by the Python community to write documentation. It is part of [Docutils](https://docutils.sourceforge.io/rst.html).

RST is a markup language like HTML but is much more lightweight and easier to read.


## Installation

To use Restructured Text, you will have to install [Python](http://www.python.org) and the `docutils` package.

`docutils` can be installed using the commandline:

```bash
$ easy_install docutils
```

If your system has `pip`, you can use it too:

```bash
$ pip install docutils
```


## File syntax

A simple example of the file syntax:

```
.. Lines starting with two dots are special commands. But if no command can be found, the line is considered as a comment.

=========================================================
Main titles are written using equals signs over and under
=========================================================

Note that each character, including spaces, needs an equals sign above and below.

Titles also use equals signs but are only underneath
====================================================

Subtitles with dashes
---------------------

You can put text in *italic* or in **bold**, you can ""mark"" text as code with double backquote ``print()``.

Special characters can be escaped using a backslash, e.g. \\ or \*.

Lists are similar to Markdown, but a little more involved.

Remember to line up list symbols (like - or \*) with the left edge of the previous text block, and remember to use blank lines to separate new lists from parent lists:    

- First item
- Second item

  - Sub item
    
- Third item

or

* First item
* Second item
    
  * Sub item

* Third item

Tables are really easy to write:

=========== ========
Country     Capital
=========== ========
France      Paris
Japan       Tokyo
=========== ========

More complex tables can be done easily (merged columns and/or rows) but I suggest you to read the complete doc for this. :)

There are multiple ways to make links:

- By adding an underscore after a word : Github_ and by adding the target URL after the text (this way has the advantage of not inserting unnecessary URLs in the visible text).
- By typing a full comprehensible URL : https://github.com/ (will be automatically converted to a link).
- By making a more Markdown-like link: `Github <https://github.com/>`_ .

.. _Github: https://github.com/

```


## How to Use It

RST comes with docutils where you have `rst2html`, for example:

```bash
$ rst2html myfile.rst output.html
```

*Note : On some systems the command could be rst2html.py*

But there are more complex applications that use the RST format:

- [Pelican](http://blog.getpelican.com/), a static site generator
- [Sphinx](http://sphinx-doc.org/), a documentation generator
- and many others


## Readings

- [Official quick reference](http://docutils.sourceforge.net/docs/user/rst/quickref.html)"
"LB Stanza (or Stanza for short) is a new optionally-typed general purpose programming language from the University of California, Berkeley. Stanza was designed to help programmers tackle the complexity of architecting large programs and significantly increase the productivity of application programmers across the entire software development life cycle.


```
; this is a comment 
;<A>
This is a block comment 
    ;<B> 
        block comments can be nested with optional tags. 
    ;<B>
;<A>
defpackage learn-stanza-in-y: 
  import core 
  import collections 

;==============================================================================
; The basics, things you'd find in most programming languages
;==============================================================================


; Variables can be mutable (var) or immutable (val)
val immutable = ""this string can't be changed""
var mutable = ""this one can be"" 
mutable = ""like this""

; The basic data types (annotations are optional) 
val an-int: Int = 12345
val a-long: Long = 12345L
val a-float: Float = 1.2345f
val a-double: Double = 3.14159
val a-string: String = ""this is a string""
val a-multiline-string = \<tag>
    this is a ""raw"" string literal 
\<tag>

; Print a formatted string with println and ""..."" % [...]
println(""this is a formatted string %_ %_"" % [mutable, immutable])

; Stanza is optionally typed, and has a ? (any) type. 
var anything:? = 0
anything = 3.14159
anything = ""a string""

; Stanza has basic collections like Tuples, Arrays, Vectors and HashTables
val tuple: Tuple<?> = [mutable, immutable]

val array = Array<?>(3)
array[0] = ""string""
array[1] = 1
array[2] = 1.23455
; array[3] = ""out-of-bounds"" ; arrays are bounds-checked 

val vector = Vector<?>()
vector[0] = ""string""
vector[1] = 1
vector[2] = 3.14159

val hash-table = HashTable<String, ?>()
hash-table[""0""] = 0
hash-table[""1""] = 1 
hash-table[""2""] = 1 


;==============================================================================
; Functions
;==============================================================================
; Functions are declared with the `defn` keyword 
defn my-function (arg:?) : ; note the space between identifier and arg list
  println(""called my-function with %_"" % [arg])

my-function(""arg"")  ; note the lack of a space to call the function

; Functions can be declared inside another function and capture variables from
; the surrounding environment.
defn outer (arg): 
  defn inner (): 
    println(""outer had arg: %_"" % [arg])
  inner()

outer(""something"")

; functions are ""first-class"" in stanza, meaning you can assign variables 
; to functions and pass functions as arguments to other functions. 
val a-function = outer 
defn do-n-times (arg, func, n:Int): 
  for i in 0 to n do : 
    func(arg)
do-n-times(""argument"", a-function, 3)

; sometimes you want to define a function inline, or use an anonymous function.
; for this you can use the syntax: 
;   fn (args): 
;       ... 
do-n-times(""hello"", fn (arg): println(arg), 2)

; there is a shorthand for writing anonymous functions
do-n-times(""hello"", { println(_) }, 2)

; the short hand works for multiple arguments as well. 
val multi-lambda = { println(_ + 2 * _) }
multi-lambda(1, 2)

;==============================================================================
; User defined types
;==============================================================================
; Structs are declared with the `defstruct` keyword
defstruct MyStruct: 
  field

; constructors are derived automatically
val my-struct = MyStruct(""field:value"")

; fields are accessed using function-call syntax
println(field(my-struct))

; Stanza supports subtyping with a ""multimethod"" system based on method 
; overloading.
deftype MyType
defmulti a-method (m:MyType)

defstruct Foo <: MyType
defstruct Bar <: MyType
defmethod a-method (a-foo: Foo):
  println(""called a-method on a Foo"")

defmethod a-method (a-foo: Bar):
  println(""called a-method on a Bar"")

;==============================================================================
; The Type System
;==============================================================================
; True and Falseare types with a single value. 
val a-true: True = true 
val a-false: False = false 

; You can declare a union type, or a value that is one of a set of types 
val a-boolean: True|False = true 
val another-boolean: True|False = false 

; You can pattern match on types 
match(a-boolean):
  (t:True): println(""is true"")
  (f:False): println(""is false"")

; You can match against a single possible type
match(a-boolean:True):
  println(""is still true"")
else: 
  println(""is not true"")

; You can compose program logic around the type of a variable
if anything is Float :
  println(""anything is a float"")
else if anything is-not String : 
  println(""anything is not an int"")
else : 
  println(""I don't know what anything is"")

;==============================================================================
; Control Flow 
;==============================================================================
; stanza has the standard basic control flow 
val condition = [false, false]
if condition[0] : 
  ; do something 
  false 
else if condition[1] : 
  ; do another thing
  false 
else :
  ; whatever else
  false

; there is also a switch statement, which can be used to pattern match
; on values (as opposed to types)
switch(anything):
  ""this"": false 
  ""that"": false 
  ""the-other-thing"": false 
  else: false 

; for and while loops are supported
while condition[0]: 
  println(""do stuff"")

for i in 0 to 10 do:  
  vector[i] = i

; stanza also supports named labels which can function as break or return 
; statements
defn another-fn (): 
  label<False> return:
    label<False> break:
      while true: 
        if condition[0] is False: 
            break(false) 
    return(false)

; For a comprehensive guide on Stanza's advanced control flow, check out 
; this page: http://lbstanza.org/chapter9.html from Stanza-by-Example

;==============================================================================
; Sequences 
;==============================================================================
; for ""loops"" are sugar for a more powerful syntax. 
val xs = [1, 2, 3] 
val ys = ['a', 'b', 'c']
val zs = [""foo"", ""bar"", ""baz""]

for (x in xs, y in ys, z in zs) do : 
  println(""x:%_, y:%_, z:%_"" % [x, y, z])


;xs, ys, and zs are all ""Seqable"" meaning they are Seq types (sequences). 
; the `do` identifier is a special function that just applies the body of
; the for loop to each element of the sequence.
; 
; A common sequence task is concatenating sequences. This is accomplished 
; using the `seq-cat` function. This is analogous to ""flattening"" iterateors
val concat = to-tuple $ 
  for sequence in [xs, ys, zs] seq-cat: 
    sequence

; we can also use a variation to interleave the elements of multiple sequences
val interleaved = to-tuple $ 
  for (x in xs, y in ys, z in zs) seq-cat : 
    [x, y, z]

println(""[%,] [%,]"" % [concat, interleaved])

; Another common task is mapping a sequence to another, for example multiplying
; all the elements of a list of numbers by a constant. To do this we use `seq`. 
var numbers = [1.0, 2.0, 3.0, 4.0] 
numbers = to-tuple $ 
  for n in numbers seq : 
    2.0 * n 
println(""%,"" % [numbers])

if find({_ == 2.0}, numbers) is-not False : 
  println(""found it!"")

; or maybe we just want to know if there's something in a sequence 
var is-there = 
  for n in numbers any? :
    n == 2.0 

; since this is ""syntactic sugar"" we can write it explicitly using an 
; anonymous function
is-there = any?({_ == 2.0}, numbers)

; a detailed reference of the sequence library and various adaptors can 
; be found here: http://lbstanza.org/reference.html#anchor439


=========================================================================
; Documentation 
;=========================================================================
;
; Top level statements can be prefixed with the ""doc"" field which takes 
; a string value and is used to autogenerate documentation for the package. 
doc: \<doc>
    # Document Strings 

    ```
    val you-can = ""include code snippets, too"" 
    ```

    To render documentation as markdown (compatible with mdbook)

    ```bash 
    stanza doc source.stanza -o docs 
    ```
\<doc>
defn docfn () : false 
```"
"```lua
-- Two dashes start a one-line comment.

--[[
     Adding two ['s and ]'s makes it a
     multi-line comment.
--]]

----------------------------------------------------
-- 1. Variables and flow control.
----------------------------------------------------

num = 42  -- Numbers can be integer or floating point.

s = 'walternate'  -- Immutable strings like Python.
t = ""double-quotes are also fine""
u = [[ Double brackets
       start and end
       multi-line strings.]]
t = nil  -- Undefines t; Lua has garbage collection.

-- Blocks are denoted with keywords like do/end:
while num < 50 do
  num = num + 1  -- No ++ or += type operators.
end

-- If clauses:
if num > 40 then
  print('over 40')
elseif s ~= 'walternate' then  -- ~= is not equals.
  -- Equality check is == like Python; ok for strs.
  io.write('not over 40\n')  -- Defaults to stdout.
else
  -- Variables are global by default.
  thisIsGlobal = 5  -- Camel case is common.

  -- How to make a variable local:
  local line = io.read()  -- Reads next stdin line.

  -- String concatenation uses the .. operator:
  print('Winter is coming, ' .. line)
end

-- Undefined variables return nil.
-- This is not an error:
foo = anUnknownVariable  -- Now foo = nil.

aBoolValue = false

-- Only nil and false are falsy; 0 and '' are true!
if not aBoolValue then print('it was false') end

-- 'or' and 'and' are short-circuited.
-- This is similar to the a?b:c operator in C/js:
ans = aBoolValue and 'yes' or 'no'  --> 'no'

karlSum = 0
for i = 1, 100 do  -- The range includes both ends.
  karlSum = karlSum + i
end

-- Use ""100, 1, -1"" as the range to count down:
fredSum = 0
for j = 100, 1, -1 do fredSum = fredSum + j end

-- In general, the range is begin, end[, step].

-- Another loop construct:
repeat
  print('the way of the future')
  num = num - 1
until num == 0


----------------------------------------------------
-- 2. Functions.
----------------------------------------------------

function fib(n)
  if n < 2 then return 1 end
  return fib(n - 2) + fib(n - 1)
end

-- Closures and anonymous functions are ok:
function adder(x)
  -- The returned function is created when adder is
  -- called, and remembers the value of x:
  return function (y) return x + y end
end
a1 = adder(9)
a2 = adder(36)
print(a1(16))  --> 25
print(a2(64))  --> 100

-- Returns, func calls, and assignments all work
-- with lists that may be mismatched in length.
-- Unmatched receivers are nil;
-- unmatched senders are discarded.

x, y, z = 1, 2, 3, 4
-- Now x = 1, y = 2, z = 3, and 4 is thrown away.

function bar(a, b, c)
  print(a, b, c)
  return 4, 8, 15, 16, 23, 42
end

x, y = bar('zaphod')  --> prints ""zaphod  nil nil""
-- Now x = 4, y = 8, values 15...42 are discarded.

-- Functions are first-class, may be local/global.
-- These are the same:
function f(x) return x * x end
f = function (x) return x * x end

-- And so are these:
local function g(x) return math.sin(x) end
local g; g  = function (x) return math.sin(x) end
-- the 'local g' decl makes g-self-references ok.

-- Trig funcs work in radians, by the way.

-- Calls with one string param don't need parens:
print 'hello'  -- Works fine.


----------------------------------------------------
-- 3. Tables.
----------------------------------------------------

-- Tables = Lua's only compound data structure;
--          they are associative arrays.
-- Similar to php arrays or js objects, they are
-- hash-lookup dicts that can also be used as lists.

-- Using tables as dictionaries / maps:

-- Dict literals have string keys by default:
t = {key1 = 'value1', key2 = false}

-- String keys can use js-like dot notation:
print(t.key1)  -- Prints 'value1'.
t.newKey = {}  -- Adds a new key/value pair.
t.key2 = nil   -- Removes key2 from the table.

-- Literal notation for any (non-nil) value as key:
u = {['@!#'] = 'qbert', [{}] = 1729, [6.28] = 'tau'}
print(u[6.28])  -- prints ""tau""

-- Key matching is basically by value for numbers
-- and strings, but by identity for tables.
a = u['@!#']  -- Now a = 'qbert'.
b = u[{}]     -- We might expect 1729, but it's nil:
-- b = nil since the lookup fails. It fails
-- because the key we used is not the same object
-- as the one used to store the original value. So
-- strings & numbers are more portable keys.

-- A one-table-param function call needs no parens:
function h(x) print(x.key1) end
h{key1 = 'Sonmi~451'}  -- Prints 'Sonmi~451'.

for key, val in pairs(u) do  -- Table iteration.
  print(key, val)
end

-- _G is a special table of all globals.
print(_G['_G'] == _G)  -- Prints 'true'.

-- Using tables as lists / arrays:

-- List literals implicitly set up int keys:
v = {'value1', 'value2', 1.21, 'gigawatts'}
for i = 1, #v do  -- #v is the size of v for lists.
  print(v[i])  -- Indices start at 1 !! SO CRAZY!
end
-- A 'list' is not a real type. v is just a table
-- with consecutive integer keys, treated as a list.

----------------------------------------------------
-- 3.1 Metatables and metamethods.
----------------------------------------------------

-- A table can have a metatable that gives the table
-- operator-overloadish behavior. Later we'll see
-- how metatables support js-prototype behavior.

f1 = {a = 1, b = 2}  -- Represents the fraction a/b.
f2 = {a = 2, b = 3}

-- This would fail:
-- s = f1 + f2

metafraction = {}
function metafraction.__add(f1, f2)
  sum = {}
  sum.b = f1.b * f2.b
  sum.a = f1.a * f2.b + f2.a * f1.b
  return sum
end

setmetatable(f1, metafraction)
setmetatable(f2, metafraction)

s = f1 + f2  -- call __add(f1, f2) on f1's metatable

-- f1, f2 have no key for their metatable, unlike
-- prototypes in js, so you must retrieve it as in
-- getmetatable(f1). The metatable is a normal table
-- with keys that Lua knows about, like __add.

-- But the next line fails since s has no metatable:
-- t = s + s
-- Class-like patterns given below would fix this.

-- An __index on a metatable overloads dot lookups:
defaultFavs = {animal = 'gru', food = 'donuts'}
myFavs = {food = 'pizza'}
setmetatable(myFavs, {__index = defaultFavs})
eatenBy = myFavs.animal  -- works! thanks, metatable

-- Direct table lookups that fail will retry using
-- the metatable's __index value, and this recurses.

-- An __index value can also be a function(tbl, key)
-- for more customized lookups.

-- Values of __index,add, .. are called metamethods.
-- Full list. Here a is a table with the metamethod.

-- __add(a, b)                     for a + b
-- __sub(a, b)                     for a - b
-- __mul(a, b)                     for a * b
-- __div(a, b)                     for a / b
-- __mod(a, b)                     for a % b
-- __pow(a, b)                     for a ^ b
-- __unm(a)                        for -a
-- __concat(a, b)                  for a .. b
-- __len(a)                        for #a
-- __eq(a, b)                      for a == b
-- __lt(a, b)                      for a < b
-- __le(a, b)                      for a <= b
-- __index(a, b)  <fn or a table>  for a.b
-- __newindex(a, b, c)             for a.b = c
-- __call(a, ...)                  for a(...)

----------------------------------------------------
-- 3.2 Class-like tables and inheritance.
----------------------------------------------------

-- Classes aren't built in; there are different ways
-- to make them using tables and metatables.

-- Explanation for this example is below it.

Dog = {}                                   -- 1.

function Dog:new()                         -- 2.
  newObj = {sound = 'woof'}                -- 3.
  self.__index = self                      -- 4.
  return setmetatable(newObj, self)        -- 5.
end

function Dog:makeSound()                   -- 6.
  print('I say ' .. self.sound)
end

mrDog = Dog:new()                          -- 7.
mrDog:makeSound()  -- 'I say woof'         -- 8.

-- 1. Dog acts like a class; it's really a table.
-- 2. function tablename:fn(...) is the same as
--    function tablename.fn(self, ...)
--    The : just adds a first arg called self.
--    Read 7 & 8 below for how self gets its value.
-- 3. newObj will be an instance of class Dog.
-- 4. self = the class being instantiated. Often
--    self = Dog, but inheritance can change it.
--    newObj gets self's functions when we set both
--    newObj's metatable and self's __index to self.
-- 5. Reminder: setmetatable returns its first arg.
-- 6. The : works as in 2, but this time we expect
--    self to be an instance instead of a class.
-- 7. Same as Dog.new(Dog), so self = Dog in new().
-- 8. Same as mrDog.makeSound(mrDog); self = mrDog.

----------------------------------------------------

-- Inheritance example:

LoudDog = Dog:new()                           -- 1.

function LoudDog:makeSound()
  s = self.sound .. ' '                       -- 2.
  print(s .. s .. s)
end

seymour = LoudDog:new()                       -- 3.
seymour:makeSound()  -- 'woof woof woof'      -- 4.

-- 1. LoudDog gets Dog's methods and variables.
-- 2. self has a 'sound' key from new(), see 3.
-- 3. Same as LoudDog.new(LoudDog), and converted to
--    Dog.new(LoudDog) as LoudDog has no 'new' key,
--    but does have __index = Dog on its metatable.
--    Result: seymour's metatable is LoudDog, and
--    LoudDog.__index = LoudDog. So seymour.key will
--    = seymour.key, LoudDog.key, Dog.key, whichever
--    table is the first with the given key.
-- 4. The 'makeSound' key is found in LoudDog; this
--    is the same as LoudDog.makeSound(seymour).

-- If needed, a subclass's new() is like the base's:
function LoudDog:new()
  newObj = {}
  -- set up newObj
  self.__index = self
  return setmetatable(newObj, self)
end

----------------------------------------------------
-- 4. Modules.
----------------------------------------------------


--[[ I'm commenting out this section so the rest of
--   this script remains runnable.
```

```lua
-- Suppose the file mod.lua looks like this:
local M = {}

local function sayMyName()
  print('Hrunkner')
end

function M.sayHello()
  print('Why hello there')
  sayMyName()
end

return M

-- Another file can use mod.lua's functionality:
local mod = require('mod')  -- Run the file mod.lua.

-- require is the standard way to include modules.
-- require acts like:     (if not cached; see below)
local mod = (function ()
  <contents of mod.lua>
end)()
-- It's like mod.lua is a function body, so that
-- locals inside mod.lua are invisible outside it.

-- This works because mod here = M in mod.lua:
mod.sayHello() -- Prints: Why hello there Hrunkner

-- This is wrong; sayMyName only exists in mod.lua:
mod.sayMyName()  -- error

-- require's return values are cached so a file is
-- run at most once, even when require'd many times.

-- Suppose mod2.lua contains ""print('Hi!')"".
local a = require('mod2')  -- Prints Hi!
local b = require('mod2')  -- Doesn't print; a=b.

-- dofile is like require without caching:
dofile('mod2.lua')  --> Hi!
dofile('mod2.lua')  --> Hi! (runs it again)

-- loadfile loads a lua file but doesn't run it yet.
f = loadfile('mod2.lua')  -- Call f() to run it.

-- load is loadfile for strings.
-- (loadstring is deprecated, use load instead)
g = load('print(343)')  -- Returns a function.
g()  -- Prints out 343; nothing printed before now.

--]]

```

## Community

If you need support join the official Lua [mailing list](https://www.lua.org/lua-l.html), [irc channel](http://lua-users.org/wiki/IrcChannel), or [forum](https://luaforum.com).


## References

I was excited to learn Lua so I could make games
with the <a href=""http://love2d.org/"">Love 2D game engine</a>. That's the why.

I started with <a href=""https://ebens.me/post/lua-for-programmers-part-1/"">BlackBulletIV's Lua for programmers</a>.
Next I read the official <a href=""http://www.lua.org/pil/contents.html"">Programming in Lua</a> book.
That's the how.

It might be helpful to check out the <a href=""http://lua-users.org/wiki/LuaShortReference"">Lua short
reference</a> on lua-users.org.

The main topics not covered are standard libraries:

* <a href=""http://lua-users.org/wiki/StringLibraryTutorial"">string library</a>
* <a href=""http://lua-users.org/wiki/TableLibraryTutorial"">table library</a>
* <a href=""http://lua-users.org/wiki/MathLibraryTutorial"">math library</a>
* <a href=""http://lua-users.org/wiki/IoLibraryTutorial"">io library</a>
* <a href=""http://lua-users.org/wiki/OsLibraryTutorial"">os library</a>

By the way, the entire file is valid Lua; save it
as learn.lua and run it with ""lua learn.lua"" !

This was first written for tylerneylon.com, and is
also available as a <a href=""https://gist.github.com/tylerneylon/5853042"">github gist</a>. Have fun with Lua!"
"**Open Graphics Library** (**OpenGL**) is a cross-language cross-platform application programming interface
(API) for rendering 2D computer graphics and 3D vector graphics.<sup>[1]</sup> In this tutorial we will be
focusing on modern OpenGL from 3.3 and above, ignoring ""immediate-mode"", Displaylists and
VBO's without use of Shaders.
I will be using C++ with SFML for window, image and context creation aswell as GLEW
for modern OpenGL extensions, though there are many other librarys available.

```cpp
// Creating an SFML window and OpenGL basic setup.
#include <GL/glew.h>
#include <GL/gl.h>
#include <SFML/Graphics.h>
#include <iostream>

int main() {
    // First we tell SFML how to setup our OpenGL context.
    sf::ContextSettings context{ 24,   // depth buffer bits
                                  8,   // stencil buffer bits
                                  4,   // MSAA samples
                                  3,   // major opengl version
                                  3 }; // minor opengl version
    // Now we create the window, enable VSync
    // and set the window active for OpenGL.
    sf::Window window{ sf::VideoMode{ 1024, 768 },
                       ""opengl window"",
                       sf::Style::Default,
		       context };
    window.setVerticalSyncEnabled(true);
    window.setActive(true);
    // After that we initialise GLEW and check if an error occurred.
    GLenum error;
    glewExperimental = GL_TRUE;
    if ((err = glewInit()) != GLEW_OK)
        std::cout << glewGetErrorString(err) << std::endl;
    // Here we set the color glClear will clear the buffers with.
    glClearColor(0.0f,    // red
                 0.0f,    // green
                 0.0f,    // blue
                 1.0f);   // alpha
    // Now we can start the event loop, poll for events and draw objects.
    sf::Event event{ };
    while (window.isOpen()) {
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close;
        }
        // Tell OpenGL to clear the color buffer
        // and the depth buffer, this will clear our window.
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        // Flip front- and backbuffer.
        window.display();
    }
    return 0;
}
```

## Loading Shaders

After creating a window and our event loop we should create a function,
that sets up our shader program.

```cpp
GLuint createShaderProgram(const std::string& vertexShaderPath,
                           const std::string& fragmentShaderPath) {
    // Load the vertex shader source.
    std::stringstream ss{ };
    std::string vertexShaderSource{ };
    std::string fragmentShaderSource{ };
    std::ifstream file{ vertexShaderPath };
    if (file.is_open()) {
        ss << file.rdbuf();
        vertexShaderSource = ss.str();
        file.close();
    }
    // Clear the stringstream and load the fragment shader source.
    ss.str(std::string{ });
    file.open(fragmentShaderPath);
    if (file.is_open()) {
        ss << file.rdbuf();
        fragmentShaderSource = ss.str();
        file.close();
    }
    // Create the program.
    GLuint program = glCreateProgram();
    // Create the shaders.
    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    // Now we can load the shader source into the shader objects and compile them.
    // Because glShaderSource() wants a const char* const*,
    // we must first create a const char* and then pass the reference.
    const char* cVertexSource = vertexShaderSource.c_str();
    glShaderSource(vertexShader,     // shader
                   1,                // number of strings
                   &cVertexSource,   // strings
                   nullptr);         // length of strings (nullptr for 1)
    glCompileShader(vertexShader);
    // Now we have to do the same for the fragment shader.
    const char* cFragmentSource = fragmentShaderSource.c_str();
    glShaderSource(fragmentShader, 1, &cFragmentSource, nullptr);
    glCompileShader(fragmentShader);
    // After attaching the source and compiling the shaders,
    // we attach them to the program;
    glAttachShader(program, vertexShader);
    glAttachShader(program, fragmentShader);
    glLinkProgram(program);
    // After linking the shaders we should detach and delete
    // them to prevent memory leak.
    glDetachShader(program, vertexShader);
    glDetachShader(program, fragmentShader);
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);
    // With everything done we can return the completed program.
    return program;
}
```

If you want to check the compilation log you can add the following between <code>glCompileShader()</code> and <code>glAttachShader()</code>.

```cpp
GLint logSize = 0;
std::vector<GLchar> logText{ };
glGetShaderiv(vertexShader,         // shader
              GL_INFO_LOG_LENGTH,   // requested parameter
              &logSize);            // return object
if (logSize > 0) {
    logText.resize(logSize);
    glGetShaderInfoLog(vertexShader,      // shader
                       logSize,           // buffer length
                       &logSize,          // returned length
                       logText.data());   // buffer
    std::cout << logText.data() << std::endl;
}
```

The same is possible after <code>glLinkProgram()</code>, just replace <code>glGetShaderiv()</code> with <code>glGetProgramiv()</code>
and <code>glGetShaderInfoLog()</code> with <code>glGetProgramInfoLog()</code>.

```cpp
// Now we can create a shader program with a vertex and a fragment shader.
// ...
glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

GLuint program = createShaderProgram(""vertex.glsl"", ""fragment.glsl"");

sf::Event event{ };
// ...
// We also have to delete the program at the end of the application.
// ...
    }
    glDeleteProgram(program);	
    return 0;
}
// ...
```

Ofcourse we have to create the vertex and fragment shader before we can load them,
so lets create two basic shaders.

**Vertex Shader**

```glsl
// Declare which version of GLSL we use.
// Here we declare, that we want to use the OpenGL 3.3 version of GLSL.
#version 330 core
// At attribute location 0 we want an input variable of type vec3,
// that contains the position of the vertex.
// Setting the location is optional, if you don't set it you can ask for the
// location with glGetAttribLocation().
layout(location = 0) in vec3 position;
// Every shader starts in it's main function.
void main() {
    // gl_Position is a predefined variable that holds
    // the final vertex position.
    // It consists of a x, y, z and w coordinate.
    gl_Position = vec4(position, 1.0);
}
```

**Fragment Shader**

```glsl
#version 330 core
// The fragment shader does not have a predefined variable for
// the vertex color, so we have to define a output vec4,
// that holds the final vertex color.
out vec4 outColor;

void main() {
    // We simply set the output color to red.
    // The parameters are red, green, blue and alpha.
    outColor = vec4(1.0, 0.0, 0.0, 1.0);
}
```

## VAO and VBO
Now we need to define some vertex position we can pass to our shaders. Lets define a simple 2D quad.

```cpp
// The vertex data is defined in a counter-clockwise way,
// as this is the default front face.
std::vector<float> vertexData {
    -0.5f,  0.5f, 0.0f,
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.5f,  0.5f, 0.0f
};
// If you want to use a clockwise definition, you can simply call
glFrontFace(GL_CW);
// Next we need to define a Vertex Array Object (VAO).
// The VAO stores the current state while its active.
GLuint vao = 0;
glGenVertexArrays(1, &vao);
glBindVertexArray(vao);
// With the VAO active we can now create a Vertex Buffer Object (VBO).
// The VBO stores our vertex data.
GLuint vbo = 0;
glGenBuffers(1, &vbo);
glBindBuffer(GL_ARRAY_BUFFER, vbo);
// For reading and copying there are also GL_*_READ and GL_*_COPY,
// if your data changes more often use GL_DYNAMIC_* or GL_STREAM_*.
glBufferData(GL_ARRAY_BUFFER,     // target buffer
             sizeof(vertexData[0]) * vertexData.size(),   // size
             vertexData.data(),   // data
             GL_STATIC_DRAW);     // usage
// After filling the VBO link it to the location 0 in our vertex shader,
// which holds the vertex position.
// ...
// To ask for the attribute location, if you haven't set it:
GLint posLocation = glGetAttribLocation(program, ""position"");
// ..
glEnableVertexAttribArray(0);
glVertexAttribPointer(0, 3,       // location and size
                      GL_FLOAT,   // type of data
                      GL_FALSE,   // normalized (always false for floats)
                      0,          // stride (interleaved arrays)
                      nullptr);   // offset (interleaved arrays)
// Everything should now be saved in our VAO and we can unbind it and the VBO.
glBindVertexArray(0);
glBindBuffer(GL_ARRAY_BUFFER, 0);
// Now we can draw the vertex data in our render loop.
// ...
glClear(GL_COLOR_BUFFER_BIT);
// Tell OpenGL we want to use our shader program.
glUseProgram(program);
// Binding the VAO loads the data we need.
glBindVertexArray(vao);
// We want to draw a quad starting at index 0 of the VBO using 4 indices.
glDrawArrays(GL_QUADS, 0, 4);
glBindVertexArray(0);
window.display();
// ...
// Ofcource we have to delete the allocated memory for the VAO and VBO at
// the end of our application.
// ...
glDeleteBuffers(1, &vbo);
glDeleteVertexArrays(1, &vao);
glDeleteProgram(program);
return 0;
// ...
```

You can find the current code here: [OpenGL - 1](https://pastebin.com/W8jdmVHD).

## More VBO's and Color
Let's create another VBO for some colors.

```cpp
std::vector<float> colorData {
    1.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f,
    0.0f, 0.0f, 1.0f,
    1.0f, 1.0f, 0.0f
};
```

Next we can simply change some previous parameters to create a second VBO for our colors.

```cpp
// ...
GLuint vbo[2];
glGenBuffers(2, vbo);
glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
// ...
glDeleteBuffers(2, vbo);
/ ...
// With these changes made we now have to load our color data into the new VBO
// ...
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

glBindBuffer(GL_ARRAY_BUFFER, vbo[1]);
glBufferData(GL_ARRAY_BUFFER, sizeof(colorData[0]) * colorData.size(),
             colorData.data(), GL_STATIC_DRAW);
glEnableVertexAttribArray(1);
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

glBindVertexArray(0);  
// ...
```

Next we have to change our vertex shader to pass the color data to the fragment shader.<br>
**Vertex Shader**

```glsl
#version 330 core

layout(location = 0) in vec3 position;
// The new location has to differ from any other input variable.
// It is the same index we need to pass to
// glEnableVertexAttribArray() and glVertexAttribPointer().
layout(location = 1) in vec3 color;

out vec3 fColor;

void main() {
    fColor = color;
    gl_Position = vec4(position, 1.0);
}
```

**Fragment Shader**

```glsl
#version 330 core

in vec3 fColor;

out vec4 outColor;

void main() {
    outColor = vec4(fColor, 1.0);
}
```

We define a new input variable ```color``` which represents our color data, this data
is passed on to ```fColor```, which is an output variable of our vertex shader and
becomes an input variable for our fragment shader.
It is imporatant that variables passed between shaders have the exact same name
and type.

## Handling VBO's

```cpp
// If you want to completely clear and refill a VBO use glBufferData(),
// just like we did before.
// ...
// There are two mains ways to update a subset of a VBO's data.
// To update a VBO with existing data
std::vector<float> newSubData {
	-0.25f, 0.5f, 0.0f
};
glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
glBufferSubData(GL_ARRAY_BUFFER,      // target buffer
                0,                    // offset
                sizeof(newSubData[0]) * newSubData.size(),   // size
                newSubData.data());   // data
// This would update the first three values in our vbo[0] buffer.
// If you want to update starting at a specific location just set the second
// parameter to that value and multiply by the types size.
// ...
// If you are streaming data, for example from a file,
// it is faster to directly pass the data to the buffer.
// Other access values are GL_READ_ONLY and GL_READ_WRITE.
glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
// You can static_cast<float*>() the void* to be more safe.
void* Ptr = glMapBuffer(GL_ARRAY_BUFFER,   // buffer to map
                        GL_WRITE_ONLY);    // access to buffer
memcpy(Ptr, newSubData.data(), sizeof(newSubData[0]) * newSubData.size());
// To copy to a specific location add a destination offset to memcpy().
glUnmapBuffer(GL_ARRAY_BUFFER);
// ...
// There is also a way to copy data from one buffer to another,
// If we have two VBO's vbo[0] and vbo[1], we can copy like so
// You can also read from GL_ARRAY_BUFFER.
glBindBuffer(GL_COPY_READ_BUFFER, vbo[0]);
// GL_COPY_READ_BUFFER and GL_COPY_WRITE_BUFFER are specifically for
// copying buffer data.
glBindBuffer(GL_COPY_WRITE_BUFFER, vbo[1]);
glCopyBufferSubData(GL_COPY_READ_BUFFER,    // read buffer
                    GL_COPY_WRITE_BUFFER,   // write buffer
                    0, 0,                   // read and write offset
                    sizeof(vbo[0]) * 3);    // copy size
// This will copy the first three elements from vbo[0] to vbo[1].
```

## Uniforms

**Fragment Shader**

```glsl
// Uniforms are variables like in and out, however,
// we can change them easily by passing new values with glUniform().
// Lets define a time variable in our fragment shader.
#version 330 core
// Unlike a in/out variable we can use a uniform in every shader,
// without the need to pass it to the next one, they are global.
// Don't use locations already used for attributes!
// Uniform layout locations require OpenGL 4.3!
layout(location = 10) uniform float time;

in vec3 fColor;

out vec4 outColor;

void main() {
    // Create a sine wave from 0 to 1 based on the time passed to the shader.
    float factor = (sin(time * 2) + 1) / 2;
    outColor = vec4(fColor.r * factor, fColor.g * factor, fColor.b * factor, 1.0);
}
```

Back to our source code.

```cpp
// If we haven't set the layout location, we can ask for it.
GLint timeLocation = glGetUniformLocation(program, ""time"");
// ...
// Also we should define a Timer counting the current time.
sf::Clock clock{ };
// In out render loop we can now update the uniform every frame.
    // ...
    window.display();
    glUniform1f(10,   // location
                clock.getElapsedTime().asSeconds());   // data
}
// ...
```

With the time getting updated every frame the quad should now be changing from
fully colored to pitch black.
There are different types of glUniform() you can find simple documentation here:
[glUniform - OpenGL Refpage](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml)

## Indexing and IBO's

Element Array Buffers or more commonly Index Buffer Objects (IBO) allow us to use the
same vertex data again which makes drawing a lot easier and faster. here's an example:

```cpp
// Lets create a quad from two rectangles.
// We can simply use the old vertex data from before.
// First, we have to create the IBO.
// The index is referring to the first declaration in the VBO.
std::vector<unsigned int> iboData {
    0, 1, 2,
    0, 2, 3
};
// That's it, as you can see we could reuse 0 - the top left
// and 2 - the bottom right.
// Now that we have our data, we have to fill it into a buffer.
// Note that this has to happen between the two glBindVertexArray() calls,
// so it gets saved into the VAO.
GLuint ibo = 0;
glGenBufferrs(1, &ibo);
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(iboData[0]) * iboData.size(),
             iboData.data(), GL_STATIC_DRAW);
// Next in our render loop, we replace glDrawArrays() with:
glDrawElements(GL_TRIANGLES, iboData.size(), GL_UNSIGNED_INT, nullptr);
// Remember to delete the allocated memory for the IBO.
```

You can find the current code here: [OpenGL - 2](https://pastebin.com/R3Z9ACDE).

## Textures

To load out texture we first need a library that loads the data, for simplicity I will be
using SFML, however there are a lot of librarys for loading image data.

```cpp
// Lets save we have a texture called ""my_tex.tga"", we can load it with:
sf::Image image;
image.loadFromFile(""my_tex.tga"");
// We have to flip the texture around the y-Axis, because OpenGL's texture
// origin is the bottom left corner, not the top left.
image.flipVertically();
// After loading it we have to create a OpenGL texture.
GLuint texture = 0;
glGenTextures(1, &texture);
glBindTexture(GL_TEXTURE_2D, texture);
// Specify what happens when the coordinates are out of range.
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
// Specify the filtering if the object is very large.
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
// Load the image data to the texture.
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image.getSize().x, image.getSize().y,
             0, GL_RGBA, GL_UNSIGNED_BYTE, image.getPixelsPtr());
// Unbind the texture to prevent modifications.
glBindTexture(GL_TEXTURE_2D, 0);
// Delete the texture at the end of the application.
// ...
glDeleteTextures(1, &texture);
```

Ofcourse there are more texture formats than only 2D textures,
You can find further information on parameters here:
[glBindTexture - OpenGL Refpage](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTexture.xhtml)<br>
[glTexImage2D - OpenGL Refpage](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml)<br>
[glTexParameter - OpenGL Refpage](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml)<br>

```cpp
// With the texture created, we now have to specify the UV,
// or in OpenGL terms ST coordinates.
std::vector<float> texCoords {
    // The texture coordinates have to match the triangles/quad
    // definition.
    0.0f, 1.0f,	   // start at top-left
    0.0f, 0.0f,	   // go round counter-clockwise
    1.0f, 0.0f,
    1.0f, 1.0f     // end at top-right
};
// Now we increase the VBO's size again just like we did for the colors.
// ...
GLuint vbo[3];
glGenBuffers(3, vbo);
// ...
glDeleteBuffers(3, vbo);
// ...
// Load the texture coordinates into the new buffer.
glBindBuffer(GL_ARRAY_BUFFER, vbo[2]);
glBufferData(GL_ARRAY_BUFFER, sizeof(texCoords[0]) * texCoords.size(),
             texCoords.data(), GL_STATIC_DRAW);
glEnableVertexAttribArray(2);
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 0, nullptr);
// Because the VAO does not store the texture we have to bind it before drawing.
// ...
glBindVertexArray(vao);
glBindTexture(GL_TEXTURE_2D, texture);
glDrawElements(GL_TRIANGLES, iboData.size(), GL_UNSIGNED_INT, nullptr);
// ...
```

Change the shaders to pass the data to the fragment shader.<br>

**Vertex Shader**

```glsl
#version 330 core

layout(location = 0) in vec3 position;
layout(location = 1) in vec3 color;
layout(location = 2) in vec2 texCoords;

out vec3 fColor;
out vec2 fTexCoords;

void main() {
    fColor = color;
    fTexCoords = texCoords;
    gl_Position = vec4(position, 1.0);
}
```

**Fragment Shader**

```glsl
#version 330 core
// sampler2D represents our 2D texture.
uniform sampler2D tex;
uniform float time;

in vec3 fColor;
in vec2 fTexCoords;

out vec4 outColor;

void main() {
    // texture() loads the current texure data at the specified texture coords,
    // then we can simply multiply them by our color.
    outColor = texture(tex, fTexCoords) * vec4(fColor, 1.0);
}
```

You can find the current code here: [OpenGL - 3](https://pastebin.com/u3bcwM6q)

## Matrix Transformation

**Vertex Shader**

```glsl
#version 330 core

layout(location = 0) in vec3 position;
layout(location = 1) in vec3 color;
layout(location = 2) in vec2 texCoords;
// Create 2 4x4 matricies, 1 for the projection matrix
// and 1 for the model matrix.
// Because we draw in a static scene, we don't need a view matrix.
uniform mat4 projection;
uniform mat4 model;

out vec3 fColor;
out vec2 fTexCoords;

void main() {
    fColor = color;
    fTexCoords = texCoords;
    // Multiplay the position by the model matrix and then by the
    // projection matrix.
    // Beware order of multiplication for matricies!
    gl_Position = projection * model * vec4(position, 1.0);
}
```

In our source we now need to change the vertex data, create a model- and a projection matrix.

```cpp
// The new vertex data, counter-clockwise declaration.
std::vector<float> vertexData {  
    0.0f, 1.0f, 0.0f,   // top left
    0.0f, 0.0f, 0.0f,   // bottom left
    1.0f, 0.0f, 0.0f,   // bottom right
    1.0f, 1.0f, 0.0f    // top right
};
// Request the location of our matricies.
GLint projectionLocation = glGetUniformLocation(program, ""projection"");
GLint modelLocation = glGetUniformLocation(program, ""model"");
// Declaring the matricies.
// Orthogonal matrix for a 1024x768 window.
std::vector<float> projection {  
    0.001953f,       0.0f,  0.0f, 0.0f,
         0.0f, -0.002604f,  0.0f, 0.0f,
         0.0f,       0.0f, -1.0f, 0.0f,
        -1.0f,       1.0f,  0.0f, 1.0f
};
// Model matrix translating to x 50, y 50
// and scaling to x 200, y 200.
std::vector<float> model {  
    200.0f,   0.0f, 0.0f, 0.0f,
      0.0f, 200.0f, 0.0f, 0.0f,
      0.0f,   0.0f, 1.0f, 0.0f,
     50.0f,  50.0f, 0.0f, 1.0f
};
// Now we can send our calculated matricies to the program.
glUseProgram(program);
glUniformMatrix4fv(projectionLocation,   // location
                   1,                    // count
                   GL_FALSE,             // transpose the matrix
                   projection.data());   // data
glUniformMatrix4fv(modelLocation, 1, GL_FALSE, model.data());
glUseProgram(0);
// The glUniform*() calls have to be done, while the program is bound.
```

The application should now display the texture at the defined position and size.<br>
You can find the current code here: [OpenGL - 4](https://pastebin.com/9ahpFLkY)

```cpp
// There are many math librarys for OpenGL, which create
// matricies and vectors, the most used in C++ is glm (OpenGL Mathematics).
// Its a header only library.
// The same code using glm would look like:
glm::mat4 projection{ glm::ortho(0.0f, 1024.0f, 768.0f, 0.0f) };
glUniformMatrix4fv(projectionLocation, 1, GL_FALSE,
                   glm::value_ptr(projection));
// Initialise the model matrix to the identity matrix, otherwise every
// multiplication would be 0.
glm::mat4 model{ 1.0f };
model = glm::translate(model, glm::vec3{ 50.0f, 50.0f, 0.0f });
model = glm::scale(model, glm::vec3{ 200.0f, 200.0f, 0.0f });
glUniformMatrix4fv(modelLocation, 1, GL_FALSE,
                   glm::value_ptr(model));
```

## Geometry Shader

Geometry shaders were introduced in OpenGL 3.2, they can produce vertices
that are send to the rasterizer. They can also change the primitive type e.g.
they can take a point as an input and output other primitives.
Geometry shaders are inbetween the vertex and the fragment shader.

**Vertex Shader**

```glsl
#version 330 core

layout(location = 0) in vec3 position;
layout(location = 1) in vec3 color;
// Create an output interface block passed to the next shadaer stage.
// Interface blocks can be used to structure data passed between shaders.
out VS_OUT {
    vec3 color;
} vs_out;

void main() {
    vs_out.color = color
    gl_Position = vec4(position, 1.0);
}
```

**Geometry Shader**

```glsl
#version 330 core
// The geometry shader takes in points.
layout(points) in;
// It outputs a triangle every 3 vertices emitted.
layout(triangle_strip, max_vertices = 3) out;
// VS_OUT becomes an input variable in the geometry shader.
// Every input to the geometry shader in treated as an array.
in VS_OUT {
    vec3 color;
} gs_in[];
// Output color for the fragment shader.
// You can also simply define color as 'out vec3 color',
// If you don't want to use interface blocks.
out GS_OUT {
    vec3 color;
} gs_out;

void main() {
    // Each emit calls the fragment shader, so we set a color for each vertex.
    gs_out.color = mix(gs_in[0].color, vec3(1.0, 0.0, 0.0), 0.5);
    // Move 0.5 units to the left and emit the new vertex.
    // gl_in[] is the current vertex from the vertex shader, here we only
    // use 0, because we are receiving points.
    gl_Position = gl_in[0].gl_Position + vec4(-0.5, 0.0, 0.0, 0.0);
    EmitVertex();
    gs_out.color = mix(gs_in[0].color, vec3(0.0, 1.0, 0.0), 0.5);
    // Move 0.5 units to the right and emit the new vertex.
    gl_Position = gl_in[0].gl_Position + vec4(0.5, 0.0, 0.0, 0.0);
    EmitVertex();
    gs_out.color = mix(gs_in[0].color, vec3(0.0, 0.0, 1.0), 0.5);
    // Move 0.5 units up and emit the new vertex.
    gl_Position = gl_in[0].gl_Position + vec4(0.0, 0.75, 0.0, 0.0);
    EmitVertex();
    EndPrimitive();
}
```

**Fragment Shader**

```glsl
in GS_OUT {
    vec3 color;
} fs_in;

out vec4 outColor;

void main() {
    outColor = vec4(fs_in.color, 1.0);
}
```

If you now store a single point with a single color in a VBO and draw them,
you should see a triangle, with your color mixed half way between
red, green and blue on each vertex.


## Quotes
<sup>[1]</sup>[OpenGL - Wikipedia](https://en.wikipedia.org/wiki/OpenGL)

## Books

- OpenGL Superbible - Fifth Edition (covering OpenGL 3.3)
- OpenGL Programming Guide - Eighth Edition (covering OpenGL 4.3)"
"```ruby
# This is a comment

=begin
This is a multi-line comment.
The beginning line must start with ""=begin""
and the ending line must start with ""=end"".

You can do this, or start each line in
a multi-line comment with the # character.
=end

# In Ruby, (almost) everything is an object.
# This includes numbers...
3.class #=> Integer

# ...and strings...
""Hello"".class #=> String

# ...and even methods!
""Hello"".method(:class).class #=> Method

# Some basic arithmetic
1 + 1 #=> 2
8 - 1 #=> 7
10 * 2 #=> 20
35 / 5 #=> 7
2 ** 5 #=> 32
5 % 3 #=> 2

# Bitwise operators
3 & 5 #=> 1
3 | 5 #=> 7
3 ^ 5 #=> 6

# Arithmetic is just syntactic sugar
# for calling a method on an object
1.+(3) #=> 4
10.* 5 #=> 50
100.methods.include?(:/) #=> true

# Special values are objects
nil # equivalent to null in other languages
true # truth
false # falsehood

nil.class #=> NilClass
true.class #=> TrueClass
false.class #=> FalseClass

# Equality
1 == 1 #=> true
2 == 1 #=> false

# Inequality
1 != 1 #=> false
2 != 1 #=> true

# Apart from false itself, nil is the only other 'falsey' value

!!nil   #=> false
!!false #=> false
!!0     #=> true
!!""""    #=> true

# More comparisons
1 < 10 #=> true
1 > 10 #=> false
2 <= 2 #=> true
2 >= 2 #=> true

# Combined comparison operator (returns `1` when the first argument is greater, 
# `-1` when the second argument is greater, and `0` otherwise)
1 <=> 10 #=> -1 (1 < 10)
10 <=> 1 #=> 1 (10 > 1)
1 <=> 1 #=> 0 (1 == 1)

# Logical operators
true && false #=> false
true || false #=> true

# There are alternate versions of the logical operators with much lower
# precedence. These are meant to be used as flow-control constructs to chain
# statements together until one of them returns true or false.

# `do_something_else` only called if `do_something` succeeds.
do_something() and do_something_else()
# `log_error` only called if `do_something` fails.
do_something() or log_error()

# String interpolation

placeholder = 'use string interpolation'
""I can #{placeholder} when using double quoted strings""
#=> ""I can use string interpolation when using double quoted strings""

# You can combine strings using `+`, but not with other types
'hello ' + 'world'  #=> ""hello world""
'hello ' + 3 #=> TypeError: can't convert Fixnum into String
'hello ' + 3.to_s #=> ""hello 3""
""hello #{3}"" #=> ""hello 3""

# ...or combine strings and operators
'hello ' * 3 #=> ""hello hello hello ""

# ...or append to string
'hello' << ' world' #=> ""hello world""

# You can print to the output with a newline at the end
puts ""I'm printing!""
#=> I'm printing!
#=> nil

# ...or print to the output without a newline
print ""I'm printing!""
#=> ""I'm printing!"" => nil

# Variables
x = 25 #=> 25
x #=> 25

# Note that assignment returns the value assigned.
# This means you can do multiple assignment.

x = y = 10 #=> 10
x #=> 10
y #=> 10

# By convention, use snake_case for variable names.
snake_case = true

# Use descriptive variable names
path_to_project_root = '/good/name/'
m = '/bad/name/'

# Symbols are immutable, reusable constants represented internally by an
# integer value. They're often used instead of strings to efficiently convey
# specific, meaningful values.

:pending.class #=> Symbol

status = :pending

status == :pending #=> true

status == 'pending' #=> false

status == :approved #=> false

# Strings can be converted into symbols and vice versa.
status.to_s #=> ""pending""
""argon"".to_sym #=> :argon

# Arrays

# This is an array.
array = [1, 2, 3, 4, 5] #=> [1, 2, 3, 4, 5]

# Arrays can contain different types of items.
[1, 'hello', false] #=> [1, ""hello"", false]

# You might prefer %w instead of quotes
%w[foo bar baz] #=> [""foo"", ""bar"", ""baz""]

# Arrays can be indexed.
# From the front...
array[0] #=> 1
array.first #=> 1
array[12] #=> nil

# ...or from the back...
array[-1] #=> 5
array.last #=> 5

# ...or with a start index and length...
array[2, 3] #=> [3, 4, 5]

# ...or with a range...
array[1..3] #=> [2, 3, 4]

# You can reverse an Array.
# Return a new array with reversed values
[1,2,3].reverse #=> [3,2,1]
# Reverse an array in place to update variable with reversed values
a = [1,2,3]
a.reverse! #=> a==[3,2,1] because of the bang ('!') call to reverse

# Like arithmetic, [var] access is just syntactic sugar
# for calling a method '[]' on an object.
array.[] 0 #=> 1
array.[] 12 #=> nil

# You can add to an array...
array << 6 #=> [1, 2, 3, 4, 5, 6]
# Or like this
array.push(6) #=> [1, 2, 3, 4, 5, 6]

# ...and check if an item exists in an array
array.include?(1) #=> true

# Hashes are Ruby's primary dictionary with key/value pairs.
# Hashes are denoted with curly braces.
hash = { 'color' => 'green', 'number' => 5 }

hash.keys #=> ['color', 'number']

# Hashes can be quickly looked up by key.
hash['color'] #=> ""green""
hash['number'] #=> 5

# Asking a hash for a key that doesn't exist returns nil.
hash['nothing here'] #=> nil

# When using symbols for keys in a hash, you can use an alternate syntax.

hash = { :defcon => 3, :action => true }
hash.keys #=> [:defcon, :action]

hash = { defcon: 3, action: true }
hash.keys #=> [:defcon, :action]

# Check existence of keys and values in hash
hash.key?(:defcon) #=> true
hash.value?(3) #=> true

# Tip: Both Arrays and Hashes are Enumerable!
# They share a lot of useful methods such as each, map, count, and more.

# Control structures

# Conditionals
if true
  'if statement'
elsif false
  'else if, optional'
else
  'else, also optional'
end

# If a condition controls invocation of a single statement rather than a block of code
# you can use postfix-if notation
warnings = ['Patronimic is missing', 'Address too short']
puts(""Some warnings occurred:\n"" + warnings.join(""\n""))  if !warnings.empty?

# Rephrase condition if `unless` sounds better than `if`
puts(""Some warnings occurred:\n"" + warnings.join(""\n""))  unless warnings.empty?

# Loops
# In Ruby, traditional `for` loops aren't very common. Instead, these 
# basic loops are implemented using enumerable, which hinges on `each`.
(1..5).each do |counter|
  puts ""iteration #{counter}""
end

# Which is roughly equivalent to the following, which is unusual to see in Ruby.
for counter in 1..5
  puts ""iteration #{counter}""
end

# The `do |variable| ... end` construct above is called a 'block'. Blocks are similar
# to lambdas, anonymous functions or closures in other programming languages. They can
# be passed around as objects, called, or attached as methods.
#
# The 'each' method of a range runs the block once for each element of the range.
# The block is passed a counter as a parameter.

# You can also surround blocks in curly brackets.
(1..5).each { |counter| puts ""iteration #{counter}"" }

# The contents of data structures can also be iterated using each.
array.each do |element|
  puts ""#{element} is part of the array""
end
hash.each do |key, value|
  puts ""#{key} is #{value}""
end

# If you still need an index you can use 'each_with_index' and define an index
# variable.
array.each_with_index do |element, index|
  puts ""#{element} is number #{index} in the array""
end

counter = 1
while counter <= 5 do
  puts ""iteration #{counter}""
  counter += 1
end
#=> iteration 1
#=> iteration 2
#=> iteration 3
#=> iteration 4
#=> iteration 5

# There are a bunch of other helpful looping functions in Ruby.
# For example: 'map', 'reduce', 'inject', the list goes on.
# Map, for instance, takes the array it's looping over, does something
# to it as defined in your block, and returns an entirely new array.
array = [1,2,3,4,5]
doubled = array.map do |element|
  element * 2
end
puts doubled
#=> [2,4,6,8,10]
puts array
#=> [1,2,3,4,5]

# another useful syntax is .map(&:method)
a = [""FOO"", ""BAR"", ""BAZ""]
a.map { |s| s.downcase } #=> [""foo"", ""bar"", ""baz""]
a.map(&:downcase) #=> [""foo"", ""bar"", ""baz""]

# Case construct
grade = 'B'

case grade
when 'A'
  puts 'Way to go kiddo'
when 'B'
  puts 'Better luck next time'
when 'C'
  puts 'You can do better'
when 'D'
  puts 'Scraping through'
when 'F'
  puts 'You failed!'
else
  puts 'Alternative grading system, eh?'
end
#=> ""Better luck next time""

# Cases can also use ranges
grade = 82
case grade
when 90..100
  puts 'Hooray!'
when 80...90
  puts 'OK job'
else
  puts 'You failed!'
end
#=> ""OK job""

# Exception handling
begin
  # Code here that might raise an exception
  raise NoMemoryError, 'You ran out of memory.'
rescue NoMemoryError => exception_variable
  puts 'NoMemoryError was raised', exception_variable
rescue RuntimeError => other_exception_variable
  puts 'RuntimeError was raised now'
else
  puts 'This runs if no exceptions were thrown at all'
ensure
  puts 'This code always runs no matter what'
end

# Methods

def double(x)
  x * 2
end

# Methods (and blocks) implicitly return the value of the last statement.
double(2) #=> 4

# Parentheses are optional where the interpretation is unambiguous.
double 3 #=> 6

double double 3 #=> 12

def sum(x, y)
  x + y
end

# Method arguments are separated by a comma.
sum 3, 4 #=> 7

sum sum(3, 4), 5 #=> 12

# yield
# All methods have an implicit, optional block parameter.
# It can be called with the 'yield' keyword.
def surround
  puts '{'
  yield
  puts '}'
end

surround { puts 'hello world' }

#=> {
#=> hello world
#=> }

# Blocks can be converted into a 'proc' object, which wraps the block 
# and allows it to be passed to another method, bound to a different scope,
# or manipulated otherwise. This is most common in method parameter lists,
# where you frequently see a trailing '&block' parameter that will accept 
# the block, if one is given, and convert it to a 'Proc'. The naming here is
# convention; it would work just as well with '&pineapple'.
def guests(&block)
  block.class #=> Proc
  block.call(4)
end

# The 'call' method on the Proc is similar to calling 'yield' when a block is 
# present. The arguments passed to 'call' will be forwarded to the block as arguments.

guests { |n| ""You have #{n} guests."" }
# => ""You have 4 guests.""

# You can pass a list of arguments, which will be converted into an array.
# That's what splat operator (""*"") is for.
def guests(*array)
  array.each { |guest| puts guest }
end

# There is also the shorthand block syntax. It's most useful when you need
# to call a simple method on all array items.
upcased = ['Watch', 'these', 'words', 'get', 'upcased'].map(&:upcase)
puts upcased
#=> [""WATCH"", ""THESE"", ""WORDS"", ""GET"", ""UPCASED""]
 
sum = [1, 2, 3, 4, 5].reduce(&:+)
puts sum
#=> 15

# Destructuring

# Ruby will automatically destructure arrays on assignment to multiple variables.
a, b, c = [1, 2, 3]
a #=> 1
b #=> 2
c #=> 3

# In some cases, you will want to use the splat operator: `*` to prompt destructuring
# of an array into a list.
ranked_competitors = [""John"", ""Sally"", ""Dingus"", ""Moe"", ""Marcy""]

def best(first, second, third)
  puts ""Winners are #{first}, #{second}, and #{third}.""
end

best *ranked_competitors.first(3) #=> Winners are John, Sally, and Dingus.

# The splat operator can also be used in parameters.
def best(first, second, third, *others)
  puts ""Winners are #{first}, #{second}, and #{third}.""
  puts ""There were #{others.count} other participants.""
end

best *ranked_competitors 
#=> Winners are John, Sally, and Dingus.
#=> There were 2 other participants.

# By convention, all methods that return booleans end with a question mark.
5.even? #=> false
5.odd? #=> true

# By convention, if a method name ends with an exclamation mark, it does something destructive
# like mutate the receiver. Many methods have a ! version to make a change, and
# a non-! version to just return a new changed version.
company_name = ""Dunder Mifflin""
company_name.upcase #=> ""DUNDER MIFFLIN""
company_name #=> ""Dunder Mifflin""
# We're mutating company_name this time.
company_name.upcase! #=> ""DUNDER MIFFLIN""
company_name #=> ""DUNDER MIFFLIN""

# Classes

# You can define a class with the 'class' keyword.
class Human

  # A class variable. It is shared by all instances of this class.
  @@species = 'H. sapiens'

  # Basic initializer
  def initialize(name, age = 0)
    # Assign the argument to the 'name' instance variable for the instance.
    @name = name
    # If no age given, we will fall back to the default in the arguments list.
    @age = age
  end

  # Basic setter method
  def name=(name)
    @name = name
  end

  # Basic getter method
  def name
    @name
  end

  # The above functionality can be encapsulated using the attr_accessor method as follows.
  attr_accessor :name

  # Getter/setter methods can also be created individually like this.
  attr_reader :name
  attr_writer :name

  # A class method uses self to distinguish from instance methods.
  # It can only be called on the class, not an instance.
  def self.say(msg)
    puts msg
  end

  def species
    @@species
  end
end

# Instantiating of a class
jim = Human.new('Jim Halpert')
dwight = Human.new('Dwight K. Schrute')

# You can call the methods of the generated object.
jim.species #=> ""H. sapiens""
jim.name #=> ""Jim Halpert""
jim.name = ""Jim Halpert II"" #=> ""Jim Halpert II""
jim.name #=> ""Jim Halpert II""
dwight.species #=> ""H. sapiens""
dwight.name #=> ""Dwight K. Schrute""

# Calling of a class method
Human.say('Hi') #=> ""Hi""

# Variable's scopes are defined by the way we name them.
# Variables that start with $ have global scope.
$var = ""I'm a global var""
defined? $var #=> ""global-variable""

# Variables that start with @ have instance scope.
@var = ""I'm an instance var""
defined? @var #=> ""instance-variable""

# Variables that start with @@ have class scope.
@@var = ""I'm a class var""
defined? @@var #=> ""class variable""

# Variables that start with a capital letter are constants.
Var = ""I'm a constant""
defined? Var #=> ""constant""

# Class is also an object in ruby. So a class can have instance variables.
# A class variable is shared among the class and all of its descendants.

# Base class
class Human
  @@foo = 0

  def self.foo
    @@foo
  end

  def self.foo=(value)
    @@foo = value
  end
end

# Derived class
class Worker < Human
end

Human.foo #=> 0
Worker.foo #=> 0

Human.foo = 2
Worker.foo #=> 2

# A class instance variable is not shared by the class's descendants.
class Human
  @bar = 0

  def self.bar
    @bar
  end

  def self.bar=(value)
    @bar = value
  end
end

class Doctor < Human
end

Human.bar #=> 0
Doctor.bar #=> nil

module ModuleExample
  def foo
    'foo'
  end
end

# Including modules binds their methods to the class instances.
# Extending modules binds their methods to the class itself.
class Person
  include ModuleExample
end

class Book
  extend ModuleExample
end

Person.foo     #=> NoMethodError: undefined method `foo' for Person:Class
Person.new.foo #=> ""foo""
Book.foo       #=> ""foo""
Book.new.foo   #=> NoMethodError: undefined method `foo'

# Callbacks are executed when including and extending a module
module ConcernExample
  def self.included(base)
    base.extend(ClassMethods)
    base.send(:include, InstanceMethods)
  end

  module ClassMethods
    def bar
      'bar'
    end
  end

  module InstanceMethods
    def qux
      'qux'
    end
  end
end

class Something
  include ConcernExample
end

Something.bar     #=> ""bar""
Something.qux     #=> NoMethodError: undefined method `qux'
Something.new.bar #=> NoMethodError: undefined method `bar'
Something.new.qux #=> ""qux""
```

## Additional resources

- [Learn Ruby by Example with Challenges](http://www.learneroo.com/modules/61/nodes/338) - A variant of this reference with in-browser challenges.
- [An Interactive Tutorial for Ruby](https://rubymonk.com/) - Learn Ruby through a series of interactive tutorials.
- [Official Documentation](http://ruby-doc.org/core)
- [Ruby from other languages](https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/)
- [Programming Ruby](http://www.amazon.com/Programming-Ruby-1-9-2-0-Programmers/dp/1937785491/) - An older [free edition](http://ruby-doc.com/docs/ProgrammingRuby/) is available online.
- [Ruby Style Guide](https://github.com/bbatsov/ruby-style-guide) - A community-driven Ruby coding style guide.
- [Try Ruby](https://try.ruby-lang.org/) - Learn the basic of Ruby programming language, interactive in the browser."
"[Janet](https://janet-lang.org/) is a Lisp-like (Clojure-like),
lexically-scoped, dynamically-typed, garbage-collected, C-based, high-level
language. The entire language (core library, interpreter, compiler, assembler,
PEG) is about 300-500 kB and should run on many constrained systems.

I encourage you to try out the code snippets below in the Janet
repl (either by [installing Janet](https://janet-lang.org/docs/index.html),
or else by using the repl embedded in the Janet homepage).

As we only have a scant *y* minutes, we'll survey the basics here and
leave the remaining details for the manual. So please, keep your arms and
legs inside the vehicle at all times, and on with the scenic tour!

```python
# A comment.

# Some literal values.
true
false
nil

# Typical style for symbols (identifiers-for / names-of things).
do-stuff
pants-on-fire!
foo->bar  # Evidently for converting foos to bars.
fully-charged?
_  # Usually used as a dummy variable.

# Keywords are like symbols that start with a colon, are treated like
# constants, and are typically used as map keys or pieces of syntax in
# macros.
:a
:some-val

# Numbers #####################################################################
5
1e3    # => 1000
1_000  # => 1000
2e-03  # => 0.002
0xff   # => 255

# You can specify a radix (base) like so:
16rff   # => 255 (same as 0xff)
2r1101  # =>  13

# Some numbers in the math library:
math/pi  # => 3.14159
math/e   # => 2.71828

# Strings #####################################################################
""hello""
""hey\tthere""  # contains a tab

# For multi-line strings, use one or more backticks. No escapes allowed.
``a long
multi-line
string``  # => ""a long\nmulti-line\nstring""

# Strings and data structures in Janet come in two varieties: mutable and
# immutable. The literal for the mutable variety is written with a `@` in
# front of it.

# A mutable string (aka ""buffer"").
@""this""
@`a multi-line
one here`

(string ""con"" ""cat"" ""enate"")  # => ""concatenate""

# To get a substring:
(string/slice ""abcdefgh"" 2 5)  # => ""cde""
# To find a substring:
(string/find ""de"" ""abcdefgh"")  # => 3

# See the string library for more (splitting, replacement, etc.)

# Arrays and Tuples ###########################################################
# Arrays are mutable, tuples are immutable.

# Arrays (mutable)
@(4 5 6)
@[4 5 6]

# Tuples (immutable)
# Note that an open paren usually indicates a function call, so if you want a
# literal tuple with parens, you need to ""quote"" it (with a starting single
# quote mark).
'(4 5 6)
[4 5 6]  # ... or just use square brackets.

# Tables and Structs (AKA: ""maps"", ""hashmaps"", ""dictionaries"")
@{:a 1 :b 2 :c 3}  # table  (mutable)
{:a 1 :b 2 :c 3}   # struct (immutable)

# More about how to work with arrays/tuples and tables/structs below.

# Bindings ####################################################################
# ... or ""Name Some Things!"" (that is, bind a value to a symbol)
(def x 4.7)  # Define a constant, `x`.
x            # => 4.7
(quote x)    # => x (the symbol x)
'x           # => x (the symbol x (shorthand))
(print x)    # prints 4.7

# Since we used `def`, can't change to what `x` refers:
(set x 5.6)  # Error, `x` is a constant.

(var y 10)
(set y 12)  # Works, since `y` was made var.

# Note that bindings are local to the scope they're called in. `let`
# creates a local scope and makes some bindings all in one shot:
(let [a 2
      b 3]
  (print ""Hello from inside this local scope."")
  (* a b))  # => 6

# Destructuring is supported, both for arrays/tuples ...
(def a [""foos"" ""bars"" ""moos""])
(let [[s1 _ s2] a]
  (print s1 s2))  # foosmoos

# ... and for tables/structs.
(def t {:a ""ayy"" :b ""bee"" :c ""sea""})
(let [{:a a :b b} t]
  (print a b))  # ayybee

# You can even destructure right in a `def`:
(def [aa1 aa2] a)
aa1  # => foos
aa2  # => bars

(def {:c body-of-water :b insect-friend} t)
body-of-water  # => sea
insect-friend  # => bee

# Note that keywords evaluate to themselves, whereas symbols evaluate
# to whatever value they're bound to (unless you quote them).

# Operators ###################################################################
# Janet supports the usual ensemble of operators.
# +, -, *, /, and so on. Note:
(/ 5 3)  # =>  1.66667
(% 5 3)  # =>  2 (remainder)
(- 5)    # => -5 (or you can just write `-5`)

(++ i)    # increments
(-- i)    # decrements
(+= i 3)  # add 3 to `i`
(*= i 3)  # triple `i`
# ... and so on for the other operations on numbers.

# Comparison
# =  <  >  not=  <=  >=
(< 2 7 12)  # => true

# Functions ###################################################################
# Call them:
(- 5 3)  # => 2 (Yes, operators and functions work the same.)
(math/sin (/ math/pi 2))  # => 1
(range 5)  # => @[0 1 2 3 4]

# Create them:
(defn mult-by-2
  ``First line of docstring.

  Some more of the docstring.

  Possibly more!``
  [x]
  (print ""Hi."")
  (print ""Will compute using: "" x)
  (* 2 x))

(print (mult-by-2 6))  # => 12 (after printing ""Hi"" and so forth)

# If you have a function named ""main"" in your file, `janet` will automatically
# call it for you when you run the file.

# Interactively read a function's docs from within the repl:
(doc mult-by-2)

# Note, functions have to be defined before they can be used in a function,
# so if you design top-down, you'll need to write your functions from the
# bottom of the file up.

# You can make anonymous functions as well:
(fn [x] (+ x x))
(fn my-func [x] (+ x x))  # This one's less anonymous.

# Use `do` to make some side-effecting calls and then evaluate to
# the last form in the `do`:
(def n (do
         (print ""hi"")
         (do-some-side-effecting 42)
         3))
n  # => 3

# You might say that function bodies provide an ""implicit do"".

# Operations on data structures ###############################################
# (Making all these mutable so we can ... mutate them.)
(def s @""Hello, World!"")
(def a @[:a :b :c :d :e])
(def t @{:a 1 :b 2})

(length s)  # => 13
(length a)  # =>  5
(length t)  # =>  2

# Getting values:
(s 7)   # => 87 (which is the code point for ""W"")
(a 1)   # => :b
(t :a)  # => 1
(keys t)    # => @[:a :b]
(values t)  # => @[1 2]

# Changing values (for mutable data structures):
(put s 2 87)   # @""HeWlo, World!""
(put a 2 :x)   # @[:a :b :x :d :e]
(put t :b 42)  # @{:a 1 :b 42}

# Adding & removing values (again, for mutable data structures):
(buffer/push-string s ""??"")  # @""HeWlo, World!??""
(array/push a :f)  # @[:a :b :x :d :e :f]
(array/pop a)      # => :f, and it's also removed from `a`.
(put t :x 88)      # @{:a 1 :b 42 :x 88}

# See the manual for a wide variety of functions for working with
# buffers/strings, arrays/tuples, and tables/struct.

# Flow control ################################################################
(if some-condition
  42
  38)

# Only `nil` and `false` are falsey. Everything else is truthy.

(if got-it?
  71)  # No false-branch value. Returns `nil` if `got-it?` is falsey.

(var i 10)
(while (pos? i)
  (print ""... "" i)
  (-- i))
# Now `i` is 0.

# `case` compares the dispatch value to each of the options.
(var x 2)
(case x
  1 ""won""
  2 ""too""
  3 ""tree""
  ""unknown"")  # => ""too""

# `cond` evaluates conditions until it gets a `true`.
(set x 8)
(cond
  (= x 1) ""won""
  (= x 2) ""too""
  (< x 10) ""tree""
  ""oof!"")  # => ""tree""

(when (avoided-wipeout?)
  (do-side-effecty-thing 88)
  (smell-the-roses)
  (paint-fencepost-error))

# Pattern matching.
# `match` is like a high-powered switch expression. If you switch on a data
# structure, it can look inside to try and match on its contents. For example,
# matching on a table or struct:
(def t {:a 1 :b 2 :c 3})
(match t
  {:yar v} (print ""matches key :yar! "" v)
  {:moo v} (print ""matches key :moo! "" v)
  {:c   v} (print ""matches key :c! ""   v)
  _ (print ""no match""))  # => prints ""matches key :c! 3""

# Iterating ###################################################################
# Iterate over an integer range:
(for i 0 5
  (print i))  # prints 0, 1, 2, 3, 4

# There's also the more general `loop`:
(loop [i :range [0 10] :when (even? i)]
  (print i))

# Loop over an array/tuple:
(def words [""foo"" ""bar"" ""baz""])
(each word words
  (print word))

# Loop over a table/struct:
(def t {:a 1 :b 2})
(eachp [k v] t  # Loop over each pair in `t`.
  (print k "" --> "" v))

# Can also use `eachk` to loop over keys in a table or struct.

# Functional programming ######################################################
# You'll find many familiar old friends here.
(filter even?
        (map (fn [x]
               (* x x))
             (range 10)))  # => @[0 4 16 36 64]

(reduce + 0 (range 5))  # => 10

# ...and lots more (see the API docs).

# Errata ######################################################################
(type a)                # => the type of `a` (as a keyword)
(describe a)            # => a human-readable description of `a`
(string/format ""%j"" a)  # => Janet values, nicely-formatted
```

This tour didn't cover a number of other features such as modules, fibers,
PEGs, macros, etc., but should give you a taste of what Janet is like. See
the [Janet manual](https://janet-lang.org/docs/index.html) and the [Janet API
docs](https://janet-lang.org/api/index.html) for more info."
"Python was created by Guido Van Rossum in the early 90s. It is now one of the
most popular languages in existence. I fell in love with Python for its
syntactic clarity. It's basically executable pseudocode.

Feedback would be highly appreciated! You can reach me at [@louiedinh](http://twitter.com/louiedinh)
or louiedinh [at] [google's email service]

Note: This article applies to Python 2.7 specifically, but should be applicable
to Python 2.x. Python 2.7 is reaching end of life and will stop being
maintained in 2020, it is though recommended to start learning Python with
Python 3. For Python 3.x, take a look at the [Python 3 tutorial](http://learnxinyminutes.com/docs/python/).

It is also possible to write Python code which is compatible with Python 2.7
and 3.x at the same time, using Python [`__future__` imports](https://docs.python.org/2/library/__future__.html). `__future__` imports
allow you to write Python 3 code that will run on Python 2, so check out the
Python 3 tutorial.

```python

# Single line comments start with a number symbol.

"""""" Multiline strings can be written
    using three ""s, and are often used
    as comments
""""""

####################################################
# 1. Primitive Datatypes and Operators
####################################################

# You have numbers
3  # => 3

# Math is what you would expect
1 + 1  # => 2
8 - 1  # => 7
10 * 2  # => 20
35 / 5  # => 7

# Division is a bit tricky. It is integer division and floors the results
# automatically.
5 / 2  # => 2

# To fix division we need to learn about floats.
2.0  # This is a float
11.0 / 4.0  # => 2.75 ahhh...much better

# Result of integer division truncated down both for positive and negative.
5 // 3  # => 1
5.0 // 3.0  # => 1.0 # works on floats too
-5 // 3  # => -2
-5.0 // 3.0  # => -2.0

# Note that we can also import division module(Section 6 Modules)
# to carry out normal division with just one '/'.
from __future__ import division

11 / 4  # => 2.75  ...normal division
11 // 4  # => 2 ...floored division

# Modulo operation
7 % 3  # => 1

# Exponentiation (x to the yth power)
2 ** 4  # => 16

# Enforce precedence with parentheses
(1 + 3) * 2  # => 8

# Boolean Operators
# Note ""and"" and ""or"" are case-sensitive
True and False  # => False
False or True  # => True

# Note using Bool operators with ints
0 and 2  # => 0
-5 or 0  # => -5
0 == False  # => True
2 == True  # => False
1 == True  # => True

# negate with not
not True  # => False
not False  # => True

# Equality is ==
1 == 1  # => True
2 == 1  # => False

# Inequality is !=
1 != 1  # => False
2 != 1  # => True

# More comparisons
1 < 10  # => True
1 > 10  # => False
2 <= 2  # => True
2 >= 2  # => True

# Comparisons can be chained!
1 < 2 < 3  # => True
2 < 3 < 2  # => False

# Strings are created with "" or '
""This is a string.""
'This is also a string.'

# Strings can be added too!
""Hello "" + ""world!""  # => ""Hello world!""
# Strings can be added without using '+'
""Hello "" ""world!""  # => ""Hello world!""

# ... or multiplied
""Hello"" * 3  # => ""HelloHelloHello""

# A string can be treated like a list of characters
""This is a string""[0]  # => 'T'

# You can find the length of a string
len(""This is a string"")  # => 16

# String formatting with %
# Even though the % string operator will be deprecated on Python 3.1 and removed
# later at some time, it may still be good to know how it works.
x = 'apple'
y = 'lemon'
z = ""The items in the basket are %s and %s"" % (x, y)

# A newer way to format strings is the format method.
# This method is the preferred way
""{} is a {}"".format(""This"", ""placeholder"")
""{0} can be {1}"".format(""strings"", ""formatted"")
# You can use keywords if you don't want to count.
""{name} wants to eat {food}"".format(name=""Bob"", food=""lasagna"")

# None is an object
None  # => None

# Don't use the equality ""=="" symbol to compare objects to None
# Use ""is"" instead
""etc"" is None  # => False
None is None  # => True

# The 'is' operator tests for object identity. This isn't
# very useful when dealing with primitive values, but is
# very useful when dealing with objects.

# Any object can be used in a Boolean context.
# The following values are considered falsey:
#    - None
#    - zero of any numeric type (e.g., 0, 0L, 0.0, 0j)
#    - empty sequences (e.g., '', (), [])
#    - empty containers (e.g., {}, set())
#    - instances of user-defined classes meeting certain conditions
#      see: https://docs.python.org/2/reference/datamodel.html#object.__nonzero__
#
# All other values are truthy (using the bool() function on them returns True).
bool(0)  # => False
bool("""")  # => False


####################################################
# 2. Variables and Collections
####################################################

# Python has a print statement
print ""I'm Python. Nice to meet you!""  # => I'm Python. Nice to meet you!

# Simple way to get input data from console
input_string_var = raw_input(
    ""Enter some data: "")  # Returns the data as a string
input_var = input(""Enter some data: "")  # Evaluates the data as python code
# Warning: Caution is recommended for input() method usage
# Note: In python 3, input() is deprecated and raw_input() is renamed to input()

# No need to declare variables before assigning to them.
some_var = 5  # Convention is to use lower_case_with_underscores
some_var  # => 5

# Accessing a previously unassigned variable is an exception.
# See Control Flow to learn more about exception handling.
some_other_var  # Raises a name error

# if can be used as an expression
# Equivalent of C's '?:' ternary operator
""yahoo!"" if 3 > 2 else 2  # => ""yahoo!""

# Lists store sequences
li = []
# You can start with a prefilled list
other_li = [4, 5, 6]

# Add stuff to the end of a list with append
li.append(1)  # li is now [1]
li.append(2)  # li is now [1, 2]
li.append(4)  # li is now [1, 2, 4]
li.append(3)  # li is now [1, 2, 4, 3]
# Remove from the end with pop
li.pop()  # => 3 and li is now [1, 2, 4]
# Let's put it back
li.append(3)  # li is now [1, 2, 4, 3] again.

# Access a list like you would any array
li[0]  # => 1
# Assign new values to indexes that have already been initialized with =
li[0] = 42
li[0]  # => 42
li[0] = 1  # Note: setting it back to the original value
# Look at the last element
li[-1]  # => 3

# Looking out of bounds is an IndexError
li[4]  # Raises an IndexError

# You can look at ranges with slice syntax.
# (It's a closed/open range for you mathy types.)
li[1:3]  # => [2, 4]
# Omit the beginning
li[2:]  # => [4, 3]
# Omit the end
li[:3]  # => [1, 2, 4]
# Select every second entry
li[::2]  # =>[1, 4]
# Reverse a copy of the list
li[::-1]  # => [3, 4, 2, 1]
# Use any combination of these to make advanced slices
# li[start:end:step]

# Remove arbitrary elements from a list with ""del""
del li[2]  # li is now [1, 2, 3]

# You can add lists
li + other_li  # => [1, 2, 3, 4, 5, 6]
# Note: values for li and for other_li are not modified.

# Concatenate lists with ""extend()""
li.extend(other_li)  # Now li is [1, 2, 3, 4, 5, 6]

# Remove first occurrence of a value
li.remove(2)  # li is now [1, 3, 4, 5, 6]
li.remove(2)  # Raises a ValueError as 2 is not in the list

# Insert an element at a specific index
li.insert(1, 2)  # li is now [1, 2, 3, 4, 5, 6] again

# Get the index of the first item found
li.index(2)  # => 1
li.index(7)  # Raises a ValueError as 7 is not in the list

# Check for existence in a list with ""in""
1 in li  # => True

# Examine the length with ""len()""
len(li)  # => 6

# Tuples are like lists but are immutable.
tup = (1, 2, 3)
tup[0]  # => 1
tup[0] = 3  # Raises a TypeError

# You can do all those list thingies on tuples too
len(tup)  # => 3
tup + (4, 5, 6)  # => (1, 2, 3, 4, 5, 6)
tup[:2]  # => (1, 2)
2 in tup  # => True

# You can unpack tuples (or lists) into variables
a, b, c = (1, 2, 3)  # a is now 1, b is now 2 and c is now 3
d, e, f = 4, 5, 6  # you can leave out the parentheses
# Tuples are created by default if you leave out the parentheses
g = 4, 5, 6  # => (4, 5, 6)
# Now look how easy it is to swap two values
e, d = d, e  # d is now 5 and e is now 4

# Dictionaries store mappings
empty_dict = {}
# Here is a prefilled dictionary
filled_dict = {""one"": 1, ""two"": 2, ""three"": 3}

# Look up values with []
filled_dict[""one""]  # => 1

# Get all keys as a list with ""keys()""
filled_dict.keys()  # => [""three"", ""two"", ""one""]
# Note - Dictionary key ordering is not guaranteed.
# Your results might not match this exactly.

# Get all values as a list with ""values()""
filled_dict.values()  # => [3, 2, 1]
# Note - Same as above regarding key ordering.

# Get all key-value pairs as a list of tuples with ""items()""
filled_dict.items()  # => [(""one"", 1), (""two"", 2), (""three"", 3)]

# Check for existence of keys in a dictionary with ""in""
""one"" in filled_dict  # => True
1 in filled_dict  # => False

# Looking up a non-existing key is a KeyError
filled_dict[""four""]  # KeyError

# Use ""get()"" method to avoid the KeyError
filled_dict.get(""one"")  # => 1
filled_dict.get(""four"")  # => None
# The get method supports a default argument when the value is missing
filled_dict.get(""one"", 4)  # => 1
filled_dict.get(""four"", 4)  # => 4
# note that filled_dict.get(""four"") is still => None
# (get doesn't set the value in the dictionary)

# set the value of a key with a syntax similar to lists
filled_dict[""four""] = 4  # now, filled_dict[""four""] => 4

# ""setdefault()"" inserts into a dictionary only if the given key isn't present
filled_dict.setdefault(""five"", 5)  # filled_dict[""five""] is set to 5
filled_dict.setdefault(""five"", 6)  # filled_dict[""five""] is still 5

# You can declare sets (which are like unordered lists that cannot contain
# duplicate values) using the set object.
empty_set = set()
# Initialize a ""set()"" with a bunch of values
some_set = set([1, 2, 2, 3, 4])  # some_set is now set([1, 2, 3, 4])

# order is not guaranteed, even though it may sometimes look sorted
another_set = set([4, 3, 2, 2, 1])  # another_set is now set([1, 2, 3, 4])

# Since Python 2.7, {} can be used to declare a set
filled_set = {1, 2, 2, 3, 4}  # => {1, 2, 3, 4}

# Add more items to a set
filled_set.add(5)  # filled_set is now {1, 2, 3, 4, 5}

# Do set intersection with &
other_set = {3, 4, 5, 6}
filled_set & other_set  # => {3, 4, 5}

# Do set union with |
filled_set | other_set  # => {1, 2, 3, 4, 5, 6}

# Do set difference with -
{1, 2, 3, 4} - {2, 3, 5}  # => {1, 4}

# Do set symmetric difference with ^
{1, 2, 3, 4} ^ {2, 3, 5}  # => {1, 4, 5}

# Check if set on the left is a superset of set on the right
{1, 2} >= {1, 2, 3}  # => False

# Check if set on the left is a subset of set on the right
{1, 2} <= {1, 2, 3}  # => True

# Check for existence in a set with in
2 in filled_set  # => True
10 in filled_set  # => False
10 not in filled_set # => True

# Check data type of variable
type(li)   # => list
type(filled_dict)   # => dict
type(5)   # => int


####################################################
#  3. Control Flow
####################################################

# Let's just make a variable
some_var = 5

# Here is an if statement. Indentation is significant in python!
# prints ""some_var is smaller than 10""
if some_var > 10:
    print ""some_var is totally bigger than 10.""
elif some_var < 10:  # This elif clause is optional.
    print ""some_var is smaller than 10.""
else:  # This is optional too.
    print ""some_var is indeed 10.""

""""""
For loops iterate over lists
prints:
    dog is a mammal
    cat is a mammal
    mouse is a mammal
""""""
for animal in [""dog"", ""cat"", ""mouse""]:
    # You can use {0} to interpolate formatted strings. (See above.)
    print ""{0} is a mammal"".format(animal)

""""""
""range(number)"" returns a list of numbers
from zero to the given number
prints:
    0
    1
    2
    3
""""""
for i in range(4):
    print i

""""""
""range(lower, upper)"" returns a list of numbers
from the lower number to the upper number
prints:
    4
    5
    6
    7
""""""
for i in range(4, 8):
    print i

""""""
While loops go until a condition is no longer met.
prints:
    0
    1
    2
    3
""""""
x = 0
while x < 4:
    print x
    x += 1  # Shorthand for x = x + 1

# Handle exceptions with a try/except block

# Works on Python 2.6 and up:
try:
    # Use ""raise"" to raise an error
    raise IndexError(""This is an index error"")
except IndexError as e:
    pass  # Pass is just a no-op. Usually you would do recovery here.
except (TypeError, NameError):
    pass  # Multiple exceptions can be handled together, if required.
else:  # Optional clause to the try/except block. Must follow all except blocks
    print ""All good!""  # Runs only if the code in try raises no exceptions
finally:  # Execute under all circumstances
    print ""We can clean up resources here""

# Instead of try/finally to cleanup resources you can use a with statement
with open(""myfile.txt"") as f:
    for line in f:
        print line


####################################################
# 4. Functions
####################################################

# Use ""def"" to create new functions
def add(x, y):
    print ""x is {0} and y is {1}"".format(x, y)
    return x + y  # Return values with a return statement


# Calling functions with parameters
add(5, 6)  # => prints out ""x is 5 and y is 6"" and returns 11

# Another way to call functions is with keyword arguments
add(y=6, x=5)  # Keyword arguments can arrive in any order.


# You can define functions that take a variable number of
# positional args, which will be interpreted as a tuple by using *
def varargs(*args):
    return args


varargs(1, 2, 3)  # => (1, 2, 3)


# You can define functions that take a variable number of
# keyword args, as well, which will be interpreted as a dict by using **
def keyword_args(**kwargs):
    return kwargs


# Let's call it to see what happens
keyword_args(big=""foot"", loch=""ness"")  # => {""big"": ""foot"", ""loch"": ""ness""}


# You can do both at once, if you like
def all_the_args(*args, **kwargs):
    print args
    print kwargs


""""""
all_the_args(1, 2, a=3, b=4) prints:
    (1, 2)
    {""a"": 3, ""b"": 4}
""""""

# When calling functions, you can do the opposite of args/kwargs!
# Use * to expand positional args and use ** to expand keyword args.
args = (1, 2, 3, 4)
kwargs = {""a"": 3, ""b"": 4}
all_the_args(*args)  # equivalent to all_the_args(1, 2, 3, 4)
all_the_args(**kwargs)  # equivalent to all_the_args(a=3, b=4)
all_the_args(*args, **kwargs)  # equivalent to all_the_args(1, 2, 3, 4, a=3, b=4)


# you can pass args and kwargs along to other functions that take args/kwargs
# by expanding them with * and ** respectively
def pass_all_the_args(*args, **kwargs):
    all_the_args(*args, **kwargs)
    print varargs(*args)
    print keyword_args(**kwargs)


# Function Scope
x = 5


def set_x(num):
    # Local var x not the same as global variable x
    x = num  # => 43
    print x  # => 43


def set_global_x(num):
    global x
    print x  # => 5
    x = num  # global var x is now set to 6
    print x  # => 6


set_x(43)
set_global_x(6)


# Python has first class functions
def create_adder(x):
    def adder(y):
        return x + y

    return adder


add_10 = create_adder(10)
add_10(3)  # => 13

# There are also anonymous functions
(lambda x: x > 2)(3)  # => True
(lambda x, y: x ** 2 + y ** 2)(2, 1)  # => 5

# There are built-in higher order functions
map(add_10, [1, 2, 3])  # => [11, 12, 13]
map(max, [1, 2, 3], [4, 2, 1])  # => [4, 2, 3]

filter(lambda x: x > 5, [3, 4, 5, 6, 7])  # => [6, 7]

# We can use list comprehensions for nice maps and filters
[add_10(i) for i in [1, 2, 3]]  # => [11, 12, 13]
[x for x in [3, 4, 5, 6, 7] if x > 5]  # => [6, 7]

# You can construct set and dict comprehensions as well.
{x for x in 'abcddeef' if x in 'abc'}  # => {'a', 'b', 'c'}
{x: x ** 2 for x in range(5)}  # => {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}


####################################################
# 5. Classes
####################################################

# We subclass from object to get a class.
class Human(object):
    # A class attribute. It is shared by all instances of this class
    species = ""H. sapiens""

    # Basic initializer, this is called when this class is instantiated.
    # Note that the double leading and trailing underscores denote objects
    # or attributes that are used by python but that live in user-controlled
    # namespaces. You should not invent such names on your own.
    def __init__(self, name):
        # Assign the argument to the instance's name attribute
        self.name = name

        # Initialize property
        self.age = 0

    # An instance method. All methods take ""self"" as the first argument
    def say(self, msg):
        return ""{0}: {1}"".format(self.name, msg)

    # A class method is shared among all instances
    # They are called with the calling class as the first argument
    @classmethod
    def get_species(cls):
        return cls.species

    # A static method is called without a class or instance reference
    @staticmethod
    def grunt():
        return ""*grunt*""

    # A property is just like a getter.
    # It turns the method age() into an read-only attribute
    # of the same name.
    @property
    def age(self):
        return self._age

    # This allows the property to be set
    @age.setter
    def age(self, age):
        self._age = age

    # This allows the property to be deleted
    @age.deleter
    def age(self):
        del self._age


# Instantiate a class
i = Human(name=""Ian"")
print i.say(""hi"")  # prints out ""Ian: hi""

j = Human(""Joel"")
print j.say(""hello"")  # prints out ""Joel: hello""

# Call our class method
i.get_species()  # => ""H. sapiens""

# Change the shared attribute
Human.species = ""H. neanderthalensis""
i.get_species()  # => ""H. neanderthalensis""
j.get_species()  # => ""H. neanderthalensis""

# Call the static method
Human.grunt()  # => ""*grunt*""

# Update the property
i.age = 42

# Get the property
i.age  # => 42

# Delete the property
del i.age
i.age  # => raises an AttributeError

####################################################
# 6. Modules
####################################################

# You can import modules
import math

print math.sqrt(16)  # => 4.0

# You can get specific functions from a module
from math import ceil, floor

print ceil(3.7)  # => 4.0
print floor(3.7)  # => 3.0

# You can import all functions from a module.
# Warning: this is not recommended
from math import *

# You can shorten module names
import math as m

math.sqrt(16) == m.sqrt(16)  # => True
# you can also test that the functions are equivalent
from math import sqrt

math.sqrt == m.sqrt == sqrt  # => True

# Python modules are just ordinary python files. You
# can write your own, and import them. The name of the
# module is the same as the name of the file.

# You can find out which functions and attributes
# defines a module.
import math

dir(math)


# If you have a Python script named math.py in the same
# folder as your current script, the file math.py will
# be loaded instead of the built-in Python module.
# This happens because the local folder has priority
# over Python's built-in libraries.


####################################################
# 7. Advanced
####################################################

# Generators
# A generator ""generates"" values as they are requested instead of storing
# everything up front

# The following method (*NOT* a generator) will double all values and store it
# in `double_arr`. For large size of iterables, that might get huge!
def double_numbers(iterable):
    double_arr = []
    for i in iterable:
        double_arr.append(i + i)
    return double_arr


# Running the following would mean we'll double all values first and return all
# of them back to be checked by our condition
for value in double_numbers(range(1000000)):  # `test_non_generator`
    print value
    if value > 5:
        break


# We could instead use a generator to ""generate"" the doubled value as the item
# is being requested
def double_numbers_generator(iterable):
    for i in iterable:
        yield i + i


# Running the same code as before, but with a generator, now allows us to iterate
# over the values and doubling them one by one as they are being consumed by
# our logic. Hence as soon as we see a value > 5, we break out of the
# loop and don't need to double most of the values sent in (MUCH FASTER!)
for value in double_numbers_generator(xrange(1000000)):  # `test_generator`
    print value
    if value > 5:
        break

# BTW: did you notice the use of `range` in `test_non_generator` and `xrange` in `test_generator`?
# Just as `double_numbers_generator` is the generator version of `double_numbers`
# We have `xrange` as the generator version of `range`
# `range` would return back and array with 1000000 values for us to use
# `xrange` would generate 1000000 values for us as we request / iterate over those items

# Just as you can create a list comprehension, you can create generator
# comprehensions as well.
values = (-x for x in [1, 2, 3, 4, 5])
for x in values:
    print(x)  # prints -1 -2 -3 -4 -5 to console/terminal

# You can also cast a generator comprehension directly to a list.
values = (-x for x in [1, 2, 3, 4, 5])
gen_to_list = list(values)
print(gen_to_list)  # => [-1, -2, -3, -4, -5]

# Decorators
# A decorator is a higher order function, which accepts and returns a function.
# Simple usage example – add_apples decorator will add 'Apple' element into
# fruits list returned by get_fruits target function.
def add_apples(func):
    def get_fruits():
        fruits = func()
        fruits.append('Apple')
        return fruits
    return get_fruits

@add_apples
def get_fruits():
    return ['Banana', 'Mango', 'Orange']

# Prints out the list of fruits with 'Apple' element in it:
# Banana, Mango, Orange, Apple
print ', '.join(get_fruits())

# in this example beg wraps say
# Beg will call say. If say_please is True then it will change the returned
# message
from functools import wraps


def beg(target_function):
    @wraps(target_function)
    def wrapper(*args, **kwargs):
        msg, say_please = target_function(*args, **kwargs)
        if say_please:
            return ""{} {}"".format(msg, ""Please! I am poor :("")
        return msg

    return wrapper


@beg
def say(say_please=False):
    msg = ""Can you buy me a beer?""
    return msg, say_please


print say()  # Can you buy me a beer?
print say(say_please=True)  # Can you buy me a beer? Please! I am poor :(
```

## Ready For More?

### Free Online

* [Automate the Boring Stuff with Python](https://automatetheboringstuff.com)
* [Learn Python The Hard Way](http://learnpythonthehardway.org/book/)
* [Dive Into Python](http://www.diveintopython.net/)
* [The Official Docs](http://docs.python.org/2/)
* [Hitchhiker's Guide to Python](http://docs.python-guide.org/en/latest/)
* [Python Module of the Week](http://pymotw.com/2/)
* [A Crash Course in Python for Scientists](http://nbviewer.ipython.org/5920182)
* [First Steps With Python](https://realpython.com/learn/python-first-steps/)
* [LearnPython](http://www.learnpython.org/)
* [Fullstack Python](https://www.fullstackpython.com/)

### Dead Tree

* [Programming Python](http://www.amazon.com/gp/product/0596158106/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0596158106&linkCode=as2&tag=homebits04-20)
* [Dive Into Python](http://www.amazon.com/gp/product/1441413022/ref=as_li_tf_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1441413022&linkCode=as2&tag=homebits04-20)
* [Python Essential Reference](http://www.amazon.com/gp/product/0672329786/ref=as_li_tf_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0672329786&linkCode=as2&tag=homebits04-20)"
"Pod is an easy-to-use and purely descriptive mark-up language,
with no presentational components. Besides its use for documenting
Raku programs and modules, Pod can be utilized to write language
documentation, blogs, and other types of document composition as well.

Pod documents can be easily converted to HTML and many other formats
(e.g., Markdown, Latex, plain text, etc.) by using the corresponding
variant of the `Pod::To` modules (e.g. `Pod::To::HTML` for HTML conversion).

- [General Info](#general-info)
- [Pod Basics](#pod-basics)
	- [Basic Text Formatting](#basic-text-formatting)
	- [Headings](#headings)
	- [Ordinary Paragraphs](#ordinary-paragraphs)
	- [Lists](#lists)
	- [Code Blocks](#code-blocks)
	- [Comments](#comments)
	- [Links](#links)
	- [Tables](#tables)
- [Block Structures](#block-structures)
	- [Abbreviated Blocks](#abbreviated-blocks)
	- [Delimited Blocks](#delimited-blocks)
	- [Paragraph Blocks](#paragraph-blocks)
- [Configuration Data](#configuration-data)
	- [Standard Configuration Options](#standard-configuration-options)
	- [Block Pre-configuration](#block-pre-configuration)
- [Semantic Blocks](#semantic-blocks)
- [Miscellaneous](#miscellaneous)
	- [Notes](#notes)
	- [Keyboard Input](#keyboard-input)
	- [Terminal Output](#terminal-output)
	- [Unicode](#unicode)
- [Rendering Pod](#rendering-pod)
- [Accessing Pod](#accessing-pod)

## General Info

Every Pod document has to begin with `=begin pod` and end with `=end pod`.
Everything between these two delimiters will be processed and used to
generate documentation.

```
=begin pod

A very simple Raku Pod document. All the other directives go here!

=end pod
```

Pod documents usually coexist with Raku code. If by themselves,
Pod files often have the `.pod6` suffix. Moving forward, it's assumed that
the constructs being discussed are surrounded by the `=begin pod ... =end pod`
directives.

## Pod Basics

### Basic Text Formatting

Text can be easily styled as bold, italic, underlined or verbatim (for code
formatting) using the following formatting codes: `B<>`, `I<>`, `U<>`
and `C<>`.

```
B<This text is in Bold.>

I<This text is in Italics.>

U<This text is Underlined.>

The function C<sub sum { $^x + $^y}> is treated as verbatim.
```

There are more formatting codes (e.g., `L<>`, `T<>`, etc.) but they'll be
discussed later throughout the document. You'll recognize them because they're
just a single capital letter followed immediately by a set of single or double
angle brackets. The Unicode variant («») of the angle brackets can also be
used.

### Headings

Headings are created by using the `=headN` directive where `N` is the
heading level.

```
=head1 This is level 1
=head2 This is level 2
=head3 This is level 3
=head4 This is level 4
=head5 This is level 5
=head6 This is level 6
```

### Ordinary Paragraphs

Ordinary paragraphs consist of one or more adjacent lines of text, each of
which starts with a non-whitespace character. Any paragraph is terminated
by the first blank line or block directive.

```
=head1 First level heading block

=head2 Paragraph 1

This is an ordinary paragraph. Its text will be squeezed and
short lines filled. It is terminated by the first blank line.

=head2 Paragraph 2

This is another ordinary paragraph albeit shorter.
```

Alternatively, the `=para` directive can be used to explicitly mark adjacent
lines of text as a paragraph.

```
=head1 First level heading block

=head2 Paragraph 1

=para
This is an ordinary paragraph. Its text will be squeezed and
short lines filled. It is terminated by the first blank line.

=head2 Paragraph 2

=para
This is another ordinary paragraph albeit shorter.
```

### Lists

Unordered lists can be created using the `=item` directive.

```
=item Item
=item Item
=item Another item
```

Sublists are achieved with items at each level specified using the `=item1`,
`=item2`, `=item3`, `...`, `=itemN` etc. directives. The `=item` directive
defaults to `=item1`.

```
=item1 Item one
=item1 Item two
=item1 Item three
    =item2 Sub-item
    =item2 Sub-item
=item1 Item four
```

Definition lists that define terms or commands use the `=defn` directive.
This is equivalent to the `<dl>` element in HTML.

```
=defn Beast of Bodmin
A large feline inhabiting Bodmin Moor.

=defn Morgawr
A sea serpent.

=defn Owlman
A giant owl-like creature.
```

### Code Blocks

A code block is created (which uses the HTML `<code>` element) by starting each
line with one or more whitespace characters.

```
    #`( this is comment )
    my $sum = -> $x, $y { $x + $y }
    say $sum(12, 5);
```

As shown in the [Basic Text Formatting](#basic-text-formatting) section,
inline code can be created using the `C<>` code.

```
In Raku, there are several functions/methods to output text. Some of them
are C<print>, C<put> and C<say>.
```

### Comments

Although Pod blocks are ignored by the Rakudo Raku compiler, everything
identified as a Pod block will be read and interpreted by Pod renderers. In
order to prevent Pod blocks from being rendered by any renderer, use the
`=comment` directive.

```
=comment Add more here about the algorithm.

=comment Pod comments are great for documenting the documentation.
```

To create inline comments, use the `Z<>` code.

```
Pod is awesome Z<Of course it is!>. And Raku too!
```

Given that the Raku interpreter never executes embedded Pod blocks,
comment blocks can also be used as an alternative form of nestable block
comments.

### Links

Creating links in Pod is quite easy and is done by enclosing them in
a `L<>` code. The general format is `L<Label|Url>` with `Label`
being optional.

```
Raku homepage is L<https://raku.org>.
L<Click me!|http://link.org/>.
```

Relative paths work too.

```
L<Go to music|/music/>.
```

Linking to a section in the same document works as well.

```
L<Link to Headings|#Headings>
```

### Tables

The Pod specifications are not completely handled properly yet and this
includes the handling of table. For simplicity's sake, only one way of
constructing tables is shown here. To learn about good practices and see
examples of both good and bad tables, please visit
<https://docs.raku.org/language/tables>.

```
=begin table
Option      | Description     
============|================  
data        | path to data files.
engine      | engine to be used for processing templates.
ext         | extension to be used for dest files.
=end table
```

## Block Structures

As mentioned earlier, Pod documents are specified using directives, which are
used to delimit blocks of textual content and declare optional
[configuration information](#configuration-data). Every directive starts with
an equals sign (`=`) in the first column. The content of a document is
specified within one or more blocks. Every Pod block may be declared in any of
three equivalent forms: delimited style, paragraph style, or abbreviated style.

Up to this point, we have only used the abbreviated style for the block
types (e.g., `=head1`, `=para`, `=comment`, `=item`, etc).

### Abbreviated Blocks

Abbreviated blocks are introduced by an `=` sign in the first column, which
is followed immediately by the `typename` of the block and then the content.
The rest of the line is treated as block data, rather than as configuration.
The content terminates at the next Pod directive or the first blank line
(which is not part of the block data). The general syntax is

```
=BLOCK_TYPE  BLOCK_DATA
```
For example:

```
=head1 Top level heading
```

### Delimited Blocks

Delimited blocks are bounded by `=begin` and `=end` markers, both of which are
followed by a valid Pod identifier, which is the `typename` of the block.
The general syntax is

```
=begin BLOCK_TYPE
BLOCK_DATA
=end BLOCK_TYPE
```

For example:

```
=begin head1
Top level heading
=end head1
```

This type of blocks is useful for creating headings, list items, code blocks,
etc. with multiple paragraphs. For example,

* a multiline item of a list

```
=begin item
This is a paragraph in list item.

This is another paragraph in the same list item.
=end item
```

* a code block

```
=begin code
#`(
A non-efficient recursive implementation of a power function using multi subs.
)

multi pow( Real $base, 0 ) { 1 }

multi pow( Real $base, Int $exp where * ≥ 0) {
	$base * pow($base, $exp - 1)
}

multi pow( Real $base ) {
     pow($base, 2)
}

say pow(3, 0);   #=> 1
say pow(4.2, 2); #=> 17.64
say pow(6);      #=> 36
=end code
```

### Paragraph Blocks

Paragraph blocks are introduced by a `=for` marker and terminated by
the next Pod directive or the first blank line (which is not considered to
be part of the block's contents). The `=for` marker is followed by the
`typename` of the block. The general syntax is

```
=for BLOCK_TYPE
BLOCK DATA
```

For example:

```
=for head1
Top level heading
```

## Configuration Data

Except for abbreviated blocks, both delimited blocks and paragraph
blocks can be supplied with configuration information about their
contents right after the `typename` of the block. Thus the following
are more general syntaxes for these blocks:

* Delimited blocks

```
=begin BLOCK_TYPE OPTIONAL_CONFIG_INFO
=                 ADDITIONAL_CONFIG_INFO
BLOCK_DATA
=end BLOCK_TYPE
```

* Paragraph blocks

```
=for BLOCK_TYPE OPTIONAL_CONFIG_INFO
=               ADDITIONAL_CONFIG_INFO
BLOCK DATA
```

The configuration information is provided in a format akin to the
[""colon pair""](https://docs.raku.org/language/glossary#index-entry-Colon_Pair)
syntax in Raku. The following table is a simplified version of the
different ways in which configuration info can be supplied. Please go to
<https://docs.raku.org/language/pod#Configuration_information> for a more
thorough treatment of the subject.

| Value     | Specify with...             | Example                        |
| :-------- | :------                     | :------                        |
| List      | :key($elem1, $elem2, ...)   | :tags('Pod', 'Raku')          |
| Hash      | :key{$key1 => $value1, ...} | :feeds{url => 'raku.org'}     |
| Boolean   | :key/:key(True)             | :skip-test(True)               |
| Boolean   | :!key/:key(False)           | :!skip-test                    |
| String    | :key('string')              | :nonexec-reason('SyntaxError') |
| Int       | :key(2)                     | :post-number(6)                |


### Standard Configuration Options

Pod provides a small number of standard configuration options that can
be applied uniformly to built-in block types. Some of them are:

* `:numbered`

This option specifies that the block is to be numbered. The most common
use of this option is to create numbered headings and ordered lists, but it
can be applied to any block.

For example:

```
=for head1 :numbered
The Problem
=for head1 :numbered
The Solution
=for head2 :numbered
Analysis
=for head3 :numbered
Overview
```

* `:allow`

The value of the `:allow` option must be a list of the (single-letter) names
of one or more formatting codes. Those codes will then remain active inside
the code block. The option is most often used on `=code` blocks to allow
mark-up within those otherwise verbatim blocks, though it can be used in any
block that contains verbatim text.

Given the following snippet:

```
=begin code :allow('B', 'I')
B<sub> greet( $name ) {
    B<say> ""Hello, $nameI<!>"";
}
=end code
```

we get the following output:

<pre><strong>sub</strong> greet( $name ) {
    <strong>say</strong> &quot;Hello, $name<em>!</em>&quot;;
}
</pre>

This is highly dependent on the format output. For example, while this works
when Pod is converted to HTML, it might not be preserved when converted
to Markdown.

### Block Pre-configuration

The `=config` directive allows you to prespecify standard configuration
information that is applied to every block of a particular type.
The general syntax for configuration directives is:

```
=config BLOCK_TYPE  CONFIG OPTIONS
=                  ADDITIONAL_CONFIG_INFO
```

For example, to specify that every heading level 1 be numbered, bold
and underlined, you preconfigure the `=head1` as follows:

```
=config head1 :formatted('B', 'U') :numbered
```

## Semantic Blocks

All uppercase block typenames are reserved for specifying standard
documentation, publishing, source components, or meta-information.
Some of them are:

```
=NAME
=AUTHOR
=VERSION
=CREATED
=SYNOPSIS
=DESCRIPTION
=USAGE
```

Most of these blocks would typically be used in their full
delimited forms. For example,

```
=NAME B<Doc::Magic>

=begin DESCRIPTION
This module helps you generate documentation automagically.
Not source code needed! Most of it is outsourced from a black hole.
=end DESCRIPTION

=begin SYNOPSIS
=begin code
	use Doc::Magic;

 	my Doc::Magic $doc .= new();

    my $result = $doc.create-documentation($fh);
=end code
=end SYNOPSIS

=AUTHOR Authorius Docus
=VERSION 42
```

## Miscellaneous

### Notes

Notes are rendered as footnotes and created by enclosing a note in a
`N<>` code.

```
In addition, the language is also multi-paradigmatic N<According to Wikipedia,
this means that it supports procedural, object-oriented, and functional
programming.>
```

### Keyboard Input

To flag text as keyboard input enclose it in a `K<>` code.

```
Enter your name K<John Doe>
```

### Terminal Output

To flag text as terminal output enclose it in `T<>` code.

```
Hello, T<John Doe>
```

### Unicode

To include Unicode code points or HTML5 character references in
a Pod document, enclose them in a `E<>` code.

For example:

```
Raku makes considerable use of the E<171> and E<187> characters.
Raku makes considerable use of the E<laquo> and E<raquo> characters.
```

is rendered as:

Raku makes considerable use of the « and » characters.
Raku makes considerable use of the « and » characters.

## Rendering Pod

To generate any output (i.e., Markdown, HTML, Text, etc.), you need to
have the Rakudo Raku compiler installed. In addition, you must install
a module (e.g., `Pod::To::Markdown`, `Pod::To::HTML`, `Pod::To::Text`, etc.)
that generates your desired output from Pod.

For instructions about installing Rakudo for running raku programs,
[look here](https://raku.org/downloads/).

Run the following command to generate a certain output:

```
raku --doc=TARGET input.pod6 > output.html
```

with `TARGET` being `Markdown`, `HTML`, `Text`, etc. Thus to generate
Markdown from Pod, run this:

```
raku --doc=Markdown input.pod6 > output.html
```

## Accessing Pod

In order to access Pod documentation from within a Raku program,
it is required to use the special `=` twigil (e.g., `$=pod`, `$=SYNOPSIS`,etc).

The `$=` construct provides the introspection over the Pod structure,
producing a `Pod::Block` tree root from which it is possible to access
the whole structure of the Pod document.

If we place the following piece of Raku code and the Pod documentation
in the section [Semantic blocks](#semantic-blocks) in the same file:

```
my %used-directives;
for $=pod -> $pod-item {
    for $pod-item.contents -> $pod-block {
        next unless $pod-block ~~ Pod::Block::Named;
        %used-directives{$pod-block.name} = True;
    }
}

say %used-directives.keys.join(""\n"");
```

we get the following output:

```
SYNOPSIS
NAME
VERSION
AUTHOR
DESCRIPTION
```

## Additional Information

* <https://docs.raku.org/language/pod> for the Pod documentation.
* <https://docs.raku.org/language/tables> for advices about Pod tables.
* <https://design.raku.org/S26.html> for the Pod specification."
"Emacs started its life as [""the extensible, customizable display
editor""](https://www.gnu.org/software/emacs/emacs-paper.html) and grew
over the years into a full-blown ecosystem. Many tasks, usually
relegated to a diverse set of tools can be accomplished from within
Emacs in a consistent, familiar interface. Examples include directory
management, viewing PDF documents, editing files over SSH, managing git
repos,… (the list is quite long). In short, Emacs is yours to make of it
what you will: the spectrum of users varies from those who use it to
edit text files to extreme purists who use it to virtually replace their
operating system.

Emacs is extensible via a specialized dialect of Lisp known as Emacs
Lisp (Elisp) which has a lot of macros geared towards editing text and
managing text buffers. Any key (combination) you use in Emacs is bound
to an Emacs Lisp function and may be remapped to any other function,
including ones you write
yourself.

# Key Notation

``` text
The Emacs manual and the community in general uses a convention to refer to different key combinations used within Emacs. Specifically, Emacs has the notion of a ""modifier key"" that is pressed along with another key to modify its action.

An example of this notation is ""C-c"". In this key combination ""C"" is the modifier and stands for the ""Ctrl"" key and ""c"" is the key whose action is being modified (the literal character ""c"").

The modifier shorthand:
""C-"" --> The ""CTRL"" key
""M-"" --> The ""Meta"" key (usually, the ""Alt"" key)
""s-"" --> The ""Super"" key (the ""Cmd"" key on Macs and the ""Windows"" key on PCs)

There are other, less commonly used modifiers that I will not get into here.

The key combination ""C-x C-s"" means you press ""Ctrl+x"" followed by ""Ctrl+s""

In addition to the above modifiers, the special keys ""Esc"", ""Return (Enter)"" and ""Shift"" are denoted by ""ESC"", ""RET"" and ""S"", respectively.
```

# Basic Emacs Concepts

Here, I discuss some basic Emacs concepts and terminology that may be
confusing to newcomers (especially to people used to Vim terminology)

  - A bunch of text that Emacs is editing is known as a **buffer**
  - A buffer does not necessarily correspond to an actual file on disk.
    It may be just a bunch of text in memory.
  - When a buffer corresponds to a file on disk, we say that the buffer
    is **visiting** that file.
  - Emacs typically has many buffers open at once.
  - The display of Emacs may be split into different **windows** (not to
    be confused with your operating system's windows: the operating
    system window for Emacs can have multiple Emacs windows inside it).
  - An operating system window for Emacs is called an Emacs **frame**.
    Thus, when the Emacs manual talks about opening a new frame, this
    essentially means opening a new OS *window* containing an(other)
    instance of Emacs.
  - The concepts conventionally known as cutting and pasting are
    referred to as **killing** and **yanking**, respectively in Emacs
    parlance.
  - The current position of the cursor is called the **point** in Emacs.
    Technically, **point** is defined as the position right before the
    character where the cursor currently is.
  - Finally, each buffer may have several **modes** associated with it:
    a **major mode** and possibly several **minor modes**.
  - The **major mode** defines the main behavior of Emacs in the
    currently selected buffer. This can be roughly thought of as the
    file type. For example, if you're editing a Python file, the major
    mode is (by default) `python-mode` which causes Emacs to highlight
    Python syntax and automatically indent and outdent your code blocks
    as syntactically required by your Python code.
  - **Minor modes** define subtle changes in behavior and several minor
    modes may be active at once in the same buffer. An example minor
    mode is `flyspell-mode` which automatically highlights spelling
    errors in your
buffer.

# Navigation Basics

``` text
The GUI version of Emacs can be navigated with the mouse like you would expect from a conventional GUI text editor.

The aim here is to focus on navigation solely using the keyboard as this enhances productivity immensely.


* Line movement

C-n --> Next line
C-p --> Previous line

* Character movement

C-f --> Go forward one character
C-b --> Go backward one character

* Word movement

M-f --> Go forward one word
M-b --> Go backward one word

* Sentence movement

M-a --> Move to the beginning of the sentence
M-e --> Move to the end of the sentence

* Beginning and end of line

C-a --> Move to the beginning of the line
C-e --> Move to the end of the line

* Beginning and end of buffer

M-< (""Meta+Shift+,"") --> Go to the beginning of the buffer 
M-> (""Meta+Shift+."") --> Go to the end of the buffer 

* Screen movement

C-v --> Scroll down by one screen-full (the last two lines of the previous screen are kept as overlap for a smoother transition)
M-v --> Scroll up by one screen-full (same as above but with the first two lines)

* Centering the screen

C-l --> Move current line to the screen's center

The above key combination actually cycles through different states depending on how many times it's been pressed.

C-l --> Move current line to the screen's center
C-l C-l --> Move current line to the top of the screen
C-l C-l C-l --> Restore the position of the current line to where it was before the first C-l was pressed

If you press ""C-l"" a 4th time, it cycles back to centering the current line.

* Repeating movement commands

Most movement commands take a numerical prefix argument that says ""repeat the following command that many times"".

Example:

C-u 3 C-p  --> Go up 3 lines
C-u 5 C-f  --> Go forward 5 characters

One notable exception are the screen scrolling commands:

C-u 3 C-v  --> Scroll downward 3 lines (maintaining the position of the cursor)
```

Bonus: many of the above navigation commands are the default navigation
commands in Bash (e.g. pressing ""C-b"" while entering a Bash command
takes you back one
character).

# File editing basics

``` text
* Quitting Emacs [ Now you can't say you don't know how to quit Emacs :-) ]

C-x C-c --> Quit Emacs and get prompted to save any unsaved files (buffers not visiting a file will simply be discarded unless you're running in client-server mode)

* Saving a buffer

C-x C-s --> Save the current buffer. If not visiting a file, it will prompt you for a file name to use to save the buffer.

* Searching within a buffer

C-s --> Search forwards within the buffer. Search is incremental and case-insensitive by default.
        Press C-s to move to the next match.
        If you press ""RET"", point is moved to the currently highlighted word and the search ends.
C-r --> Same as C-s except it searches backward

C-_ or C-/ --> Undo the last action. Keep pressing it to move up the undo tree.
C-? or M-_ --> Redo the previous change

The ""undo"" and ""redo"" commands can take prefix numerical arguments to undo or redo that many actions:

C-u 3 C-_ --> Undo the last 3 changes.
```

# Executing Elisp Functions

``` text
You can execute any currently loaded Elisp functions (including ones you have written yourself) via ""M-x""

M-x RET  --> Prompts you for name of function to execute (Tab completion is available).

Example:

M-x RET search-forward-regexp RET --> Prompts you for a regular expression and searches forward in the buffer for it
```

# Emacs Configuration

Emacs is configured using Elisp. On startup, it looks for a
configuration file either in `~/.emacs` or `~/.emacs.d/init.el` where
`~` refers to your home directory. If you're on Windows, consult [this
article](https://www.gnu.org/software/emacs/manual/html_node/efaq-w32/Location-of-init-file.html)
for the appropriate location of your configuration file.

# Vim inside Emacs

If you are considering the transition from Vim to Emacs and you're put
off by the non-modal nature of Emacs editing, there is an Emacs
extension known as `evil-mode` which lets you have many Vim concepts
inside Emacs. Here are some things added to Emacs by `evil-mode`:

  - Modal editing: you get normal, insert, visual and block visual modes
    like Vim. In addition, you get an ""Emacs"" mode where movement and
    navigation follow the Emacs bindings.
  - Same movement keys as Vim in normal mode
  - Leader key combinations
  - Pressing "":"" in normal mode allows you to execute commands
    (including system commands)

In my own experience, `evil-mode` helps make the transition seamless and
allows you to blend the arguably more intuitive and ergonomic
keybindings of Vim with the unbridled power of Emacs for a truly
superior editing experience.

# Discoverable Help

Emacs features a pretty powerful help system that allows you to discover
new functionality all the
time.

``` text
Obtaining help on specific topics. Tab completion is available for function and variable names.

C-h f RET --> Prompts you for the name of an elisp function and
              displays help text on it along with a clickable link
              to its source code.
C-h v RET --> Same as above with variables  

C-h k RET --> Allows you to enter a key combination and displays the
              name of the elisp function bound to it.

Searching for help:

C-h a --> Prompts you for a string to search for a command in the
          help system. Similar to the 'apropos' or 'man -k'
          commands in Unix systems.

Starting a tutorial:

C-h C-t --> Starts a tutorial designed to familiarize you with
            basic Emacs functionality.
```

# Emacs ""Killer Apps""

As I hinted above, Emacs functionality goes way beyond being a mere text
editor. I will list here a couple of Emacs ""apps"" that are fairly
powerful and popular and may interest you in and of themselves.

## Org

Technnically, `org-mode`, a major mode for buffer editing that provides
organizational tools. It is very difficult to succinctly describe what
Org can do because it's a behemoth of a tool that has many diverse uses
to different people. I will attempt to describe the main features I use
briefly.

  - Divide your file into sections and sub-sections for easy outlining
    and organizing of concepts.
  - Different headings in the outline are foldable/expandable so that
    you can focus on what you need to focus on and eliminate
    distractions.
  - You can maintain a TODO list within Org
  - You can compile TODO lists from many files into an agenda
  - Track the time you spend on each TODO task
  - Manage tables in plain text (including spreadsheet-like
    capabilities)
  - Using the extension `org-babel`, write and execute code blocks in
    your file. The results are captured and are re-usable within the
    file itself. Think Jupyter notebook for any language.
  - Display inline images and LaTeX formulas as images within your file
    (makes for a great note-taking system and/or personal wiki)
  - Export your file into many different formats (LaTeX, PDF, html,…)

Org mode is a very powerful tool to add to your productivity arsenal
and, on a personal note, was the reason that caused me to start using
Emacs after years of using Vim.

## Magit

This is a frontend to `git` from within Emacs. It features a very
intuitive and discoverable interface, yet exposes very powerful
functionality that allows you to manage commits at the chunk level,
inspect diffs, rebase, cherry-pick, … all from within the comfort of
your own editor.

# A Word of Advice

If you are considering using Emacs, a common trap that beginning users
fall into is to copy someone else's configuration file and use it as is.
I highly recommend against doing this for several reasons:

  - It will discourage you from learning and finding things out for
    yourself
  - Someone else's configuration will probably contain many things
    relevant to them that you won't need or ever use.
  - It defeats the purpose of having a customizable text editor that can
    fit your own needs.

What I encourage you to do is to look at other people's configurations
and seek to understand them and adapt only what makes sense to you. You
can find out about new features of Emacs through many YouTube videos,
screencasts or blog posts and then learn for yourself how to add them to
your configuration and workflow. This way, you grow your configuration
incrementally while increasing your knowledge of Emacs along the way.

# Additional Resources

  - [The GNU Emacs Manual](https://www.gnu.org/software/emacs/manual/emacs.html)
  - [Emacs Stack Exchange](https://emacs.stackexchange.com/)
  - [Emacs Wiki](https://www.emacswiki.org/emacs/EmacsWiki)"
"This document describes PHP 5+.

```php
<?php // PHP code must be enclosed with <?php tags

// If your php file only contains PHP code, it is best practice
// to omit the php closing tag to prevent accidental output.

// Two forward slashes start a one-line comment.

# So will a hash (aka pound symbol) but // is more common

/*
     Surrounding text in slash-asterisk and asterisk-slash
     makes it a multi-line comment.
*/

// Use ""echo"" or ""print"" to print output
print('Hello '); // Prints ""Hello "" with no line break

// () are optional for print and echo
echo ""World\n""; // Prints ""World"" with a line break
// (all statements must end with a semicolon)

// Anything outside <?php tags is echoed automatically
?>
Hello World Again!
<?php
// That is because historically PHP started as a Template engine


/************************************
 * Types & Variables
 */

// Variables begin with the $ symbol.
// A valid variable name starts with a letter or an underscore,
// followed by any number of letters, numbers, or underscores.

// You don't have to (and cannot) declare variables.
// Once you assign a value, PHP will create the variable with the right type.

// Boolean values are case-insensitive
$boolean = true;  // or TRUE or True
$boolean = FALSE; // or false or False

// Integers
$int1 = 12;   // => 12
$int2 = -12;  // => -12
$int3 = 012;  // => 10 (a leading 0 denotes an octal number)
$int4 = 0x0F; // => 15 (a leading 0x denotes a hex literal)
// Binary integer literals are available since PHP 5.4.0.
$int5 = 0b11111111; // 255 (a leading 0b denotes a binary number)

// Floats (aka doubles)
$float = 1.234;
$float = 1.2e3;
$float = 7E-10;

// Delete variable
unset($int1);

// Arithmetic
$sum        = 1 + 1; // 2
$difference = 2 - 1; // 1
$product    = 2 * 2; // 4
$quotient   = 2 / 1; // 2

// Shorthand arithmetic
$number = 0;
$number += 1;      // Increment $number by 1
echo $number++;    // Prints 1 (increments after evaluation)
echo ++$number;    // Prints 3 (increments before evaluation)
$number /= $float; // Divide and assign the quotient to $number

// Strings should be enclosed in single quotes;
$sgl_quotes = '$String'; // => '$String'

// Avoid using double quotes except to embed other variables
$dbl_quotes = ""This is a $sgl_quotes.""; // => 'This is a $String.'

// Special characters are only escaped in double quotes
$escaped   = ""This contains a \t tab character."";
$unescaped = 'This just contains a slash and a t: \t';

// Enclose a variable in curly braces if needed
$number = 23;
$apples = ""I have {$number} apples to eat."";   // => I have 23 apples to eat.
$oranges = ""I have ${number} oranges to eat.""; // => I have 23 oranges to eat.
$money = ""I have $${number} in the bank."";     // => I have $23 in the bank.

// Since PHP 5.3, nowdocs can be used for uninterpolated multi-liners
$nowdoc = <<<'END'
Multi line
string
END;

// Heredocs will do string interpolation
$heredoc = <<<END
Multi line
$sgl_quotes
END;

// String concatenation is done with .
echo 'This string ' . 'is concatenated';  // Returns 'This string is concatenated'

// Strings can be passed in as parameters to echo
echo 'Multiple', 'Parameters', 'Valid';  // Returns 'MultipleParametersValid'


/********************************
 * Constants
 */

// A constant is defined by using define()
// and can never be changed during runtime!

// a valid constant name starts with a letter or underscore,
// followed by any number of letters, numbers, or underscores.
define(""FOO"", ""something"");

// access to a constant is possible by calling the chosen name without a $
echo FOO; // Returns 'something'
echo 'This outputs ' . FOO;  // Returns 'This outputs something'



/********************************
 * Arrays
 */

// All arrays in PHP are associative arrays (hashmaps in some languages)

// Works with all PHP versions
$associative = array('One' => 1, 'Two' => 2, 'Three' => 3);

// PHP 5.4 introduced a new syntax
$associative = ['One' => 1, 'Two' => 2, 'Three' => 3];

echo $associative['One']; // prints 1

// Add an element to an associative array
$associative['Four'] = 4;

// List literals implicitly assign integer keys
$array = ['One', 'Two', 'Three'];
echo $array[0]; // => ""One""

// Add an element to the end of an array
$array[] = 'Four';
// or
array_push($array, 'Five');

// Remove element from array
unset($array[3]);

/********************************
 * Output
 */

echo('Hello World!');
// Prints Hello World! to stdout.
// Stdout is the web page if running in a browser.

print('Hello World!'); // The same as echo

// echo and print are language constructs too, so you can drop the parentheses
echo 'Hello World!';
print 'Hello World!';

$paragraph = 'paragraph';

echo 100;        // Echo scalar variables directly
echo $paragraph; // or variables

// If short open tags are configured, or your PHP version is
// 5.4.0 or greater, you can use the short echo syntax
?>
<p><?= $paragraph ?></p>
<?php

$x = 1;
$y = 2;
$x = $y; // $x now contains the same value as $y
$z = &$y;
// $z now contains a reference to $y. Changing the value of
// $z will change the value of $y also, and vice-versa.
// $x will remain unchanged as the original value of $y

echo $x; // => 2
echo $z; // => 2
$y = 0;
echo $x; // => 2
echo $z; // => 0

// Dumps type and value of variable to stdout
var_dump($z); // prints int(0)

// Prints variable to stdout in human-readable format
print_r($array); // prints: Array ( [0] => One [1] => Two [2] => Three )

/********************************
 * Logic
 */
$a = 0;
$b = '0';
$c = '1';
$d = '1';

// assert throws a warning if its argument is not true

// These comparisons will always be true, even if the types aren't the same.
assert($a == $b); // equality
assert($c != $a); // inequality
assert($c <> $a); // alternative inequality
assert($a < $c);
assert($c > $b);
assert($a <= $b);
assert($c >= $d);

// The following will only be true if the values match and are the same type.
assert($c === $d);
assert($a !== $d);
assert(1 === '1');
assert(1 !== '1');

// 'Spaceship' operator (since PHP 7)
// Returns 0 if values on either side are equal
// Returns 1 if value on the left is greater
// Returns -1 if the value on the right is greater

$a = 100;
$b = 1000;

echo $a <=> $a; // 0 since they are equal
echo $a <=> $b; // -1 since $a < $b
echo $b <=> $a; // 1 since $b > $a

// Variables can be converted between types, depending on their usage.

$integer = 1;
echo $integer + $integer; // => 2

$string = '1';
echo $string + $string; // => 2 (strings are coerced to integers)

$string = 'one';
echo $string + $string; // => 0
// Outputs 0 because the + operator cannot cast the string 'one' to a number

// Type casting can be used to treat a variable as another type

$boolean = (boolean) 1; // => true

$zero = 0;
$boolean = (boolean) $zero; // => false

// There are also dedicated functions for casting most types
$integer = 5;
$string = strval($integer);

$var = null; // Null value


/********************************
 * Control Structures
 */

if (true) {
    print 'I get printed';
}

if (false) {
    print 'I don\'t';
} else {
    print 'I get printed';
}

if (false) {
    print 'Does not get printed';
} elseif (true) {
    print 'Does';
}

// ternary operator
print (false ? 'Does not get printed' : 'Does');

// ternary shortcut operator since PHP 5.3
// equivalent of ""$x ? $x : 'Does'""
$x = false;
print($x ?: 'Does');

// null coalesce operator since php 7
$a = null;
$b = 'Does print';
echo $a ?? 'a is not set'; // prints 'a is not set'
echo $b ?? 'b is not set'; // prints 'Does print'


$x = 0;
if ($x === '0') {
    print 'Does not print';
} elseif ($x == '1') {
    print 'Does not print';
} else {
    print 'Does print';
}



// This alternative syntax is useful for templates:
?>

<?php if ($x): ?>
This is displayed if the test is truthy.
<?php else: ?>
This is displayed otherwise.
<?php endif; ?>

<?php

// Use switch to save some logic.
switch ($x) {
    case '0':
        print 'Switch does type coercion';
        break; // You must include a break, or you will fall through
               // to cases 'two' and 'three'
    case 'two':
    case 'three':
        // Do something if $variable is either 'two' or 'three'
        break;
    default:
        // Do something by default
}

// While, do...while and for loops are probably familiar
$i = 0;
while ($i < 5) {
    echo $i++;
} // Prints ""01234""

echo ""\n"";

$i = 0;
do {
    echo $i++;
} while ($i < 5); // Prints ""01234""

echo ""\n"";

for ($x = 0; $x < 10; $x++) {
    echo $x;
} // Prints ""0123456789""

echo ""\n"";

$wheels = ['bicycle' => 2, 'car' => 4];

// Foreach loops can iterate over arrays
foreach ($wheels as $wheel_count) {
    echo $wheel_count;
} // Prints ""24""

echo ""\n"";

// You can iterate over the keys as well as the values
foreach ($wheels as $vehicle => $wheel_count) {
    echo ""A $vehicle has $wheel_count wheels"";
}

echo ""\n"";

$i = 0;
while ($i < 5) {
    if ($i === 3) {
        break; // Exit out of the while loop
    }
    echo $i++;
} // Prints ""012""

for ($i = 0; $i < 5; $i++) {
    if ($i === 3) {
        continue; // Skip this iteration of the loop
    }
    echo $i;
} // Prints ""0124""


/********************************
 * Functions
 */

// Define a function with ""function"":
function my_function () {
    return 'Hello';
}

echo my_function(); // => ""Hello""

// A valid function name starts with a letter or underscore, followed by any
// number of letters, numbers, or underscores.

function add ($x, $y = 1) { // $y is optional and defaults to 1
    $result = $x + $y;
    return $result;
}

echo add(4); // => 5
echo add(4, 2); // => 6

// $result is not accessible outside the function
// print $result; // Gives a warning.

// Since PHP 5.3 you can declare anonymous functions;
$inc = function ($x) {
    return $x + 1;
};

echo $inc(2); // => 3

function foo ($x, $y, $z) {
    echo ""$x - $y - $z"";
}

// Functions can return functions
function bar ($x, $y) {
    // Use 'use' to bring in outside variables
    return function ($z) use ($x, $y) {
        foo($x, $y, $z);
    };
}

$bar = bar('A', 'B');
$bar('C'); // Prints ""A - B - C""

// You can call named functions using strings
$function_name = 'add';
echo $function_name(1, 2); // => 3
// Useful for programmatically determining which function to run.
// Or, use call_user_func(callable $callback [, $parameter [, ... ]]);


// You can get all the parameters passed to a function
function parameters() {
    $numargs = func_num_args();
    if ($numargs > 0) {
        echo func_get_arg(0) . ' | ';
    }
    $args_array = func_get_args();
    foreach ($args_array as $key => $arg) {
        echo $key . ' - ' . $arg . ' | ';
    }
}

parameters('Hello', 'World'); // Hello | 0 - Hello | 1 - World |

// Since PHP 5.6 you can get a variable number of arguments
function variable($word, ...$list) {
	echo $word . "" || "";
	foreach ($list as $item) {
		echo $item . ' | ';
	}
}

variable(""Separate"", ""Hello"", ""World""); // Separate || Hello | World |

/********************************
 * Includes
 */

<?php
// PHP within included files must also begin with a PHP open tag.

include 'my-file.php';
// The code in my-file.php is now available in the current scope.
// If the file cannot be included (e.g. file not found), a warning is emitted.

include_once 'my-file.php';
// If the code in my-file.php has been included elsewhere, it will
// not be included again. This prevents multiple class declaration errors

require 'my-file.php';
require_once 'my-file.php';
// Same as include(), except require() will cause a fatal error if the
// file cannot be included.

// Contents of my-include.php:
<?php

return 'Anything you like.';
// End file

// Includes and requires may also return a value.
$value = include 'my-include.php';

// Files are included based on the file path given or, if none is given,
// the include_path configuration directive. If the file isn't found in
// the include_path, include will finally check in the calling script's
// own directory and the current working directory before failing.
/* */

/********************************
 * Classes
 */

// Classes are defined with the class keyword

class MyClass
{
    const MY_CONST      = 'value'; // A constant

    static $staticVar   = 'static';

    // Static variables and their visibility
    public static $publicStaticVar = 'publicStatic';
    // Accessible within the class only
    private static $privateStaticVar = 'privateStatic';
    // Accessible from the class and subclasses
    protected static $protectedStaticVar = 'protectedStatic';

    // Properties must declare their visibility
    public $property    = 'public';
    public $instanceProp;
    protected $prot = 'protected'; // Accessible from the class and subclasses
    private $priv   = 'private';   // Accessible within the class only

    // Create a constructor with __construct
    public function __construct($instanceProp)
    {
        // Access instance variables with $this
        $this->instanceProp = $instanceProp;
    }

    // Methods are declared as functions inside a class
    public function myMethod()
    {
        print 'MyClass';
    }

    // final keyword would make a function unoverridable
    final function youCannotOverrideMe()
    {
    }

    // Magic Methods

    // what to do if Object is treated as a String
    public function __toString()
    {
        return $property;
    }

    // opposite to __construct()
    // called when object is no longer referenced
    public function __destruct()
    {
        print ""Destroying"";
    }

/*
 * Declaring class properties or methods as static makes them accessible without
 * needing an instantiation of the class. A property declared as static can not
 * be accessed with an instantiated class object (though a static method can).
 */

    public static function myStaticMethod()
    {
        print 'I am static';
    }
}

// Class constants can always be accessed statically
echo MyClass::MY_CONST;    // Outputs 'value';

echo MyClass::$staticVar;  // Outputs 'static';
MyClass::myStaticMethod(); // Outputs 'I am static';

// Instantiate classes using new
$my_class = new MyClass('An instance property');
// The parentheses are optional if not passing in an argument.

// Access class members using ->
echo $my_class->property;     // => ""public""
echo $my_class->instanceProp; // => ""An instance property""
$my_class->myMethod();        // => ""MyClass""

// Nullsafe operators since PHP 8
// You can use this when you're unsure if the abstraction of $my_class contains has a property/method
// it can be used in conjunction with the nullish coalesce operator to ensure proper value
echo $my_class->invalid_property // An error is thrown
echo $my_class?->invalid_property // => NULL
echo $my_class?->invalid_property ?? ""public"" // => ""public""

// Extend classes using ""extends""
class MyOtherClass extends MyClass
{
    function printProtectedProperty()
    {
        echo $this->prot;
    }

    // Override a method
    function myMethod()
    {
        parent::myMethod();
        print ' > MyOtherClass';
    }
}

$my_other_class = new MyOtherClass('Instance prop');
$my_other_class->printProtectedProperty(); // => Prints ""protected""
$my_other_class->myMethod();               // Prints ""MyClass > MyOtherClass""

final class YouCannotExtendMe
{
}

// You can use ""magic methods"" to create getters and setters
class MyMapClass
{
    private $property;

    public function __get($key)
    {
        return $this->$key;
    }

    public function __set($key, $value)
    {
        $this->$key = $value;
    }
}

$x = new MyMapClass();
echo $x->property; // Will use the __get() method
$x->property = 'Something'; // Will use the __set() method

// Classes can be abstract (using the abstract keyword) or
// implement interfaces (using the implements keyword).
// An interface is declared with the interface keyword.

interface InterfaceOne
{
    public function doSomething();
}

interface InterfaceTwo
{
    public function doSomethingElse();
}

// interfaces can be extended
interface InterfaceThree extends InterfaceTwo
{
    public function doAnotherContract();
}

abstract class MyAbstractClass implements InterfaceOne
{
    public $x = 'doSomething';
}

class MyConcreteClass extends MyAbstractClass implements InterfaceTwo
{
    public function doSomething()
    {
        echo $x;
    }

    public function doSomethingElse()
    {
        echo 'doSomethingElse';
    }
}


// Classes can implement more than one interface
class SomeOtherClass implements InterfaceOne, InterfaceTwo
{
    public function doSomething()
    {
        echo 'doSomething';
    }

    public function doSomethingElse()
    {
        echo 'doSomethingElse';
    }
}


/********************************
 * Traits
 */

// Traits are available from PHP 5.4.0 and are declared using ""trait""

trait MyTrait
{
    public function myTraitMethod()
    {
        print 'I have MyTrait';
    }
}

class MyTraitfulClass
{
    use MyTrait;
}

$cls = new MyTraitfulClass();
$cls->myTraitMethod(); // Prints ""I have MyTrait""


/********************************
 * Namespaces
 */

// This section is separate, because a namespace declaration
// must be the first statement in a file. Let's pretend that is not the case

<?php

// By default, classes exist in the global namespace, and can
// be explicitly called with a backslash.

$cls = new \MyClass();



// Set the namespace for a file
namespace My\Namespace;

class MyClass
{
}

// (from another file)
$cls = new My\Namespace\MyClass;

//Or from within another namespace.
namespace My\Other\Namespace;

use My\Namespace\MyClass;

$cls = new MyClass();

// Or you can alias the namespace;

namespace My\Other\Namespace;

use My\Namespace as SomeOtherNamespace;

$cls = new SomeOtherNamespace\MyClass();


/**********************
* Late Static Binding
*
*/

class ParentClass
{
    public static function who()
    {
        echo ""I'm a "" . __CLASS__ . ""\n"";
    }

    public static function test()
    {
        // self references the class the method is defined within
        self::who();
        // static references the class the method was invoked on
        static::who();
    }
}

ParentClass::test();
/*
I'm a ParentClass
I'm a ParentClass
*/

class ChildClass extends ParentClass
{
    public static function who()
    {
        echo ""But I'm "" . __CLASS__ . ""\n"";
    }
}

ChildClass::test();
/*
I'm a ParentClass
But I'm ChildClass
*/

/**********************
*  Magic constants
*
*/

// Get current class name. Must be used inside a class declaration.
echo ""Current class name is "" . __CLASS__;

// Get full path directory of a file
echo ""Current directory is "" . __DIR__;

    // Typical usage
    require __DIR__ . '/vendor/autoload.php';

// Get full path of a file
echo ""Current file path is "" . __FILE__;

// Get current function name
echo ""Current function name is "" . __FUNCTION__;

// Get current line number
echo ""Current line number is "" . __LINE__;

// Get the name of the current method. Only returns a value when used inside a trait or object declaration.
echo ""Current method is "" . __METHOD__;

// Get the name of the current namespace
echo ""Current namespace is "" . __NAMESPACE__;

// Get the name of the current trait. Only returns a value when used inside a trait or object declaration.
echo ""Current trait is "" . __TRAIT__;

/**********************
*  Error Handling
*
*/

// Simple error handling can be done with try catch block

try {
    // Do something
} catch (Exception $e) {
    // Handle exception
}

// When using try catch blocks in a namespaced environment it is important to
// escape to the global namespace, because Exceptions are classes, and the
// Exception class exists in the global namespace. This can be done using a
// leading backslash to catch the Exception.

try {
    // Do something
} catch (\Exception $e) {
    // Handle exception
}

// Custom exceptions

class MyException extends Exception {}

try {

    $condition = true;

    if ($condition) {
        throw new MyException('Something just happened');
    }

} catch (MyException $e) {
    // Handle my exception
}

```

## More Information

Visit the [official PHP documentation](http://www.php.net/manual/) for reference
and community input.

If you're interested in up-to-date best practices, visit
[PHP The Right Way](http://www.phptherightway.com/).

A tutorial covering basics of language, setting up coding environment and making
few practical projects at [Codecourse - PHP Basics](https://www.youtube.com/playlist?list=PLfdtiltiRHWHjTPiFDRdTOPtSyYfz3iLW).

If you're coming from a language with good package management, check out
[Composer](http://getcomposer.org/).

For common standards, visit the PHP Framework Interoperability Group's
[PSR standards](https://github.com/php-fig/fig-standards)."
"# Lambda Calculus

Lambda calculus (λ-calculus), originally created by 
[Alonzo Church](https://en.wikipedia.org/wiki/Alonzo_Church),
is the world's smallest programming language.
Despite not having numbers, strings, booleans, or any non-function datatype,
lambda calculus can be used to represent any Turing Machine!

Lambda calculus is composed of 3 elements: **variables**, **functions**, and
**applications**.


| Name        | Syntax                             | Example   | Explanation                                   |
|-------------|------------------------------------|-----------|-----------------------------------------------|
| Variable    | `<name>`                           | `x`       | a variable named ""x""                          |
| Function    | `λ<parameters>.<body>`             | `λx.x`    | a function with parameter ""x"" and body ""x""    |
| Application | `<function><variable or function>` | `(λx.x)a` | calling the function ""λx.x"" with argument ""a"" |

The most basic function is the identity function: `λx.x` which is equivalent to
`f(x) = x`. The first ""x"" is the function's argument, and the second is the
body of the function.

## Free vs. Bound Variables:

- In the function `λx.x`, ""x"" is called a bound variable because it is both in
the body of the function and a parameter.
- In `λx.y`, ""y"" is called a free variable because it is never declared before hand.

## Evaluation:

Evaluation is done via 
[β-Reduction](https://en.wikipedia.org/wiki/Lambda_calculus#Beta_reduction),
which is essentially lexically-scoped substitution.

When evaluating the
expression `(λx.x)a`, we replace all occurrences of ""x"" in the function's body
with ""a"".

- `(λx.x)a` evaluates to: `a`
- `(λx.y)a` evaluates to: `y`

You can even create higher-order functions:

- `(λx.(λy.x))a` evaluates to: `λy.a`

Although lambda calculus traditionally supports only single parameter 
functions, we can create multi-parameter functions using a technique called 
[currying](https://en.wikipedia.org/wiki/Currying).

- `(λx.λy.λz.xyz)` is equivalent to `f(x, y, z) = ((x y) z)`

Sometimes `λxy.<body>` is used interchangeably with: `λx.λy.<body>`

----

It's important to recognize that traditional **lambda calculus doesn't have
numbers, characters, or any non-function datatype!**

## Boolean Logic:

There is no ""True"" or ""False"" in lambda calculus. There isn't even a 1 or 0.

Instead:

`T` is represented by: `λx.λy.x`

`F` is represented by: `λx.λy.y`

First, we can define an ""if"" function `λbtf` that
returns `t` if `b` is True and `f` if `b` is False

`IF` is equivalent to: `λb.λt.λf.b t f`

Using `IF`, we can define the basic boolean logic operators:

`a AND b` is equivalent to: `λab.IF a b F`

`a OR b` is equivalent to: `λab.IF a T b`

`NOT a` is equivalent to: `λa.IF a F T`

*Note: `IF a b c` is essentially saying: `IF((a b) c)`*

## Numbers:

Although there are no numbers in lambda calculus, we can encode numbers using
[Church numerals](https://en.wikipedia.org/wiki/Church_encoding).

For any number n: <code>n = λf.f<sup>n</sup></code> so:

`0 = λf.λx.x`

`1 = λf.λx.f x`

`2 = λf.λx.f(f x)`

`3 = λf.λx.f(f(f x))`

To increment a Church numeral,
we use the successor function `S(n) = n + 1` which is:

`S = λn.λf.λx.f((n f) x)`

Using successor, we can define add:

`ADD = λab.(a S)b`

**Challenge:** try defining your own multiplication function!

## Get even smaller: SKI, SK and Iota

### SKI Combinator Calculus

Let S, K, I be the following functions:

`I x = x`

`K x y =  x`

`S x y z = x z (y z)`

We can convert an expression in the lambda calculus to an expression
in the SKI combinator calculus:

1. `λx.x = I`
2. `λx.c = Kc` provided that `x` does not occur free in `c`
3. `λx.(y z) = S (λx.y) (λx.z)`

Take the church number 2 for example:

`2 = λf.λx.f(f x)`

For the inner part `λx.f(f x)`:

```
  λx.f(f x)
= S (λx.f) (λx.(f x))          (case 3)
= S (K f)  (S (λx.f) (λx.x))   (case 2, 3)
= S (K f)  (S (K f) I)         (case 2, 1)
```

So:

```
  2
= λf.λx.f(f x)
= λf.(S (K f) (S (K f) I))
= λf.((S (K f)) (S (K f) I))
= S (λf.(S (K f))) (λf.(S (K f) I)) (case 3)
```

For the first argument `λf.(S (K f))`:

```
  λf.(S (K f))
= S (λf.S) (λf.(K f))       (case 3)
= S (K S) (S (λf.K) (λf.f)) (case 2, 3)
= S (K S) (S (K K) I)       (case 2, 3)
```

For the second argument `λf.(S (K f) I)`:

```
  λf.(S (K f) I)
= λf.((S (K f)) I)
= S (λf.(S (K f))) (λf.I)             (case 3)
= S (S (λf.S) (λf.(K f))) (K I)       (case 2, 3)
= S (S (K S) (S (λf.K) (λf.f))) (K I) (case 1, 3)
= S (S (K S) (S (K K) I)) (K I)       (case 1, 2)
```

Merging them up:

```
  2
= S (λf.(S (K f))) (λf.(S (K f) I))
= S (S (K S) (S (K K) I)) (S (S (K S) (S (K K) I)) (K I))
```

Expanding this, we would end up with the same expression for the
church number 2 again.

### SK Combinator Calculus

The SKI combinator calculus can still be reduced further. We can
remove the I combinator by noting that `I = SKK`. We can substitute
all `I`'s with `SKK`.

### Iota Combinator

The SK combinator calculus is still not minimal. Defining:

```
ι = λf.((f S) K)
```

We have:

```
I = ιι
K = ι(ιI) = ι(ι(ιι))
S = ι(K) = ι(ι(ι(ιι)))
```

## For more advanced reading:

1. [A Tutorial Introduction to the Lambda Calculus](http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf)
2. [Cornell CS 312 Recitation 26: The Lambda Calculus](http://www.cs.cornell.edu/courses/cs3110/2008fa/recitations/rec26.html)
3. [Wikipedia - Lambda Calculus](https://en.wikipedia.org/wiki/Lambda_calculus)
4. [Wikipedia - SKI combinator calculus](https://en.wikipedia.org/wiki/SKI_combinator_calculus)
5. [Wikipedia - Iota and Jot](https://en.wikipedia.org/wiki/Iota_and_Jot)"
"The purpose of sing is to provide a simple, safe, fast language that 
can be a good replacement for c++ for high performance applications.

Sing is an easy choice because it compiles to human-quality readable c++.

Because of that, if you work for a while with Sing and, at any time, you discover you don't like Sing anymore, you lose nothing of your work
because you are left with nice and clean c++ code. 

In some way you can also think Sing as a tool to write c++ in a way that enforces some best practices.

```go
/* Multi- line comment. 
    /* It can be nested */ 
    Use it to remark-out part of the code.
    It leaves no trace in the intermediate c++ code. 
    (sing translates into nice human readable c++)
*/

// Single line comment, can be placed only before a statement or declaration...
// ...or at the right of the first line of a statement or declaration.
// single line comments are kept into c++.
//
// here we declare if we need to use public declarations from other files. 
// (in this case from files 'sio', 'sys')
requires ""sio"";
requires ""sys"";

//
// A sing function declaration.
// All the declarations can be made public with the 'public' keyword.
// All the declarations start with a keyword specifying the type of declaration
// (in this case fn for function) then follows the name, the arguments and the
// return type.
//
// Each argument starts with a direction qualifyer (in, out, io) which tells if
// the argument is an input, an output or both...
// ...then follows the argument name and the type.
public fn singmain(in argv [*]string) i32
{
    // print is from the sio file and sends a string to the console
    sio.print(""Hello World\n"");

    // type conversions are allowed in the form of <newtype>(expression).
    sio.print(string(sum(5, 10)) + ""\n"");

    // For clarity you can specify after an argument its name separated by ':'.
    var result i32;
    recursive_power(10:base, 3:exponent, result);

    // referred here to avoid a 'not used' error.
    learnTypes();

    // functions can only return a single value of some basic type.
    return(0);
}

// You can have as many arguments as you want, comma separated. 
// You can also omit the 'in' direction qualifyer (it is the default).
fn sum(arg1 i32, arg2 i32) i32
{
    // as 'fn' declares a function, 'let' declares a constant.
    // With constants, if you place an initializer, you can omit the type.
    let the_sum = arg1 + arg2;

    return(the_sum);
}

// Arguments are passed by reference, which means that in the function body you
// use the argument names to refer to the passed variables.
// Example: all the functions in the recursion stack access the same 'result'
// variable, supplied by the singmain function. 
fn recursive_power(base i32, exponent i32, out result i32) void
{
    if (exponent == 0) {
        result = 1;
    } else {
        recursive_power(base, exponent - 1, result);
        result *= base;
    }
}

//**********************************************************
//
// TYPES
//
//**********************************************************
fn learnTypes() void
{
    // the var keyword declares mutable variables 
    // in this case an UTF-8 encoded string
    var my_name string;

    // ints of 8..64 bits size
    var int0 i8; 
    var int1 i16; 
    var int2 i32; 
    var int3 i64; 

    // uints
    var uint0 u8;
    var uint1 u16;
    var uint2 u32;
    var uint3 u64;

    // floats
    var float0 f32;
    var float1 f64;

    // complex
    var cmplx0 c64;
    var cmplx1 c128;

    cmplx0 = 0;
    cmplx1 = 0;

    // and of course...
    var bool0 bool;

    // type inference: by default constants are i32, f32, c64
    let an_int32 = 15;
    let a_float32 = 15.0;
    let a_complex = 15.0 + 3i;
    let a_string = ""Hello !"";
    let a_bool = false;

    // To create constant of different types use a conversion-like syntax:
    // NOTE: this is NOT a conversion. Just a type specification
    let a_float64 = f64(5.6);

    // in a type definition [] reads as ""array of""
    // in the example []i32 => array of i32.
    var intarray []i32 = {1, 2, 3};

    // You can specify a length, else the length is given by the initializer
    // the last initializer is replicated on the extra items
    var sizedarray [10]i32 = {1, 2, 3};

    // Specify * as the size to get a dynamic array (can change its length)
    var dyna_array [*]i32;

    // you can append items to a vector invoking a method-like function on it.
    dyna_array.push_back(an_int32);

    // getting the size of the array. sys.validate() is like assert in c
    sys.validate(dyna_array.size() == 1); 

    // a map that associates a number to a string. 
    // ""map(x)..."" reads ""map with key of type x and value of type..."" 
    var a_map map(string)i32;

    a_map.insert(""one"", 1);
    a_map.insert(""two"", 2);
    a_map.insert(""three"", 3);
    let key = ""two"";

    // note: the second argument of get_safe is the value to be returned 
    // when the key is not found.
    sio.print(""\nAnd the value is...: "" + string(a_map.get_safe(key, -1)));

    // string concatenation
    my_name = ""a"" + ""b"";
}

// an enum type can only have a value from a discrete set. 
// can't be converted to/from int !
enum Stages {first, second, last}

// you can refer to enum values (to assign/compare them)
// specifying both the typename and tagname separated with the '.' operator
var current_stage = Stages.first;


//**********************************************************
//
// POINTERS
//
//**********************************************************

// This is a factory for a dynamic vector.
// In a type declaration '*' reads 'pointer to..'
// so the return type is 'pointer to a vector of i32'
fn vectorFactory(first i32, last i32) *[*]i32
{
    var buffer [*]i32;

    // fill
    for (value in first : last) {
        buffer.push_back(value);
    }

    // The & operator returns the address of the buffer.
    // You can only use & on local variables
    // As you use & on a variable, that variable is allocated on the HEAP.
    return(&buffer);
}

fn usePointers() void
{
    var bufferptr = vectorFactory(0, 100);

    // you don't need to use the factory pattern to use pointers.
    var another_buffer [*]i32;
    var another_bufferptr = &another_buffer;

    // you can dereference a pointer with the * operator
    // sys.validate is an assertion (causes a signal if the argument is false)
    sys.validate((*bufferptr)[0] == 0);

    /* 
    // as all the pointers to a variable exit their scope the variable is
    // no more accessible and is deleted (freed)
    */
}

//**********************************************************
//
// CLASSES
//
//**********************************************************

// This is a Class. The member variables can be directly initialized here
class AClass {
public:
    var public_var = 100;       // same as any other variable declaration  
    fn is_ready() bool;         // same as any other function declaration 
    fn mut finalize() void;     // destructor (called on object deletion)
private:
    var private_var string; 

    // Changes the member variables and must be marked as 'mut' (mutable)
    fn mut private_fun(errmsg string) void;    
}

// How to declare a member function
fn AClass.is_ready() bool
{
    // inside a member function, members can be accessed thrugh the 
    // this keyword and the field selector '.'
    return(this.public_var > 10);
}

fn AClass.private_fun(errmsg string) void
{
    this.private_var = errmsg;
}

// using a class
fn useAClass() void
{
    // in this way you create a variable of type AClass.
    var instance AClass;

    // then you can access its members through the '.' operator.
    if (instance.is_ready()) {
        instance.public_var = 0;
    }
}

//**********************************************************
//
// INTERFACES
//
//**********************************************************

// You can use polymorphism in sing defining an interface...
interface ExampleInterface {
    fn mut eraseAll() void;
    fn identify_myself() void;
} 

// and then creating classes which implement the interface
// NOTE: you don't need (and cannot) re-declare the interface functions
class Implementer1 : ExampleInterface {
private:
    var to_be_erased i32 = 3;
public:    
    var only_on_impl1 = 0;
}

class Implementer2 : ExampleInterface {
private:
    var to_be_erased f32 = 3;
}

fn Implementer1.eraseAll() void
{
    this.to_be_erased = 0;
}

fn Implementer1.identify_myself() void
{
    sio.print(""\nI'm the terrible int eraser !!\n"");
}

fn Implementer2.eraseAll() void
{
    this.to_be_erased = 0;
}

fn Implementer2.identify_myself() void
{
    sio.print(""\nI'm the terrible float eraser !!\n"");
}

fn interface_casting() i32
{
    // upcasting is automatic (es: *Implementer1 to *ExampleInterface)
    var concrete Implementer1;
    var if_ptr *ExampleInterface = &concrete; 

    // you can access interface members with (guess what ?) '.'
    if_ptr.identify_myself();

    // downcasting requires a special construct 
    // (see also below the conditional structures)
    typeswitch(ref = if_ptr) {  
        case *Implementer1: return(ref.only_on_impl1);
        case *Implementer2: {}
        default: return(0);
    }

    return(1);
}

// All the loop types
fn loops() void
{
    // while: the condition must be strictly of boolean type
    var idx = 0;
    while (idx < 10) {
        ++idx;
    }

    // for in an integer range. The last value is excluded
    // 'it' is local to the loop and must not be previously declared
    for (it in 0 : 10) {
    }

    // reverse direction
    for (it in 10 : 0) {
    }

    // configurable step. The loop stops when it's >= the final value
    for (it in 0 : 100 step 3) {
    }

    // with an auxiliary counter. 
    // The counter start always at 0 and increments by one at each iteration
    for (counter, it in 3450 : 100 step -22) {
    } 

    // value assumes in turn all the values from array
    var array [*]i32 = {0, 10, 100, 1000};
    for (value in array) {
    }

    // as before with auxiliary counter
    for (counter, value in array) {
    }
}

// All the conditional structures
interface intface {}
class c0_test : intface {public: fn c0stuff() void;}
class delegating : intface {}

fn conditionals(in object intface, in objptr *intface) void
{
    let condition1 = true;
    let condition2 = true;
    let condition3 = true;
    var value = 30;

    // condition1 must be a boolean.
    if (condition1) {
        ++value;    // conditioned statement
    } 

    // you can chain conditions with else if
    if (condition1) {
        ++value;
    } else if (condition2) {
        --value;
    } 

    // a final else runs if any other condition is false
    if (condition1) {
        ++value;
    } else if (condition2) {
        --value;
    } else {
        value = 0;
    }

    // based on the switch value selects a case statement
    switch (value) {
        case 0: sio.print(""value is zero""); // a single statement !
        case 1: {}                          // do nothing
        case 2:                             // falls through
        case 3: sio.print(""value is more than one"");
        case 4: {                           // a block is a single statement !
            value = 0;
            sio.print(""how big !!"");
        }
        default: return;                    // if no one else matches
    }

    // similar to a switch but selects a case based on argument type.
    // - object must be a function argument of type interface.
    // - the case types must be classes implementing the object interface.
    // - in each case statement, ref assumes the class type of that case.
    typeswitch(ref = object) {
        case c0_test: ref.c0stuff();
        case delegating: {}
        default: return;
    }

    // - object must be an interface pointer.
    // - the case types must be pointers to classes implementing the objptr interface.
    // - in each case statement, ref assumes the class pointer type of that case.
    typeswitch(ref = objptr) {
        case *c0_test: {
            ref.c0stuff();
            return;
        }
        case *delegating: {}
        default: sio.print(""unknown pointer type !!"");
    } 
}
```

## Further Reading

[official Sing web site](https://mdegirolami.wixsite.com/singlang).

If you want to play with sing you are recommended to download the vscode plugin. Please
follow the instructions at [Getting Started](https://mdegirolami.wixsite.com/singlang/copy-of-interfacing-sing-and-c-2)"
"Scala - the scalable language

```scala

/////////////////////////////////////////////////
// 0. Basics
/////////////////////////////////////////////////
/*
  Setup Scala:

  1) Download Scala - http://www.scala-lang.org/downloads
  2) Unzip/untar to your favorite location and put the bin subdir in your `PATH` environment variable
*/

/*
  Try the REPL

  Scala has a tool called the REPL (Read-Eval-Print Loop) that is analogous to
  commandline interpreters in many other languages. You may type any Scala
  expression, and the result will be evaluated and printed.  

  The REPL is a very handy tool to test and verify code.  Use it as you read
  this tutorial to quickly explore concepts on your own.
*/

// Start a Scala REPL by running `scala`. You should see the prompt:
$ scala
scala>

// By default each expression you type is saved as a new numbered value
scala> 2 + 2
res0: Int = 4

// Default values can be reused.  Note the value type displayed in the result..
scala> res0 + 2
res1: Int = 6

// Scala is a strongly typed language. You can use the REPL to check the type
// without evaluating an expression.
scala> :type (true, 2.0)
(Boolean, Double)

// REPL sessions can be saved
scala> :save /sites/repl-test.scala

// Files can be loaded into the REPL
scala> :load /sites/repl-test.scala
Loading /sites/repl-test.scala...
res2: Int = 4
res3: Int = 6

// You can search your recent history
scala> :h?
1 2 + 2
2 res0 + 2
3 :save /sites/repl-test.scala
4 :load /sites/repl-test.scala
5 :h?

// Now that you know how to play, let's learn a little scala...

/////////////////////////////////////////////////
// 1. Basics
/////////////////////////////////////////////////

// Single-line comments start with two forward slashes

/*
  Multi-line comments, as you can already see from above, look like this.
*/

// Printing, and forcing a new line on the next print
println(""Hello world!"")
println(10)
// Hello world!
// 10

// Printing, without forcing a new line on next print
print(""Hello world"")
print(10)
// Hello world10

// Declaring values is done using either var or val.
// val declarations are immutable, whereas vars are mutable. Immutability is
// a good thing.
val x = 10 // x is now 10
x = 20     // error: reassignment to val
var y = 10
y = 20     // y is now 20

/*
  Scala is a statically typed language, yet note that in the above declarations,
  we did not specify a type. This is due to a language feature called type
  inference. In most cases, Scala compiler can guess what the type of a variable
  is, so you don't have to type it every time. We can explicitly declare the
  type of a variable like so:
*/
val z: Int = 10
val a: Double = 1.0

// Notice automatic conversion from Int to Double, result is 10.0, not 10
val b: Double = 10

// Boolean values
true
false

// Boolean operations
!true         // false
!false        // true
true == false // false
10 > 5        // true

// Math is as per usual
1 + 1   // 2
2 - 1   // 1
5 * 3   // 15
6 / 2   // 3
6 / 4   // 1
6.0 / 4 // 1.5
6 / 4.0 // 1.5


// Evaluating an expression in the REPL gives you the type and value of the result

1 + 7

/* The above line results in:

  scala> 1 + 7
  res29: Int = 8

  This means the result of evaluating 1 + 7 is an object of type Int with a
  value of 8

  Note that ""res29"" is a sequentially generated variable name to store the
  results of the expressions you typed, your output may differ.
*/

""Scala strings are surrounded by double quotes""
'a' // A Scala Char
// 'Single quote strings don't exist' <= This causes an error

// Strings have the usual Java methods defined on them
""hello world"".length
""hello world"".substring(2, 6)
""hello world"".replace(""C"", ""3"")

// They also have some extra Scala methods. See also: scala.collection.immutable.StringOps
""hello world"".take(5)
""hello world"".drop(5)

// String interpolation: notice the prefix ""s""
val n = 45
s""We have $n apples"" // => ""We have 45 apples""

// Expressions inside interpolated strings are also possible
val a = Array(11, 9, 6)
s""My second daughter is ${a(0) - a(2)} years old.""    // => ""My second daughter is 5 years old.""
s""We have double the amount of ${n / 2.0} in apples."" // => ""We have double the amount of 22.5 in apples.""
s""Power of 2: ${math.pow(2, 2)}""                      // => ""Power of 2: 4""

// Formatting with interpolated strings with the prefix ""f""
f""Power of 5: ${math.pow(5, 2)}%1.0f""         // ""Power of 5: 25""
f""Square root of 122: ${math.sqrt(122)}%1.4f"" // ""Square root of 122: 11.0454""

// Raw strings, ignoring special characters.
raw""New line feed: \n. Carriage return: \r."" // => ""New line feed: \n. Carriage return: \r.""

// Some characters need to be ""escaped"", e.g. a double quote inside a string:
""They stood outside the \""Rose and Crown\"""" // => ""They stood outside the ""Rose and Crown""""

// Triple double-quotes let strings span multiple rows and contain quotes
val html = """"""<form id=""daform"">
                <p>Press belo', Joe</p>
                <input type=""submit"">
              </form>""""""


/////////////////////////////////////////////////
// 2. Functions
/////////////////////////////////////////////////

// Functions are defined like so:
//
//   def functionName(args...): ReturnType = { body... }
//
// If you come from more traditional languages, notice the omission of the
// return keyword. In Scala, the last expression in the function block is the
// return value.
def sumOfSquares(x: Int, y: Int): Int = {
  val x2 = x * x
  val y2 = y * y
  x2 + y2
}

// The { } can be omitted if the function body is a single expression:
def sumOfSquaresShort(x: Int, y: Int): Int = x * x + y * y

// Syntax for calling functions is familiar:
sumOfSquares(3, 4)  // => 25

// You can use parameters names to specify them in different order
def subtract(x: Int, y: Int): Int = x - y

subtract(10, 3)     // => 7
subtract(y=10, x=3) // => -7

// In most cases (with recursive functions the most notable exception), function
// return type can be omitted, and the same type inference we saw with variables
// will work with function return values:
def sq(x: Int) = x * x  // Compiler can guess return type is Int

// Functions can have default parameters:
def addWithDefault(x: Int, y: Int = 5) = x + y
addWithDefault(1, 2) // => 3
addWithDefault(1)    // => 6


// Anonymous functions look like this:
(x: Int) => x * x

// Unlike defs, even the input type of anonymous functions can be omitted if the
// context makes it clear. Notice the type ""Int => Int"" which means a function
// that takes Int and returns Int.
val sq: Int => Int = x => x * x

// Anonymous functions can be called as usual:
sq(10)   // => 100

// If each argument in your anonymous function is
// used only once, Scala gives you an even shorter way to define them. These
// anonymous functions turn out to be extremely common, as will be obvious in
// the data structure section.
val addOne: Int => Int = _ + 1
val weirdSum: (Int, Int) => Int = (_ * 2 + _ * 3)

addOne(5)      // => 6
weirdSum(2, 4) // => 16


// The return keyword exists in Scala, but it only returns from the inner-most
// def that surrounds it.
// WARNING: Using return in Scala is error-prone and should be avoided.
// It has no effect on anonymous functions. For example here you may expect foo(7) should return 17 but it returns 7:
def foo(x: Int): Int = {
  val anonFunc: Int => Int = { z =>
    if (z > 5)
      return z // This line makes z the return value of foo!
    else
      z + 2    // This line is the return value of anonFunc
  }
  anonFunc(x) + 10  // This line is the return value of foo
}

foo(7) // => 7

/////////////////////////////////////////////////
// 3. Flow Control
/////////////////////////////////////////////////

1 to 5
val r = 1 to 5
r.foreach(println)

r foreach println
// NB: Scala is quite lenient when it comes to dots and brackets - study the
// rules separately. This helps write DSLs and APIs that read like English

// Why doesn't `println` need any parameters here?
// Stay tuned for first-class functions in the Functional Programming section below!
(5 to 1 by -1) foreach (println)

// A while loop
var i = 0
while (i < 10) { println(""i "" + i); i += 1 }

while (i < 10) { println(""i "" + i); i += 1 }   // Yes, again. What happened? Why?

i    // Show the value of i. Note that while is a loop in the classical sense -
     // it executes sequentially while changing the loop variable. while is very
     // fast, but using the combinators and comprehensions above is easier
     // to understand and parallelize

// A do-while loop
i = 0
do {
  println(""i is still less than 10"")
  i += 1
} while (i < 10)

// Recursion is the idiomatic way of repeating an action in Scala (as in most
// other functional languages).
// Recursive functions need an explicit return type, the compiler can't infer it.
// Here it's Unit, which is analogous to a `void` return type in Java
def showNumbersInRange(a: Int, b: Int): Unit = {
  print(a)
  if (a < b)
    showNumbersInRange(a + 1, b)
}
showNumbersInRange(1, 14)


// Conditionals

val x = 10

if (x == 1) println(""yeah"")
if (x == 10) println(""yeah"")
if (x == 11) println(""yeah"")
if (x == 11) println(""yeah"") else println(""nay"")

println(if (x == 10) ""yeah"" else ""nope"")
val text = if (x == 10) ""yeah"" else ""nope""


/////////////////////////////////////////////////
// 4. Data Structures
/////////////////////////////////////////////////

val a = Array(1, 2, 3, 5, 8, 13)
a(0)     // Int = 1
a(3)     // Int = 5
a(21)    // Throws an exception

val m = Map(""fork"" -> ""tenedor"", ""spoon"" -> ""cuchara"", ""knife"" -> ""cuchillo"")
m(""fork"")         // java.lang.String = tenedor
m(""spoon"")        // java.lang.String = cuchara
m(""bottle"")       // Throws an exception

val safeM = m.withDefaultValue(""no lo se"")
safeM(""bottle"")   // java.lang.String = no lo se

val s = Set(1, 3, 7)
s(0)      // Boolean = false
s(1)      // Boolean = true

/* Look up the documentation of map here -
 * https://www.scala-lang.org/api/current/scala/collection/immutable/Map.html
 * and make sure you can read it
 */


// Tuples

(1, 2)

(4, 3, 2)

(1, 2, ""three"")

(a, 2, ""three"")

// Why have this?
val divideInts = (x: Int, y: Int) => (x / y, x % y)

// The function divideInts gives you the result and the remainder
divideInts(10, 3)    // (Int, Int) = (3,1)

// To access the elements of a tuple, use _._n where n is the 1-based index of
// the element
val d = divideInts(10, 3)    // (Int, Int) = (3,1)

d._1    // Int = 3
d._2    // Int = 1

// Alternatively you can do multiple-variable assignment to tuple, which is more
// convenient and readable in many cases
val (div, mod) = divideInts(10, 3)

div     // Int = 3
mod     // Int = 1


/////////////////////////////////////////////////
// 5. Object Oriented Programming
/////////////////////////////////////////////////

/*
  Aside: Everything we've done so far in this tutorial has been simple
  expressions (values, functions, etc). These expressions are fine to type into
  the command-line interpreter for quick tests, but they cannot exist by
  themselves in a Scala file. For example, you cannot have just ""val x = 5"" in
  a Scala file. Instead, the only top-level constructs allowed in Scala are:

  - objects
  - classes
  - case classes
  - traits

  And now we will explain what these are.
*/

// classes are similar to classes in other languages. Constructor arguments are
// declared after the class name, and initialization is done in the class body.
class Dog(br: String) {
  // Constructor code here
  var breed: String = br

  // Define a method called bark, returning a String
  def bark = ""Woof, woof!""

  // Values and methods are assumed public. ""protected"" and ""private"" keywords
  // are also available.
  private def sleep(hours: Int) =
    println(s""I'm sleeping for $hours hours"")

  // Abstract methods are simply methods with no body. If we uncomment the
  // def line below, class Dog would need to be declared abstract like so:
  //   abstract class Dog(...) { ... }
  // def chaseAfter(what: String): String
}

val mydog = new Dog(""greyhound"")
println(mydog.breed) // => ""greyhound""
println(mydog.bark)  // => ""Woof, woof!""


// The ""object"" keyword creates a type AND a singleton instance of it. It is
// common for Scala classes to have a ""companion object"", where the per-instance
// behavior is captured in the classes themselves, but behavior related to all
// instance of that class go in objects. The difference is similar to class
// methods vs static methods in other languages. Note that objects and classes
// can have the same name.
object Dog {
  def allKnownBreeds = List(""pitbull"", ""shepherd"", ""retriever"")
  def createDog(breed: String) = new Dog(breed)
}


// Case classes are classes that have extra functionality built in. A common
// question for Scala beginners is when to use classes and when to use case
// classes. The line is quite fuzzy, but in general, classes tend to focus on
// encapsulation, polymorphism, and behavior. The values in these classes tend
// to be private, and only methods are exposed. The primary purpose of case
// classes is to hold immutable data. They often have few methods, and the
// methods rarely have side-effects.
case class Person(name: String, phoneNumber: String)

// Create a new instance. Note cases classes don't need ""new""
val george = Person(""George"", ""1234"")
val kate = Person(""Kate"", ""4567"")

// With case classes, you get a few perks for free, like getters:
george.phoneNumber  // => ""1234""

// Per field equality (no need to override .equals)
Person(""George"", ""1234"") == Person(""Kate"", ""1236"")  // => false

// Easy way to copy
// otherGeorge == Person(""George"", ""9876"")
val otherGeorge = george.copy(phoneNumber = ""9876"")

// And many others. Case classes also get pattern matching for free, see below.

// Traits
// Similar to Java interfaces, traits define an object type and method
// signatures. Scala allows partial implementation of those methods.
// Constructor parameters are not allowed. Traits can inherit from other
// traits or classes without parameters.

trait Dog {
	def breed: String
	def color: String
	def bark: Boolean = true
	def bite: Boolean
}
class SaintBernard extends Dog {
	val breed = ""Saint Bernard""
	val color = ""brown""
	def bite = false
}  

scala> val b = new SaintBernard
res0: SaintBernard = SaintBernard@3e57cd70  
scala> b.breed  
res1: String = Saint Bernard  
scala> b.bark  
res2: Boolean = true  
scala> b.bite  
res3: Boolean = false  

// A trait can also be used as Mixin. The class ""extends"" the first trait,
// but the keyword ""with"" can add additional traits.

trait Bark {
	def bark: String = ""Woof""
}
trait Dog {
	def breed: String
	def color: String
}
class SaintBernard extends Dog with Bark {
	val breed = ""Saint Bernard""
	val color = ""brown""
}

scala> val b = new SaintBernard
b: SaintBernard = SaintBernard@7b69c6ba
scala> b.bark
res0: String = Woof


/////////////////////////////////////////////////
// 6. Pattern Matching
/////////////////////////////////////////////////

// Pattern matching is a powerful and commonly used feature in Scala. Here's how
// you pattern match a case class. NB: Unlike other languages, Scala cases do
// not need breaks, fall-through does not happen.

def matchPerson(person: Person): String = person match {
  // Then you specify the patterns:
  case Person(""George"", number) => ""We found George! His number is "" + number
  case Person(""Kate"", number)   => ""We found Kate! Her number is "" + number
  case Person(name, number)     => ""We matched someone : "" + name + "", phone : "" + number
}

// Regular expressions are also built in.
// Create a regex with the `r` method on a string:
val email = ""(.*)@(.*)"".r

// Pattern matching might look familiar to the switch statements in the C family
// of languages, but this is much more powerful. In Scala, you can match much
// more:
def matchEverything(obj: Any): String = obj match {
  // You can match values:
  case ""Hello world"" => ""Got the string Hello world""

  // You can match by type:
  case x: Double => ""Got a Double: "" + x

  // You can specify conditions:
  case x: Int if x > 10000 => ""Got a pretty big number!""

  // You can match case classes as before:
  case Person(name, number) => s""Got contact info for $name!""

  // You can match regular expressions:
  case email(name, domain) => s""Got email address $name@$domain""

  // You can match tuples:
  case (a: Int, b: Double, c: String) => s""Got a tuple: $a, $b, $c""

  // You can match data structures:
  case List(1, b, c) => s""Got a list with three elements and starts with 1: 1, $b, $c""

  // You can nest patterns:
  case List(List((1, 2, ""YAY""))) => ""Got a list of list of tuple""

  // Match any case (default) if all previous haven't matched
  case _ => ""Got unknown object""
}

// In fact, you can pattern match any object with an ""unapply"" method. This
// feature is so powerful that Scala lets you define whole functions as
// patterns:
val patternFunc: Person => String = {
  case Person(""George"", number) => s""George's number: $number""
  case Person(name, number) => s""Random person's number: $number""
}


/////////////////////////////////////////////////
// 7. Functional Programming
/////////////////////////////////////////////////

// Scala allows methods and functions to return, or take as parameters, other
// functions or methods.

val add10: Int => Int = _ + 10 // A function taking an Int and returning an Int
List(1, 2, 3) map add10 // List(11, 12, 13) - add10 is applied to each element

// Anonymous functions can be used instead of named functions:
List(1, 2, 3) map (x => x + 10)

// And the underscore symbol, can be used if there is just one argument to the
// anonymous function. It gets bound as the variable
List(1, 2, 3) map (_ + 10)

// If the anonymous block AND the function you are applying both take one
// argument, you can even omit the underscore
List(""Dom"", ""Bob"", ""Natalia"") foreach println


// Combinators
// Using `s` from above:
// val s = Set(1, 3, 7)

s.map(sq)

val sSquared = s.map(sq)

sSquared.filter(_ < 10)

sSquared.reduce (_+_)

// The filter function takes a predicate (a function from A -> Boolean) and
// selects all elements which satisfy the predicate
List(1, 2, 3) filter (_ > 2) // List(3)
case class Person(name: String, age: Int)
List(
  Person(name = ""Dom"", age = 23),
  Person(name = ""Bob"", age = 30)
).filter(_.age > 25) // List(Person(""Bob"", 30))


// Certain collections (such as List) in Scala have a `foreach` method,
// which takes as an argument a type returning Unit - that is, a void method
val aListOfNumbers = List(1, 2, 3, 4, 10, 20, 100)
aListOfNumbers foreach (x => println(x))
aListOfNumbers foreach println

// For comprehensions

for { n <- s } yield sq(n)

val nSquared2 = for { n <- s } yield sq(n)

for { n <- nSquared2 if n < 10 } yield n

for { n <- s; nSquared = n * n if nSquared < 10} yield nSquared

/* NB Those were not for loops. The semantics of a for loop is 'repeat', whereas
   a for-comprehension defines a relationship between two sets of data. */


/////////////////////////////////////////////////
// 8. Implicits
/////////////////////////////////////////////////

/* WARNING WARNING: Implicits are a set of powerful features of Scala, and
 * therefore it is easy to abuse them. Beginners to Scala should resist the
 * temptation to use them until they understand not only how they work, but also
 * best practices around them. We only include this section in the tutorial
 * because they are so commonplace in Scala libraries that it is impossible to
 * do anything meaningful without using a library that has implicits. This is
 * meant for you to understand and work with implicits, not declare your own.
 */

// Any value (vals, functions, objects, etc) can be declared to be implicit by
// using the, you guessed it, ""implicit"" keyword. Note we are using the Dog
// class from section 5 in these examples.
implicit val myImplicitInt = 100
implicit def myImplicitFunction(breed: String) = new Dog(""Golden "" + breed)

// By itself, implicit keyword doesn't change the behavior of the value, so
// above values can be used as usual.
myImplicitInt + 2                   // => 102
myImplicitFunction(""Pitbull"").breed // => ""Golden Pitbull""

// The difference is that these values are now eligible to be used when another
// piece of code ""needs"" an implicit value. One such situation is implicit
// function arguments:
def sendGreetings(toWhom: String)(implicit howMany: Int) =
  s""Hello $toWhom, $howMany blessings to you and yours!""

// If we supply a value for ""howMany"", the function behaves as usual
sendGreetings(""John"")(1000)  // => ""Hello John, 1000 blessings to you and yours!""

// But if we omit the implicit parameter, an implicit value of the same type is
// used, in this case, ""myImplicitInt"":
sendGreetings(""Jane"")  // => ""Hello Jane, 100 blessings to you and yours!""

// Implicit function parameters enable us to simulate type classes in other
// functional languages. It is so often used that it gets its own shorthand. The
// following two lines mean the same thing:
// def foo[T](implicit c: C[T]) = ...
// def foo[T : C] = ...


// Another situation in which the compiler looks for an implicit is if you have
//   obj.method(...)
// but ""obj"" doesn't have ""method"" as a method. In this case, if there is an
// implicit conversion of type A => B, where A is the type of obj, and B has a
// method called ""method"", that conversion is applied. So having
// myImplicitFunction above in scope, we can say:
""Retriever"".breed // => ""Golden Retriever""
""Sheperd"".bark    // => ""Woof, woof!""

// Here the String is first converted to Dog using our function above, and then
// the appropriate method is called. This is an extremely powerful feature, but
// again, it is not to be used lightly. In fact, when you defined the implicit
// function above, your compiler should have given you a warning, that you
// shouldn't do this unless you really know what you're doing.


/////////////////////////////////////////////////
// 9. Misc
/////////////////////////////////////////////////

// Importing things
import scala.collection.immutable.List

// Import all ""sub packages""
import scala.collection.immutable._

// Import multiple classes in one statement
import scala.collection.immutable.{List, Map}

// Rename an import using '=>'
import scala.collection.immutable.{List => ImmutableList}

// Import all classes, except some. The following excludes Map and Set:
import scala.collection.immutable.{Map => _, Set => _, _}

// Java classes can also be imported. Scala syntax can be used
import java.swing.{JFrame, JWindow}

// Your program's entry point is defined in a scala file using an object, with a
// single method, main:
object Application {
  def main(args: Array[String]): Unit = {
    // stuff goes here.
  }
}

// Files can contain multiple classes and objects. Compile with scalac




// Input and output

// To read a file line by line
import scala.io.Source
for(line <- Source.fromFile(""myfile.txt"").getLines())
  println(line)

// To write a file use Java's PrintWriter
val writer = new PrintWriter(""myfile.txt"")
writer.write(""Writing line for line"" + util.Properties.lineSeparator)
writer.write(""Another line here"" + util.Properties.lineSeparator)
writer.close()

```

## Further resources

* [Scala for the impatient](http://horstmann.com/scala/)
* [Twitter Scala school](http://twitter.github.io/scala_school/)
* [The scala documentation](http://docs.scala-lang.org/)
* [Try Scala in your browser](http://scalatutorials.com/tour/)
* Join the [Scala user group](https://groups.google.com/forum/#!forum/scala-user)"
"```vim
"" ##############
""  Introduction
"" ##############
""
"" Vim script (also called VimL) is the subset of Vim's ex-commands which
"" supplies a number of features one would expect from a scripting language,
"" such as values, variables, functions or loops. Always keep in the back of
"" your mind that a Vim script file is just a sequence of ex-commands. It is
"" very common for a script to mix programming-language features and raw
"" ex-commands.
""
"" You can run Vim script directly by entering the commands in command-line mode
"" (press `:` to enter command-line mode), or you can write them to a file
"" (without the leading `:`) and source it in a running Vim instance (`:source
"" path/to/file`). Some files are sourced automatically as part of your
"" configuration (see |startup|). This guide assumes that you are familiar
"" with ex-commands and will only cover the scripting. Help topics to the
"" relevant manual sections are included.
""
"" See |usr_41.txt| for the official introduction to Vim script. A comment is
"" anything following an unmatched `""` until the end of the line, and `|`
"" separates instructions (what `;` does in most other languages). References to
"" the manual as surrounded with `|`, such as |help.txt|.

"" This is a comment

"" The vertical line '|' (pipe) separates commands
echo 'Hello' | echo 'world!'

"" Putting a comment after a command usually works
pwd                   "" Displays the current working directory

"" Except for some commands it does not; use the command delimiter before the
"" comment (echo assumes that the quotation mark begins a string)
echo 'Hello world!'  | "" Displays a message

"" Line breaks can be escaped by placing a backslash as the first non-whitespace
"" character on the *following* line. Only works in script files, not on the
"" command line
echo "" Hello
    \ world ""

echo [1, 
    \ 2]

echo {
    \ 'a': 1,
    \ 'b': 2
\}


"" #######
""  Types
"" #######
""
"" For an overview of types see |E712|. For an overview of operators see
"" |expression-syntax|

"" Numbers (|expr-number|)
"" #######

echo  123         | "" Decimal
echo  0b1111011   | "" Binary
echo  0173        | "" Octal
echo  0x7B        | "" Hexadecimal
echo  123.0       | "" Floating-point
echo  1.23e2      | "" Floating-point (scientific notation)

"" Note that an *integer* number with a leading `0` is in octal notation. The
"" usual arithmetic operations are supported.

echo  1 + 2       | "" Addition
echo  1 - 2       | "" Subtraction
echo  - 1         | "" Negation (unary minus)
echo  + 1         | "" Unary plus (does nothing really, but still legal)
echo  1 * 2       | "" Multiplication
echo  1 / 2       | "" Division
echo  1 % 2       | "" Modulo (remainder)

"" Booleans (|Boolean|)
"" ########
""
"" The number 0 is false, every other number is true. Strings are implicitly
"" converted to numbers (see below). There are two pre-defined semantic
"" constants.

echo  v:true      | "" Evaluates to 1 or the string 'v:true'
echo  v:false     | "" Evaluates to 0 or the string 'v:false'

"" Boolean values can result from comparison of two objects.

echo  x == y             | "" Equality by value
echo  x != y             | "" Inequality
echo  x >  y             | "" Greater than
echo  x >= y             | "" Greater than or equal
echo  x <  y             | "" Smaller than
echo  x <= y             | "" Smaller than or equal
echo  x is y             | "" Instance identity (lists and dictionaries)
echo  x isnot y          | "" Instance non-identity (lists and dictionaries)

"" Strings are compared based on their alphanumerical ordering
"" echo 'a' < 'b'. Case sensitivity depends on the setting of 'ignorecase'
""
"" Explicit case-sensitivity is specified by appending '#' (match case) or '?'
"" (ignore case) to the operator. Prefer explicitly case sensitivity when writing
"" portable scripts.

echo  'a' <  'B'         | "" True or false depending on 'ignorecase'
echo  'a' <? 'B'         | "" True
echo  'a' <# 'B'         | "" False

"" Regular expression matching
echo  ""hi"" =~  ""hello""    | "" Regular expression match, uses 'ignorecase'
echo  ""hi"" =~# ""hello""    | "" Regular expression match, case sensitive
echo  ""hi"" =~? ""hello""    | "" Regular expression match, case insensitive
echo  ""hi"" !~  ""hello""    | "" Regular expression unmatch, use 'ignorecase'
echo  ""hi"" !~# ""hello""    | "" Regular expression unmatch, case sensitive
echo  ""hi"" !~? ""hello""    | "" Regular expression unmatch, case insensitive

"" Boolean operations are possible.

echo  v:true && v:false       | "" Logical AND
echo  v:true || v:false       | "" Logical OR
echo  ! v:true                | "" Logical NOT
echo  v:true ? 'yes' : 'no'   | "" Ternary operator


"" Strings (|String|)
"" #######
""
"" An ordered zero-indexed sequence of bytes. The encoding of text into bytes
"" depends on the option |'encoding'|.

"" Literal constructors
echo  ""Hello world\n""   | "" The last two characters stand for newline
echo  'Hello world\n'   | "" The last two characters are literal
echo  'Let''s go!'      | "" Two single quotes become one quote character

"" Single-quote strings take all characters are literal, except two single
"" quotes, which are taken to be a single quote in the string itself. See 
"" |expr-quote| for all possible escape sequences.

"" String concatenation
"" The .. operator is preferred, but only supported in since Vim 8.1.1114
echo  'Hello ' .  'world'  | "" String concatenation
echo  'Hello ' .. 'world'  | "" String concatenation (new variant)

"" String indexing
echo  'Hello'[0]           | "" First byte
echo  'Hello'[1]           | "" Second byte
echo  'Hellö'[4]           | "" Returns a byte, not the character 'ö'

"" Substrings (second index is inclusive)
echo  'Hello'[:]           | "" Copy of entire string
echo  'Hello'[1:3]         | "" Substring, second to fourth byte
echo  'Hello'[1:-2]        | "" Substring until second to last byte
echo  'Hello'[1:]          | "" Substring with starting index
echo  'Hello'[:2]          | "" Substring with ending index
echo  'Hello'[-2:]         | "" Substring relative to end of string

"" A negative index is relative to the end of the string. See
"" |string-functions| for all string-related functions.

"" Lists (|List|)
"" #####
""
"" An ordered zero-indexed heterogeneous sequence of arbitrary Vim script
"" objects.

"" Literal constructor
echo  []                   | "" Empty list
echo  [1, 2, 'Hello']      | "" List with elements
echo  [1, 2, 'Hello', ]    | "" Trailing comma permitted
echo  [[1, 2], 'Hello']    | "" Lists can be nested arbitrarily

"" List concatenation
echo  [1, 2] + [3, 4]      | "" Creates a new list

"" List indexing, negative is relative to end of list (|list-index|)
echo  [1, 2, 3, 4][2]      | "" Third element
echo  [1, 2, 3, 4][-1]     | "" Last element

"" List slicing (|sublist|)
echo  [1, 2, 3, 4][:]      | "" Shallow copy of entire list
echo  [1, 2, 3, 4][:2]     | "" Sublist until third item (inclusive)
echo  [1, 2, 3, 4][2:]     | "" Sublist from third item (inclusive)
echo  [1, 2, 3, 4][:-2]    | "" Sublist until second-to-last item (inclusive)

"" All slicing operations create new lists. To modify a list in-place use list
"" functions (|list-functions|) or assign directly to an item (see below about
"" variables).


"" Dictionaries (|Dictionary|)
"" ############
""
"" An unordered sequence of key-value pairs, keys are always strings (numbers
"" are implicitly converted to strings).

"" Dictionary literal
echo  {}                       | "" Empty dictionary
echo  {'a': 1, 'b': 2}         | "" Dictionary literal
echo  {'a': 1, 'b': 2, }       | "" Trailing comma permitted
echo  {'x': {'a': 1, 'b': 2}}  | "" Nested dictionary

"" Indexing a dictionary
echo  {'a': 1, 'b': 2}['a']    | "" Literal index
echo  {'a': 1, 'b': 2}.a       | "" Syntactic sugar for simple keys

"" See |dict-functions| for dictionary manipulation functions.


"" Funcref (|Funcref|)
"" #######
""
"" Reference to a function, uses the function name as a string for construction.
"" When stored in a variable the name of the variable has the same restrictions
"" as a function name (see below).

echo  function('type')                   | "" Reference to function type()
"" Note that `funcref('type')` will throw an error because the argument must be
"" a user-defined function; see further below for defining your own functions.
echo  funcref('type')                    | "" Reference by identity, not name
"" A lambda (|lambda|) is an anonymous function; it can only contain one
"" expression in its body, which is also its implicit return value.
echo  {x -> x * x}                       | "" Anonymous function
echo  function('substitute', ['hello'])  | "" Partial function


"" Regular expression (|regular-expression|)
"" ##################
""
"" A regular expression pattern is generally a string, but in some cases you can
"" also use a regular expression between a pair of delimiters (usually `/`, but
"" you can choose anything).

"" Substitute 'hello' for 'Hello'
substitute/hello/Hello/


"" ###########################
""  Implicit type conversions
"" ###########################
""
"" Strings are converted to numbers, and numbers to strings when necessary. A
"" number becomes its decimal notation as a string. A string becomes its
"" numerical value if it can be parsed to a number, otherwise it becomes zero.

echo  ""1"" + 1         | "" Number
echo  ""1"" .. 1        | "" String
echo  ""0xA"" + 1       | "" Number

"" Strings are treated like numbers when used as booleans
echo ""true"" ? 1 : 0   | "" This string is parsed to 0, which is false

"" ###########
""  Variables
"" ###########
"" 
"" Variables are bound within a scope; if no scope is provided a default is
"" chosen by Vim. Use `:let` and `:const` to bind a value and `:unlet` to unbind
"" it.

let b:my_var = 1        | "" Local to current buffer
let w:my_var = 1        | "" Local to current window
let t:my_var = 1        | "" Local to current tab page
let g:my_var = 1        | "" Global variable
let l:my_var = 1        | "" Local to current function (see functions below)
let s:my_var = 1        | "" Local to current script file
let a:my_arg = 1        | "" Function argument (see functions below)

"" The Vim scope is read-only
echo  v:true            | "" Special built-in Vim variables (|v:var|)

"" Access special Vim memory like variables
let @a = 'Hello'        | "" Register
let $PATH=''            | "" Environment variable
let &textwidth = 79     | "" Option
let &l:textwidth = 79   | "" Local option
let &g:textwidth = 79   | "" Global option

"" Access scopes as dictionaries (can be modified like all dictionaries)
"" See the |dict-functions|, especially |get()|, for access and manipulation
echo  b:                | "" All buffer variables
echo  w:                | "" All window variables
echo  t:                | "" All tab page variables
echo  g:                | "" All global variables
echo  l:                | "" All local variables
echo  s:                | "" All script variables
echo  a:                | "" All function arguments
echo  v:                | "" All Vim variables

"" Constant variables
const x = 10            | "" See |:const|, |:lockvar|

"" Function reference variables have the same restrictions as function names
let IsString = {x -> type(x) == type('')}    | "" Global: capital letter
let s:isNumber = {x -> type(x) == type(0)}   | "" Local: any name allowed

"" When omitted the scope `g:` is implied, except in functions, there `l:` is
"" implied.


"" Multiple value binding (list unpacking)
"" #######################################
""
"" Assign values of list to multiple variables (number of items must match)
let [x, y] = [1, 2]

"" Assign the remainder to a rest variable (note the semicolon)
let [mother, father; children] = ['Alice', 'Bob', 'Carol', 'Dennis', 'Emily']


"" ##############
""  Flow control
"" ##############

"" Conditional (|:if|, |:elseif|, |:else|, |:endif|)
"" ###########
"" 
"" Conditions are set between `if` and `endif`. They can be nested.

let condition = v:true

if condition
    echo 'First condition'
elseif another_condition
    echo 'Second condition'
else
    echo 'Fail'
endif

"" Loops (|:for|, |:endfor|, |:while|, |:endwhile|, |:break|, |:continue|)
"" #####
""
"" Two types of loops: `:for` and `:while`. Use `:continue` to skip to the next
"" iteration, `:break` to break out of the loop.

"" For-loop (|:for|, |:endfor|)
"" ========
""
"" For-loops iterate over lists and nothing else. If you want to iterate over
"" another sequence you need to use a function which will create a list.

"" Iterate over a list
for person in ['Alice', 'Bob', 'Carol', 'Dennis', 'Emily']
    echo 'Hello ' .. person
endfor

"" Iterate over a nested list by unpacking it
for [x, y] in [[1, 0], [0, 1], [-1, 0], [0, -1]]
    echo 'Position: x ='  .. x .. ', y = ' .. y
endfor

"" Iterate over a range of numbers
for i in range(10, 0, -1)  "" Count down from 10
    echo 'T minus'  .. i
endfor

"" Iterate over the keys of a dictionary
for symbol in keys({'π': 3.14, 'e': 2.71})
    echo 'The constant ' .. symbol .. ' is a transcendent number'
endfor

"" Iterate over the values of a dictionary
for value in values({'π': 3.14, 'e': 2.71})
    echo 'The value ' .. value .. ' approximates a transcendent number'
endfor

"" Iterate over the keys and values of a dictionary
for [symbol, value] in items({'π': 3.14, 'e': 2.71})
    echo 'The number ' .. symbol .. ' is approximately ' .. value
endfor

"" While-loops (|:while|, |:endwhile|)

let there_yet = v:true
while !there_yet
    echo 'Are we there yet?'
endwhile


"" Exception handling (|exception-handling|)
"" ##################
""
"" Throw new exceptions as strings, catch them by pattern-matching a regular
"" expression against the string

"" Throw new exception
throw ""Wrong arguments""

"" Guard against an exception (the second catch matches any exception)
try
    source path/to/file
catch /Cannot open/
    echo 'Looks like that file does not exist'
catch /.*/
    echo 'Something went wrong, but I do not know what'
finally
    echo 'I am done trying'
endtry


"" ##########
""  Functions
"" ##########

"" Defining functions (|:function|, |:endfunction|)
"" ##################

"" Unscoped function names have to start with a capital letter
function! AddNumbersLoudly(x, y)
    "" Use a: scope to access arguments
    echo 'Adding'  .. a:x ..  'and'  .. a:y   | "" A side effect
    return a:x + a:y                          | "" A return value
endfunction

"" Scoped function names may start with a lower-case letter
function! s:addNumbersLoudly(x, y)
    echo 'Adding'  .. a:x ..  'and'  .. a:y
    return a:x + a:y
endfunction

"" Without the exclamation mark it would be an error to re-define a function,
"" with the exclamation mark the new definition can replace the old one. Since
"" Vim script files can be reloaded several times over the course of a session
"" it is best to use the exclamation mark unless you really know what you are
"" doing.

"" Function definitions can have special qualifiers following the argument list.

"" Range functions define two implicit arguments, which will be set to the range
"" of the ex-command
function! FirstAndLastLine() range
    echo [a:firstline, a:lastline]
endfunction

"" Prints the first and last line that match a pattern (|cmdline-ranges|)
/^#!/,/!#$/call FirstAndLastLine()

"" Aborting functions, abort once error occurs (|:func-abort|)
function! SourceMyFile() abort
    source my-file.vim        | "" Try sourcing non-existing file
    echo 'This will never be printed'
endfunction

"" Closures, functions carrying values from outer scope (|:func-closure|)
function! MakeAdder(x)
    function! Adder(n) closure
        return a:n + a:x
    endfunction
    return funcref('Adder')
endfunction
let AddFive = MakeAdder(5)
echo AddFive(3)               | "" Prints 8

"" Dictionary functions, poor man's OOP methods (|Dictionary-function|)
function! Mylen() dict
    return len(self.data)     | "" Implicit variable self
endfunction
let mydict = {'data': [0, 1, 2, 3], 'len': function(""Mylen"")}
echo mydict.len()

"" Alternatively, more concise
let mydict = {'data': [0, 1, 2, 3]}
function! mydict.len()
    return len(self.data)
endfunction

"" Calling functions (|:call|)
"" #################

"" Call a function for its return value, and possibly for its side effects
let animals = keys({'cow': 'moo', 'dog': 'woof', 'cat': 'meow'})

"" Call a function for its side effects only, ignore potential return value
call sign_undefine()

"" The call() function calls a function reference and passes parameters as a
"" list, and returns the function's result.
echo  call(function('get'), [{'a': 1, 'b': 2}, 'c', 3])   | "" Prints 3

"" Recall that Vim script is embedded within the ex-commands, that is why we
"" cannot just call a function directly, we have to use the `:call` ex-command.

"" Function namespaces (|write-library-script|, |autoload|)
"" ###################

"" Must be defined in autoload/foo/bar.vim
"" Namspaced function names do not have to start with a capital letter
function! foo#bar#log(value)
    echomsg value
endfunction

call foo#bar#log('Hello')


"" #############################
""  Frequently used ex-commands
"" #############################


"" Sourcing runtime files (|'runtimepath'|)
"" ######################

"" Source first match among runtime paths
runtime plugin/my-plugin.vim


"" Defining new ex-commands (|40.2|, |:command|)
"" ########################

"" First argument here is the name of the command, rest is the command body
command! SwapAdjacentLines normal! ddp

"" The exclamation mark works the same as with `:function`. User-defined
"" commands must start with a capital letter. The `:command` command can take a
"" number of attributes (some of which have their own parameters with `=`), such
"" as `-nargs`, all of them start with a dash to set them apart from the command
"" name.

command! -nargs=1 Error echoerr <args>


"" Defining auto-commands (|40.3|, |autocmd|, |autocommand-events|)
"" ######################

"" The arguments are ""events"", ""patterns"", rest is ""commands""
autocmd BufWritePost $MYVIMRC source $MYVIMRC

"" Events and patterns are separated by commas with no space between. See
"" |autocmd-events| for standard events, |User| for custom events. Everything
"" else are the ex-commands which will be executed.

"" Auto groups
"" ===========
""
"" When a file is sourced multiple times the auto-commands are defined anew,
"" without deleting the old ones, causing auto-commands to pile up over time.
"" Use auto-groups and the following ritual to guard against this.

augroup auto-source   | "" The name of the group is arbitrary
    autocmd!          | "" Deletes all auto-commands in the current group
    autocmd BufWritePost $MYVIMRC source $MYVIMRC
augroup END           | "" Switch back to default auto-group

"" It is also possible to assign a group directly. This is useful if the
"" definition of the group is in one script and the definition of the
"" auto-command is in another script.

"" In one file
augroup auto-source
    autocmd!
augroup END

"" In another file
autocmd auto-source BufWritePost $MYVIMRC source $MYVIMRC

"" Executing (run-time macros of sorts)
"" ####################################

"" Sometimes we need to construct an ex-command where part of the command is not
"" known until runtime.

let line = 3                | "" Line number determined at runtime
execute line .. 'delete'    | "" Delete a line

"" Executing normal-mode commands
"" ##############################
""
"" Use `:normal` to play back a sequence of normal mode commands from the
"" command-line. Add an exclamation mark to ignore user mappings.

normal! ggddGp             | "" Transplant first line to end of buffer

"" Window commands can be used with :normal, or with :wincmd if :normal would
"" not work
wincmd L                   | "" Move current window all the way to the right


"" ###########################
""  Frequently used functions
"" ###########################

"" Feature check
echo  has('nvim')                  | "" Running Neovim
echo  has('python3')               | "" Support for Python 3 plugins
echo  has('unix')                  | "" Running on a Unix system
echo  has('win32')                 | "" Running on a Windows system


"" Test if something exists
echo  exists('&mouse')             | "" Option (exists only)
echo  exists('+mouse')             | "" Option (exists and works)
echo  exists('$HOSTNAME')          | "" Environment variable
echo  exists('*strftime')          | "" Built-in function
echo  exists('**s:MyFunc')         | "" User-defined function
echo  exists('bufcount')           | "" Variable (scope optional)
echo  exists('my_dict[""foo""]')     | "" Variable (dictionary entry)
echo  exists('my_dict[""foo""]')     | "" Variable (dictionary entry)
echo  exists(':Make')              | "" Command
echo  exists(""#CursorHold"")        | "" Auto-command defined for event
echo  exists(""#BufReadPre#*.gz"")   | "" Event and pattern
echo  exists(""#filetypeindent"")    | "" Auto-command group
echo  exists(""##ColorScheme"")      | "" Auto-command supported for event

"" Various dynamic values (see |expand()|)
echo  expand('%')                  | "" Current file name
echo  expand('<cword>')            | "" Current word under cursor
echo  expand('%:p')                | "" Modifier are possible

"" Type tests
"" There are unique constants defined for the following types. Older versions
"" of Vim lack the type variables, see the reference "" documentation for a
"" workaround
echo  type(my_var) == v:t_number      | "" Number
echo  type(my_var) == v:t_string      | "" String
echo  type(my_var) == v:t_func        | "" Funcref
echo  type(my_var) == v:t_list        | "" List
echo  type(my_var) == v:t_dict        | "" Dictionary
echo  type(my_var) == v:t_float       | "" Float
echo  type(my_var) == v:t_bool        | "" Explicit Boolean
"" For the null object should compare it against itself
echo  my_var is v:null

"" Format strings
echo  printf('%d in hexadecimal is %X', 123, 123)


"" #####################
""  Tricks of the trade
"" #####################

"" Source guard
"" ############

"" Prevent a file from being sourced multiple times; users can set the variable
"" in their configuration to prevent the plugin from loading at all.
if exists('g:loaded_my_plugin')
    finish
endif
let g:loaded_my_plugin = v:true

"" Default values
"" ##############

"" Get a default value: if the user defines a variable use it, otherwise use a
"" hard-coded default. Uses the fact that a scope is also a dictionary.
let s:greeting = get(g:, 'my_plugin_greeting', 'Hello')
```"
"## Introduction

Processing is a programming language for creation of digital arts and
multimedia content, allowing non-programmers to learn fundamentals of computer
programming in a visual context.

While the language is based on Java language, its syntax has been largely
influenced by both Java and Javascript syntaxes. [See more here](https://processing.org/reference/)

The language is statically typed, and also comes with its official IDE to
compile and run the scripts.

```
/* ---------
   Comments
   ---------
*/

// Single-line comment starts with //

/*
   Since Processing is based on Java,
   the syntax for its comments are the same as Java (as you may have noticed above)!
   Multi-line comments are wrapped as seen here.
*/

/* ---------------------------------------
   Writing and Running Processing Programs
   ---------------------------------------
*/

// In Processing, the program entry point is a function named setup() with a
// void return type.
// Note! The syntax looks strikingly similar to that of C++.
void setup() {
  // This prints out the classic output ""Hello World!"" to the console when run.
  println(""Hello World!""); // Another language with a semi-column trap, aint it?
}

// Normally, we put all the static codes inside the setup() method as the name
// suggest since it only runs once.
// It can range from setting the background colours, setting the canvas size.
background(color); // setting the background colour
size(width,height,[renderer]); // setting the canvas size with optional
// parameter defining renderer
// You will see more of them throughout this document.

// If you want to run the codes indefinitely, it has to be placed in draw()
// method.
// draw() must exist if you want the code to run continuously and obviously,
// there can only be one draw() method.
int i = 0;
void draw() {
  // This block of code loops forever until stopped
  print(i);
  i++; // Increment Operator!
}

// Now that we know how to write the working script and how to run it,
// we will proceed to explore what data types and collections are supported in
// Processing.

/* ------------------------
   Datatypes & collections
   ------------------------
*/

// According to Processing References, Processing supports 8 primitive
// datatypes as follows.

boolean booleanValue = true; // Boolean
byte byteValueOfA = 23; // Byte
char charValueOfA = 'A'; // Char
color colourValueOfWhiteM = color(255, 255, 255); // Colour (Specified using
// color() method)
color colourValueOfWhiteH = #FFFFFF; // Colour (Specified using hash value)
int intValue = 5; // Integer (Number without decimals)
long longValue = 2147483648L; // ""L"" is added to number to mark it as a long
float floatValue = 1.12345; // Float (32-bit floating-point numbers)
double doubleValue = 1.12345D; // Double (64-bit floating-point numbers)

// NOTE!
// Although datatypes ""long"" and ""double"" work in the language,
// processing functions do not use these datatypes, therefore
// they need to be converted into ""int"" and ""float"" datatypes respectively,
// using (int) and (float) syntax before passing into a function.

// There is a whole bunch of default composite datatypes available for use in
// Processing.
// Primarily, I will brief through the most commonly used ones to save time.

// String
// While char datatype uses '', String datatype uses """" - double quotes.
String sampleString = ""Hello, Processing!"";
// String can be constructed from an array of char datatypes as well. We will
// discuss array very soon.
char source = {'H', 'E', 'L', 'L', 'O'};
String stringFromSource = new String(source); // HELLO
// As in Java, strings can be concatenated using the ""+"" operator.
print(""Hello "" + ""World!""); // Hello World!

// Array
// Arrays in Processing can hold any datatypes including Objects themselves.
// Since arrays are similar to objects, they must be created with the keyword
// ""new"".
int[] intArray = new int[5];
int[] intArrayWithValues = {1, 2, 3}; // You can also populate with data.

// ArrayList
// Functions are similar to those of array; arraylists can hold any datatypes.
// The only difference is arraylists resize dynamically, as it is a form of
// resizable-array implementation of the Java ""List"" interface.
ArrayList<Integer> intArrayList = new ArrayList<Integer>();

// Object
// Since it is based on Java, Processing supports object-oriented programming.
// That means you can basically define any datatypes of your own and manipulate
// them to your needs.
// Of course, a class has to be defined before for the object you want.
// Format --> ClassName InstanceName
SomeRandomClass myObject // then instantiate later
//or
SomeRandomClass myObjectInstantiated = new SomeRandomClass();

// Processing comes up with more collections (eg. - Dictionaries and Lists) by
// default, for the simplicity sake, I will leave them out of discussion here.

/* ------------
   Maths
   ------------
*/

// Arithmetic
1 + 1 // 2
2 - 1 // 1
2 * 3 // 6
3 / 2 // 1
3.0 / 2 // 1.5
3.0 % 2 // 1.0

// Processing also comes with a set of functions that simplify mathematical
// operations.
float f = sq(3); // f = 9.0
float p = pow(3, 3); // p = 27.0
int a = abs(-13); // a = 13
int r1 = round(3.1); // r1 = 3
int r2 = round(3.7); // r2 = 4
float sr = sqrt(25); // sr = 5.0

// Vectors
// Processing provides an easy way to implement vectors in its environment
// using PVector class. It can describe a two or three dimensional vector and
// comes with a set of methods which are useful for matrices operations.
// You can find more information on PVector class and its functions here.
// (https://processing.org/reference/PVector.html)

// Trigonometry
// Processing also supports trigonometric operations by supplying a set of
// functions. sin(), cos(), tan(), asin(), acos(), atan() and also degrees()
// and radians() for convenient conversion.
// However, those functions take angle in radians as the parameter so it has
// to be converted beforehand.
float one = sin(PI/2); // one = 1.0
// As you may have noticed, there exists a set of constants for trigonometric
// uses;
// PI, HALF_PI, QUARTER_PI and so on...

/* -------------
   Control Flow
   -------------
*/

// Conditional Statements
// If Statements - The same syntax as if statements in Java.
if (author.getAppearance().equals(""hot"")) {
  print(""Narcissism at its best!"");
} else {
  // You can check for other conditions here.
  print(""Something is really wrong here!"");
}
// A shortcut for if-else statements can also be used.
int i = 3;
String value = (i > 5) ? ""Big"" : ""Small""; // ""Small""

// Switch-case structure can be used to check multiple conditions concisely.
// It is important to use the break statement. If the `break`-statement does 
// not exist the program executes all the following cases after a case was true.
int value = 2;
switch(value) {
  case 0:
    print(""Nought!""); // This does not get executed.
    break; // Jumps to the next statement
  case 1:
    print(""Getting there...""); // This again does not get executed.
    break;
  case 2:
    print(""Bravo!""); // This line gets executed.
    break;
  default:
    print(""Not found!""); // This line gets executed if our value was some other value.
    break;
}

// Iterative statements
// For Statements - Again, the same syntax as in Java
for(int i = 0; i < 5; i++){
  print(i); // prints from 0 to 4
}

// While Statements - Again, nothing new if you are familiar with Java syntax.
int j = 3;
while(j > 0) {
  print(j);
  j--; // This is important to prevent from the code running indefinitely.
}

// loop()| noLoop() | redraw() | exit()
// These are more of Processing-specific functions to configure program flow.
loop(); // allows the draw() method to run forever while
noLoop(); // only allows it to run once.
redraw(); // runs the draw() method once more.
exit(); // This stops the program. It is useful for programs with draw()
// running continuously.
```

## Drawing with Processing

Since you will have understood the basics of the language by now, we will now
look into the best part of Processing - DRAWING.

```
/* ------
   Shapes
   ------
*/

// 2D Shapes

// Point
point(x, y); // In 2D space
point(x, y, z); // In 3D space
// Draws a point in the coordinate space.

// Line
line(x1, y1, x2, y2); // In 2D space
line(x1, y1, z1, x2, y2, z2); // In 3D space
// Draws a line connecting two points defined by (x1, y1) and (x2, y2).

// Triangle
triangle(x1, y1, x2, y2, x3, y3);
// Draws a triangle connecting three points defined by coordinate parameters.

// Rectangle
rect(a, b, c, d, [r]); // With optional parameter defining the radius of all corners
rect(a, b, c, d, [tl, tr, br, bl]); // With optional set of parameters defining
// radius of each corner
// Draws a rectangle with {a, b} as a top left coordinate and c and d as width
// and height respectively.

// Quad
quad(x, y, x2, y2, x3, y3, x4, y4);
// Draws a quadrilateral with parameters defining coordinates of each corner
// point.

// Ellipse
ellipse(x, y, width, height);
// Draws an eclipse at point {x, y} with width and height specified.

// Arc
arc(x, y, width, height, start, stop, [mode]);
// While the first four parameters are self-explanatory,
// start and end defined the angles the arc starts and ends (in radians).
// Optional parameter [mode] defines the filling;
// PIE gives pie-like outline, CHORD gives the chord-like outline and OPEN is
// CHORD without strokes

// Curves
// Processing provides two implementation of curves; using curve() and bezier().
// Since I plan to keep this simple I wont be discussing any further details.
// However, if you want to implement it in your sketch, here are the references:
// (https://processing.org/reference/curve_.html)
// (https://processing.org/reference/bezier_.html)

// 3D Shapes

// 3D space can be configured by setting ""P3D"" to the renderer parameter in
// size() method.
size(width, height, P3D);
// In 3D space, you will have to translate to the particular coordinate to
// render the 3D shapes.

// Box
box(size);  // Cube with same length defined by size
box(w, h, d); // Box with width, height and depth separately defined

// Sphere
sphere(radius); // Its size is defined using the radius parameter
// Mechanism behind rendering spheres is implemented by tessellating triangles.
// That said, how much detail being rendered is controlled by function
// sphereDetail(res)
// More information here: (https://processing.org/reference/sphereDetail_.html)

// Irregular Shapes
// What if you wanted to draw something thats not made available by Processing
// functions?
// You can use beginShape(), endShape(), vertex(x,y) to define shapes by
// specifying each point. More information here:
// (https://processing.org/reference/beginShape_.html)
// You can also use custom made shapes using PShape class:
// (https://processing.org/reference/PShape.html)

/* ---------------
   Transformations
   ---------------
*/

// Transformations are particularly useful to keep track of the coordinate
// space and the vertices of the shapes you have drawn. Particularly;
// matrix stack methods; pushMatrix(), popMatrix() and translate(x,y)
pushMatrix(); // Saves the current coordinate system to the stack
// ... apply all the transformations here ...
popMatrix(); // Restores the saved coordinate system
// Using them, the coordinate system can be preserved and visualized without
// causing any conflicts.

// Translate
translate(x, y); // Translates to point{x, y} i.e. - setting origin to that point
translate(x, y, z); // 3D counterpart of the function

// Rotate
rotate(angle); // Rotate the amount specified by the angle parameter
// It has 3 3D counterparts to perform rotation, each for every dimension,
// namely: rotateX(angle), rotateY(angle), rotateZ(angle)

// Scale
scale(s); // Scale the coordinate system by either expanding or contracting it.

/* --------------------
   Styling and Textures
   --------------------
*/

// Colours
// As I have discussed earlier, the background colour can be configured using
// background() function. You can define a color object beforehand and then
// pass it to the function as an argument.
color c = color(255, 255, 255); // WHITE!
// By default, Processing uses RGB colour scheme but it can be configured to
// HSB using colorMode(). Read more here:
// (https://processing.org/reference/colorMode_.html)
background(c); // By now, the background colour should be white.
// You can use fill() function to select the colour for filling the shapes.
// It has to be configured before you start drawing shapes so the colours gets
// applied.
fill(color(0, 0, 0));
// If you just want to colour the outlines of the shapes then you can use
// stroke() function.
stroke(255, 255, 0, 200); // stroke colour set to yellow with transparency
// set to a lower value.

// Images
// Processing can render images and use them in several ways. Mostly stored as
// PImage datatype.
filter(shader); // Processing supports several filter functions for image manipulation.
texture(image); // PImage can be passed into arguments for texture-mapping the shapes.
```

If you want to take things further, there are more things Processing is powered
for. Rendering models, shaders and whatnot. There's too much to cover in a
short documentation, so I will leave them out here. Should you be interested,
please check out the references.

```
// Before we move on, I will touch a little bit more on how to import libraries
// so you can extend Processing functionality to another horizon.

/* -------
   Imports
   -------
*/

// The power of Processing can be further visualized when we import libraries
// and packages into our sketches.
// Import statement can be written as below at the top of the source code.
import processing.something.*;
```

## DTC?

Down To Code? Let's get our hands dirty!

Let us see an example from openprocessing to visualize how much Processing is
capable of within few lines of code.

Copy the code below into your Processing IDE and see the magic.

```
// Disclaimer: I did not write this program since I currently am occupied with
// internship and this sketch is adapted from openprocessing since it shows
// something cool with simple codes.
// Retrieved from: (https://www.openprocessing.org/sketch/559769)

float theta;
float a;
float col;
float num;

void setup() {
  size(600,600);
}

void draw() {
  background(#F2F2F2);
  translate(width/2, height/2);
  theta = map(sin(millis()/1000.0), -1, 1, 0, PI/6);

  float num=6;
  for (int i=0; i<num; i++) {
    a =350;
    rotate(TWO_PI/num);
    branch(a);
  }

}

void branch(float len) {
  col=map(len, 0, 90, 150, 255);
  fill(col, 0, 74);
  stroke (col, 0, 74);
  line(0, 0, 0, -len);
  ellipse(0, -len, 3, 3);
  len *= 0.7;

  if (len>30) {
    pushMatrix();
    translate(0, -30);
    rotate(theta);
    branch(len);
    popMatrix();

    pushMatrix();
    translate(0, -30);
    rotate(-theta);
    branch(len);
    popMatrix();

  }
}
```

Processing is easy to learn and is particularly useful to create multimedia
contents (even in 3D) without having to type a lot of codes. It is so simple
that you can read through the code and get a rough idea of the program flow.

However, that does not apply when you introduce external libraries, packages
and even your own classes. (Trust me! Processing projects can get real humongous...)

## Some useful resources

 - [Processing Website](http://processing.org)
 - [Processing Sketches](http://openprocessing.org)"
"Nix is a simple functional language developed for the
[Nix package manager](https://nixos.org/nix/) and
[NixOS](https://nixos.org/).

You can evaluate Nix expressions using
[nix-instantiate](https://nixos.org/nix/manual/#sec-nix-instantiate)
or [`nix repl`](https://nixos.org/nix/manual/#ssec-relnotes-2.0).

```
with builtins; [

  #  Comments
  #=========================================

  # Inline comments look like this.

  /* Multi-line comments
     look like this. */


  #  Booleans
  #=========================================

  (true && false)               # And
  #=> false

  (true || false)               # Or
  #=> true

  (if 3 < 4 then ""a"" else ""b"")  # Conditional
  #=> ""a""


  #  Integers and Floats
  #=========================================

  # There are two numeric types: integers and floats

  1 0 42 (-3)       # Some integers

  123.43 .27e13     # A couple of floats

  # Operations will preserve numeric type

  (4 + 6 + 12 - 2)  # Addition
  #=> 20
  (4 - 2.5)
  #=> 1.5

  (7 / 2)           # Division
  #=> 3
  (7 / 2.0)
  #=> 3.5


  #  Strings
  #=========================================

  ""Strings literals are in double quotes.""

  ""
    String literals can span
    multiple lines.
  ""

  ''
    This is called an ""indented string"" literal.
    It intelligently strips leading whitespace.
  ''

  ''
    a
      b
  ''
  #=> ""a\n  b""

  (""ab"" + ""cd"")   # String concatenation
  #=> ""abcd""

  # Antiquotation lets you embed values into strings.
  (""Your home directory is ${getEnv ""HOME""}"")
  #=> ""Your home directory is /home/alice""


  #  Paths
  #=========================================

  # Nix has a primitive data type for paths.
  /tmp/tutorials/learn.nix

  # A relative path is resolved to an absolute path at parse
  # time, relative to the file in which it occurs.
  tutorials/learn.nix
  #=> /the-base-path/tutorials/learn.nix

  # A path must contain at least one slash, so a relative
  # path for a file in the same directory needs a ./ prefix,
  ./learn.nix
  #=> /the-base-path/learn.nix

  # The / operator must be surrounded by whitespace if
  # you want it to signify division.

  7/2        # This is a path literal
  (7 / 2)    # This is integer division


  #  Imports
  #=========================================

  # A nix file contains a single top-level expression with no free
  # variables. An import expression evaluates to the value of the
  # file that it imports.
  (import /tmp/foo.nix)

  # Imports can also be specified by strings.
  (import ""/tmp/foo.nix"")

  # Import paths must be absolute. Path literals
  # are automatically resolved, so this is fine.
  (import ./foo.nix)

  # But this does not happen with strings.
  (import ""./foo.nix"")
  #=> error: string ‘foo.nix’ doesn't represent an absolute path


  #  Let
  #=========================================

  # `let` blocks allow us to bind values to variables.
  (let x = ""a""; in
    x + x + x)
  #=> ""aaa""

  # Bindings can refer to each other, and their order does not matter.
  (let y = x + ""b"";
       x = ""a""; in
    y + ""c"")
  #=> ""abc""

  # Inner bindings shadow outer bindings.
  (let a = 1; in
    let a = 2; in
      a)
  #=> 2


  #  Functions
  #=========================================

  (n: n + 1)      # Function that adds 1

  ((n: n + 1) 5)  # That same function, applied to 5
  #=> 6

  # There is no syntax for named functions, but they
  # can be bound by `let` blocks like any other value.
  (let succ = (n: n + 1); in succ 5)
  #=> 6

  # A function has exactly one argument.
  # Multiple arguments can be achieved with currying.
  ((x: y: x + ""-"" + y) ""a"" ""b"")
  #=> ""a-b""

  # We can also have named function arguments,
  # which we'll get to later after we introduce sets.


  #  Lists
  #=========================================

  # Lists are denoted by square brackets.

  (length [1 2 3 ""x""])
  #=> 4

  ([1 2 3] ++ [4 5])
  #=> [1 2 3 4 5]

  (concatLists [[1 2] [3 4] [5]])
  #=> [1 2 3 4 5]

  (head [1 2 3])
  #=> 1
  (tail [1 2 3])
  #=> [2 3]

  (elemAt [""a"" ""b"" ""c"" ""d""] 2)
  #=> ""c""

  (elem 2 [1 2 3])
  #=> true
  (elem 5 [1 2 3])
  #=> false

  (filter (n: n < 3) [1 2 3 4])
  #=> [ 1 2 ]


  #  Sets
  #=========================================

  # A ""set"" is an unordered mapping with string keys.
  { foo = [1 2]; bar = ""x""; }

  # The . operator pulls a value out of a set.
  { a = 1; b = 2; }.a
  #=> 1

  # The ? operator tests whether a key is present in a set.
  ({ a = 1; b = 2; } ? a)
  #=> true
  ({ a = 1; b = 2; } ? c)
  #=> false

  # The // operator merges two sets.
  ({ a = 1; } // { b = 2; })
  #=> { a = 1; b = 2; }

  # Values on the right override values on the left.
  ({ a = 1; b = 2; } // { a = 3; c = 4; })
  #=> { a = 3; b = 2; c = 4; }

  # The rec keyword denotes a ""recursive set"",
  # in which attributes can refer to each other.
  (let a = 1; in     { a = 2; b = a; }.b)
  #=> 1
  (let a = 1; in rec { a = 2; b = a; }.b)
  #=> 2

  # Nested sets can be defined in a piecewise fashion.
  {
    a.b   = 1;
    a.c.d = 2;
    a.c.e = 3;
  }.a.c
  #=> { d = 2; e = 3; }

  # Sets are immutable, so you can't redefine an attribute:
  {
    a = { b = 1; };
    a.b = 2;
  }
  #=> attribute 'a.b' at (string):3:5 already defined at (string):2:11

  # However, an attribute's set members can also be defined piecewise
  # way even if the attribute itself has been directly assigned.
  {
    a = { b = 1; };
    a.c = 2;
  }
  #=> { a = { b = 1; c = 2; }; }


  #  With
  #=========================================

  # The body of a `with` block is evaluated with
  # a set's mappings bound to variables.
  (with { a = 1; b = 2; };
    a + b)
  # => 3

  # Inner bindings shadow outer bindings.
  (with { a = 1; b = 2; };
    (with { a = 5; };
      a + b))
  #=> 7

  # This first line of tutorial starts with ""with builtins;""
  # because builtins is a set that contains all of the built-in
  # functions (length, head, tail, filter, etc.). This saves
  # us from having to write, for example, ""builtins.length""
  # instead of just ""length"".


  #  Set patterns
  #=========================================

  # Sets are useful when we need to pass multiple values
  # to a function.
  (args: args.x + ""-"" + args.y) { x = ""a""; y = ""b""; }
  #=> ""a-b""

  # This can be written more clearly using set patterns.
  ({x, y}: x + ""-"" + y) { x = ""a""; y = ""b""; }
  #=> ""a-b""

  # By default, the pattern fails on sets containing extra keys.
  ({x, y}: x + ""-"" + y) { x = ""a""; y = ""b""; z = ""c""; }
  #=> error: anonymous function called with unexpected argument ‘z’

  # Adding "", ..."" allows ignoring extra keys.
  ({x, y, ...}: x + ""-"" + y) { x = ""a""; y = ""b""; z = ""c""; }
  #=> ""a-b""


  #  Errors
  #=========================================

  # `throw` causes evaluation to abort with an error message.
  (2 + (throw ""foo""))
  #=> error: foo

  # `tryEval` catches thrown errors.
  (tryEval 42)
  #=> { success = true; value = 42; }
  (tryEval (2 + (throw ""foo"")))
  #=> { success = false; value = false; }

  # `abort` is like throw, but it's fatal; it cannot be caught.
  (tryEval (abort ""foo""))
  #=> error: evaluation aborted with the following error message: ‘foo’

  # `assert` evaluates to the given value if true;
  # otherwise it throws a catchable exception.
  (assert 1 < 2; 42)
  #=> 42
  (assert 1 > 2; 42)
  #=> error: assertion failed at (string):1:1
  (tryEval (assert 1 > 2; 42))
  #=> { success = false; value = false; }


  #  Impurity
  #=========================================

  # Because repeatability of builds is critical to the Nix package
  # manager, functional purity is emphasized in the Nix language
  # used to describe Nix packages. But there are a few impurities.

  # You can refer to environment variables.
  (getEnv ""HOME"")
  #=> ""/home/alice""

  # The trace function is used for debugging. It prints the first
  # argument to stderr and evaluates to the second argument.
  (trace 1 2)
  #=> trace: 1
  #=> 2

  # You can write files into the Nix store. Although impure, this is
  # fairly safe because the file name is derived from the hash of
  # its contents. You can read files from anywhere. In this example,
  # we write a file into the store, and then read it back out.
  (let filename = toFile ""foo.txt"" ""hello!""; in
    [filename (builtins.readFile filename)])
  #=> [ ""/nix/store/ayh05aay2anx135prqp0cy34h891247x-foo.txt"" ""hello!"" ]

  # We can also download files into the Nix store.
  (fetchurl ""https://example.com/package-1.2.3.tgz"")
  #=> ""/nix/store/2drvlh8r57f19s9il42zg89rdr33m2rm-package-1.2.3.tgz""

]
```

### Further Reading

* [Nix Manual - Nix expression language]
  (https://nixos.org/nix/manual/#ch-expression-language)

* [James Fisher - Nix by example - Part 1: The Nix expression language]
  (https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55)

* [Susan Potter - Nix Cookbook - Nix By Example]
  (https://ops.functionalalgebra.com/nix-by-example/)
  
* [Rommel Martinez - A Gentle Introduction to the Nix Family]
  (https://web.archive.org/web/20210121042658/https://ebzzry.io/en/nix/#nix)"
"Solidity lets you program on [Ethereum](https://www.ethereum.org/), a
blockchain-based virtual machine that allows the creation and
execution of smart contracts, without requiring centralized or trusted parties.

Solidity is a statically typed, contract programming language that has
similarities to Javascript and C. Like objects in OOP, each contract contains
state variables, functions, and common data types. Contract-specific features
include modifier (guard) clauses, event notifiers for listeners, and custom
global variables.

Some Ethereum contract examples include crowdfunding, voting, [decentralized finance](https://defipulse.com/), and blind auctions.

There is a high risk and high cost of errors in Solidity code, so you must be very careful to test
and slowly rollout. WITH THE RAPID CHANGES IN ETHEREUM, THIS DOCUMENT IS UNLIKELY TO STAY UP TO
DATE, SO YOU SHOULD FOLLOW THE SOLIDITY CHAT ROOM AND ETHEREUM BLOG FOR THE LATEST. ALL CODE HERE IS
PROVIDED AS IS, WITH SUBSTANTIAL RISK OF ERRORS OR DEPRECATED CODE PATTERNS.

Unlike other code, you may also need to add in design patterns like pausing, deprecation, and
throttling usage to reduce risk. This document primarily discusses syntax, and so excludes many
popular design patterns.

As Solidity and Ethereum are under active development, experimental or beta
features are typically marked, and subject to change. Pull requests welcome.

# Working with Remix and Metamask

One of the easiest ways to build, deploy, and test solidity code is by using the:

1. [Remix Web IDE](https://remix.ethereum.org/) 
2. [Metamask wallet](https://metamask.io/).

To get started, [download the Metamask Browser Extension](https://metamask.io/). 

Once installed, we will be working with Remix. The below code will be pre-loaded, but before we head over there, let's look at a few tips to get started with remix. Load it all by [hitting this link](https://remix.ethereum.org/#version=soljson-v0.6.6+commit.6c089d02.js&optimize=false&evmVersion=null&gist=f490c0d51141dd0515244db40bbd0c17&runs=200).

1. Choose the Solidity compiler

![Solidity-in-remix](images/solidity/remix-solidity.png)

2. Open the file loaded by that link

![Solidity-choose-file](images/solidity/remix-choose-file.png)

3. Compile the file

![Solidity-compile](images/solidity/remix-compile.png)

4. Deploy 

![Solidity-deploy](images/solidity/remix-deploy.png)

5. Play with contracts

![Solidity-deploy](images/solidity/remix-interact.png)

You've deployed your first contract! Congrats!

You can test out and play with the functions defined. Check out the comments to learn about what each does. 


## Working on a testnet

Deploying and testing on a testnet is the most accurate way to test your smart contracts in solidity. 
To do this let's first get some testnet ETH from the Kovan testnet. 

[Pop into this Gitter Channel](https://gitter.im/kovan-testnet/faucet) and drop your metamask address in.

In your metamask, you'll want to change to the `Kovan` testnet. 

![Solidity-in-remix](images/solidity/metamask-kovan.png)

You'll be given some free test Ethereum. Ethereum is needed to deploy smart contracts when working with a testnet. 

In the previous example, we didn't use a testnet, we deployed to a fake virtual environment. 
When working with a testnet, we can actually see and interact with our contracts in a persistent manner. 

To deploy to a testnet, on the `#4 Deploy` step, change your `environment` to `injected web3`.
This will use whatever network is currently selected in your metamask as the network to deploy to. 

![Solidity-in-remix](images/solidity/remix-testnet.png)

For now, please continue to use the `Javascript VM` unless instructed otherwise. When you deploy to a testnet, metamask will pop up to ask you to ""confirm"" the transaction. Hit yes, and after a delay, you'll get the same contract interface at the bottom of your screen. 


```javascript
// First, a simple Bank contract
// Allows deposits, withdrawals, and balance checks

// simple_bank.sol (note .sol extension)
/* **** START EXAMPLE **** */

// Declare the source file compiler version
pragma solidity ^0.6.6;

// Start with Natspec comment (the three slashes)
// used for documentation - and as descriptive data for UI elements/actions

/// @title SimpleBank
/// @author nemild

/* 'contract' has similarities to 'class' in other languages (class variables,
inheritance, etc.) */
contract SimpleBank { // CapWords
    // Declare state variables outside function, persist through life of contract

    // dictionary that maps addresses to balances
    // always be careful about overflow attacks with numbers
    mapping (address => uint) private balances;

    // ""private"" means that other contracts can't directly query balances
    // but data is still viewable to other parties on blockchain

    address public owner;
    // 'public' makes externally readable (not writeable) by users or contracts

    // Events - publicize actions to external listeners
    event LogDepositMade(address accountAddress, uint amount);

    // Constructor, can receive one or many variables here; only one allowed
    constructor() public {
        // msg provides details about the message that's sent to the contract
        // msg.sender is contract caller (address of contract creator)
        owner = msg.sender;
    }

    /// @notice Deposit ether into bank
    /// @return The balance of the user after the deposit is made
    function deposit() public payable returns (uint) {
        // Use 'require' to test user inputs, 'assert' for internal invariants
        // Here we are making sure that there isn't an overflow issue
        require((balances[msg.sender] + msg.value) >= balances[msg.sender]);

        balances[msg.sender] += msg.value;
        // no ""this."" or ""self."" required with state variable
        // all values set to data type's initial value by default

        emit LogDepositMade(msg.sender, msg.value); // fire event

        return balances[msg.sender];
    }

    /// @notice Withdraw ether from bank
    /// @dev This does not return any excess ether sent to it
    /// @param withdrawAmount amount you want to withdraw
    /// @return remainingBal
    function withdraw(uint withdrawAmount) public returns (uint remainingBal) {
        require(withdrawAmount <= balances[msg.sender]);

        // Note the way we deduct the balance right away, before sending
        // Every .transfer/.send from this contract can call an external function
        // This may allow the caller to request an amount greater
        // than their balance using a recursive call
        // Aim to commit state before calling external functions, including .transfer/.send
        balances[msg.sender] -= withdrawAmount;

        // this automatically throws on a failure, which means the updated balance is reverted
        msg.sender.transfer(withdrawAmount);

        return balances[msg.sender];
    }

    /// @notice Get balance
    /// @return The balance of the user
    // 'view' (ex: constant) prevents function from editing state variables;
    // allows function to run locally/off blockchain
    function balance() view public returns (uint) {
        return balances[msg.sender];
    }
}
// ** END EXAMPLE **


// Now, the basics of Solidity

// 1. DATA TYPES AND ASSOCIATED METHODS
// uint used for currency amount (there are no doubles
//  or floats) and for dates (in unix time)
uint x;

// int of 256 bits, cannot be changed after instantiation
int constant a = 8;
int256 constant a = 8; // same effect as line above, here the 256 is explicit
uint constant VERSION_ID = 0x123A1; // A hex constant
// with 'constant', compiler replaces each occurrence with actual value

// All state variables (those outside a function)
// are by default 'internal' and accessible inside contract
// and in all contracts that inherit ONLY
// Need to explicitly set to 'public' to allow external contracts to access
int256 public a = 8;

// For int and uint, can explicitly set space in steps of 8 up to 256
// e.g., int8, int16, int24
uint8 b;
int64 c;
uint248 e;

// Be careful that you don't overflow, and protect against attacks that do
// For example, for an addition, you'd do:
uint256 c = a + b;
assert(c >= a); // assert tests for internal invariants; require is used for user inputs
// For more examples of common arithmetic issues, see Zeppelin's SafeMath library
// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol


// No random functions built in, you can get a pseduo-random number by hashing the current blockhash, or get a truly random number using something like Chainlink VRF. 
// https://docs.chain.link/docs/get-a-random-number

// Type casting
int x = int(b);

bool b = true; // or do 'var b = true;' for inferred typing

// Addresses - holds 20 byte/160 bit Ethereum addresses
// No arithmetic allowed
address public owner;

// Types of accounts:
// Contract account: address set on create (func of creator address, num transactions sent)
// External Account: (person/external entity): address created from public key

// Add 'public' field to indicate publicly/externally accessible
// a getter is automatically created, but NOT a setter

// All addresses can be sent ether
owner.transfer(SOME_BALANCE); // fails and reverts on failure

// Can also do a lower level .send call, which returns a false if it failed
if (owner.send) {} // REMEMBER: wrap send in 'if', as contract addresses have
// functions executed on send and these can fail
// Also, make sure to deduct balances BEFORE attempting a send, as there is a risk of a recursive
// call that can drain the contract

// Can check balance
owner.balance; // the balance of the owner (user or contract)


// Bytes available from 1 to 32
byte a; // byte is same as bytes1
bytes2 b;
bytes32 c;

// Dynamically sized bytes
bytes m; // A special array, same as byte[] array (but packed tightly)
// More expensive than byte1-byte32, so use those when possible

// same as bytes, but does not allow length or index access (for now)
string n = ""hello""; // stored in UTF8, note double quotes, not single
// string utility functions to be added in future
// prefer bytes32/bytes, as UTF8 uses more storage

// Type inference
// var does inferred typing based on first assignment,
// can't be used in functions parameters
var a = true;
// use carefully, inference may provide wrong type
// e.g., an int8, when a counter needs to be int16

// var can be used to assign function to variable
function a(uint x) returns (uint) {
    return x * 2;
}
var f = a;
f(22); // call

// by default, all values are set to 0 on instantiation

// Delete can be called on most types
// (does NOT destroy value, but sets value to 0, the initial value)
delete x;


// Destructuring/Tuples
(x, y) = (2, 7); // assign/swap multiple values


// 2. DATA STRUCTURES
// Arrays
bytes32[5] nicknames; // static array
bytes32[] names; // dynamic array
uint newLength = names.push(""John""); // adding returns new length of the array
// Length
names.length; // get length
names.length = 1; // lengths can be set (for dynamic arrays in storage only)

// multidimensional array
uint[][5] x; // arr with 5 dynamic array elements (opp order of most languages)

// Dictionaries (any type to any other type)
mapping (string => uint) public balances;
balances[""charles""] = 1;
// balances[""ada""] result is 0, all non-set key values return zeroes
// 'public' allows following from another contract
contractName.balances(""charles""); // returns 1
// 'public' created a getter (but not setter) like the following:
function balances(string _account) returns (uint balance) {
    return balances[_account];
}

// Nested mappings
mapping (address => mapping (address => uint)) public custodians;

// To delete
delete balances[""John""];
delete balances; // sets all elements to 0

// Unlike other languages, CANNOT iterate through all elements in
// mapping, without knowing source keys - can build data structure
// on top to do this

// Structs
struct Bank {
    address owner;
    uint balance;
}
Bank b = Bank({
    owner: msg.sender,
    balance: 5
});
// or
Bank c = Bank(msg.sender, 5);

c.balance = 5; // set to new value
delete b;
// sets to initial value, set all variables in struct to 0, except mappings

// Enums
enum State { Created, Locked, Inactive }; // often used for state machine
State public state; // Declare variable from enum
state = State.Created;
// enums can be explicitly converted to ints
uint createdState = uint(State.Created); //  0

// Data locations: Memory vs. storage vs. calldata - all complex types (arrays,
// structs) have a data location
// 'memory' does not persist, 'storage' does
// Default is 'storage' for local and state variables; 'memory' for func params
// stack holds small local variables

// for most types, can explicitly set which data location to use


// 3. Simple operators
// Comparisons, bit operators and arithmetic operators are provided
// exponentiation: **
// exclusive or: ^
// bitwise negation: ~


// 4. Global Variables of note
// ** this **
this; // address of contract
// often used at end of contract life to transfer remaining balance to party
this.balance;
this.someFunction(); // calls func externally via call, not via internal jump

// ** msg - Current message received by the contract ** **
msg.sender; // address of sender
msg.value; // amount of ether provided to this contract in wei, the function should be marked ""payable""
msg.data; // bytes, complete call data
msg.gas; // remaining gas

// ** tx - This transaction **
tx.origin; // address of sender of the transaction
tx.gasprice; // gas price of the transaction

// ** block - Information about current block **
now; // current time (approximately), alias for block.timestamp (uses Unix time)
// Note that this can be manipulated by miners, so use carefully

block.number; // current block number
block.difficulty; // current block difficulty
block.blockhash(1); // returns bytes32, only works for most recent 256 blocks
block.gasLimit();

// ** storage - Persistent storage hash **
storage['abc'] = 'def'; // maps 256 bit words to 256 bit words


// 5. FUNCTIONS AND MORE
// A. Functions
// Simple function
function increment(uint x) returns (uint) {
    x += 1;
    return x;
}

// Functions can return many arguments,
// and by specifying returned arguments name explicit return is not needed
function increment(uint x, uint y) returns (uint x, uint y) {
    x += 1;
    y += 1;
}
// Call previous function
uint (a,b) = increment(1,1);

// 'view' (alias for 'constant')
// indicates that function does not/cannot change persistent vars
// View function execute locally, not on blockchain
// Noted: constant keyword will soon be deprecated.
uint y = 1;

function increment(uint x) view returns (uint x) {
    x += 1;
    y += 1; // this line would fail
    // y is a state variable, and can't be changed in a view function
}

// 'pure' is more strict than 'view' or 'constant', and does not
// even allow reading of state vars
// The exact rules are more complicated, so see more about
// view/pure:
// http://solidity.readthedocs.io/en/develop/contracts.html#view-functions

// 'Function Visibility specifiers'
// These can be placed where 'view' is, including:
// public - visible externally and internally (default for function)
// external - only visible externally (including a call made with this.)
// private - only visible in the current contract
// internal - only visible in current contract, and those deriving from it

// Generally, a good idea to mark each function explicitly

// Functions hoisted - and can assign a function to a variable
function a() {
    var z = b;
    z();
}

function b() {

}

// All functions that receive ether must be marked 'payable'
function depositEther() public payable {
    balances[msg.sender] += msg.value;
}


// Prefer loops to recursion (max call stack depth is 1024)
// Also, don't setup loops that you haven't bounded,
// as this can hit the gas limit

// B. Events
// Events are notify external parties; easy to search and
// access events from outside blockchain (with lightweight clients)
// typically declare after contract parameters

// Typically, capitalized - and add Log in front to be explicit and prevent confusion
// with a function call

// Declare
event LogSent(address indexed from, address indexed to, uint amount); // note capital first letter

// Call
LogSent(from, to, amount);

/**

For an external party (a contract or external entity), to watch using
the Web3 Javascript library:

// The following is Javascript code, not Solidity code
Coin.LogSent().watch({}, '', function(error, result) {
    if (!error) {
        console.log(""Coin transfer: "" + result.args.amount +
            "" coins were sent from "" + result.args.from +
            "" to "" + result.args.to + ""."");
        console.log(""Balances now:\n"" +
            ""Sender: "" + Coin.balances.call(result.args.from) +
            ""Receiver: "" + Coin.balances.call(result.args.to));
    }
}
**/

// Common paradigm for one contract to depend on another (e.g., a
// contract that depends on current exchange rate provided by another)

// C. Modifiers
// Modifiers validate inputs to functions such as minimal balance or user auth;
// similar to guard clause in other languages

// '_' (underscore) often included as last line in body, and indicates
// function being called should be placed there
modifier onlyAfter(uint _time) { require (now >= _time); _; }
modifier onlyOwner { require(msg.sender == owner); _; }
// commonly used with state machines
modifier onlyIfStateA (State currState) { require(currState == State.A); _; }

// Append right after function declaration
function changeOwner(newOwner)
onlyAfter(someTime)
onlyOwner()
onlyIfState(State.A)
{
    owner = newOwner;
}

// underscore can be included before end of body,
// but explicitly returning will skip, so use carefully
modifier checkValue(uint amount) {
    _;
    if (msg.value > amount) {
        uint amountToRefund = amount - msg.value;
        msg.sender.transfer(amountToRefund);
    }
}


// 6. BRANCHING AND LOOPS

// All basic logic blocks work - including if/else, for, while, break, continue
// return - but no switch

// Syntax same as javascript, but no type conversion from non-boolean
// to boolean (comparison operators must be used to get the boolean val)

// For loops that are determined by user behavior, be careful - as contracts have a maximal
// amount of gas for a block of code - and will fail if that is exceeded
// For example:
for(uint x = 0; x < refundAddressList.length; x++) {
    refundAddressList[x].transfer(SOME_AMOUNT);
}

// Two errors above:
// 1. A failure on transfer stops the loop from completing, tying up money
// 2. This loop could be arbitrarily long (based on the amount of users who need refunds), and
// therefore may always fail as it exceeds the max gas for a block
// Instead, you should let people withdraw individually from their subaccount, and mark withdrawn
// e.g., favor pull payments over push payments


// 7. OBJECTS/CONTRACTS

// A. Calling external contract
contract InfoFeed {
    function info() payable returns (uint ret)  { return 42; }
}

contract Consumer {
    InfoFeed feed; // points to contract on blockchain

    // Set feed to existing contract instance
    function setFeed(address addr) {
        // automatically cast, be careful; constructor is not called
        feed = InfoFeed(addr);
    }

    // Set feed to new instance of contract
    function createNewFeed() {
        feed = new InfoFeed(); // new instance created; constructor called
    }

    function callFeed() {
        // final parentheses call contract, can optionally add
        // custom ether value or gas
        feed.info.value(10).gas(800)();
    }
}

// B. Inheritance

// Order matters, last inherited contract (i.e., 'def') can override parts of
// previously inherited contracts
contract MyContract is abc, def(""a custom argument to def"") {

// Override function
    function z() {
        if (msg.sender == owner) {
            def.z(); // call overridden function from def
            super.z(); // call immediate parent overridden function
        }
    }
}

// abstract function
function someAbstractFunction(uint x);
// cannot be compiled, so used in base/abstract contracts
// that are then implemented

// C. Import

import ""filename"";
import ""github.com/ethereum/dapp-bin/library/iterable_mapping.sol"";


// 8. OTHER KEYWORDS

// A. Selfdestruct
// selfdestruct current contract, sending funds to address (often creator)
selfdestruct(SOME_ADDRESS);

// removes storage/code from current/future blocks
// helps thin clients, but previous data persists in blockchain

// Common pattern, lets owner end the contract and receive remaining funds
function remove() {
    if(msg.sender == creator) { // Only let the contract creator do this
        selfdestruct(creator); // Makes contract inactive, returns funds
    }
}

// May want to deactivate contract manually, rather than selfdestruct
// (ether sent to selfdestructed contract is lost)


// 9. CONTRACT DESIGN NOTES

// A. Obfuscation
// All variables are publicly viewable on blockchain, so anything
// that is private needs to be obfuscated (e.g., hashed w/secret)

// Steps: 1. Commit to something, 2. Reveal commitment
keccak256(""some_bid_amount"", ""some secret""); // commit

// call contract's reveal function in the future
// showing bid plus secret that hashes to SHA3
reveal(100, ""mySecret"");

// B. Storage optimization
// Writing to blockchain can be expensive, as data stored forever; encourages
// smart ways to use memory (eventually, compilation will be better, but for now
// benefits to planning data structures - and storing min amount in blockchain)

// Cost can often be high for items like multidimensional arrays
// (cost is for storing data - not declaring unfilled variables)

// C. Data access in blockchain
// Cannot restrict human or computer from reading contents of
// transaction or transaction's state

// While 'private' prevents other *contracts* from reading data
// directly - any other party can still read data in blockchain

// All data to start of time is stored in blockchain, so
// anyone can observe all previous data and changes

// D. Oracles and External Data
// Oracles are ways to interact with your smart contracts outside the blockchain. 
// They are used to get data from the real world, send post requests, to the real world
// or vise versa.

// Time-based implementations of contracts are also done through oracles, as 
// contracts need to be directly called and can not ""subscribe"" to a time. 
// Due to smart contracts being decentralized, you also want to get your data
// in a decentralized manner, otherwise you run into the centralized risk that 
// smart contract design matter prevents. 

// To easiest way get and use pre-boxed decentralized data is with Chainlink Data Feeds
// https://docs.chain.link/docs/get-the-latest-price
// We can reference on-chain reference points that have already been aggregated by 
// multiple sources and delivered on-chain, and we can use it as a ""data bank"" 
// of sources. 

// You can see other examples making API calls here:
// https://docs.chain.link/docs/make-a-http-get-request

// And you can of course build your own oracle network, just be sure to know 
// how centralized vs decentralized your application is. 

// Setting up oracle networks yourself

// E. Cron Job
// Contracts must be manually called to handle time-based scheduling; can create external
// code to regularly ping, or provide incentives (ether) for others to
//

// F. Observer Pattern
// An Observer Pattern lets you register as a subscriber and
// register a function which is called by the oracle (note, the oracle pays
// for this action to be run)
// Some similarities to subscription in Pub/sub

// This is an abstract contract, both client and server classes import
// the client should implement
contract SomeOracleCallback {
    function oracleCallback(int _value, uint _time, bytes32 info) external;
}

contract SomeOracle {
    SomeOracleCallback[] callbacks; // array of all subscribers

    // Register subscriber
    function addSubscriber(SomeOracleCallback a) {
        callbacks.push(a);
    }

    function notify(value, time, info) private {
        for(uint i = 0;i < callbacks.length; i++) {
            // all called subscribers must implement the oracleCallback
            callbacks[i].oracleCallback(value, time, info);
        }
    }

    function doSomething() public {
        // Code to do something

        // Notify all subscribers
        notify(_value, _time, _info);
    }
}

// Now, your client contract can addSubscriber by importing SomeOracleCallback
// and registering with Some Oracle

// G. State machines
// see example below for State enum and inState modifier
```

Work with the full example below using the [`Javascript VM` in remix here.](https://remix.ethereum.org/#version=soljson-v0.6.6+commit.6c089d02.js&optimize=false&evmVersion=null&gist=3d12cd503dcedfcdd715ef61f786be0b&runs=200)

```javascript
// *** EXAMPLE: A crowdfunding example (broadly similar to Kickstarter) ***
// ** START EXAMPLE **

// CrowdFunder.sol
pragma solidity ^0.6.6;

/// @title CrowdFunder
/// @author nemild
contract CrowdFunder {
    // Variables set on create by creator
    address public creator;
    address payable public fundRecipient; // creator may be different than recipient, and must be payable
    uint public minimumToRaise; // required to tip, else everyone gets refund
    string campaignUrl;
    byte version = ""1"";

    // Data structures
    enum State {
        Fundraising,
        ExpiredRefund,
        Successful
    }
    struct Contribution {
        uint amount;
        address payable contributor;
    }

    // State variables
    State public state = State.Fundraising; // initialize on create
    uint public totalRaised;
    uint public raiseBy;
    uint public completeAt;
    Contribution[] contributions;

    event LogFundingReceived(address addr, uint amount, uint currentTotal);
    event LogWinnerPaid(address winnerAddress);

    modifier inState(State _state) {
        require(state == _state);
        _;
    }

    modifier isCreator() {
        require(msg.sender == creator);
        _;
    }

    // Wait 24 weeks after final contract state before allowing contract destruction
    modifier atEndOfLifecycle() {
    require(((state == State.ExpiredRefund || state == State.Successful) &&
        completeAt + 24 weeks < now));
        _;
    }

    function crowdFund(
        uint timeInHoursForFundraising,
        string memory _campaignUrl,
        address payable _fundRecipient,
        uint _minimumToRaise)
        public
    {
        creator = msg.sender;
        fundRecipient = _fundRecipient;
        campaignUrl = _campaignUrl;
        minimumToRaise = _minimumToRaise;
        raiseBy = now + (timeInHoursForFundraising * 1 hours);
    }

    function contribute()
    public
    payable
    inState(State.Fundraising)
    returns(uint256 id)
    {
        contributions.push(
            Contribution({
                amount: msg.value,
                contributor: msg.sender
            }) // use array, so can iterate
        );
        totalRaised += msg.value;

        emit LogFundingReceived(msg.sender, msg.value, totalRaised);

        checkIfFundingCompleteOrExpired();
        return contributions.length - 1; // return id
    }

    function checkIfFundingCompleteOrExpired()
    public
    {
        if (totalRaised > minimumToRaise) {
            state = State.Successful;
            payOut();

            // could incentivize sender who initiated state change here
        } else if ( now > raiseBy )  {
            state = State.ExpiredRefund; // backers can now collect refunds by calling getRefund(id)
        }
        completeAt = now;
    }

    function payOut()
    public
    inState(State.Successful)
    {
        fundRecipient.transfer(address(this).balance);
        LogWinnerPaid(fundRecipient);
    }

    function getRefund(uint256 id)
    inState(State.ExpiredRefund)
    public
    returns(bool)
    {
        require(contributions.length > id && id >= 0 && contributions[id].amount != 0 );

        uint256 amountToRefund = contributions[id].amount;
        contributions[id].amount = 0;

        contributions[id].contributor.transfer(amountToRefund);

        return true;
    }

    function removeContract()
    public
    isCreator()
    atEndOfLifecycle()
    {
        selfdestruct(msg.sender);
        // creator gets all money that hasn't be claimed
    }
}
// ** END EXAMPLE **

```

Some more functions. 

```javascript
// 10. OTHER NATIVE FUNCTIONS

// Currency units
// Currency is defined using wei, smallest unit of Ether
uint minAmount = 1 wei;
uint a = 1 finney; // 1 ether == 1000 finney
// Other units, see: http://ether.fund/tool/converter

// Time units
1 == 1 second
1 minutes == 60 seconds

// Can multiply a variable times unit, as units are not stored in a variable
uint x = 5;
(x * 1 days); // 5 days

// Careful about leap seconds/years with equality statements for time
// (instead, prefer greater than/less than)

// Cryptography
// All strings passed are concatenated before hash action
sha3(""ab"", ""cd"");
ripemd160(""abc"");
sha256(""def"");

// 11. SECURITY

// Bugs can be disastrous in Ethereum contracts - and even popular patterns in Solidity,
// may be found to be antipatterns

// See security links at the end of this doc

// 12. LOW LEVEL FUNCTIONS
// call - low level, not often used, does not provide type safety
successBoolean = someContractAddress.call('function_name', 'arg1', 'arg2');

// callcode - Code at target address executed in *context* of calling contract
// provides library functionality
someContractAddress.callcode('function_name');


// 13. STYLE NOTES
// Based on Python's PEP8 style guide
// Full Style guide: http://solidity.readthedocs.io/en/develop/style-guide.html

// Quick summary:
// 4 spaces for indentation
// Two lines separate contract declarations (and other top level declarations)
// Avoid extraneous spaces in parentheses
// Can omit curly braces for one line statement (if, for, etc)
// else should be placed on own line


// 14. NATSPEC COMMENTS
// used for documentation, commenting, and external UIs

// Contract natspec - always above contract definition
/// @title Contract title
/// @author Author name

// Function natspec
/// @notice information about what function does; shown when function to execute
/// @dev Function documentation for developer

// Function parameter/return value natspec
/// @param someParam Some description of what the param does
/// @return Description of the return value
```

## Additional resources
- [Solidity Docs](https://solidity.readthedocs.org/en/latest/)
- [Chainlink Beginner Tutorials](https://docs.chain.link/docs/beginners-tutorial)
- [Smart Contract Best Practices](https://github.com/ConsenSys/smart-contract-best-practices)
- [Superblocks Lab - Browser based IDE for Solidity](https://lab.superblocks.com/)
- [EthFiddle - The JsFiddle for Solidity](https://ethfiddle.com/)
- [Browser-based Solidity Editor](https://remix.ethereum.org/)
- [Gitter Solidity Chat room](https://gitter.im/ethereum/solidity)
- [Modular design strategies for Ethereum Contracts](https://docs.erisindustries.com/tutorials/solidity/)
- [Chainlink Documentation](https://docs.chain.link/docs/getting-started)

## Smart Contract Development Frameworks
- [Hardhat](https://hardhat.org/)
- [Brownie](https://github.com/eth-brownie/brownie)
- [Truffle](https://www.trufflesuite.com/)

## Important libraries
- [Zeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts): Libraries that provide common contract patterns (crowdfuding, safemath, etc)
- [Chainlink](https://github.com/smartcontractkit/chainlink): Code that allows you to interact with external data

## Sample contracts
- [Dapp Bin](https://github.com/ethereum/dapp-bin)
- [Defi Example](https://github.com/PatrickAlphaC/chainlink_defi)
- [Solidity Baby Step Contracts](https://github.com/fivedogit/solidity-baby-steps/tree/master/contracts)
- [ConsenSys Contracts](https://github.com/ConsenSys/dapp-store-contracts)
- [State of Dapps](http://dapps.ethercasts.com/)

## Security
- [Thinking About Smart Contract Security](https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/)
- [Smart Contract Security](https://blog.ethereum.org/2016/06/10/smart-contract-security/)
- [Hacking Distributed Blog](http://hackingdistributed.com/)

## Style
- [Solidity Style Guide](http://solidity.readthedocs.io/en/latest/style-guide.html): Ethereum's style guide is heavily derived from Python's [PEP 8](https://www.python.org/dev/peps/pep-0008/) style guide.

## Editors
- [Remix](https://remix.ethereum.org/)
- [Emacs Solidity Mode](https://github.com/ethereum/emacs-solidity)
- [Vim Solidity](https://github.com/tomlion/vim-solidity)
- Editor Snippets ([Ultisnips format](https://gist.github.com/nemild/98343ce6b16b747788bc))

## Future To Dos
- New keywords: protected, inheritable
- List of common design patterns (throttling, RNG, version upgrade)
- Common security anti patterns

Feel free to send a pull request with any edits - or email nemild -/at-/ gmail"
"Elm is a functional reactive programming language that compiles to (client-side)
JavaScript. Elm is statically typed, meaning that the compiler catches most
errors immediately and provides a clear and understandable error message. Elm is
great for designing user interfaces and games for the web.


```haskell
-- Single line comments start with two dashes.
{- Multiline comments can be enclosed in a block like this.
{- They can be nested. -}
-}

{-- The Basics --}

-- Arithmetic
1 + 1 -- 2
8 - 1 -- 7
10 * 2 -- 20

-- Every number literal without a decimal point can be either an Int or a Float.
33 / 2 -- 16.5 with floating point division
33 // 2 -- 16 with integer division

-- Exponents
5 ^ 2 -- 25

-- Booleans
not True -- False
not False -- True
1 == 1 -- True
1 /= 1 -- False
1 < 10 -- True

-- Strings and characters
""This is a string because it uses double quotes.""
'a' -- characters in single quotes

-- Strings can be appended.
""Hello "" ++ ""world!"" -- ""Hello world!""

{-- Lists, Tuples, and Records --}

-- Every element in a list must have the same type.
[""the"", ""quick"", ""brown"", ""fox""]
[1, 2, 3, 4, 5]
-- The second example can also be written with two dots.
List.range 1 5

-- Append lists just like strings.
List.range 1 5 ++ List.range 6 10 == List.range 1 10 -- True

-- To add one item, use ""cons"".
0 :: List.range 1 5 -- [0, 1, 2, 3, 4, 5]

-- The head and tail of a list are returned as a Maybe. Instead of checking
-- every value to see if it's null, you deal with missing values explicitly.
List.head (List.range 1 5) -- Just 1
List.tail (List.range 1 5) -- Just [2, 3, 4, 5]
List.head [] -- Nothing
-- List.functionName means the function lives in the List module.

-- Every element in a tuple can be a different type, but a tuple has a
-- fixed length.
(""elm"", 42)

-- Access the elements of a pair with the first and second functions.
-- (This is a shortcut; we'll come to the ""real way"" in a bit.)
Tuple.first (""elm"", 42) -- ""elm""
Tuple.second (""elm"", 42) -- 42

-- The empty tuple, or ""unit"", is sometimes used as a placeholder.
-- It is the only value of its type, also called ""Unit"".
()

-- Records are like tuples but the fields have names. The order of fields
-- doesn't matter. Notice that record values use equals signs, not colons.
{ x = 3, y = 7 }

-- Access a field with a dot and the field name.
{ x = 3, y = 7 }.x -- 3

-- Or with an accessor function, which is a dot and the field name on its own.
.y { x = 3, y = 7 } -- 7

-- Update the fields of a record. (It must have the fields already.)
{ person |
  name = ""George"" }

-- Update multiple fields at once, using the current values.
{ particle |
  position = particle.position + particle.velocity,
  velocity = particle.velocity + particle.acceleration }

{-- Control Flow --}

-- If statements always have an else, and the branches must be the same type.
if powerLevel > 9000 then
  ""WHOA!""
else
  ""meh""

-- If statements can be chained.
if n < 0 then
  ""n is negative""
else if n > 0 then
  ""n is positive""
else
  ""n is zero""

-- Use case statements to pattern match on different possibilities.
case aList of
  [] -> ""matches the empty list""
  [x]-> ""matches a list of exactly one item, "" ++ toString x
  x::xs -> ""matches a list of at least one item whose head is "" ++ toString x
-- Pattern matches go in order. If we put [x] last, it would never match because
-- x::xs also matches (xs would be the empty list). Matches do not ""fall through"".
-- The compiler will alert you to missing or extra cases.

-- Pattern match on a Maybe.
case List.head aList of
  Just x -> ""The head is "" ++ toString x
  Nothing -> ""The list was empty.""

{-- Functions --}

-- Elm's syntax for functions is very minimal, relying mostly on whitespace
-- rather than parentheses and curly brackets. There is no ""return"" keyword.

-- Define a function with its name, arguments, an equals sign, and the body.
multiply a b =
  a * b

-- Apply (call) a function by passing it arguments (no commas necessary).
multiply 7 6 -- 42

-- Partially apply a function by passing only some of its arguments.
-- Then give that function a new name.
double =
  multiply 2

-- Constants are similar, except there are no arguments.
answer =
  42

-- Pass functions as arguments to other functions.
List.map double (List.range 1 4) -- [2, 4, 6, 8]

-- Or write an anonymous function.
List.map (\a -> a * 2) (List.range 1 4) -- [2, 4, 6, 8]

-- You can pattern match in function definitions when there's only one case.
-- This function takes one tuple rather than two arguments.
-- This is the way you'll usually unpack/extract values from tuples.
area (width, height) =
  width * height

area (6, 7) -- 42

-- Use curly brackets to pattern match record field names.
-- Use let to define intermediate values.
volume {width, height, depth} =
  let
    area = width * height
  in
    area * depth

volume { width = 3, height = 2, depth = 7 } -- 42

-- Functions can be recursive.
fib n =
  if n < 2 then
    1
  else
    fib (n - 1) + fib (n - 2)

List.map fib (List.range 0 8) -- [1, 1, 2, 3, 5, 8, 13, 21, 34]

-- Another recursive function (use List.length in real code).
listLength aList =
  case aList of
    [] -> 0
    x::xs -> 1 + listLength xs

-- Function calls happen before any infix operator. Parens indicate precedence.
cos (degrees 30) ^ 2 + sin (degrees 30) ^ 2 -- 1
-- First degrees is applied to 30, then the result is passed to the trig
-- functions, which is then squared, and the addition happens last.

{-- Types and Type Annotations --}

-- The compiler will infer the type of every value in your program.
-- Types are always uppercase. Read x : T as ""x has type T"".
-- Some common types, which you might see in Elm's REPL.
5 : Int
6.7 : Float
""hello"" : String
True : Bool

-- Functions have types too. Read -> as ""goes to"". Think of the rightmost type
-- as the type of the return value, and the others as arguments.
not : Bool -> Bool
round : Float -> Int

-- When you define a value, it's good practice to write its type above it.
-- The annotation is a form of documentation, which is verified by the compiler.
double : Int -> Int
double x = x * 2

-- Function arguments are passed in parentheses.
-- Lowercase types are type variables: they can be any type, as long as each
-- call is consistent.
List.map : (a -> b) -> List a -> List b
-- ""List dot map has type a-goes-to-b, goes to list of a, goes to list of b.""

-- There are three special lowercase types: number, comparable, and appendable.
-- Numbers allow you to use arithmetic on Ints and Floats.
-- Comparable allows you to order numbers and strings, like a < b.
-- Appendable things can be combined with a ++ b.

{-- Type Aliases and Union Types --}

-- When you write a record or tuple, its type already exists.
-- (Notice that record types use colon and record values use equals.)
origin : { x : Float, y : Float, z : Float }
origin =
  { x = 0, y = 0, z = 0 }

-- You can give existing types a nice name with a type alias.
type alias Point3D =
  { x : Float, y : Float, z : Float }

-- If you alias a record, you can use the name as a constructor function.
otherOrigin : Point3D
otherOrigin =
  Point3D 0 0 0

-- But it's still the same type, so you can equate them.
origin == otherOrigin -- True

-- By contrast, defining a union type creates a type that didn't exist before.
-- A union type is so called because it can be one of many possibilities.
-- Each of the possibilities is represented as a ""tag"".
type Direction =
  North | South | East | West

-- Tags can carry other values of known type. This can work recursively.
type IntTree =
  Leaf | Node Int IntTree IntTree
-- ""Leaf"" and ""Node"" are the tags. Everything following a tag is a type.

-- Tags can be used as values or functions.
root : IntTree
root =
  Node 7 Leaf Leaf

-- Union types (and type aliases) can use type variables.
type Tree a =
  Leaf | Node a (Tree a) (Tree a)
-- ""The type tree-of-a is a leaf, or a node of a, tree-of-a, and tree-of-a.""

-- Pattern match union tags. The uppercase tags will be matched exactly. The
-- lowercase variables will match anything. Underscore also matches anything,
-- but signifies that you aren't using it.
leftmostElement : Tree a -> Maybe a
leftmostElement tree =
  case tree of
    Leaf -> Nothing
    Node x Leaf _ -> Just x
    Node _ subtree _ -> leftmostElement subtree

-- That's pretty much it for the language itself. Now let's see how to organize
-- and run your code.

{-- Modules and Imports --}

-- The core libraries are organized into modules, as are any third-party
-- libraries you may use. For large projects, you can define your own modules.

-- Put this at the top of the file. If omitted, you're in Main.
module Name where

-- By default, everything is exported. You can specify exports explicitly.
module Name (MyType, myValue) where

-- One common pattern is to export a union type but not its tags. This is known
-- as an ""opaque type"", and is frequently used in libraries.

-- Import code from other modules to use it in this one.
-- Places Dict in scope, so you can call Dict.insert.
import Dict

-- Imports the Dict module and the Dict type, so your annotations don't have to
-- say Dict.Dict. You can still use Dict.insert.
import Dict exposing (Dict)

-- Rename an import.
import Graphics.Collage as C

{-- Ports --}

-- A port indicates that you will be communicating with the outside world.
-- Ports are only allowed in the Main module.

-- An incoming port is just a type signature.
port clientID : Int

-- An outgoing port has a definition.
port clientOrders : List String
port clientOrders = [""Books"", ""Groceries"", ""Furniture""]

-- We won't go into the details, but you set up callbacks in JavaScript to send
-- on incoming ports and receive on outgoing ports.

{-- Command Line Tools --}

-- Compile a file.
$ elm make MyFile.elm

-- The first time you do this, Elm will install the core libraries and create
-- elm-package.json, where information about your project is kept.

-- The reactor is a server that compiles and runs your files.
-- Click the wrench next to file names to enter the time-travelling debugger!
$ elm reactor

-- Experiment with simple expressions in a Read-Eval-Print Loop.
$ elm repl

-- Packages are identified by GitHub username and repo name.
-- Install a new package, and record it in elm-package.json.
$ elm package install elm-lang/html

-- See what changed between versions of a package.
$ elm package diff elm-lang/html 1.1.0 2.0.0
-- Elm's package manager enforces semantic versioning, so minor version bumps
-- will never break your build!
```

The Elm language is surprisingly small. You can now look through almost any Elm
source code and have a rough idea of what is going on. However, the possibilities
for error-resistant and easy-to-refactor code are endless!

Here are some useful resources.

* The [Elm website](http://elm-lang.org/). Includes:
  * Links to the [installers](http://elm-lang.org/install)
  * [Documentation guides](http://elm-lang.org/docs), including the [syntax reference](http://elm-lang.org/docs/syntax)
  * Lots of helpful [examples](http://elm-lang.org/examples)

* Documentation for [Elm's core libraries](http://package.elm-lang.org/packages/elm-lang/core/latest/). Take note of:
  * [Basics](http://package.elm-lang.org/packages/elm-lang/core/latest/Basics), which is imported by default
  * [Maybe](http://package.elm-lang.org/packages/elm-lang/core/latest/Maybe) and its cousin [Result](http://package.elm-lang.org/packages/elm-lang/core/latest/Result), commonly used for missing values or error handling
  * Data structures like [List](http://package.elm-lang.org/packages/elm-lang/core/latest/List), [Array](http://package.elm-lang.org/packages/elm-lang/core/latest/Array), [Dict](http://package.elm-lang.org/packages/elm-lang/core/latest/Dict), and [Set](http://package.elm-lang.org/packages/elm-lang/core/latest/Set)
  * JSON [encoding](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Encode) and [decoding](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode)

* [The Elm Architecture](https://github.com/evancz/elm-architecture-tutorial#the-elm-architecture). An essay by Elm's creator with examples on how to organize code into components.

* The [Elm mailing list](https://groups.google.com/forum/#!forum/elm-discuss). Everyone is friendly and helpful.

* [Scope in Elm](https://github.com/elm-guides/elm-for-js/blob/master/Scope.md#scope-in-elm) and [How to Read a Type Annotation](https://github.com/elm-guides/elm-for-js/blob/master/How%20to%20Read%20a%20Type%20Annotation.md#how-to-read-a-type-annotation). More community guides on the basics of Elm, written for JavaScript developers.

Go out and write some Elm!"
"```erlang
% Percent sign starts a one-line comment.

%% Two percent characters shall be used to comment functions.

%%% Three percent characters shall be used to comment modules.

% We use three types of punctuation in Erlang.
% Commas (`,`) separate arguments in function calls, data constructors, and
% patterns.
% Periods (`.`) (followed by whitespace) separate entire functions and
% expressions in the shell.
% Semicolons (`;`) separate clauses. We find clauses in several contexts:
% function definitions and in `case`, `if`, `try..catch`, and `receive`
% expressions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 1. Variables and pattern matching.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% In Erlang new variables are bound with an `=` statement.
Num = 42.  % All variable names must start with an uppercase letter.

% Erlang has single-assignment variables; if you try to assign a different
% value to the variable `Num`, you’ll get an error.
Num = 43. % ** exception error: no match of right hand side value 43

% In most languages, `=` denotes an assignment statement. In Erlang, however,
% `=` denotes a pattern-matching operation. When an empty variable is used on the
% left hand side of the `=` operator to is bound (assigned), but when a bound
% variable is used on the left hand side the following behaviour is observed.
% `Lhs = Rhs` really means this: evaluate the right side (`Rhs`), and then
% match the result against the pattern on the left side (`Lhs`).
Num = 7 * 6.

% Floating-point number.
Pi = 3.14159.

% Atoms are used to represent different non-numerical constant values. Atoms
% start with lowercase letters, followed by a sequence of alphanumeric
% characters or the underscore (`_`) or at (`@`) sign.
Hello = hello.
OtherNode = example@node.

% Atoms with non alphanumeric values can be written by enclosing the atoms
% with apostrophes.
AtomWithSpace = 'some atom with space'.

% Tuples are similar to structs in C.
Point = {point, 10, 45}.

% If we want to extract some values from a tuple, we use the pattern-matching
% operator `=`.
{point, X, Y} = Point.  % X = 10, Y = 45

% We can use `_` as a placeholder for variables that we’re not interested in.
% The symbol `_` is called an anonymous variable. Unlike regular variables,
% several occurrences of `_` in the same pattern don’t have to bind to the
% same value.
Person = {person, {name, {first, joe}, {last, armstrong}}, {footsize, 42}}.
{_, {_, {_, Who}, _}, _} = Person.  % Who = joe

% We create a list by enclosing the list elements in square brackets and
% separating them with commas.
% The individual elements of a list can be of any type.
% The first element of a list is the head of the list. If you imagine removing
% the head from the list, what’s left is called the tail of the list.
ThingsToBuy = [{apples, 10}, {pears, 6}, {milk, 3}].

% If `T` is a list, then `[H|T]` is also a list, with head `H` and tail `T`.
% The vertical bar (`|`) separates the head of a list from its tail.
% `[]` is the empty list.
% We can extract elements from a list with a pattern-matching operation. If we
% have a nonempty list `L`, then the expression `[X|Y] = L`, where `X` and `Y`
% are unbound variables, will extract the head of the list into `X` and the tail
% of the list into `Y`.
[FirstThing|OtherThingsToBuy] = ThingsToBuy.
% FirstThing = {apples, 10}
% OtherThingsToBuy = [{pears, 6}, {milk, 3}]

% There are no strings in Erlang. Strings are really just lists of integers.
% Strings are enclosed in double quotation marks (`""`).
Name = ""Hello"".
[72, 101, 108, 108, 111] = ""Hello"".


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 2. Sequential programming.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Modules are the basic unit of code in Erlang. All the functions we write are
% stored in modules. Modules are stored in files with `.erl` extensions.
% Modules must be compiled before the code can be run. A compiled module has the
% extension `.beam`.
-module(geometry).
-export([area/1]). % the list of functions exported from the module.

% The function `area` consists of two clauses. The clauses are separated by a
% semicolon, and the final clause is terminated by dot-whitespace.
% Each clause has a head and a body; the head consists of a function name
% followed by a pattern (in parentheses), and the body consists of a sequence of
% expressions, which are evaluated if the pattern in the head is successfully
% matched against the calling arguments. The patterns are matched in the order
% they appear in the function definition.
area({rectangle, Width, Ht}) -> Width * Ht;
area({circle, R})            -> 3.14159 * R * R.

% Compile the code in the file geometry.erl.
c(geometry).  % {ok,geometry}

% We need to include the module name together with the function name in order to
% identify exactly which function we want to call.
geometry:area({rectangle, 10, 5}).  % 50
geometry:area({circle, 1.4}).  % 6.15752

% In Erlang, two functions with the same name and different arity (number of
% arguments) in the same module represent entirely different functions.
-module(lib_misc).
-export([sum/1]). % export function `sum` of arity 1
                  % accepting one argument: list of integers.
sum(L) -> sum(L, 0).
sum([], N)    -> N;
sum([H|T], N) -> sum(T, H+N).

% Funs are ""anonymous"" functions. They are called this way because they have
% no name. However, they can be assigned to variables.
Double = fun(X) -> 2 * X end. % `Double` points to an anonymous function
                              % with handle: #Fun<erl_eval.6.17052888>
Double(2).  % 4

% Functions accept funs as their arguments and can return funs.
Mult = fun(Times) -> ( fun(X) -> X * Times end ) end.
Triple = Mult(3).
Triple(5).  % 15

% List comprehensions are expressions that create lists without having to use
% funs, maps, or filters.
% The notation `[F(X) || X <- L]` means ""the list of `F(X)` where `X` is taken
% from the list `L`.""
L = [1,2,3,4,5].
[2 * X || X <- L].  % [2,4,6,8,10]
% A list comprehension can have generators and filters, which select subset of
% the generated values.
EvenNumbers = [N || N <- [1, 2, 3, 4], N rem 2 == 0]. % [2, 4]

% Guards are constructs that we can use to increase the power of pattern
% matching. Using guards, we can perform simple tests and comparisons on the
% variables in a pattern.
% You can use guards in the heads of function definitions where they are
% introduced by the `when` keyword, or you can use them at any place in the
% language where an expression is allowed.
max(X, Y) when X > Y -> X;
max(X, Y) -> Y.

% A guard is a series of guard expressions, separated by commas (`,`).
% The guard `GuardExpr1, GuardExpr2, ..., GuardExprN` is true if all the guard
% expressions `GuardExpr1`, `GuardExpr2`, ..., `GuardExprN` evaluate to `true`.
is_cat(A) when is_atom(A), A =:= cat -> true;
is_cat(A) -> false.
is_dog(A) when is_atom(A), A =:= dog -> true;
is_dog(A) -> false.

% We won't dwell on the `=:=` operator here; just be aware that it is used to
% check whether two Erlang expressions have the same value *and* the same type.
% Contrast this behaviour to that of the `==` operator:
1 + 2 =:= 3.   % true
1 + 2 =:= 3.0. % false
1 + 2 ==  3.0. % true

% A guard sequence is either a single guard or a series of guards, separated
% by semicolons (`;`). The guard sequence `G1; G2; ...; Gn` is true if at
% least one of the guards `G1`, `G2`, ..., `Gn` evaluates to `true`.
is_pet(A) when is_atom(A), (A =:= dog);(A =:= cat) -> true;
is_pet(A)                                             -> false.

% Warning: not all valid Erlang expressions can be used as guard expressions;
% in particular, our `is_cat` and `is_dog` functions cannot be used within the
% guard sequence in `is_pet`'s definition. For a description of the
% expressions allowed in guard sequences, refer to the specific section
% in the Erlang reference manual:
% http://erlang.org/doc/reference_manual/expressions.html#guards


% Records provide a method for associating a name with a particular element in a
% tuple.
% Record definitions can be included in Erlang source code files or put in files
% with the extension `.hrl`, which are then included by Erlang source code
% files.
-record(todo, {
  status = reminder,  % Default value
  who = joe,
  text
}).

% We have to read the record definitions into the shell before we can define a
% record. We use the shell function `rr` (short for read records) to do this.
rr(""records.hrl"").  % [todo]

% Creating and updating records:
X = #todo{}.
% #todo{status = reminder, who = joe, text = undefined}
X1 = #todo{status = urgent, text = ""Fix errata in book""}.
% #todo{status = urgent, who = joe, text = ""Fix errata in book""}
X2 = X1#todo{status = done}.
% #todo{status = done, who = joe, text = ""Fix errata in book""}

% `case` expressions.
% `filter` returns a list of all elements `X` in a list `L` for which `P(X)` is
% true.
filter(P, [H|T]) ->
  case P(H) of
    true -> [H|filter(P, T)];
    false -> filter(P, T)
  end;
filter(P, []) -> [].
filter(fun(X) -> X rem 2 == 0 end, [1, 2, 3, 4]). % [2, 4]

% `if` expressions.
max(X, Y) ->
  if
    X > Y -> X;
    X < Y -> Y;
    true -> nil
  end.

% Warning: at least one of the guards in the `if` expression must evaluate to
% `true`; otherwise, an exception will be raised.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 3. Exceptions.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Exceptions are raised by the system when internal errors are encountered or
% explicitly in code by calling `throw(Exception)`, `exit(Exception)`, or
% `erlang:error(Exception)`.
generate_exception(1) -> a;
generate_exception(2) -> throw(a);
generate_exception(3) -> exit(a);
generate_exception(4) -> {'EXIT', a};
generate_exception(5) -> erlang:error(a).

% Erlang has two methods of catching an exception. One is to enclose the call to
% the function that raises the exception within a `try...catch` expression.
catcher(N) ->
  try generate_exception(N) of
    Val -> {N, normal, Val}
  catch
    throw:X -> {N, caught, thrown, X};
    exit:X -> {N, caught, exited, X};
    error:X -> {N, caught, error, X}
  end.

% The other is to enclose the call in a `catch` expression. When you catch an
% exception, it is converted into a tuple that describes the error.
catcher(N) -> catch generate_exception(N).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 4. Concurrency
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Erlang relies on the actor model for concurrency. All we need to write
% concurrent programs in Erlang are three primitives: spawning processes,
% sending messages and receiving messages.

% To start a new process, we use the `spawn` function, which takes a function
% as argument.

F = fun() -> 2 + 2 end. % #Fun<erl_eval.20.67289768>
spawn(F). % <0.44.0>

% `spawn` returns a pid (process identifier); you can use this pid to send
% messages to the process. To do message passing, we use the `!` operator.
% For all of this to be useful, we need to be able to receive messages. This is
% achieved with the `receive` mechanism:

-module(calculateGeometry).
-compile(export_all).
calculateArea() ->
    receive
      {rectangle, W, H} ->
        W * H;
      {circle, R} ->
        3.14 * R * R;
      _ ->
        io:format(""We can only calculate area of rectangles or circles."")
    end.

% Compile the module and create a process that evaluates `calculateArea` in the
% shell.
c(calculateGeometry).
CalculateArea = spawn(calculateGeometry, calculateArea, []).
CalculateArea ! {circle, 2}. % 12.56000000000000049738

% The shell is also a process; you can use `self` to get the current pid.
self(). % <0.41.0>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 5. Testing with EUnit
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Unit tests can be written using EUnits's test generators and assert macros
-module(fib).
-export([fib/1]).
-include_lib(""eunit/include/eunit.hrl"").

fib(0) -> 1;
fib(1) -> 1;
fib(N) when N > 1 -> fib(N-1) + fib(N-2).

fib_test_() ->
    [?_assert(fib(0) =:= 1),
     ?_assert(fib(1) =:= 1),
     ?_assert(fib(2) =:= 2),
     ?_assert(fib(3) =:= 3),
     ?_assert(fib(4) =:= 5),
     ?_assert(fib(5) =:= 8),
     ?_assertException(error, function_clause, fib(-1)),
     ?_assert(fib(31) =:= 2178309)
    ].

% EUnit will automatically export to a test() function to allow running the tests
% in the erlang shell
fib:test()

% The popular erlang build tool Rebar is also compatible with EUnit
% ```
% rebar eunit
% ```

```

## References

* [""Learn You Some Erlang for great good!""](http://learnyousomeerlang.com/)
* [""Programming Erlang: Software for a Concurrent World"" by Joe Armstrong](http://pragprog.com/book/jaerlang/programming-erlang)
* [Erlang/OTP Reference Documentation](http://www.erlang.org/doc/)
* [Erlang - Programming Rules and Conventions](http://www.erlang.se/doc/programming_rules.shtml)"
"Markdown was created by John Gruber in 2004. It's meant to be an easy to read
and write syntax which converts easily to HTML (and now many other formats as
well).

Markdown also varies in implementation from one parser to a next. This
guide will attempt to clarify when features are universal or when they are
specific to a certain parser.

- [HTML Elements](#html-elements)
- [Headings](#headings)
- [Simple text styles](#simple-text-styles)
- [Paragraphs](#paragraphs)
- [Lists](#lists)
- [Code blocks](#code-blocks)
- [Horizontal rule](#horizontal-rule)
- [Links](#links)
  - [Table of contents](#table-of-contents)
- [Images](#images)
- [Miscellany](#miscellany)
  - [Auto-links](#auto-links)
  - [Auto-links for emails](#auto-links-for-emails)
  - [Escaping characters](#escaping-characters)
  - [Keyboard keys](#keyboard-keys)
  - [Tables](#tables)
- [Markdownlint](#markdownlint)
- [Further reading](#further-reading)

## HTML Elements

Markdown is a superset of HTML, so any HTML file is valid Markdown.

```md
<!--This means we can use HTML elements in Markdown, such as the comment
element, and they won't be affected by a markdown parser. However, if you
create an HTML element in your markdown file, you cannot use markdown syntax
within that element's contents.-->
```

## Headings

You can create HTML elements `<h1>` through `<h6>` easily by prepending the
text you want to be in that element by a number of hashes (#).

```md
# This is an <h1>
## This is an <h2>
### This is an <h3>
#### This is an <h4>
##### This is an <h5>
###### This is an <h6>
```

Markdown also provides us with two alternative ways of indicating h1 and h2.

```md
This is an h1
=============

This is an h2
-------------
```

## Simple text styles

Text can be easily styled as italic or bold using markdown.

```md
*This text is in italics.*
_And so is this text._

**This text is in bold.**
__And so is this text.__

***This text is in both.***
**_As is this!_**
*__And this!__*
```

In GitHub Flavored Markdown, which is used to render markdown files on
GitHub, we also have strikethrough:

```md
~~This text is rendered with strikethrough.~~
```

## Paragraphs

Paragraphs are a one or multiple adjacent lines of text separated by one or
multiple blank lines.

```md
This is a paragraph. I'm typing in a paragraph isn't this fun?

Now I'm in paragraph 2.
I'm still in paragraph 2 too!


I'm in paragraph three!
```

Should you ever want to insert an HTML `<br />` tag, you can end a paragraph
with two or more spaces and then begin a new paragraph.

```md
I end with two spaces (highlight me to see them).

There's a <br /> above me!
```

Block quotes are easy and done with the > character.

```md
> This is a block quote. You can either
> manually wrap your lines and put a `>` before every line or you can let your lines get really long and wrap on their own.
> It doesn't make a difference so long as they start with a `>`.

> You can also use more than one level
>> of indentation?
> How neat is that?

```

## Lists

Unordered lists can be made using asterisks, pluses, or hyphens.

```md
* Item
* Item
* Another item

or

+ Item
+ Item
+ One more item

or

- Item
- Item
- One last item
```

Ordered lists are done with a number followed by a period.

```md
1. Item one
2. Item two
3. Item three
```

You don't even have to label the items correctly and Markdown will still
render the numbers in order, but this may not be a good idea.

```md
1. Item one
1. Item two
1. Item three
```

(This renders the same as the example above.)

You can also use sublists.

```md
1. Item one
2. Item two
3. Item three
    * Sub-item
    * Sub-item
4. Item four
```

There are even task lists. This creates HTML checkboxes.

```md
Boxes below without the 'x' are unchecked HTML checkboxes.
- [ ] First task to complete.
- [ ] Second task that needs done
This checkbox below will be a checked HTML checkbox.
- [x] This task has been completed
```

## Code blocks

You can indicate a code block (which uses the `<code>` element) by indenting
a line with four spaces or a tab.

```md
    This is code
    So is this
```

You can also re-tab (or add an additional four spaces) for indentation
inside your code.

```md
    my_array.each do |item|
        puts item
    end
```

Inline code can be created using the backtick character `` ` ``.

```md
John didn't even know what the `go_to()` function did!
```

In GitHub Flavored Markdown, you can use a special syntax for code.

<pre>
<code class=""highlight"">&#x60;&#x60;&#x60;ruby
def foobar
    puts ""Hello world!""
end
&#x60;&#x60;&#x60;</code></pre>

The above text doesn't require indenting, plus GitHub will use syntax
highlighting of the language you specify after the opening <code>```</code>.

## Horizontal rule

Horizontal rules (`<hr/>`) are easily added with three or more asterisks or
hyphens, with or without spaces.

```md
***
---
- - -
****************
```

## Links

One of the best things about markdown is how easy it is to make links. Put
the text to display in hard brackets [] followed by the url in parentheses ()

```md
[Click me!](http://test.com/)
```

You can also add a link title using quotes inside the parentheses.

```md
[Click me!](http://test.com/ ""Link to Test.com"")
```

Relative paths work too.

```md
[Go to music](/music/).
```

Markdown also supports reference style links.

<pre><code class=""highlight"">&#x5b;<span class=""nv"">Click this link</span>][<span class=""ss"">link1</span>] for more info about it!
&#x5b;<span class=""nv"">Also check out this link</span>][<span class=""ss"">foobar</span>] if you want to.

&#x5b;<span class=""nv"">link1</span>]: <span class=""sx"">http://test.com/</span> <span class=""nn"">""Cool!""</span>
&#x5b;<span class=""nv"">foobar</span>]: <span class=""sx"">http://foobar.biz/</span> <span class=""nn"">""Alright!""</span></code></pre>

The title can also be in single quotes or in parentheses, or omitted
entirely. The references can be anywhere in your document and the reference IDs
can be anything so long as they are unique.

There is also ""implicit naming"" which lets you use the link text as the id.

<pre><code class=""highlight"">&#x5b;<span class=""nv"">This</span>][] is a link.

&#x5b;<span class=""nv"">This</span>]: <span class=""sx"">http://thisisalink.com/</span></code></pre>

But it's not that commonly used.

### Table of contents

Some Markdown flavors even make use of the combination of lists, links and
headings in order to create tables of contents. In this case, heading titles in
lowercase are prepended with hash (`#`) and are used as link ids. Should the
heading have multiple words, they will be connected with a hyphen (`-`), that
also replaces some special characters. (Some other special characters are
omitted though.)

```md
- [Heading](#heading)
- [Another heading](#another-heading)
- [Chapter](#chapter)
  - [Subchapter <h3 />](#subchapter-h3-)
```

Nonetheless, this is a feature that might not be working in all Markdown
implementations the same way.

## Images

Images are done the same way as links but with an exclamation point in front!

```md
![This is the alt-attribute for my image](http://imgur.com/myimage.jpg ""An optional title"")
```

And reference style works as expected.

<pre><code class=""highlight"">!&#x5b;<span class=""nv"">This is the alt-attribute.</span>][<span class=""ss"">myimage</span>]

&#x5b;<span class=""nv"">myimage</span>]: <span class=""sx"">relative/urls/cool/image.jpg</span> <span class=""nn"">""if you need a title, it's here""</span></code></pre>

## Miscellany

### Auto-links

```md
<http://testwebsite.com/> is equivalent to
[http://testwebsite.com/](http://testwebsite.com/)
```

### Auto-links for emails

```md
<foo@bar.com>
```

### Escaping characters

```md
I want to type *this text surrounded by asterisks* but I don't want it to be
in italics, so I do this: \*this text surrounded by asterisks\*.
```

### Keyboard keys

In GitHub Flavored Markdown, you can use a `<kbd>` tag to represent keyboard
keys.

```md
Your computer crashed? Try sending a
<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd>
```

### Tables

Tables are only available in GitHub Flavored Markdown and are slightly
cumbersome, but if you really want it:

```md
| Col1         | Col2     | Col3          |
| :----------- | :------: | ------------: |
| Left-aligned | Centered | Right-aligned |
| blah         | blah     | blah          |
```

or, for the same results

```md
Col 1 | Col2 | Col3
:-- | :-: | --:
Ugh this is so ugly | make it | stop
```

## Markdownlint

In order to simplify work with Markdown and to unify its coding style,
`Markdownlint` has been created. Available as a
[separate tool](https://github.com/markdownlint/markdownlint)
as well as a plugin for some IDEs, it can be used to ensure validity and
readability of Markdown.

---

## Further reading

For more info, check out John Gruber's official post of syntax [here](http://daringfireball.net/projects/markdown/syntax) and Adam Pritchard's great cheatsheet [here](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet).

If you want to learn more on some major Markdown flavors' features, see:

- [GitHub flavored Markdown](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax)
- [GitLab flavored Markdown](https://docs.gitlab.com/ee/user/markdown.html)"
"```d
// You know what's coming...
module hello;

import std.stdio;

// args is optional
void main(string[] args) {
    writeln(""Hello, World!"");
}
```

If you're like me and spend way too much time on the internet, odds are you've heard
about [D](http://dlang.org/). The D programming language is a modern, general-purpose,
multi-paradigm language with support for everything from low-level features to
expressive high-level abstractions.

D is actively developed by a large group of super-smart people and is spearheaded by
[Walter Bright](https://en.wikipedia.org/wiki/Walter_Bright) and
[Andrei Alexandrescu](https://en.wikipedia.org/wiki/Andrei_Alexandrescu).
With all that out of the way, let's look at some examples!

```d
import std.stdio;

void main() {

    // Conditionals and loops work as expected.
    for(int i = 0; i < 10000; i++) {
        writeln(i);
    }

    // 'auto' can be used for inferring types.
    auto n = 1;

    // Numeric literals can use '_' as a digit separator for clarity.
    while(n < 10_000) {
        n += n;
    }

    do {
        n -= (n / 2);
    } while(n > 0);

    // For and while are nice, but in D-land we prefer 'foreach' loops.
    // The '..' creates a continuous range, including the first value
    // but excluding the last.
    foreach(n; 1..1_000_000) {
        if(n % 2 == 0)
            writeln(n);
    }

    // There's also 'foreach_reverse' when you want to loop backwards.
    foreach_reverse(n; 1..int.max) {
        if(n % 2 == 1) {
            writeln(n);
        } else {
            writeln(""No!"");
        }
    }
}
```

We can define new types with `struct`, `class`, `union`, and `enum`. Structs and unions
are passed to functions by value (i.e. copied) and classes are passed by reference. Furthermore,
we can use templates to parameterize all of these on both types and values!

```d
// Here, 'T' is a type parameter. Think '<T>' from C++/C#/Java.
struct LinkedList(T) {
    T data = null;

    // Use '!' to instantiate a parameterized type. Again, think '<T>'.
    LinkedList!(T)* next;
}

class BinTree(T) {
    T data = null;

    // If there is only one template parameter, we can omit the parentheses.
    BinTree!T left;
    BinTree!T right;
}

enum Day {
    Sunday,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
}

// Use alias to create abbreviations for types.
alias IntList = LinkedList!int;
alias NumTree = BinTree!double;

// We can create function templates as well!
T max(T)(T a, T b) {
    if(a < b)
        return b;

    return a;
}

// Use the ref keyword to ensure pass by reference. That is, even if 'a' and 'b'
// are value types, they will always be passed by reference to 'swap()'.
void swap(T)(ref T a, ref T b) {
    auto temp = a;

    a = b;
    b = temp;
}

// With templates, we can also parameterize on values, not just types.
class Matrix(uint m, uint n, T = int) {
    T[m] rows;
    T[n] columns;
}

auto mat = new Matrix!(3, 3); // We've defaulted type 'T' to 'int'.

```

Speaking of classes, let's talk about properties for a second. A property
is roughly a function that may act like an lvalue, so we can
have the syntax of POD structures (`structure.x = 7`) with the semantics of
getter and setter methods (`object.setX(7)`)!

```d
// Consider a class parameterized on types 'T' & 'U'.
class MyClass(T, U) {
    T _data;
    U _other;
}

// And ""getter"" and ""setter"" methods like so:
class MyClass(T, U) {
    T _data;
    U _other;

    // Constructors are always named 'this'.
    this(T t, U u) {
        // This will call the setter methods below.
        data = t;
        other = u;
    }

    // getters
    @property T data() {
        return _data;
    }

    @property U other() {
        return _other;
    }

    // setters
    @property void data(T t) {
        _data = t;
    }

    @property void other(U u) {
        _other = u;
    }
}

// And we use them in this manner:
void main() {
    auto mc = new MyClass!(int, string)(7, ""seven"");

    // Import the 'stdio' module from the standard library for writing to
    // console (imports can be local to a scope).
    import std.stdio;

    // Call the getters to fetch the values.
    writefln(""Earlier: data = %d, str = %s"", mc.data, mc.other);

    // Call the setters to assign new values.
    mc.data = 8;
    mc.other = ""eight"";

    // Call the getters again to fetch the new values.
    writefln(""Later: data = %d, str = %s"", mc.data, mc.other);
}
```

With properties, we can add any amount of logic to
our getter and setter methods, and keep the clean syntax of
accessing members directly!

Other object-oriented goodies at our disposal
include interfaces, abstract classes,
and overriding methods. D does inheritance just like Java:
Extend one class, implement as many interfaces as you please.

We've seen D's OOP facilities, but let's switch gears. D offers
functional programming with first-class functions, `pure`
functions, and immutable data. In addition, all of your favorite
functional algorithms (map, filter, reduce and friends) can be
found in the wonderful `std.algorithm` module!

```d
import std.algorithm : map, filter, reduce;
import std.range : iota; // builds an end-exclusive range
import std.stdio;

void main() {
    // We want to print the sum of a list of squares of even ints
    // from 1 to 100. Easy!

    // Just pass lambda expressions as template parameters!
    // You can pass any function you like, but lambdas are convenient here.
    auto num = iota(1, 101).filter!(x => x % 2 == 0)
                           .map!(y => y ^^ 2)
                           .reduce!((a, b) => a + b);

    writeln(num);
}
```

Notice how we got to build a nice Haskellian pipeline to compute num?
That's thanks to a D innovation know as Uniform Function Call Syntax (UFCS).
With UFCS, we can choose whether to write a function call as a method
or free function call! Walter wrote a nice article on this
[here.](http://www.drdobbs.com/cpp/uniform-function-call-syntax/232700394)
In short, you can call functions whose first parameter
is of some type A on any expression of type A as a method.

I like parallelism. Anyone else like parallelism? Sure you do. Let's do some!

```d
// Let's say we want to populate a large array with the square root of all
// consecutive integers starting from 1 (up until the size of the array), and we
// want to do this concurrently taking advantage of as many cores as we have
// available.

import std.stdio;
import std.parallelism : parallel;
import std.math : sqrt;

void main() {
    // Create your large array
    auto arr = new double[1_000_000];

    // Use an index, access every array element by reference (because we're
    // going to change each element) and just call parallel on the array!
    foreach(i, ref elem; parallel(arr)) {
        elem = sqrt(i + 1.0);
    }
}
```"
